Binary files xv6-riscv/.git/index and xv62/.git/index differ
diff -ruN xv6-riscv/.git/logs/HEAD xv62/.git/logs/HEAD
--- xv6-riscv/.git/logs/HEAD	2025-09-13 15:52:01.162542543 +0000
+++ xv62/.git/logs/HEAD	2025-09-13 14:34:47.198963899 +0000
@@ -1 +1 @@
-0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757778721 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
+0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757455055 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
diff -ruN xv6-riscv/.git/logs/refs/heads/riscv xv62/.git/logs/refs/heads/riscv
--- xv6-riscv/.git/logs/refs/heads/riscv	2025-09-13 15:52:01.162542543 +0000
+++ xv62/.git/logs/refs/heads/riscv	2025-09-13 14:34:47.195297232 +0000
@@ -1 +1 @@
-0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757778721 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
+0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757455055 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
diff -ruN xv6-riscv/.git/logs/refs/remotes/origin/HEAD xv62/.git/logs/refs/remotes/origin/HEAD
--- xv6-riscv/.git/logs/refs/remotes/origin/HEAD	2025-09-13 15:52:01.162542543 +0000
+++ xv62/.git/logs/refs/remotes/origin/HEAD	2025-09-13 14:34:47.195297232 +0000
@@ -1 +1 @@
-0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757778721 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
+0000000000000000000000000000000000000000 996f6ee34877db51c697479d97abdf127e09f5b4 Nandini Chakaravarthy <nandinichakaravarthy@gmail.com> 1757455055 +0000	clone: from git://github.com/mit-pdos/xv6-riscv.git
Binary files xv6-riscv/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.idx and xv62/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.idx differ
Binary files xv6-riscv/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.pack and xv62/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.pack differ
Binary files xv6-riscv/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.rev and xv62/.git/objects/pack/pack-8cd0f6439c89ba94dea63133ec4f8834fc33b2fe.rev differ
Binary files xv6-riscv/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.idx and xv62/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.idx differ
Binary files xv6-riscv/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.pack and xv62/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.pack differ
Binary files xv6-riscv/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.rev and xv62/.git/objects/pack/pack-ce29bde09275fb612ae588c0e4f8d64b4f02417b.rev differ
diff -ruN xv6-riscv/Makefile xv62/Makefile
--- xv6-riscv/Makefile	2025-09-13 15:52:01.162542543 +0000
+++ xv62/Makefile	2025-09-13 15:44:53.594975554 +0000
@@ -80,6 +80,27 @@
 ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
 CFLAGS += -fno-pie -nopie
 endif
+ifdef SCHEDULER
+CFLAGS += -D$(SCHEDULER)
+endif
+# ---
+
+.PHONY: qemu-cfs qemu-fcfs
+
+
+
+qemu-cfs: CFLAGS += -DCFS
+
+qemu-cfs: clean qemu
+
+
+
+qemu-fcfs: CFLAGS += -DFCFS
+
+qemu-fcfs: clean qemu
+
+
+
 
 LDFLAGS = -z max-page-size=4096
 
@@ -142,6 +163,8 @@
 	$U/_logstress\
 	$U/_forphan\
 	$U/_dorphan\
+	$U/_readcount\
+	$U/_loop\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
Binary files xv6-riscv/fs.img and xv62/fs.img differ
diff -ruN xv6-riscv/kernel/bio.d xv62/kernel/bio.d
--- xv6-riscv/kernel/bio.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/bio.d	2025-09-14 12:32:49.260883647 +0000
@@ -0,0 +1,3 @@
+kernel/bio.o: kernel/bio.c kernel/types.h kernel/param.h \
+ kernel/spinlock.h kernel/sleeplock.h kernel/riscv.h kernel/defs.h \
+ kernel/fs.h kernel/buf.h
Binary files xv6-riscv/kernel/bio.o and xv62/kernel/bio.o differ
diff -ruN xv6-riscv/kernel/console.d xv62/kernel/console.d
--- xv6-riscv/kernel/console.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/console.d	2025-09-14 12:32:48.588883785 +0000
@@ -0,0 +1,5 @@
+kernel/console.o: kernel/console.c \
+ /usr/lib/gcc-cross/riscv64-linux-gnu/13/include/stdarg.h kernel/types.h \
+ kernel/param.h kernel/spinlock.h kernel/sleeplock.h kernel/fs.h \
+ kernel/file.h kernel/memlayout.h kernel/riscv.h kernel/defs.h \
+ kernel/proc.h
Binary files xv6-riscv/kernel/console.o and xv62/kernel/console.o differ
Binary files xv6-riscv/kernel/entry.o and xv62/kernel/entry.o differ
diff -ruN xv6-riscv/kernel/exec.d xv62/kernel/exec.d
--- xv6-riscv/kernel/exec.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/exec.d	2025-09-14 12:32:49.668883563 +0000
@@ -0,0 +1,3 @@
+kernel/exec.o: kernel/exec.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/spinlock.h kernel/proc.h \
+ kernel/defs.h kernel/elf.h
Binary files xv6-riscv/kernel/exec.o and xv62/kernel/exec.o differ
diff -ruN xv6-riscv/kernel/file.d xv62/kernel/file.d
--- xv6-riscv/kernel/file.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/file.d	2025-09-14 12:32:49.568883584 +0000
@@ -0,0 +1,3 @@
+kernel/file.o: kernel/file.c kernel/types.h kernel/riscv.h kernel/defs.h \
+ kernel/param.h kernel/fs.h kernel/spinlock.h kernel/sleeplock.h \
+ kernel/file.h kernel/stat.h kernel/proc.h
Binary files xv6-riscv/kernel/file.o and xv62/kernel/file.o differ
diff -ruN xv6-riscv/kernel/fs.d xv62/kernel/fs.d
--- xv6-riscv/kernel/fs.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/fs.d	2025-09-14 12:32:49.424883614 +0000
@@ -0,0 +1,3 @@
+kernel/fs.o: kernel/fs.c kernel/types.h kernel/riscv.h kernel/defs.h \
+ kernel/param.h kernel/stat.h kernel/spinlock.h kernel/proc.h \
+ kernel/sleeplock.h kernel/fs.h kernel/buf.h kernel/file.h
Binary files xv6-riscv/kernel/fs.o and xv62/kernel/fs.o differ
diff -ruN xv6-riscv/kernel/kalloc.d xv62/kernel/kalloc.d
--- xv6-riscv/kernel/kalloc.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/kalloc.d	2025-09-14 12:32:48.712883759 +0000
@@ -0,0 +1,2 @@
+kernel/kalloc.o: kernel/kalloc.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/spinlock.h kernel/riscv.h kernel/defs.h
Binary files xv6-riscv/kernel/kalloc.o and xv62/kernel/kalloc.o differ
Binary files xv6-riscv/kernel/kernel and xv62/kernel/kernel differ
diff -ruN xv6-riscv/kernel/kernel.asm xv62/kernel/kernel.asm
--- xv6-riscv/kernel/kernel.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/kernel.asm	2025-09-14 12:32:49.940883507 +0000
@@ -0,0 +1,12909 @@
+
+kernel/kernel:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000080000000 <_entry>:
+_entry:
+        # set up a stack for C.
+        # stack0 is declared in start.c,
+        # with a 4096-byte stack per CPU.
+        # sp = stack0 + ((hartid + 1) * 4096)
+        la sp, stack0
+    80000000:	0000a117          	auipc	sp,0xa
+    80000004:	1a813103          	ld	sp,424(sp) # 8000a1a8 <_GLOBAL_OFFSET_TABLE_+0x8>
+        li a0, 1024*4
+    80000008:	6505                	lui	a0,0x1
+        csrr a1, mhartid
+    8000000a:	f14025f3          	csrr	a1,mhartid
+        addi a1, a1, 1
+    8000000e:	0585                	addi	a1,a1,1
+        mul a0, a0, a1
+    80000010:	02b50533          	mul	a0,a0,a1
+        add sp, sp, a0
+    80000014:	912a                	add	sp,sp,a0
+        # jump to start() in start.c
+        call start
+    80000016:	04a000ef          	jal	80000060 <start>
+
+000000008000001a <spin>:
+spin:
+        j spin
+    8000001a:	a001                	j	8000001a <spin>
+
+000000008000001c <timerinit>:
+}
+
+// ask each hart to generate timer interrupts.
+void
+timerinit()
+{
+    8000001c:	1141                	addi	sp,sp,-16
+    8000001e:	e422                	sd	s0,8(sp)
+    80000020:	0800                	addi	s0,sp,16
+#define MIE_STIE (1L << 5)  // supervisor timer
+static inline uint64
+r_mie()
+{
+  uint64 x;
+  asm volatile("csrr %0, mie" : "=r" (x) );
+    80000022:	304027f3          	csrr	a5,mie
+  // enable supervisor-mode timer interrupts.
+  w_mie(r_mie() | MIE_STIE);
+    80000026:	0207e793          	ori	a5,a5,32
+}
+
+static inline void 
+w_mie(uint64 x)
+{
+  asm volatile("csrw mie, %0" : : "r" (x));
+    8000002a:	30479073          	csrw	mie,a5
+static inline uint64
+r_menvcfg()
+{
+  uint64 x;
+  // asm volatile("csrr %0, menvcfg" : "=r" (x) );
+  asm volatile("csrr %0, 0x30a" : "=r" (x) );
+    8000002e:	30a027f3          	csrr	a5,0x30a
+  
+  // enable the sstc extension (i.e. stimecmp).
+  w_menvcfg(r_menvcfg() | (1L << 63)); 
+    80000032:	577d                	li	a4,-1
+    80000034:	177e                	slli	a4,a4,0x3f
+    80000036:	8fd9                	or	a5,a5,a4
+
+static inline void 
+w_menvcfg(uint64 x)
+{
+  // asm volatile("csrw menvcfg, %0" : : "r" (x));
+  asm volatile("csrw 0x30a, %0" : : "r" (x));
+    80000038:	30a79073          	csrw	0x30a,a5
+
+static inline uint64
+r_mcounteren()
+{
+  uint64 x;
+  asm volatile("csrr %0, mcounteren" : "=r" (x) );
+    8000003c:	306027f3          	csrr	a5,mcounteren
+  
+  // allow supervisor to use stimecmp and time.
+  w_mcounteren(r_mcounteren() | 2);
+    80000040:	0027e793          	ori	a5,a5,2
+  asm volatile("csrw mcounteren, %0" : : "r" (x));
+    80000044:	30679073          	csrw	mcounteren,a5
+// machine-mode cycle counter
+static inline uint64
+r_time()
+{
+  uint64 x;
+  asm volatile("csrr %0, time" : "=r" (x) );
+    80000048:	c01027f3          	rdtime	a5
+  
+  // ask for the very first timer interrupt.
+  w_stimecmp(r_time() + 1000000);
+    8000004c:	000f4737          	lui	a4,0xf4
+    80000050:	24070713          	addi	a4,a4,576 # f4240 <_entry-0x7ff0bdc0>
+    80000054:	97ba                	add	a5,a5,a4
+  asm volatile("csrw 0x14d, %0" : : "r" (x));
+    80000056:	14d79073          	csrw	stimecmp,a5
+}
+    8000005a:	6422                	ld	s0,8(sp)
+    8000005c:	0141                	addi	sp,sp,16
+    8000005e:	8082                	ret
+
+0000000080000060 <start>:
+{
+    80000060:	1141                	addi	sp,sp,-16
+    80000062:	e406                	sd	ra,8(sp)
+    80000064:	e022                	sd	s0,0(sp)
+    80000066:	0800                	addi	s0,sp,16
+  asm volatile("csrr %0, mstatus" : "=r" (x) );
+    80000068:	300027f3          	csrr	a5,mstatus
+  x &= ~MSTATUS_MPP_MASK;
+    8000006c:	7779                	lui	a4,0xffffe
+    8000006e:	7ff70713          	addi	a4,a4,2047 # ffffffffffffe7ff <end+0xffffffff7ffda8f7>
+    80000072:	8ff9                	and	a5,a5,a4
+  x |= MSTATUS_MPP_S;
+    80000074:	6705                	lui	a4,0x1
+    80000076:	80070713          	addi	a4,a4,-2048 # 800 <_entry-0x7ffff800>
+    8000007a:	8fd9                	or	a5,a5,a4
+  asm volatile("csrw mstatus, %0" : : "r" (x));
+    8000007c:	30079073          	csrw	mstatus,a5
+  asm volatile("csrw mepc, %0" : : "r" (x));
+    80000080:	00001797          	auipc	a5,0x1
+    80000084:	dbc78793          	addi	a5,a5,-580 # 80000e3c <main>
+    80000088:	34179073          	csrw	mepc,a5
+  asm volatile("csrw satp, %0" : : "r" (x));
+    8000008c:	4781                	li	a5,0
+    8000008e:	18079073          	csrw	satp,a5
+  asm volatile("csrw medeleg, %0" : : "r" (x));
+    80000092:	67c1                	lui	a5,0x10
+    80000094:	17fd                	addi	a5,a5,-1 # ffff <_entry-0x7fff0001>
+    80000096:	30279073          	csrw	medeleg,a5
+  asm volatile("csrw mideleg, %0" : : "r" (x));
+    8000009a:	30379073          	csrw	mideleg,a5
+  asm volatile("csrr %0, sie" : "=r" (x) );
+    8000009e:	104027f3          	csrr	a5,sie
+  w_sie(r_sie() | SIE_SEIE | SIE_STIE);
+    800000a2:	2207e793          	ori	a5,a5,544
+  asm volatile("csrw sie, %0" : : "r" (x));
+    800000a6:	10479073          	csrw	sie,a5
+  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
+    800000aa:	57fd                	li	a5,-1
+    800000ac:	83a9                	srli	a5,a5,0xa
+    800000ae:	3b079073          	csrw	pmpaddr0,a5
+  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
+    800000b2:	47bd                	li	a5,15
+    800000b4:	3a079073          	csrw	pmpcfg0,a5
+  timerinit();
+    800000b8:	f65ff0ef          	jal	8000001c <timerinit>
+  asm volatile("csrr %0, mhartid" : "=r" (x) );
+    800000bc:	f14027f3          	csrr	a5,mhartid
+  w_tp(id);
+    800000c0:	2781                	sext.w	a5,a5
+}
+
+static inline void 
+w_tp(uint64 x)
+{
+  asm volatile("mv tp, %0" : : "r" (x));
+    800000c2:	823e                	mv	tp,a5
+  asm volatile("mret");
+    800000c4:	30200073          	mret
+}
+    800000c8:	60a2                	ld	ra,8(sp)
+    800000ca:	6402                	ld	s0,0(sp)
+    800000cc:	0141                	addi	sp,sp,16
+    800000ce:	8082                	ret
+
+00000000800000d0 <consolewrite>:
+//
+// user write()s to the console go here.
+//
+int
+consolewrite(int user_src, uint64 src, int n)
+{
+    800000d0:	7119                	addi	sp,sp,-128
+    800000d2:	fc86                	sd	ra,120(sp)
+    800000d4:	f8a2                	sd	s0,112(sp)
+    800000d6:	f4a6                	sd	s1,104(sp)
+    800000d8:	0100                	addi	s0,sp,128
+  char buf[32];
+  int i = 0;
+
+  while(i < n){
+    800000da:	06c05a63          	blez	a2,8000014e <consolewrite+0x7e>
+    800000de:	f0ca                	sd	s2,96(sp)
+    800000e0:	ecce                	sd	s3,88(sp)
+    800000e2:	e8d2                	sd	s4,80(sp)
+    800000e4:	e4d6                	sd	s5,72(sp)
+    800000e6:	e0da                	sd	s6,64(sp)
+    800000e8:	fc5e                	sd	s7,56(sp)
+    800000ea:	f862                	sd	s8,48(sp)
+    800000ec:	f466                	sd	s9,40(sp)
+    800000ee:	8aaa                	mv	s5,a0
+    800000f0:	8b2e                	mv	s6,a1
+    800000f2:	8a32                	mv	s4,a2
+  int i = 0;
+    800000f4:	4481                	li	s1,0
+    int nn = sizeof(buf);
+    if(nn > n - i)
+    800000f6:	02000c13          	li	s8,32
+    800000fa:	02000c93          	li	s9,32
+      nn = n - i;
+    if(either_copyin(buf, user_src, src+i, nn) == -1)
+    800000fe:	5bfd                	li	s7,-1
+    80000100:	a035                	j	8000012c <consolewrite+0x5c>
+    if(nn > n - i)
+    80000102:	0009099b          	sext.w	s3,s2
+    if(either_copyin(buf, user_src, src+i, nn) == -1)
+    80000106:	86ce                	mv	a3,s3
+    80000108:	01648633          	add	a2,s1,s6
+    8000010c:	85d6                	mv	a1,s5
+    8000010e:	f8040513          	addi	a0,s0,-128
+    80000112:	170020ef          	jal	80002282 <either_copyin>
+    80000116:	03750e63          	beq	a0,s7,80000152 <consolewrite+0x82>
+      break;
+    uartwrite(buf, nn);
+    8000011a:	85ce                	mv	a1,s3
+    8000011c:	f8040513          	addi	a0,s0,-128
+    80000120:	778000ef          	jal	80000898 <uartwrite>
+    i += nn;
+    80000124:	009904bb          	addw	s1,s2,s1
+  while(i < n){
+    80000128:	0144da63          	bge	s1,s4,8000013c <consolewrite+0x6c>
+    if(nn > n - i)
+    8000012c:	409a093b          	subw	s2,s4,s1
+    80000130:	0009079b          	sext.w	a5,s2
+    80000134:	fcfc57e3          	bge	s8,a5,80000102 <consolewrite+0x32>
+    80000138:	8966                	mv	s2,s9
+    8000013a:	b7e1                	j	80000102 <consolewrite+0x32>
+    8000013c:	7906                	ld	s2,96(sp)
+    8000013e:	69e6                	ld	s3,88(sp)
+    80000140:	6a46                	ld	s4,80(sp)
+    80000142:	6aa6                	ld	s5,72(sp)
+    80000144:	6b06                	ld	s6,64(sp)
+    80000146:	7be2                	ld	s7,56(sp)
+    80000148:	7c42                	ld	s8,48(sp)
+    8000014a:	7ca2                	ld	s9,40(sp)
+    8000014c:	a819                	j	80000162 <consolewrite+0x92>
+  int i = 0;
+    8000014e:	4481                	li	s1,0
+    80000150:	a809                	j	80000162 <consolewrite+0x92>
+    80000152:	7906                	ld	s2,96(sp)
+    80000154:	69e6                	ld	s3,88(sp)
+    80000156:	6a46                	ld	s4,80(sp)
+    80000158:	6aa6                	ld	s5,72(sp)
+    8000015a:	6b06                	ld	s6,64(sp)
+    8000015c:	7be2                	ld	s7,56(sp)
+    8000015e:	7c42                	ld	s8,48(sp)
+    80000160:	7ca2                	ld	s9,40(sp)
+  }
+
+  return i;
+}
+    80000162:	8526                	mv	a0,s1
+    80000164:	70e6                	ld	ra,120(sp)
+    80000166:	7446                	ld	s0,112(sp)
+    80000168:	74a6                	ld	s1,104(sp)
+    8000016a:	6109                	addi	sp,sp,128
+    8000016c:	8082                	ret
+
+000000008000016e <consoleread>:
+// user_dist indicates whether dst is a user
+// or kernel address.
+//
+int
+consoleread(int user_dst, uint64 dst, int n)
+{
+    8000016e:	711d                	addi	sp,sp,-96
+    80000170:	ec86                	sd	ra,88(sp)
+    80000172:	e8a2                	sd	s0,80(sp)
+    80000174:	e4a6                	sd	s1,72(sp)
+    80000176:	e0ca                	sd	s2,64(sp)
+    80000178:	fc4e                	sd	s3,56(sp)
+    8000017a:	f852                	sd	s4,48(sp)
+    8000017c:	f456                	sd	s5,40(sp)
+    8000017e:	f05a                	sd	s6,32(sp)
+    80000180:	1080                	addi	s0,sp,96
+    80000182:	8aaa                	mv	s5,a0
+    80000184:	8a2e                	mv	s4,a1
+    80000186:	89b2                	mv	s3,a2
+  uint target;
+  int c;
+  char cbuf;
+
+  target = n;
+    80000188:	00060b1b          	sext.w	s6,a2
+  acquire(&cons.lock);
+    8000018c:	00012517          	auipc	a0,0x12
+    80000190:	07450513          	addi	a0,a0,116 # 80012200 <cons>
+    80000194:	23b000ef          	jal	80000bce <acquire>
+  while(n > 0){
+    // wait until interrupt handler has put some
+    // input into cons.buffer.
+    while(cons.r == cons.w){
+    80000198:	00012497          	auipc	s1,0x12
+    8000019c:	06848493          	addi	s1,s1,104 # 80012200 <cons>
+      if(killed(myproc())){
+        release(&cons.lock);
+        return -1;
+      }
+      sleep(&cons.r, &cons.lock);
+    800001a0:	00012917          	auipc	s2,0x12
+    800001a4:	0f890913          	addi	s2,s2,248 # 80012298 <cons+0x98>
+  while(n > 0){
+    800001a8:	0b305d63          	blez	s3,80000262 <consoleread+0xf4>
+    while(cons.r == cons.w){
+    800001ac:	0984a783          	lw	a5,152(s1)
+    800001b0:	09c4a703          	lw	a4,156(s1)
+    800001b4:	0af71263          	bne	a4,a5,80000258 <consoleread+0xea>
+      if(killed(myproc())){
+    800001b8:	716010ef          	jal	800018ce <myproc>
+    800001bc:	759010ef          	jal	80002114 <killed>
+    800001c0:	e12d                	bnez	a0,80000222 <consoleread+0xb4>
+      sleep(&cons.r, &cons.lock);
+    800001c2:	85a6                	mv	a1,s1
+    800001c4:	854a                	mv	a0,s2
+    800001c6:	517010ef          	jal	80001edc <sleep>
+    while(cons.r == cons.w){
+    800001ca:	0984a783          	lw	a5,152(s1)
+    800001ce:	09c4a703          	lw	a4,156(s1)
+    800001d2:	fef703e3          	beq	a4,a5,800001b8 <consoleread+0x4a>
+    800001d6:	ec5e                	sd	s7,24(sp)
+    }
+
+    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];
+    800001d8:	00012717          	auipc	a4,0x12
+    800001dc:	02870713          	addi	a4,a4,40 # 80012200 <cons>
+    800001e0:	0017869b          	addiw	a3,a5,1
+    800001e4:	08d72c23          	sw	a3,152(a4)
+    800001e8:	07f7f693          	andi	a3,a5,127
+    800001ec:	9736                	add	a4,a4,a3
+    800001ee:	01874703          	lbu	a4,24(a4)
+    800001f2:	00070b9b          	sext.w	s7,a4
+
+    if(c == C('D')){  // end-of-file
+    800001f6:	4691                	li	a3,4
+    800001f8:	04db8663          	beq	s7,a3,80000244 <consoleread+0xd6>
+      }
+      break;
+    }
+
+    // copy the input byte to the user-space buffer.
+    cbuf = c;
+    800001fc:	fae407a3          	sb	a4,-81(s0)
+    if(either_copyout(user_dst, dst, &cbuf, 1) == -1)
+    80000200:	4685                	li	a3,1
+    80000202:	faf40613          	addi	a2,s0,-81
+    80000206:	85d2                	mv	a1,s4
+    80000208:	8556                	mv	a0,s5
+    8000020a:	02e020ef          	jal	80002238 <either_copyout>
+    8000020e:	57fd                	li	a5,-1
+    80000210:	04f50863          	beq	a0,a5,80000260 <consoleread+0xf2>
+      break;
+
+    dst++;
+    80000214:	0a05                	addi	s4,s4,1
+    --n;
+    80000216:	39fd                	addiw	s3,s3,-1
+
+    if(c == '\n'){
+    80000218:	47a9                	li	a5,10
+    8000021a:	04fb8d63          	beq	s7,a5,80000274 <consoleread+0x106>
+    8000021e:	6be2                	ld	s7,24(sp)
+    80000220:	b761                	j	800001a8 <consoleread+0x3a>
+        release(&cons.lock);
+    80000222:	00012517          	auipc	a0,0x12
+    80000226:	fde50513          	addi	a0,a0,-34 # 80012200 <cons>
+    8000022a:	23d000ef          	jal	80000c66 <release>
+        return -1;
+    8000022e:	557d                	li	a0,-1
+    }
+  }
+  release(&cons.lock);
+
+  return target - n;
+}
+    80000230:	60e6                	ld	ra,88(sp)
+    80000232:	6446                	ld	s0,80(sp)
+    80000234:	64a6                	ld	s1,72(sp)
+    80000236:	6906                	ld	s2,64(sp)
+    80000238:	79e2                	ld	s3,56(sp)
+    8000023a:	7a42                	ld	s4,48(sp)
+    8000023c:	7aa2                	ld	s5,40(sp)
+    8000023e:	7b02                	ld	s6,32(sp)
+    80000240:	6125                	addi	sp,sp,96
+    80000242:	8082                	ret
+      if(n < target){
+    80000244:	0009871b          	sext.w	a4,s3
+    80000248:	01677a63          	bgeu	a4,s6,8000025c <consoleread+0xee>
+        cons.r--;
+    8000024c:	00012717          	auipc	a4,0x12
+    80000250:	04f72623          	sw	a5,76(a4) # 80012298 <cons+0x98>
+    80000254:	6be2                	ld	s7,24(sp)
+    80000256:	a031                	j	80000262 <consoleread+0xf4>
+    80000258:	ec5e                	sd	s7,24(sp)
+    8000025a:	bfbd                	j	800001d8 <consoleread+0x6a>
+    8000025c:	6be2                	ld	s7,24(sp)
+    8000025e:	a011                	j	80000262 <consoleread+0xf4>
+    80000260:	6be2                	ld	s7,24(sp)
+  release(&cons.lock);
+    80000262:	00012517          	auipc	a0,0x12
+    80000266:	f9e50513          	addi	a0,a0,-98 # 80012200 <cons>
+    8000026a:	1fd000ef          	jal	80000c66 <release>
+  return target - n;
+    8000026e:	413b053b          	subw	a0,s6,s3
+    80000272:	bf7d                	j	80000230 <consoleread+0xc2>
+    80000274:	6be2                	ld	s7,24(sp)
+    80000276:	b7f5                	j	80000262 <consoleread+0xf4>
+
+0000000080000278 <consputc>:
+{
+    80000278:	1141                	addi	sp,sp,-16
+    8000027a:	e406                	sd	ra,8(sp)
+    8000027c:	e022                	sd	s0,0(sp)
+    8000027e:	0800                	addi	s0,sp,16
+  if(c == BACKSPACE){
+    80000280:	10000793          	li	a5,256
+    80000284:	00f50863          	beq	a0,a5,80000294 <consputc+0x1c>
+    uartputc_sync(c);
+    80000288:	6a4000ef          	jal	8000092c <uartputc_sync>
+}
+    8000028c:	60a2                	ld	ra,8(sp)
+    8000028e:	6402                	ld	s0,0(sp)
+    80000290:	0141                	addi	sp,sp,16
+    80000292:	8082                	ret
+    uartputc_sync('\b'); uartputc_sync(' '); uartputc_sync('\b');
+    80000294:	4521                	li	a0,8
+    80000296:	696000ef          	jal	8000092c <uartputc_sync>
+    8000029a:	02000513          	li	a0,32
+    8000029e:	68e000ef          	jal	8000092c <uartputc_sync>
+    800002a2:	4521                	li	a0,8
+    800002a4:	688000ef          	jal	8000092c <uartputc_sync>
+    800002a8:	b7d5                	j	8000028c <consputc+0x14>
+
+00000000800002aa <consoleintr>:
+// do erase/kill processing, append to cons.buf,
+// wake up consoleread() if a whole line has arrived.
+//
+void
+consoleintr(int c)
+{
+    800002aa:	1101                	addi	sp,sp,-32
+    800002ac:	ec06                	sd	ra,24(sp)
+    800002ae:	e822                	sd	s0,16(sp)
+    800002b0:	e426                	sd	s1,8(sp)
+    800002b2:	1000                	addi	s0,sp,32
+    800002b4:	84aa                	mv	s1,a0
+  acquire(&cons.lock);
+    800002b6:	00012517          	auipc	a0,0x12
+    800002ba:	f4a50513          	addi	a0,a0,-182 # 80012200 <cons>
+    800002be:	111000ef          	jal	80000bce <acquire>
+
+  switch(c){
+    800002c2:	47d5                	li	a5,21
+    800002c4:	08f48f63          	beq	s1,a5,80000362 <consoleintr+0xb8>
+    800002c8:	0297c563          	blt	a5,s1,800002f2 <consoleintr+0x48>
+    800002cc:	47a1                	li	a5,8
+    800002ce:	0ef48463          	beq	s1,a5,800003b6 <consoleintr+0x10c>
+    800002d2:	47c1                	li	a5,16
+    800002d4:	10f49563          	bne	s1,a5,800003de <consoleintr+0x134>
+  case C('P'):  // Print process list.
+    procdump();
+    800002d8:	7f5010ef          	jal	800022cc <procdump>
+      }
+    }
+    break;
+  }
+  
+  release(&cons.lock);
+    800002dc:	00012517          	auipc	a0,0x12
+    800002e0:	f2450513          	addi	a0,a0,-220 # 80012200 <cons>
+    800002e4:	183000ef          	jal	80000c66 <release>
+}
+    800002e8:	60e2                	ld	ra,24(sp)
+    800002ea:	6442                	ld	s0,16(sp)
+    800002ec:	64a2                	ld	s1,8(sp)
+    800002ee:	6105                	addi	sp,sp,32
+    800002f0:	8082                	ret
+  switch(c){
+    800002f2:	07f00793          	li	a5,127
+    800002f6:	0cf48063          	beq	s1,a5,800003b6 <consoleintr+0x10c>
+    if(c != 0 && cons.e-cons.r < INPUT_BUF_SIZE){
+    800002fa:	00012717          	auipc	a4,0x12
+    800002fe:	f0670713          	addi	a4,a4,-250 # 80012200 <cons>
+    80000302:	0a072783          	lw	a5,160(a4)
+    80000306:	09872703          	lw	a4,152(a4)
+    8000030a:	9f99                	subw	a5,a5,a4
+    8000030c:	07f00713          	li	a4,127
+    80000310:	fcf766e3          	bltu	a4,a5,800002dc <consoleintr+0x32>
+      c = (c == '\r') ? '\n' : c;
+    80000314:	47b5                	li	a5,13
+    80000316:	0cf48763          	beq	s1,a5,800003e4 <consoleintr+0x13a>
+      consputc(c);
+    8000031a:	8526                	mv	a0,s1
+    8000031c:	f5dff0ef          	jal	80000278 <consputc>
+      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;
+    80000320:	00012797          	auipc	a5,0x12
+    80000324:	ee078793          	addi	a5,a5,-288 # 80012200 <cons>
+    80000328:	0a07a683          	lw	a3,160(a5)
+    8000032c:	0016871b          	addiw	a4,a3,1
+    80000330:	0007061b          	sext.w	a2,a4
+    80000334:	0ae7a023          	sw	a4,160(a5)
+    80000338:	07f6f693          	andi	a3,a3,127
+    8000033c:	97b6                	add	a5,a5,a3
+    8000033e:	00978c23          	sb	s1,24(a5)
+      if(c == '\n' || c == C('D') || cons.e-cons.r == INPUT_BUF_SIZE){
+    80000342:	47a9                	li	a5,10
+    80000344:	0cf48563          	beq	s1,a5,8000040e <consoleintr+0x164>
+    80000348:	4791                	li	a5,4
+    8000034a:	0cf48263          	beq	s1,a5,8000040e <consoleintr+0x164>
+    8000034e:	00012797          	auipc	a5,0x12
+    80000352:	f4a7a783          	lw	a5,-182(a5) # 80012298 <cons+0x98>
+    80000356:	9f1d                	subw	a4,a4,a5
+    80000358:	08000793          	li	a5,128
+    8000035c:	f8f710e3          	bne	a4,a5,800002dc <consoleintr+0x32>
+    80000360:	a07d                	j	8000040e <consoleintr+0x164>
+    80000362:	e04a                	sd	s2,0(sp)
+    while(cons.e != cons.w &&
+    80000364:	00012717          	auipc	a4,0x12
+    80000368:	e9c70713          	addi	a4,a4,-356 # 80012200 <cons>
+    8000036c:	0a072783          	lw	a5,160(a4)
+    80000370:	09c72703          	lw	a4,156(a4)
+          cons.buf[(cons.e-1) % INPUT_BUF_SIZE] != '\n'){
+    80000374:	00012497          	auipc	s1,0x12
+    80000378:	e8c48493          	addi	s1,s1,-372 # 80012200 <cons>
+    while(cons.e != cons.w &&
+    8000037c:	4929                	li	s2,10
+    8000037e:	02f70863          	beq	a4,a5,800003ae <consoleintr+0x104>
+          cons.buf[(cons.e-1) % INPUT_BUF_SIZE] != '\n'){
+    80000382:	37fd                	addiw	a5,a5,-1
+    80000384:	07f7f713          	andi	a4,a5,127
+    80000388:	9726                	add	a4,a4,s1
+    while(cons.e != cons.w &&
+    8000038a:	01874703          	lbu	a4,24(a4)
+    8000038e:	03270263          	beq	a4,s2,800003b2 <consoleintr+0x108>
+      cons.e--;
+    80000392:	0af4a023          	sw	a5,160(s1)
+      consputc(BACKSPACE);
+    80000396:	10000513          	li	a0,256
+    8000039a:	edfff0ef          	jal	80000278 <consputc>
+    while(cons.e != cons.w &&
+    8000039e:	0a04a783          	lw	a5,160(s1)
+    800003a2:	09c4a703          	lw	a4,156(s1)
+    800003a6:	fcf71ee3          	bne	a4,a5,80000382 <consoleintr+0xd8>
+    800003aa:	6902                	ld	s2,0(sp)
+    800003ac:	bf05                	j	800002dc <consoleintr+0x32>
+    800003ae:	6902                	ld	s2,0(sp)
+    800003b0:	b735                	j	800002dc <consoleintr+0x32>
+    800003b2:	6902                	ld	s2,0(sp)
+    800003b4:	b725                	j	800002dc <consoleintr+0x32>
+    if(cons.e != cons.w){
+    800003b6:	00012717          	auipc	a4,0x12
+    800003ba:	e4a70713          	addi	a4,a4,-438 # 80012200 <cons>
+    800003be:	0a072783          	lw	a5,160(a4)
+    800003c2:	09c72703          	lw	a4,156(a4)
+    800003c6:	f0f70be3          	beq	a4,a5,800002dc <consoleintr+0x32>
+      cons.e--;
+    800003ca:	37fd                	addiw	a5,a5,-1
+    800003cc:	00012717          	auipc	a4,0x12
+    800003d0:	ecf72a23          	sw	a5,-300(a4) # 800122a0 <cons+0xa0>
+      consputc(BACKSPACE);
+    800003d4:	10000513          	li	a0,256
+    800003d8:	ea1ff0ef          	jal	80000278 <consputc>
+    800003dc:	b701                	j	800002dc <consoleintr+0x32>
+    if(c != 0 && cons.e-cons.r < INPUT_BUF_SIZE){
+    800003de:	ee048fe3          	beqz	s1,800002dc <consoleintr+0x32>
+    800003e2:	bf21                	j	800002fa <consoleintr+0x50>
+      consputc(c);
+    800003e4:	4529                	li	a0,10
+    800003e6:	e93ff0ef          	jal	80000278 <consputc>
+      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;
+    800003ea:	00012797          	auipc	a5,0x12
+    800003ee:	e1678793          	addi	a5,a5,-490 # 80012200 <cons>
+    800003f2:	0a07a703          	lw	a4,160(a5)
+    800003f6:	0017069b          	addiw	a3,a4,1
+    800003fa:	0006861b          	sext.w	a2,a3
+    800003fe:	0ad7a023          	sw	a3,160(a5)
+    80000402:	07f77713          	andi	a4,a4,127
+    80000406:	97ba                	add	a5,a5,a4
+    80000408:	4729                	li	a4,10
+    8000040a:	00e78c23          	sb	a4,24(a5)
+        cons.w = cons.e;
+    8000040e:	00012797          	auipc	a5,0x12
+    80000412:	e8c7a723          	sw	a2,-370(a5) # 8001229c <cons+0x9c>
+        wakeup(&cons.r);
+    80000416:	00012517          	auipc	a0,0x12
+    8000041a:	e8250513          	addi	a0,a0,-382 # 80012298 <cons+0x98>
+    8000041e:	30b010ef          	jal	80001f28 <wakeup>
+    80000422:	bd6d                	j	800002dc <consoleintr+0x32>
+
+0000000080000424 <consoleinit>:
+
+void
+consoleinit(void)
+{
+    80000424:	1141                	addi	sp,sp,-16
+    80000426:	e406                	sd	ra,8(sp)
+    80000428:	e022                	sd	s0,0(sp)
+    8000042a:	0800                	addi	s0,sp,16
+  initlock(&cons.lock, "cons");
+    8000042c:	00007597          	auipc	a1,0x7
+    80000430:	bd458593          	addi	a1,a1,-1068 # 80007000 <etext>
+    80000434:	00012517          	auipc	a0,0x12
+    80000438:	dcc50513          	addi	a0,a0,-564 # 80012200 <cons>
+    8000043c:	712000ef          	jal	80000b4e <initlock>
+
+  uartinit();
+    80000440:	400000ef          	jal	80000840 <uartinit>
+
+  // connect read and write system calls
+  // to consoleread and consolewrite.
+  devsw[CONSOLE].read = consoleread;
+    80000444:	00023797          	auipc	a5,0x23
+    80000448:	92c78793          	addi	a5,a5,-1748 # 80022d70 <devsw>
+    8000044c:	00000717          	auipc	a4,0x0
+    80000450:	d2270713          	addi	a4,a4,-734 # 8000016e <consoleread>
+    80000454:	eb98                	sd	a4,16(a5)
+  devsw[CONSOLE].write = consolewrite;
+    80000456:	00000717          	auipc	a4,0x0
+    8000045a:	c7a70713          	addi	a4,a4,-902 # 800000d0 <consolewrite>
+    8000045e:	ef98                	sd	a4,24(a5)
+}
+    80000460:	60a2                	ld	ra,8(sp)
+    80000462:	6402                	ld	s0,0(sp)
+    80000464:	0141                	addi	sp,sp,16
+    80000466:	8082                	ret
+
+0000000080000468 <printint>:
+
+static char digits[] = "0123456789abcdef";
+
+static void
+printint(long long xx, int base, int sign)
+{
+    80000468:	7139                	addi	sp,sp,-64
+    8000046a:	fc06                	sd	ra,56(sp)
+    8000046c:	f822                	sd	s0,48(sp)
+    8000046e:	0080                	addi	s0,sp,64
+  char buf[20];
+  int i;
+  unsigned long long x;
+
+  if(sign && (sign = (xx < 0)))
+    80000470:	c219                	beqz	a2,80000476 <printint+0xe>
+    80000472:	08054063          	bltz	a0,800004f2 <printint+0x8a>
+    x = -xx;
+  else
+    x = xx;
+    80000476:	4881                	li	a7,0
+    80000478:	fc840693          	addi	a3,s0,-56
+
+  i = 0;
+    8000047c:	4781                	li	a5,0
+  do {
+    buf[i++] = digits[x % base];
+    8000047e:	00007617          	auipc	a2,0x7
+    80000482:	2c260613          	addi	a2,a2,706 # 80007740 <digits>
+    80000486:	883e                	mv	a6,a5
+    80000488:	2785                	addiw	a5,a5,1
+    8000048a:	02b57733          	remu	a4,a0,a1
+    8000048e:	9732                	add	a4,a4,a2
+    80000490:	00074703          	lbu	a4,0(a4)
+    80000494:	00e68023          	sb	a4,0(a3)
+  } while((x /= base) != 0);
+    80000498:	872a                	mv	a4,a0
+    8000049a:	02b55533          	divu	a0,a0,a1
+    8000049e:	0685                	addi	a3,a3,1
+    800004a0:	feb773e3          	bgeu	a4,a1,80000486 <printint+0x1e>
+
+  if(sign)
+    800004a4:	00088a63          	beqz	a7,800004b8 <printint+0x50>
+    buf[i++] = '-';
+    800004a8:	1781                	addi	a5,a5,-32
+    800004aa:	97a2                	add	a5,a5,s0
+    800004ac:	02d00713          	li	a4,45
+    800004b0:	fee78423          	sb	a4,-24(a5)
+    800004b4:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+    800004b8:	02f05963          	blez	a5,800004ea <printint+0x82>
+    800004bc:	f426                	sd	s1,40(sp)
+    800004be:	f04a                	sd	s2,32(sp)
+    800004c0:	fc840713          	addi	a4,s0,-56
+    800004c4:	00f704b3          	add	s1,a4,a5
+    800004c8:	fff70913          	addi	s2,a4,-1
+    800004cc:	993e                	add	s2,s2,a5
+    800004ce:	37fd                	addiw	a5,a5,-1
+    800004d0:	1782                	slli	a5,a5,0x20
+    800004d2:	9381                	srli	a5,a5,0x20
+    800004d4:	40f90933          	sub	s2,s2,a5
+    consputc(buf[i]);
+    800004d8:	fff4c503          	lbu	a0,-1(s1)
+    800004dc:	d9dff0ef          	jal	80000278 <consputc>
+  while(--i >= 0)
+    800004e0:	14fd                	addi	s1,s1,-1
+    800004e2:	ff249be3          	bne	s1,s2,800004d8 <printint+0x70>
+    800004e6:	74a2                	ld	s1,40(sp)
+    800004e8:	7902                	ld	s2,32(sp)
+}
+    800004ea:	70e2                	ld	ra,56(sp)
+    800004ec:	7442                	ld	s0,48(sp)
+    800004ee:	6121                	addi	sp,sp,64
+    800004f0:	8082                	ret
+    x = -xx;
+    800004f2:	40a00533          	neg	a0,a0
+  if(sign && (sign = (xx < 0)))
+    800004f6:	4885                	li	a7,1
+    x = -xx;
+    800004f8:	b741                	j	80000478 <printint+0x10>
+
+00000000800004fa <printf>:
+}
+
+// Print to the console.
+int
+printf(char *fmt, ...)
+{
+    800004fa:	7131                	addi	sp,sp,-192
+    800004fc:	fc86                	sd	ra,120(sp)
+    800004fe:	f8a2                	sd	s0,112(sp)
+    80000500:	e8d2                	sd	s4,80(sp)
+    80000502:	0100                	addi	s0,sp,128
+    80000504:	8a2a                	mv	s4,a0
+    80000506:	e40c                	sd	a1,8(s0)
+    80000508:	e810                	sd	a2,16(s0)
+    8000050a:	ec14                	sd	a3,24(s0)
+    8000050c:	f018                	sd	a4,32(s0)
+    8000050e:	f41c                	sd	a5,40(s0)
+    80000510:	03043823          	sd	a6,48(s0)
+    80000514:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+  int i, cx, c0, c1, c2;
+  char *s;
+
+  if(panicking == 0)
+    80000518:	0000a797          	auipc	a5,0xa
+    8000051c:	cac7a783          	lw	a5,-852(a5) # 8000a1c4 <panicking>
+    80000520:	c3a1                	beqz	a5,80000560 <printf+0x66>
+    acquire(&pr.lock);
+
+  va_start(ap, fmt);
+    80000522:	00840793          	addi	a5,s0,8
+    80000526:	f8f43423          	sd	a5,-120(s0)
+  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
+    8000052a:	000a4503          	lbu	a0,0(s4)
+    8000052e:	28050763          	beqz	a0,800007bc <printf+0x2c2>
+    80000532:	f4a6                	sd	s1,104(sp)
+    80000534:	f0ca                	sd	s2,96(sp)
+    80000536:	ecce                	sd	s3,88(sp)
+    80000538:	e4d6                	sd	s5,72(sp)
+    8000053a:	e0da                	sd	s6,64(sp)
+    8000053c:	f862                	sd	s8,48(sp)
+    8000053e:	f466                	sd	s9,40(sp)
+    80000540:	f06a                	sd	s10,32(sp)
+    80000542:	ec6e                	sd	s11,24(sp)
+    80000544:	4981                	li	s3,0
+    if(cx != '%'){
+    80000546:	02500a93          	li	s5,37
+    i++;
+    c0 = fmt[i+0] & 0xff;
+    c1 = c2 = 0;
+    if(c0) c1 = fmt[i+1] & 0xff;
+    if(c1) c2 = fmt[i+2] & 0xff;
+    if(c0 == 'd'){
+    8000054a:	06400b13          	li	s6,100
+      printint(va_arg(ap, int), 10, 1);
+    } else if(c0 == 'l' && c1 == 'd'){
+    8000054e:	06c00c13          	li	s8,108
+      printint(va_arg(ap, uint64), 10, 1);
+      i += 1;
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+      printint(va_arg(ap, uint64), 10, 1);
+      i += 2;
+    } else if(c0 == 'u'){
+    80000552:	07500c93          	li	s9,117
+      printint(va_arg(ap, uint64), 10, 0);
+      i += 1;
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+      printint(va_arg(ap, uint64), 10, 0);
+      i += 2;
+    } else if(c0 == 'x'){
+    80000556:	07800d13          	li	s10,120
+      printint(va_arg(ap, uint64), 16, 0);
+      i += 1;
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+      printint(va_arg(ap, uint64), 16, 0);
+      i += 2;
+    } else if(c0 == 'p'){
+    8000055a:	07000d93          	li	s11,112
+    8000055e:	a01d                	j	80000584 <printf+0x8a>
+    acquire(&pr.lock);
+    80000560:	00012517          	auipc	a0,0x12
+    80000564:	d4850513          	addi	a0,a0,-696 # 800122a8 <pr>
+    80000568:	666000ef          	jal	80000bce <acquire>
+    8000056c:	bf5d                	j	80000522 <printf+0x28>
+      consputc(cx);
+    8000056e:	d0bff0ef          	jal	80000278 <consputc>
+      continue;
+    80000572:	84ce                	mv	s1,s3
+  for(i = 0; (cx = fmt[i] & 0xff) != 0; i++){
+    80000574:	0014899b          	addiw	s3,s1,1
+    80000578:	013a07b3          	add	a5,s4,s3
+    8000057c:	0007c503          	lbu	a0,0(a5)
+    80000580:	20050b63          	beqz	a0,80000796 <printf+0x29c>
+    if(cx != '%'){
+    80000584:	ff5515e3          	bne	a0,s5,8000056e <printf+0x74>
+    i++;
+    80000588:	0019849b          	addiw	s1,s3,1
+    c0 = fmt[i+0] & 0xff;
+    8000058c:	009a07b3          	add	a5,s4,s1
+    80000590:	0007c903          	lbu	s2,0(a5)
+    if(c0) c1 = fmt[i+1] & 0xff;
+    80000594:	20090b63          	beqz	s2,800007aa <printf+0x2b0>
+    80000598:	0017c783          	lbu	a5,1(a5)
+    c1 = c2 = 0;
+    8000059c:	86be                	mv	a3,a5
+    if(c1) c2 = fmt[i+2] & 0xff;
+    8000059e:	c789                	beqz	a5,800005a8 <printf+0xae>
+    800005a0:	009a0733          	add	a4,s4,s1
+    800005a4:	00274683          	lbu	a3,2(a4)
+    if(c0 == 'd'){
+    800005a8:	03690963          	beq	s2,s6,800005da <printf+0xe0>
+    } else if(c0 == 'l' && c1 == 'd'){
+    800005ac:	05890363          	beq	s2,s8,800005f2 <printf+0xf8>
+    } else if(c0 == 'u'){
+    800005b0:	0d990663          	beq	s2,s9,8000067c <printf+0x182>
+    } else if(c0 == 'x'){
+    800005b4:	11a90d63          	beq	s2,s10,800006ce <printf+0x1d4>
+    } else if(c0 == 'p'){
+    800005b8:	15b90663          	beq	s2,s11,80000704 <printf+0x20a>
+      printptr(va_arg(ap, uint64));
+    } else if(c0 == 'c'){
+    800005bc:	06300793          	li	a5,99
+    800005c0:	18f90563          	beq	s2,a5,8000074a <printf+0x250>
+      consputc(va_arg(ap, uint));
+    } else if(c0 == 's'){
+    800005c4:	07300793          	li	a5,115
+    800005c8:	18f90b63          	beq	s2,a5,8000075e <printf+0x264>
+      if((s = va_arg(ap, char*)) == 0)
+        s = "(null)";
+      for(; *s; s++)
+        consputc(*s);
+    } else if(c0 == '%'){
+    800005cc:	03591b63          	bne	s2,s5,80000602 <printf+0x108>
+      consputc('%');
+    800005d0:	02500513          	li	a0,37
+    800005d4:	ca5ff0ef          	jal	80000278 <consputc>
+    800005d8:	bf71                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, int), 10, 1);
+    800005da:	f8843783          	ld	a5,-120(s0)
+    800005de:	00878713          	addi	a4,a5,8
+    800005e2:	f8e43423          	sd	a4,-120(s0)
+    800005e6:	4605                	li	a2,1
+    800005e8:	45a9                	li	a1,10
+    800005ea:	4388                	lw	a0,0(a5)
+    800005ec:	e7dff0ef          	jal	80000468 <printint>
+    800005f0:	b751                	j	80000574 <printf+0x7a>
+    } else if(c0 == 'l' && c1 == 'd'){
+    800005f2:	01678f63          	beq	a5,s6,80000610 <printf+0x116>
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+    800005f6:	03878b63          	beq	a5,s8,8000062c <printf+0x132>
+    } else if(c0 == 'l' && c1 == 'u'){
+    800005fa:	09978e63          	beq	a5,s9,80000696 <printf+0x19c>
+    } else if(c0 == 'l' && c1 == 'x'){
+    800005fe:	0fa78563          	beq	a5,s10,800006e8 <printf+0x1ee>
+    } else if(c0 == 0){
+      break;
+    } else {
+      // Print unknown % sequence to draw attention.
+      consputc('%');
+    80000602:	8556                	mv	a0,s5
+    80000604:	c75ff0ef          	jal	80000278 <consputc>
+      consputc(c0);
+    80000608:	854a                	mv	a0,s2
+    8000060a:	c6fff0ef          	jal	80000278 <consputc>
+    8000060e:	b79d                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint64), 10, 1);
+    80000610:	f8843783          	ld	a5,-120(s0)
+    80000614:	00878713          	addi	a4,a5,8
+    80000618:	f8e43423          	sd	a4,-120(s0)
+    8000061c:	4605                	li	a2,1
+    8000061e:	45a9                	li	a1,10
+    80000620:	6388                	ld	a0,0(a5)
+    80000622:	e47ff0ef          	jal	80000468 <printint>
+      i += 1;
+    80000626:	0029849b          	addiw	s1,s3,2
+    8000062a:	b7a9                	j	80000574 <printf+0x7a>
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+    8000062c:	06400793          	li	a5,100
+    80000630:	02f68863          	beq	a3,a5,80000660 <printf+0x166>
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+    80000634:	07500793          	li	a5,117
+    80000638:	06f68d63          	beq	a3,a5,800006b2 <printf+0x1b8>
+    } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+    8000063c:	07800793          	li	a5,120
+    80000640:	fcf691e3          	bne	a3,a5,80000602 <printf+0x108>
+      printint(va_arg(ap, uint64), 16, 0);
+    80000644:	f8843783          	ld	a5,-120(s0)
+    80000648:	00878713          	addi	a4,a5,8
+    8000064c:	f8e43423          	sd	a4,-120(s0)
+    80000650:	4601                	li	a2,0
+    80000652:	45c1                	li	a1,16
+    80000654:	6388                	ld	a0,0(a5)
+    80000656:	e13ff0ef          	jal	80000468 <printint>
+      i += 2;
+    8000065a:	0039849b          	addiw	s1,s3,3
+    8000065e:	bf19                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint64), 10, 1);
+    80000660:	f8843783          	ld	a5,-120(s0)
+    80000664:	00878713          	addi	a4,a5,8
+    80000668:	f8e43423          	sd	a4,-120(s0)
+    8000066c:	4605                	li	a2,1
+    8000066e:	45a9                	li	a1,10
+    80000670:	6388                	ld	a0,0(a5)
+    80000672:	df7ff0ef          	jal	80000468 <printint>
+      i += 2;
+    80000676:	0039849b          	addiw	s1,s3,3
+    8000067a:	bded                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint32), 10, 0);
+    8000067c:	f8843783          	ld	a5,-120(s0)
+    80000680:	00878713          	addi	a4,a5,8
+    80000684:	f8e43423          	sd	a4,-120(s0)
+    80000688:	4601                	li	a2,0
+    8000068a:	45a9                	li	a1,10
+    8000068c:	0007e503          	lwu	a0,0(a5)
+    80000690:	dd9ff0ef          	jal	80000468 <printint>
+    80000694:	b5c5                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint64), 10, 0);
+    80000696:	f8843783          	ld	a5,-120(s0)
+    8000069a:	00878713          	addi	a4,a5,8
+    8000069e:	f8e43423          	sd	a4,-120(s0)
+    800006a2:	4601                	li	a2,0
+    800006a4:	45a9                	li	a1,10
+    800006a6:	6388                	ld	a0,0(a5)
+    800006a8:	dc1ff0ef          	jal	80000468 <printint>
+      i += 1;
+    800006ac:	0029849b          	addiw	s1,s3,2
+    800006b0:	b5d1                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint64), 10, 0);
+    800006b2:	f8843783          	ld	a5,-120(s0)
+    800006b6:	00878713          	addi	a4,a5,8
+    800006ba:	f8e43423          	sd	a4,-120(s0)
+    800006be:	4601                	li	a2,0
+    800006c0:	45a9                	li	a1,10
+    800006c2:	6388                	ld	a0,0(a5)
+    800006c4:	da5ff0ef          	jal	80000468 <printint>
+      i += 2;
+    800006c8:	0039849b          	addiw	s1,s3,3
+    800006cc:	b565                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint32), 16, 0);
+    800006ce:	f8843783          	ld	a5,-120(s0)
+    800006d2:	00878713          	addi	a4,a5,8
+    800006d6:	f8e43423          	sd	a4,-120(s0)
+    800006da:	4601                	li	a2,0
+    800006dc:	45c1                	li	a1,16
+    800006de:	0007e503          	lwu	a0,0(a5)
+    800006e2:	d87ff0ef          	jal	80000468 <printint>
+    800006e6:	b579                	j	80000574 <printf+0x7a>
+      printint(va_arg(ap, uint64), 16, 0);
+    800006e8:	f8843783          	ld	a5,-120(s0)
+    800006ec:	00878713          	addi	a4,a5,8
+    800006f0:	f8e43423          	sd	a4,-120(s0)
+    800006f4:	4601                	li	a2,0
+    800006f6:	45c1                	li	a1,16
+    800006f8:	6388                	ld	a0,0(a5)
+    800006fa:	d6fff0ef          	jal	80000468 <printint>
+      i += 1;
+    800006fe:	0029849b          	addiw	s1,s3,2
+    80000702:	bd8d                	j	80000574 <printf+0x7a>
+    80000704:	fc5e                	sd	s7,56(sp)
+      printptr(va_arg(ap, uint64));
+    80000706:	f8843783          	ld	a5,-120(s0)
+    8000070a:	00878713          	addi	a4,a5,8
+    8000070e:	f8e43423          	sd	a4,-120(s0)
+    80000712:	0007b983          	ld	s3,0(a5)
+  consputc('0');
+    80000716:	03000513          	li	a0,48
+    8000071a:	b5fff0ef          	jal	80000278 <consputc>
+  consputc('x');
+    8000071e:	07800513          	li	a0,120
+    80000722:	b57ff0ef          	jal	80000278 <consputc>
+    80000726:	4941                	li	s2,16
+    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
+    80000728:	00007b97          	auipc	s7,0x7
+    8000072c:	018b8b93          	addi	s7,s7,24 # 80007740 <digits>
+    80000730:	03c9d793          	srli	a5,s3,0x3c
+    80000734:	97de                	add	a5,a5,s7
+    80000736:	0007c503          	lbu	a0,0(a5)
+    8000073a:	b3fff0ef          	jal	80000278 <consputc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+    8000073e:	0992                	slli	s3,s3,0x4
+    80000740:	397d                	addiw	s2,s2,-1
+    80000742:	fe0917e3          	bnez	s2,80000730 <printf+0x236>
+    80000746:	7be2                	ld	s7,56(sp)
+    80000748:	b535                	j	80000574 <printf+0x7a>
+      consputc(va_arg(ap, uint));
+    8000074a:	f8843783          	ld	a5,-120(s0)
+    8000074e:	00878713          	addi	a4,a5,8
+    80000752:	f8e43423          	sd	a4,-120(s0)
+    80000756:	4388                	lw	a0,0(a5)
+    80000758:	b21ff0ef          	jal	80000278 <consputc>
+    8000075c:	bd21                	j	80000574 <printf+0x7a>
+      if((s = va_arg(ap, char*)) == 0)
+    8000075e:	f8843783          	ld	a5,-120(s0)
+    80000762:	00878713          	addi	a4,a5,8
+    80000766:	f8e43423          	sd	a4,-120(s0)
+    8000076a:	0007b903          	ld	s2,0(a5)
+    8000076e:	00090d63          	beqz	s2,80000788 <printf+0x28e>
+      for(; *s; s++)
+    80000772:	00094503          	lbu	a0,0(s2)
+    80000776:	de050fe3          	beqz	a0,80000574 <printf+0x7a>
+        consputc(*s);
+    8000077a:	affff0ef          	jal	80000278 <consputc>
+      for(; *s; s++)
+    8000077e:	0905                	addi	s2,s2,1
+    80000780:	00094503          	lbu	a0,0(s2)
+    80000784:	f97d                	bnez	a0,8000077a <printf+0x280>
+    80000786:	b3fd                	j	80000574 <printf+0x7a>
+        s = "(null)";
+    80000788:	00007917          	auipc	s2,0x7
+    8000078c:	88090913          	addi	s2,s2,-1920 # 80007008 <etext+0x8>
+      for(; *s; s++)
+    80000790:	02800513          	li	a0,40
+    80000794:	b7dd                	j	8000077a <printf+0x280>
+    80000796:	74a6                	ld	s1,104(sp)
+    80000798:	7906                	ld	s2,96(sp)
+    8000079a:	69e6                	ld	s3,88(sp)
+    8000079c:	6aa6                	ld	s5,72(sp)
+    8000079e:	6b06                	ld	s6,64(sp)
+    800007a0:	7c42                	ld	s8,48(sp)
+    800007a2:	7ca2                	ld	s9,40(sp)
+    800007a4:	7d02                	ld	s10,32(sp)
+    800007a6:	6de2                	ld	s11,24(sp)
+    800007a8:	a811                	j	800007bc <printf+0x2c2>
+    800007aa:	74a6                	ld	s1,104(sp)
+    800007ac:	7906                	ld	s2,96(sp)
+    800007ae:	69e6                	ld	s3,88(sp)
+    800007b0:	6aa6                	ld	s5,72(sp)
+    800007b2:	6b06                	ld	s6,64(sp)
+    800007b4:	7c42                	ld	s8,48(sp)
+    800007b6:	7ca2                	ld	s9,40(sp)
+    800007b8:	7d02                	ld	s10,32(sp)
+    800007ba:	6de2                	ld	s11,24(sp)
+    }
+
+  }
+  va_end(ap);
+
+  if(panicking == 0)
+    800007bc:	0000a797          	auipc	a5,0xa
+    800007c0:	a087a783          	lw	a5,-1528(a5) # 8000a1c4 <panicking>
+    800007c4:	c799                	beqz	a5,800007d2 <printf+0x2d8>
+    release(&pr.lock);
+
+  return 0;
+}
+    800007c6:	4501                	li	a0,0
+    800007c8:	70e6                	ld	ra,120(sp)
+    800007ca:	7446                	ld	s0,112(sp)
+    800007cc:	6a46                	ld	s4,80(sp)
+    800007ce:	6129                	addi	sp,sp,192
+    800007d0:	8082                	ret
+    release(&pr.lock);
+    800007d2:	00012517          	auipc	a0,0x12
+    800007d6:	ad650513          	addi	a0,a0,-1322 # 800122a8 <pr>
+    800007da:	48c000ef          	jal	80000c66 <release>
+  return 0;
+    800007de:	b7e5                	j	800007c6 <printf+0x2cc>
+
+00000000800007e0 <panic>:
+
+void
+panic(char *s)
+{
+    800007e0:	1101                	addi	sp,sp,-32
+    800007e2:	ec06                	sd	ra,24(sp)
+    800007e4:	e822                	sd	s0,16(sp)
+    800007e6:	e426                	sd	s1,8(sp)
+    800007e8:	e04a                	sd	s2,0(sp)
+    800007ea:	1000                	addi	s0,sp,32
+    800007ec:	84aa                	mv	s1,a0
+  panicking = 1;
+    800007ee:	4905                	li	s2,1
+    800007f0:	0000a797          	auipc	a5,0xa
+    800007f4:	9d27aa23          	sw	s2,-1580(a5) # 8000a1c4 <panicking>
+  printf("panic: ");
+    800007f8:	00007517          	auipc	a0,0x7
+    800007fc:	82050513          	addi	a0,a0,-2016 # 80007018 <etext+0x18>
+    80000800:	cfbff0ef          	jal	800004fa <printf>
+  printf("%s\n", s);
+    80000804:	85a6                	mv	a1,s1
+    80000806:	00007517          	auipc	a0,0x7
+    8000080a:	81a50513          	addi	a0,a0,-2022 # 80007020 <etext+0x20>
+    8000080e:	cedff0ef          	jal	800004fa <printf>
+  panicked = 1; // freeze uart output from other CPUs
+    80000812:	0000a797          	auipc	a5,0xa
+    80000816:	9b27a723          	sw	s2,-1618(a5) # 8000a1c0 <panicked>
+  for(;;)
+    8000081a:	a001                	j	8000081a <panic+0x3a>
+
+000000008000081c <printfinit>:
+    ;
+}
+
+void
+printfinit(void)
+{
+    8000081c:	1141                	addi	sp,sp,-16
+    8000081e:	e406                	sd	ra,8(sp)
+    80000820:	e022                	sd	s0,0(sp)
+    80000822:	0800                	addi	s0,sp,16
+  initlock(&pr.lock, "pr");
+    80000824:	00007597          	auipc	a1,0x7
+    80000828:	80458593          	addi	a1,a1,-2044 # 80007028 <etext+0x28>
+    8000082c:	00012517          	auipc	a0,0x12
+    80000830:	a7c50513          	addi	a0,a0,-1412 # 800122a8 <pr>
+    80000834:	31a000ef          	jal	80000b4e <initlock>
+}
+    80000838:	60a2                	ld	ra,8(sp)
+    8000083a:	6402                	ld	s0,0(sp)
+    8000083c:	0141                	addi	sp,sp,16
+    8000083e:	8082                	ret
+
+0000000080000840 <uartinit>:
+extern volatile int panicking; // from printf.c
+extern volatile int panicked; // from printf.c
+
+void
+uartinit(void)
+{
+    80000840:	1141                	addi	sp,sp,-16
+    80000842:	e406                	sd	ra,8(sp)
+    80000844:	e022                	sd	s0,0(sp)
+    80000846:	0800                	addi	s0,sp,16
+  // disable interrupts.
+  WriteReg(IER, 0x00);
+    80000848:	100007b7          	lui	a5,0x10000
+    8000084c:	000780a3          	sb	zero,1(a5) # 10000001 <_entry-0x6fffffff>
+
+  // special mode to set baud rate.
+  WriteReg(LCR, LCR_BAUD_LATCH);
+    80000850:	10000737          	lui	a4,0x10000
+    80000854:	f8000693          	li	a3,-128
+    80000858:	00d701a3          	sb	a3,3(a4) # 10000003 <_entry-0x6ffffffd>
+
+  // LSB for baud rate of 38.4K.
+  WriteReg(0, 0x03);
+    8000085c:	468d                	li	a3,3
+    8000085e:	10000637          	lui	a2,0x10000
+    80000862:	00d60023          	sb	a3,0(a2) # 10000000 <_entry-0x70000000>
+
+  // MSB for baud rate of 38.4K.
+  WriteReg(1, 0x00);
+    80000866:	000780a3          	sb	zero,1(a5)
+
+  // leave set-baud mode,
+  // and set word length to 8 bits, no parity.
+  WriteReg(LCR, LCR_EIGHT_BITS);
+    8000086a:	00d701a3          	sb	a3,3(a4)
+
+  // reset and enable FIFOs.
+  WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);
+    8000086e:	10000737          	lui	a4,0x10000
+    80000872:	461d                	li	a2,7
+    80000874:	00c70123          	sb	a2,2(a4) # 10000002 <_entry-0x6ffffffe>
+
+  // enable transmit and receive interrupts.
+  WriteReg(IER, IER_TX_ENABLE | IER_RX_ENABLE);
+    80000878:	00d780a3          	sb	a3,1(a5)
+
+  initlock(&tx_lock, "uart");
+    8000087c:	00006597          	auipc	a1,0x6
+    80000880:	7b458593          	addi	a1,a1,1972 # 80007030 <etext+0x30>
+    80000884:	00012517          	auipc	a0,0x12
+    80000888:	a3c50513          	addi	a0,a0,-1476 # 800122c0 <tx_lock>
+    8000088c:	2c2000ef          	jal	80000b4e <initlock>
+}
+    80000890:	60a2                	ld	ra,8(sp)
+    80000892:	6402                	ld	s0,0(sp)
+    80000894:	0141                	addi	sp,sp,16
+    80000896:	8082                	ret
+
+0000000080000898 <uartwrite>:
+// transmit buf[] to the uart. it blocks if the
+// uart is busy, so it cannot be called from
+// interrupts, only from write() system calls.
+void
+uartwrite(char buf[], int n)
+{
+    80000898:	715d                	addi	sp,sp,-80
+    8000089a:	e486                	sd	ra,72(sp)
+    8000089c:	e0a2                	sd	s0,64(sp)
+    8000089e:	fc26                	sd	s1,56(sp)
+    800008a0:	ec56                	sd	s5,24(sp)
+    800008a2:	0880                	addi	s0,sp,80
+    800008a4:	8aaa                	mv	s5,a0
+    800008a6:	84ae                	mv	s1,a1
+  acquire(&tx_lock);
+    800008a8:	00012517          	auipc	a0,0x12
+    800008ac:	a1850513          	addi	a0,a0,-1512 # 800122c0 <tx_lock>
+    800008b0:	31e000ef          	jal	80000bce <acquire>
+
+  int i = 0;
+  while(i < n){ 
+    800008b4:	06905063          	blez	s1,80000914 <uartwrite+0x7c>
+    800008b8:	f84a                	sd	s2,48(sp)
+    800008ba:	f44e                	sd	s3,40(sp)
+    800008bc:	f052                	sd	s4,32(sp)
+    800008be:	e85a                	sd	s6,16(sp)
+    800008c0:	e45e                	sd	s7,8(sp)
+    800008c2:	8a56                	mv	s4,s5
+    800008c4:	9aa6                	add	s5,s5,s1
+    while(tx_busy != 0){
+    800008c6:	0000a497          	auipc	s1,0xa
+    800008ca:	90648493          	addi	s1,s1,-1786 # 8000a1cc <tx_busy>
+      // wait for a UART transmit-complete interrupt
+      // to set tx_busy to 0.
+      sleep(&tx_chan, &tx_lock);
+    800008ce:	00012997          	auipc	s3,0x12
+    800008d2:	9f298993          	addi	s3,s3,-1550 # 800122c0 <tx_lock>
+    800008d6:	0000a917          	auipc	s2,0xa
+    800008da:	8f290913          	addi	s2,s2,-1806 # 8000a1c8 <tx_chan>
+    }   
+      
+    WriteReg(THR, buf[i]);
+    800008de:	10000bb7          	lui	s7,0x10000
+    i += 1;
+    tx_busy = 1;
+    800008e2:	4b05                	li	s6,1
+    800008e4:	a005                	j	80000904 <uartwrite+0x6c>
+      sleep(&tx_chan, &tx_lock);
+    800008e6:	85ce                	mv	a1,s3
+    800008e8:	854a                	mv	a0,s2
+    800008ea:	5f2010ef          	jal	80001edc <sleep>
+    while(tx_busy != 0){
+    800008ee:	409c                	lw	a5,0(s1)
+    800008f0:	fbfd                	bnez	a5,800008e6 <uartwrite+0x4e>
+    WriteReg(THR, buf[i]);
+    800008f2:	000a4783          	lbu	a5,0(s4)
+    800008f6:	00fb8023          	sb	a5,0(s7) # 10000000 <_entry-0x70000000>
+    tx_busy = 1;
+    800008fa:	0164a023          	sw	s6,0(s1)
+  while(i < n){ 
+    800008fe:	0a05                	addi	s4,s4,1
+    80000900:	015a0563          	beq	s4,s5,8000090a <uartwrite+0x72>
+    while(tx_busy != 0){
+    80000904:	409c                	lw	a5,0(s1)
+    80000906:	f3e5                	bnez	a5,800008e6 <uartwrite+0x4e>
+    80000908:	b7ed                	j	800008f2 <uartwrite+0x5a>
+    8000090a:	7942                	ld	s2,48(sp)
+    8000090c:	79a2                	ld	s3,40(sp)
+    8000090e:	7a02                	ld	s4,32(sp)
+    80000910:	6b42                	ld	s6,16(sp)
+    80000912:	6ba2                	ld	s7,8(sp)
+  }
+
+  release(&tx_lock);
+    80000914:	00012517          	auipc	a0,0x12
+    80000918:	9ac50513          	addi	a0,a0,-1620 # 800122c0 <tx_lock>
+    8000091c:	34a000ef          	jal	80000c66 <release>
+}
+    80000920:	60a6                	ld	ra,72(sp)
+    80000922:	6406                	ld	s0,64(sp)
+    80000924:	74e2                	ld	s1,56(sp)
+    80000926:	6ae2                	ld	s5,24(sp)
+    80000928:	6161                	addi	sp,sp,80
+    8000092a:	8082                	ret
+
+000000008000092c <uartputc_sync>:
+// interrupts, for use by kernel printf() and
+// to echo characters. it spins waiting for the uart's
+// output register to be empty.
+void
+uartputc_sync(int c)
+{
+    8000092c:	1101                	addi	sp,sp,-32
+    8000092e:	ec06                	sd	ra,24(sp)
+    80000930:	e822                	sd	s0,16(sp)
+    80000932:	e426                	sd	s1,8(sp)
+    80000934:	1000                	addi	s0,sp,32
+    80000936:	84aa                	mv	s1,a0
+  if(panicking == 0)
+    80000938:	0000a797          	auipc	a5,0xa
+    8000093c:	88c7a783          	lw	a5,-1908(a5) # 8000a1c4 <panicking>
+    80000940:	cf95                	beqz	a5,8000097c <uartputc_sync+0x50>
+    push_off();
+
+  if(panicked){
+    80000942:	0000a797          	auipc	a5,0xa
+    80000946:	87e7a783          	lw	a5,-1922(a5) # 8000a1c0 <panicked>
+    8000094a:	ef85                	bnez	a5,80000982 <uartputc_sync+0x56>
+    for(;;)
+      ;
+  }
+
+  // wait for Transmit Holding Empty to be set in LSR.
+  while((ReadReg(LSR) & LSR_TX_IDLE) == 0)
+    8000094c:	10000737          	lui	a4,0x10000
+    80000950:	0715                	addi	a4,a4,5 # 10000005 <_entry-0x6ffffffb>
+    80000952:	00074783          	lbu	a5,0(a4)
+    80000956:	0207f793          	andi	a5,a5,32
+    8000095a:	dfe5                	beqz	a5,80000952 <uartputc_sync+0x26>
+    ;
+  WriteReg(THR, c);
+    8000095c:	0ff4f513          	zext.b	a0,s1
+    80000960:	100007b7          	lui	a5,0x10000
+    80000964:	00a78023          	sb	a0,0(a5) # 10000000 <_entry-0x70000000>
+
+  if(panicking == 0)
+    80000968:	0000a797          	auipc	a5,0xa
+    8000096c:	85c7a783          	lw	a5,-1956(a5) # 8000a1c4 <panicking>
+    80000970:	cb91                	beqz	a5,80000984 <uartputc_sync+0x58>
+    pop_off();
+}
+    80000972:	60e2                	ld	ra,24(sp)
+    80000974:	6442                	ld	s0,16(sp)
+    80000976:	64a2                	ld	s1,8(sp)
+    80000978:	6105                	addi	sp,sp,32
+    8000097a:	8082                	ret
+    push_off();
+    8000097c:	212000ef          	jal	80000b8e <push_off>
+    80000980:	b7c9                	j	80000942 <uartputc_sync+0x16>
+    for(;;)
+    80000982:	a001                	j	80000982 <uartputc_sync+0x56>
+    pop_off();
+    80000984:	28e000ef          	jal	80000c12 <pop_off>
+}
+    80000988:	b7ed                	j	80000972 <uartputc_sync+0x46>
+
+000000008000098a <uartgetc>:
+
+// read one input character from the UART.
+// return -1 if none is waiting.
+int
+uartgetc(void)
+{
+    8000098a:	1141                	addi	sp,sp,-16
+    8000098c:	e422                	sd	s0,8(sp)
+    8000098e:	0800                	addi	s0,sp,16
+  if(ReadReg(LSR) & LSR_RX_READY){
+    80000990:	100007b7          	lui	a5,0x10000
+    80000994:	0795                	addi	a5,a5,5 # 10000005 <_entry-0x6ffffffb>
+    80000996:	0007c783          	lbu	a5,0(a5)
+    8000099a:	8b85                	andi	a5,a5,1
+    8000099c:	cb81                	beqz	a5,800009ac <uartgetc+0x22>
+    // input data is ready.
+    return ReadReg(RHR);
+    8000099e:	100007b7          	lui	a5,0x10000
+    800009a2:	0007c503          	lbu	a0,0(a5) # 10000000 <_entry-0x70000000>
+  } else {
+    return -1;
+  }
+}
+    800009a6:	6422                	ld	s0,8(sp)
+    800009a8:	0141                	addi	sp,sp,16
+    800009aa:	8082                	ret
+    return -1;
+    800009ac:	557d                	li	a0,-1
+    800009ae:	bfe5                	j	800009a6 <uartgetc+0x1c>
+
+00000000800009b0 <uartintr>:
+// handle a uart interrupt, raised because input has
+// arrived, or the uart is ready for more output, or
+// both. called from devintr().
+void
+uartintr(void)
+{
+    800009b0:	1101                	addi	sp,sp,-32
+    800009b2:	ec06                	sd	ra,24(sp)
+    800009b4:	e822                	sd	s0,16(sp)
+    800009b6:	e426                	sd	s1,8(sp)
+    800009b8:	1000                	addi	s0,sp,32
+  ReadReg(ISR); // acknowledge the interrupt
+    800009ba:	100007b7          	lui	a5,0x10000
+    800009be:	0789                	addi	a5,a5,2 # 10000002 <_entry-0x6ffffffe>
+    800009c0:	0007c783          	lbu	a5,0(a5)
+
+  acquire(&tx_lock);
+    800009c4:	00012517          	auipc	a0,0x12
+    800009c8:	8fc50513          	addi	a0,a0,-1796 # 800122c0 <tx_lock>
+    800009cc:	202000ef          	jal	80000bce <acquire>
+  if(ReadReg(LSR) & LSR_TX_IDLE){
+    800009d0:	100007b7          	lui	a5,0x10000
+    800009d4:	0795                	addi	a5,a5,5 # 10000005 <_entry-0x6ffffffb>
+    800009d6:	0007c783          	lbu	a5,0(a5)
+    800009da:	0207f793          	andi	a5,a5,32
+    800009de:	eb89                	bnez	a5,800009f0 <uartintr+0x40>
+    // UART finished transmitting; wake up sending thread.
+    tx_busy = 0;
+    wakeup(&tx_chan);
+  }
+  release(&tx_lock);
+    800009e0:	00012517          	auipc	a0,0x12
+    800009e4:	8e050513          	addi	a0,a0,-1824 # 800122c0 <tx_lock>
+    800009e8:	27e000ef          	jal	80000c66 <release>
+
+  // read and process incoming characters.
+  while(1){
+    int c = uartgetc();
+    if(c == -1)
+    800009ec:	54fd                	li	s1,-1
+    800009ee:	a831                	j	80000a0a <uartintr+0x5a>
+    tx_busy = 0;
+    800009f0:	00009797          	auipc	a5,0x9
+    800009f4:	7c07ae23          	sw	zero,2012(a5) # 8000a1cc <tx_busy>
+    wakeup(&tx_chan);
+    800009f8:	00009517          	auipc	a0,0x9
+    800009fc:	7d050513          	addi	a0,a0,2000 # 8000a1c8 <tx_chan>
+    80000a00:	528010ef          	jal	80001f28 <wakeup>
+    80000a04:	bff1                	j	800009e0 <uartintr+0x30>
+      break;
+    consoleintr(c);
+    80000a06:	8a5ff0ef          	jal	800002aa <consoleintr>
+    int c = uartgetc();
+    80000a0a:	f81ff0ef          	jal	8000098a <uartgetc>
+    if(c == -1)
+    80000a0e:	fe951ce3          	bne	a0,s1,80000a06 <uartintr+0x56>
+  }
+}
+    80000a12:	60e2                	ld	ra,24(sp)
+    80000a14:	6442                	ld	s0,16(sp)
+    80000a16:	64a2                	ld	s1,8(sp)
+    80000a18:	6105                	addi	sp,sp,32
+    80000a1a:	8082                	ret
+
+0000000080000a1c <kfree>:
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(void *pa)
+{
+    80000a1c:	1101                	addi	sp,sp,-32
+    80000a1e:	ec06                	sd	ra,24(sp)
+    80000a20:	e822                	sd	s0,16(sp)
+    80000a22:	e426                	sd	s1,8(sp)
+    80000a24:	e04a                	sd	s2,0(sp)
+    80000a26:	1000                	addi	s0,sp,32
+  struct run *r;
+
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    80000a28:	03451793          	slli	a5,a0,0x34
+    80000a2c:	e7a9                	bnez	a5,80000a76 <kfree+0x5a>
+    80000a2e:	84aa                	mv	s1,a0
+    80000a30:	00023797          	auipc	a5,0x23
+    80000a34:	4d878793          	addi	a5,a5,1240 # 80023f08 <end>
+    80000a38:	02f56f63          	bltu	a0,a5,80000a76 <kfree+0x5a>
+    80000a3c:	47c5                	li	a5,17
+    80000a3e:	07ee                	slli	a5,a5,0x1b
+    80000a40:	02f57b63          	bgeu	a0,a5,80000a76 <kfree+0x5a>
+    panic("kfree");
+
+  // Fill with junk to catch dangling refs.
+  memset(pa, 1, PGSIZE);
+    80000a44:	6605                	lui	a2,0x1
+    80000a46:	4585                	li	a1,1
+    80000a48:	25a000ef          	jal	80000ca2 <memset>
+
+  r = (struct run*)pa;
+
+  acquire(&kmem.lock);
+    80000a4c:	00012917          	auipc	s2,0x12
+    80000a50:	88c90913          	addi	s2,s2,-1908 # 800122d8 <kmem>
+    80000a54:	854a                	mv	a0,s2
+    80000a56:	178000ef          	jal	80000bce <acquire>
+  r->next = kmem.freelist;
+    80000a5a:	01893783          	ld	a5,24(s2)
+    80000a5e:	e09c                	sd	a5,0(s1)
+  kmem.freelist = r;
+    80000a60:	00993c23          	sd	s1,24(s2)
+  release(&kmem.lock);
+    80000a64:	854a                	mv	a0,s2
+    80000a66:	200000ef          	jal	80000c66 <release>
+}
+    80000a6a:	60e2                	ld	ra,24(sp)
+    80000a6c:	6442                	ld	s0,16(sp)
+    80000a6e:	64a2                	ld	s1,8(sp)
+    80000a70:	6902                	ld	s2,0(sp)
+    80000a72:	6105                	addi	sp,sp,32
+    80000a74:	8082                	ret
+    panic("kfree");
+    80000a76:	00006517          	auipc	a0,0x6
+    80000a7a:	5c250513          	addi	a0,a0,1474 # 80007038 <etext+0x38>
+    80000a7e:	d63ff0ef          	jal	800007e0 <panic>
+
+0000000080000a82 <freerange>:
+{
+    80000a82:	7179                	addi	sp,sp,-48
+    80000a84:	f406                	sd	ra,40(sp)
+    80000a86:	f022                	sd	s0,32(sp)
+    80000a88:	ec26                	sd	s1,24(sp)
+    80000a8a:	1800                	addi	s0,sp,48
+  p = (char*)PGROUNDUP((uint64)pa_start);
+    80000a8c:	6785                	lui	a5,0x1
+    80000a8e:	fff78713          	addi	a4,a5,-1 # fff <_entry-0x7ffff001>
+    80000a92:	00e504b3          	add	s1,a0,a4
+    80000a96:	777d                	lui	a4,0xfffff
+    80000a98:	8cf9                	and	s1,s1,a4
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+    80000a9a:	94be                	add	s1,s1,a5
+    80000a9c:	0295e263          	bltu	a1,s1,80000ac0 <freerange+0x3e>
+    80000aa0:	e84a                	sd	s2,16(sp)
+    80000aa2:	e44e                	sd	s3,8(sp)
+    80000aa4:	e052                	sd	s4,0(sp)
+    80000aa6:	892e                	mv	s2,a1
+    kfree(p);
+    80000aa8:	7a7d                	lui	s4,0xfffff
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+    80000aaa:	6985                	lui	s3,0x1
+    kfree(p);
+    80000aac:	01448533          	add	a0,s1,s4
+    80000ab0:	f6dff0ef          	jal	80000a1c <kfree>
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+    80000ab4:	94ce                	add	s1,s1,s3
+    80000ab6:	fe997be3          	bgeu	s2,s1,80000aac <freerange+0x2a>
+    80000aba:	6942                	ld	s2,16(sp)
+    80000abc:	69a2                	ld	s3,8(sp)
+    80000abe:	6a02                	ld	s4,0(sp)
+}
+    80000ac0:	70a2                	ld	ra,40(sp)
+    80000ac2:	7402                	ld	s0,32(sp)
+    80000ac4:	64e2                	ld	s1,24(sp)
+    80000ac6:	6145                	addi	sp,sp,48
+    80000ac8:	8082                	ret
+
+0000000080000aca <kinit>:
+{
+    80000aca:	1141                	addi	sp,sp,-16
+    80000acc:	e406                	sd	ra,8(sp)
+    80000ace:	e022                	sd	s0,0(sp)
+    80000ad0:	0800                	addi	s0,sp,16
+  initlock(&kmem.lock, "kmem");
+    80000ad2:	00006597          	auipc	a1,0x6
+    80000ad6:	56e58593          	addi	a1,a1,1390 # 80007040 <etext+0x40>
+    80000ada:	00011517          	auipc	a0,0x11
+    80000ade:	7fe50513          	addi	a0,a0,2046 # 800122d8 <kmem>
+    80000ae2:	06c000ef          	jal	80000b4e <initlock>
+  freerange(end, (void*)PHYSTOP);
+    80000ae6:	45c5                	li	a1,17
+    80000ae8:	05ee                	slli	a1,a1,0x1b
+    80000aea:	00023517          	auipc	a0,0x23
+    80000aee:	41e50513          	addi	a0,a0,1054 # 80023f08 <end>
+    80000af2:	f91ff0ef          	jal	80000a82 <freerange>
+}
+    80000af6:	60a2                	ld	ra,8(sp)
+    80000af8:	6402                	ld	s0,0(sp)
+    80000afa:	0141                	addi	sp,sp,16
+    80000afc:	8082                	ret
+
+0000000080000afe <kalloc>:
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+void *
+kalloc(void)
+{
+    80000afe:	1101                	addi	sp,sp,-32
+    80000b00:	ec06                	sd	ra,24(sp)
+    80000b02:	e822                	sd	s0,16(sp)
+    80000b04:	e426                	sd	s1,8(sp)
+    80000b06:	1000                	addi	s0,sp,32
+  struct run *r;
+
+  acquire(&kmem.lock);
+    80000b08:	00011497          	auipc	s1,0x11
+    80000b0c:	7d048493          	addi	s1,s1,2000 # 800122d8 <kmem>
+    80000b10:	8526                	mv	a0,s1
+    80000b12:	0bc000ef          	jal	80000bce <acquire>
+  r = kmem.freelist;
+    80000b16:	6c84                	ld	s1,24(s1)
+  if(r)
+    80000b18:	c485                	beqz	s1,80000b40 <kalloc+0x42>
+    kmem.freelist = r->next;
+    80000b1a:	609c                	ld	a5,0(s1)
+    80000b1c:	00011517          	auipc	a0,0x11
+    80000b20:	7bc50513          	addi	a0,a0,1980 # 800122d8 <kmem>
+    80000b24:	ed1c                	sd	a5,24(a0)
+  release(&kmem.lock);
+    80000b26:	140000ef          	jal	80000c66 <release>
+
+  if(r)
+    memset((char*)r, 5, PGSIZE); // fill with junk
+    80000b2a:	6605                	lui	a2,0x1
+    80000b2c:	4595                	li	a1,5
+    80000b2e:	8526                	mv	a0,s1
+    80000b30:	172000ef          	jal	80000ca2 <memset>
+  return (void*)r;
+}
+    80000b34:	8526                	mv	a0,s1
+    80000b36:	60e2                	ld	ra,24(sp)
+    80000b38:	6442                	ld	s0,16(sp)
+    80000b3a:	64a2                	ld	s1,8(sp)
+    80000b3c:	6105                	addi	sp,sp,32
+    80000b3e:	8082                	ret
+  release(&kmem.lock);
+    80000b40:	00011517          	auipc	a0,0x11
+    80000b44:	79850513          	addi	a0,a0,1944 # 800122d8 <kmem>
+    80000b48:	11e000ef          	jal	80000c66 <release>
+  if(r)
+    80000b4c:	b7e5                	j	80000b34 <kalloc+0x36>
+
+0000000080000b4e <initlock>:
+#include "proc.h"
+#include "defs.h"
+
+void
+initlock(struct spinlock *lk, char *name)
+{
+    80000b4e:	1141                	addi	sp,sp,-16
+    80000b50:	e422                	sd	s0,8(sp)
+    80000b52:	0800                	addi	s0,sp,16
+  lk->name = name;
+    80000b54:	e50c                	sd	a1,8(a0)
+  lk->locked = 0;
+    80000b56:	00052023          	sw	zero,0(a0)
+  lk->cpu = 0;
+    80000b5a:	00053823          	sd	zero,16(a0)
+}
+    80000b5e:	6422                	ld	s0,8(sp)
+    80000b60:	0141                	addi	sp,sp,16
+    80000b62:	8082                	ret
+
+0000000080000b64 <holding>:
+// Interrupts must be off.
+int
+holding(struct spinlock *lk)
+{
+  int r;
+  r = (lk->locked && lk->cpu == mycpu());
+    80000b64:	411c                	lw	a5,0(a0)
+    80000b66:	e399                	bnez	a5,80000b6c <holding+0x8>
+    80000b68:	4501                	li	a0,0
+  return r;
+}
+    80000b6a:	8082                	ret
+{
+    80000b6c:	1101                	addi	sp,sp,-32
+    80000b6e:	ec06                	sd	ra,24(sp)
+    80000b70:	e822                	sd	s0,16(sp)
+    80000b72:	e426                	sd	s1,8(sp)
+    80000b74:	1000                	addi	s0,sp,32
+  r = (lk->locked && lk->cpu == mycpu());
+    80000b76:	6904                	ld	s1,16(a0)
+    80000b78:	53b000ef          	jal	800018b2 <mycpu>
+    80000b7c:	40a48533          	sub	a0,s1,a0
+    80000b80:	00153513          	seqz	a0,a0
+}
+    80000b84:	60e2                	ld	ra,24(sp)
+    80000b86:	6442                	ld	s0,16(sp)
+    80000b88:	64a2                	ld	s1,8(sp)
+    80000b8a:	6105                	addi	sp,sp,32
+    80000b8c:	8082                	ret
+
+0000000080000b8e <push_off>:
+// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts
+// are initially off, then push_off, pop_off leaves them off.
+
+void
+push_off(void)
+{
+    80000b8e:	1101                	addi	sp,sp,-32
+    80000b90:	ec06                	sd	ra,24(sp)
+    80000b92:	e822                	sd	s0,16(sp)
+    80000b94:	e426                	sd	s1,8(sp)
+    80000b96:	1000                	addi	s0,sp,32
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80000b98:	100024f3          	csrr	s1,sstatus
+    80000b9c:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+    80000ba0:	9bf5                	andi	a5,a5,-3
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80000ba2:	10079073          	csrw	sstatus,a5
+
+  // disable interrupts to prevent an involuntary context
+  // switch while using mycpu().
+  intr_off();
+
+  if(mycpu()->noff == 0)
+    80000ba6:	50d000ef          	jal	800018b2 <mycpu>
+    80000baa:	5d3c                	lw	a5,120(a0)
+    80000bac:	cb99                	beqz	a5,80000bc2 <push_off+0x34>
+    mycpu()->intena = old;
+  mycpu()->noff += 1;
+    80000bae:	505000ef          	jal	800018b2 <mycpu>
+    80000bb2:	5d3c                	lw	a5,120(a0)
+    80000bb4:	2785                	addiw	a5,a5,1
+    80000bb6:	dd3c                	sw	a5,120(a0)
+}
+    80000bb8:	60e2                	ld	ra,24(sp)
+    80000bba:	6442                	ld	s0,16(sp)
+    80000bbc:	64a2                	ld	s1,8(sp)
+    80000bbe:	6105                	addi	sp,sp,32
+    80000bc0:	8082                	ret
+    mycpu()->intena = old;
+    80000bc2:	4f1000ef          	jal	800018b2 <mycpu>
+  return (x & SSTATUS_SIE) != 0;
+    80000bc6:	8085                	srli	s1,s1,0x1
+    80000bc8:	8885                	andi	s1,s1,1
+    80000bca:	dd64                	sw	s1,124(a0)
+    80000bcc:	b7cd                	j	80000bae <push_off+0x20>
+
+0000000080000bce <acquire>:
+{
+    80000bce:	1101                	addi	sp,sp,-32
+    80000bd0:	ec06                	sd	ra,24(sp)
+    80000bd2:	e822                	sd	s0,16(sp)
+    80000bd4:	e426                	sd	s1,8(sp)
+    80000bd6:	1000                	addi	s0,sp,32
+    80000bd8:	84aa                	mv	s1,a0
+  push_off(); // disable interrupts to avoid deadlock.
+    80000bda:	fb5ff0ef          	jal	80000b8e <push_off>
+  if(holding(lk))
+    80000bde:	8526                	mv	a0,s1
+    80000be0:	f85ff0ef          	jal	80000b64 <holding>
+  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
+    80000be4:	4705                	li	a4,1
+  if(holding(lk))
+    80000be6:	e105                	bnez	a0,80000c06 <acquire+0x38>
+  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
+    80000be8:	87ba                	mv	a5,a4
+    80000bea:	0cf4a7af          	amoswap.w.aq	a5,a5,(s1)
+    80000bee:	2781                	sext.w	a5,a5
+    80000bf0:	ffe5                	bnez	a5,80000be8 <acquire+0x1a>
+  __sync_synchronize();
+    80000bf2:	0330000f          	fence	rw,rw
+  lk->cpu = mycpu();
+    80000bf6:	4bd000ef          	jal	800018b2 <mycpu>
+    80000bfa:	e888                	sd	a0,16(s1)
+}
+    80000bfc:	60e2                	ld	ra,24(sp)
+    80000bfe:	6442                	ld	s0,16(sp)
+    80000c00:	64a2                	ld	s1,8(sp)
+    80000c02:	6105                	addi	sp,sp,32
+    80000c04:	8082                	ret
+    panic("acquire");
+    80000c06:	00006517          	auipc	a0,0x6
+    80000c0a:	44250513          	addi	a0,a0,1090 # 80007048 <etext+0x48>
+    80000c0e:	bd3ff0ef          	jal	800007e0 <panic>
+
+0000000080000c12 <pop_off>:
+
+void
+pop_off(void)
+{
+    80000c12:	1141                	addi	sp,sp,-16
+    80000c14:	e406                	sd	ra,8(sp)
+    80000c16:	e022                	sd	s0,0(sp)
+    80000c18:	0800                	addi	s0,sp,16
+  struct cpu *c = mycpu();
+    80000c1a:	499000ef          	jal	800018b2 <mycpu>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80000c1e:	100027f3          	csrr	a5,sstatus
+  return (x & SSTATUS_SIE) != 0;
+    80000c22:	8b89                	andi	a5,a5,2
+  if(intr_get())
+    80000c24:	e78d                	bnez	a5,80000c4e <pop_off+0x3c>
+    panic("pop_off - interruptible");
+  if(c->noff < 1)
+    80000c26:	5d3c                	lw	a5,120(a0)
+    80000c28:	02f05963          	blez	a5,80000c5a <pop_off+0x48>
+    panic("pop_off");
+  c->noff -= 1;
+    80000c2c:	37fd                	addiw	a5,a5,-1
+    80000c2e:	0007871b          	sext.w	a4,a5
+    80000c32:	dd3c                	sw	a5,120(a0)
+  if(c->noff == 0 && c->intena)
+    80000c34:	eb09                	bnez	a4,80000c46 <pop_off+0x34>
+    80000c36:	5d7c                	lw	a5,124(a0)
+    80000c38:	c799                	beqz	a5,80000c46 <pop_off+0x34>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80000c3a:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() | SSTATUS_SIE);
+    80000c3e:	0027e793          	ori	a5,a5,2
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80000c42:	10079073          	csrw	sstatus,a5
+    intr_on();
+}
+    80000c46:	60a2                	ld	ra,8(sp)
+    80000c48:	6402                	ld	s0,0(sp)
+    80000c4a:	0141                	addi	sp,sp,16
+    80000c4c:	8082                	ret
+    panic("pop_off - interruptible");
+    80000c4e:	00006517          	auipc	a0,0x6
+    80000c52:	40250513          	addi	a0,a0,1026 # 80007050 <etext+0x50>
+    80000c56:	b8bff0ef          	jal	800007e0 <panic>
+    panic("pop_off");
+    80000c5a:	00006517          	auipc	a0,0x6
+    80000c5e:	40e50513          	addi	a0,a0,1038 # 80007068 <etext+0x68>
+    80000c62:	b7fff0ef          	jal	800007e0 <panic>
+
+0000000080000c66 <release>:
+{
+    80000c66:	1101                	addi	sp,sp,-32
+    80000c68:	ec06                	sd	ra,24(sp)
+    80000c6a:	e822                	sd	s0,16(sp)
+    80000c6c:	e426                	sd	s1,8(sp)
+    80000c6e:	1000                	addi	s0,sp,32
+    80000c70:	84aa                	mv	s1,a0
+  if(!holding(lk))
+    80000c72:	ef3ff0ef          	jal	80000b64 <holding>
+    80000c76:	c105                	beqz	a0,80000c96 <release+0x30>
+  lk->cpu = 0;
+    80000c78:	0004b823          	sd	zero,16(s1)
+  __sync_synchronize();
+    80000c7c:	0330000f          	fence	rw,rw
+  __sync_lock_release(&lk->locked);
+    80000c80:	0310000f          	fence	rw,w
+    80000c84:	0004a023          	sw	zero,0(s1)
+  pop_off();
+    80000c88:	f8bff0ef          	jal	80000c12 <pop_off>
+}
+    80000c8c:	60e2                	ld	ra,24(sp)
+    80000c8e:	6442                	ld	s0,16(sp)
+    80000c90:	64a2                	ld	s1,8(sp)
+    80000c92:	6105                	addi	sp,sp,32
+    80000c94:	8082                	ret
+    panic("release");
+    80000c96:	00006517          	auipc	a0,0x6
+    80000c9a:	3da50513          	addi	a0,a0,986 # 80007070 <etext+0x70>
+    80000c9e:	b43ff0ef          	jal	800007e0 <panic>
+
+0000000080000ca2 <memset>:
+#include "types.h"
+
+void*
+memset(void *dst, int c, uint n)
+{
+    80000ca2:	1141                	addi	sp,sp,-16
+    80000ca4:	e422                	sd	s0,8(sp)
+    80000ca6:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+    80000ca8:	ca19                	beqz	a2,80000cbe <memset+0x1c>
+    80000caa:	87aa                	mv	a5,a0
+    80000cac:	1602                	slli	a2,a2,0x20
+    80000cae:	9201                	srli	a2,a2,0x20
+    80000cb0:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+    80000cb4:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+    80000cb8:	0785                	addi	a5,a5,1
+    80000cba:	fee79de3          	bne	a5,a4,80000cb4 <memset+0x12>
+  }
+  return dst;
+}
+    80000cbe:	6422                	ld	s0,8(sp)
+    80000cc0:	0141                	addi	sp,sp,16
+    80000cc2:	8082                	ret
+
+0000000080000cc4 <memcmp>:
+
+int
+memcmp(const void *v1, const void *v2, uint n)
+{
+    80000cc4:	1141                	addi	sp,sp,-16
+    80000cc6:	e422                	sd	s0,8(sp)
+    80000cc8:	0800                	addi	s0,sp,16
+  const uchar *s1, *s2;
+
+  s1 = v1;
+  s2 = v2;
+  while(n-- > 0){
+    80000cca:	ca05                	beqz	a2,80000cfa <memcmp+0x36>
+    80000ccc:	fff6069b          	addiw	a3,a2,-1 # fff <_entry-0x7ffff001>
+    80000cd0:	1682                	slli	a3,a3,0x20
+    80000cd2:	9281                	srli	a3,a3,0x20
+    80000cd4:	0685                	addi	a3,a3,1
+    80000cd6:	96aa                	add	a3,a3,a0
+    if(*s1 != *s2)
+    80000cd8:	00054783          	lbu	a5,0(a0)
+    80000cdc:	0005c703          	lbu	a4,0(a1)
+    80000ce0:	00e79863          	bne	a5,a4,80000cf0 <memcmp+0x2c>
+      return *s1 - *s2;
+    s1++, s2++;
+    80000ce4:	0505                	addi	a0,a0,1
+    80000ce6:	0585                	addi	a1,a1,1
+  while(n-- > 0){
+    80000ce8:	fed518e3          	bne	a0,a3,80000cd8 <memcmp+0x14>
+  }
+
+  return 0;
+    80000cec:	4501                	li	a0,0
+    80000cee:	a019                	j	80000cf4 <memcmp+0x30>
+      return *s1 - *s2;
+    80000cf0:	40e7853b          	subw	a0,a5,a4
+}
+    80000cf4:	6422                	ld	s0,8(sp)
+    80000cf6:	0141                	addi	sp,sp,16
+    80000cf8:	8082                	ret
+  return 0;
+    80000cfa:	4501                	li	a0,0
+    80000cfc:	bfe5                	j	80000cf4 <memcmp+0x30>
+
+0000000080000cfe <memmove>:
+
+void*
+memmove(void *dst, const void *src, uint n)
+{
+    80000cfe:	1141                	addi	sp,sp,-16
+    80000d00:	e422                	sd	s0,8(sp)
+    80000d02:	0800                	addi	s0,sp,16
+  const char *s;
+  char *d;
+
+  if(n == 0)
+    80000d04:	c205                	beqz	a2,80000d24 <memmove+0x26>
+    return dst;
+  
+  s = src;
+  d = dst;
+  if(s < d && s + n > d){
+    80000d06:	02a5e263          	bltu	a1,a0,80000d2a <memmove+0x2c>
+    s += n;
+    d += n;
+    while(n-- > 0)
+      *--d = *--s;
+  } else
+    while(n-- > 0)
+    80000d0a:	1602                	slli	a2,a2,0x20
+    80000d0c:	9201                	srli	a2,a2,0x20
+    80000d0e:	00c587b3          	add	a5,a1,a2
+{
+    80000d12:	872a                	mv	a4,a0
+      *d++ = *s++;
+    80000d14:	0585                	addi	a1,a1,1
+    80000d16:	0705                	addi	a4,a4,1 # fffffffffffff001 <end+0xffffffff7ffdb0f9>
+    80000d18:	fff5c683          	lbu	a3,-1(a1)
+    80000d1c:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+    80000d20:	feb79ae3          	bne	a5,a1,80000d14 <memmove+0x16>
+
+  return dst;
+}
+    80000d24:	6422                	ld	s0,8(sp)
+    80000d26:	0141                	addi	sp,sp,16
+    80000d28:	8082                	ret
+  if(s < d && s + n > d){
+    80000d2a:	02061693          	slli	a3,a2,0x20
+    80000d2e:	9281                	srli	a3,a3,0x20
+    80000d30:	00d58733          	add	a4,a1,a3
+    80000d34:	fce57be3          	bgeu	a0,a4,80000d0a <memmove+0xc>
+    d += n;
+    80000d38:	96aa                	add	a3,a3,a0
+    while(n-- > 0)
+    80000d3a:	fff6079b          	addiw	a5,a2,-1
+    80000d3e:	1782                	slli	a5,a5,0x20
+    80000d40:	9381                	srli	a5,a5,0x20
+    80000d42:	fff7c793          	not	a5,a5
+    80000d46:	97ba                	add	a5,a5,a4
+      *--d = *--s;
+    80000d48:	177d                	addi	a4,a4,-1
+    80000d4a:	16fd                	addi	a3,a3,-1
+    80000d4c:	00074603          	lbu	a2,0(a4)
+    80000d50:	00c68023          	sb	a2,0(a3)
+    while(n-- > 0)
+    80000d54:	fef71ae3          	bne	a4,a5,80000d48 <memmove+0x4a>
+    80000d58:	b7f1                	j	80000d24 <memmove+0x26>
+
+0000000080000d5a <memcpy>:
+
+// memcpy exists to placate GCC.  Use memmove.
+void*
+memcpy(void *dst, const void *src, uint n)
+{
+    80000d5a:	1141                	addi	sp,sp,-16
+    80000d5c:	e406                	sd	ra,8(sp)
+    80000d5e:	e022                	sd	s0,0(sp)
+    80000d60:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+    80000d62:	f9dff0ef          	jal	80000cfe <memmove>
+}
+    80000d66:	60a2                	ld	ra,8(sp)
+    80000d68:	6402                	ld	s0,0(sp)
+    80000d6a:	0141                	addi	sp,sp,16
+    80000d6c:	8082                	ret
+
+0000000080000d6e <strncmp>:
+
+int
+strncmp(const char *p, const char *q, uint n)
+{
+    80000d6e:	1141                	addi	sp,sp,-16
+    80000d70:	e422                	sd	s0,8(sp)
+    80000d72:	0800                	addi	s0,sp,16
+  while(n > 0 && *p && *p == *q)
+    80000d74:	ce11                	beqz	a2,80000d90 <strncmp+0x22>
+    80000d76:	00054783          	lbu	a5,0(a0)
+    80000d7a:	cf89                	beqz	a5,80000d94 <strncmp+0x26>
+    80000d7c:	0005c703          	lbu	a4,0(a1)
+    80000d80:	00f71a63          	bne	a4,a5,80000d94 <strncmp+0x26>
+    n--, p++, q++;
+    80000d84:	367d                	addiw	a2,a2,-1
+    80000d86:	0505                	addi	a0,a0,1
+    80000d88:	0585                	addi	a1,a1,1
+  while(n > 0 && *p && *p == *q)
+    80000d8a:	f675                	bnez	a2,80000d76 <strncmp+0x8>
+  if(n == 0)
+    return 0;
+    80000d8c:	4501                	li	a0,0
+    80000d8e:	a801                	j	80000d9e <strncmp+0x30>
+    80000d90:	4501                	li	a0,0
+    80000d92:	a031                	j	80000d9e <strncmp+0x30>
+  return (uchar)*p - (uchar)*q;
+    80000d94:	00054503          	lbu	a0,0(a0)
+    80000d98:	0005c783          	lbu	a5,0(a1)
+    80000d9c:	9d1d                	subw	a0,a0,a5
+}
+    80000d9e:	6422                	ld	s0,8(sp)
+    80000da0:	0141                	addi	sp,sp,16
+    80000da2:	8082                	ret
+
+0000000080000da4 <strncpy>:
+
+char*
+strncpy(char *s, const char *t, int n)
+{
+    80000da4:	1141                	addi	sp,sp,-16
+    80000da6:	e422                	sd	s0,8(sp)
+    80000da8:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while(n-- > 0 && (*s++ = *t++) != 0)
+    80000daa:	87aa                	mv	a5,a0
+    80000dac:	86b2                	mv	a3,a2
+    80000dae:	367d                	addiw	a2,a2,-1
+    80000db0:	02d05563          	blez	a3,80000dda <strncpy+0x36>
+    80000db4:	0785                	addi	a5,a5,1
+    80000db6:	0005c703          	lbu	a4,0(a1)
+    80000dba:	fee78fa3          	sb	a4,-1(a5)
+    80000dbe:	0585                	addi	a1,a1,1
+    80000dc0:	f775                	bnez	a4,80000dac <strncpy+0x8>
+    ;
+  while(n-- > 0)
+    80000dc2:	873e                	mv	a4,a5
+    80000dc4:	9fb5                	addw	a5,a5,a3
+    80000dc6:	37fd                	addiw	a5,a5,-1
+    80000dc8:	00c05963          	blez	a2,80000dda <strncpy+0x36>
+    *s++ = 0;
+    80000dcc:	0705                	addi	a4,a4,1
+    80000dce:	fe070fa3          	sb	zero,-1(a4)
+  while(n-- > 0)
+    80000dd2:	40e786bb          	subw	a3,a5,a4
+    80000dd6:	fed04be3          	bgtz	a3,80000dcc <strncpy+0x28>
+  return os;
+}
+    80000dda:	6422                	ld	s0,8(sp)
+    80000ddc:	0141                	addi	sp,sp,16
+    80000dde:	8082                	ret
+
+0000000080000de0 <safestrcpy>:
+
+// Like strncpy but guaranteed to NUL-terminate.
+char*
+safestrcpy(char *s, const char *t, int n)
+{
+    80000de0:	1141                	addi	sp,sp,-16
+    80000de2:	e422                	sd	s0,8(sp)
+    80000de4:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  if(n <= 0)
+    80000de6:	02c05363          	blez	a2,80000e0c <safestrcpy+0x2c>
+    80000dea:	fff6069b          	addiw	a3,a2,-1
+    80000dee:	1682                	slli	a3,a3,0x20
+    80000df0:	9281                	srli	a3,a3,0x20
+    80000df2:	96ae                	add	a3,a3,a1
+    80000df4:	87aa                	mv	a5,a0
+    return os;
+  while(--n > 0 && (*s++ = *t++) != 0)
+    80000df6:	00d58963          	beq	a1,a3,80000e08 <safestrcpy+0x28>
+    80000dfa:	0585                	addi	a1,a1,1
+    80000dfc:	0785                	addi	a5,a5,1
+    80000dfe:	fff5c703          	lbu	a4,-1(a1)
+    80000e02:	fee78fa3          	sb	a4,-1(a5)
+    80000e06:	fb65                	bnez	a4,80000df6 <safestrcpy+0x16>
+    ;
+  *s = 0;
+    80000e08:	00078023          	sb	zero,0(a5)
+  return os;
+}
+    80000e0c:	6422                	ld	s0,8(sp)
+    80000e0e:	0141                	addi	sp,sp,16
+    80000e10:	8082                	ret
+
+0000000080000e12 <strlen>:
+
+int
+strlen(const char *s)
+{
+    80000e12:	1141                	addi	sp,sp,-16
+    80000e14:	e422                	sd	s0,8(sp)
+    80000e16:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+    80000e18:	00054783          	lbu	a5,0(a0)
+    80000e1c:	cf91                	beqz	a5,80000e38 <strlen+0x26>
+    80000e1e:	0505                	addi	a0,a0,1
+    80000e20:	87aa                	mv	a5,a0
+    80000e22:	86be                	mv	a3,a5
+    80000e24:	0785                	addi	a5,a5,1
+    80000e26:	fff7c703          	lbu	a4,-1(a5)
+    80000e2a:	ff65                	bnez	a4,80000e22 <strlen+0x10>
+    80000e2c:	40a6853b          	subw	a0,a3,a0
+    80000e30:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+    80000e32:	6422                	ld	s0,8(sp)
+    80000e34:	0141                	addi	sp,sp,16
+    80000e36:	8082                	ret
+  for(n = 0; s[n]; n++)
+    80000e38:	4501                	li	a0,0
+    80000e3a:	bfe5                	j	80000e32 <strlen+0x20>
+
+0000000080000e3c <main>:
+volatile static int started = 0;
+
+// start() jumps here in supervisor mode on all CPUs.
+void
+main()
+{
+    80000e3c:	1141                	addi	sp,sp,-16
+    80000e3e:	e406                	sd	ra,8(sp)
+    80000e40:	e022                	sd	s0,0(sp)
+    80000e42:	0800                	addi	s0,sp,16
+  if(cpuid() == 0){
+    80000e44:	25f000ef          	jal	800018a2 <cpuid>
+    virtio_disk_init(); // emulated hard disk
+    userinit();      // first user process
+    __sync_synchronize();
+    started = 1;
+  } else {
+    while(started == 0)
+    80000e48:	00009717          	auipc	a4,0x9
+    80000e4c:	38870713          	addi	a4,a4,904 # 8000a1d0 <started>
+  if(cpuid() == 0){
+    80000e50:	c51d                	beqz	a0,80000e7e <main+0x42>
+    while(started == 0)
+    80000e52:	431c                	lw	a5,0(a4)
+    80000e54:	2781                	sext.w	a5,a5
+    80000e56:	dff5                	beqz	a5,80000e52 <main+0x16>
+      ;
+    __sync_synchronize();
+    80000e58:	0330000f          	fence	rw,rw
+    printf("hart %d starting\n", cpuid());
+    80000e5c:	247000ef          	jal	800018a2 <cpuid>
+    80000e60:	85aa                	mv	a1,a0
+    80000e62:	00006517          	auipc	a0,0x6
+    80000e66:	23650513          	addi	a0,a0,566 # 80007098 <etext+0x98>
+    80000e6a:	e90ff0ef          	jal	800004fa <printf>
+    kvminithart();    // turn on paging
+    80000e6e:	080000ef          	jal	80000eee <kvminithart>
+    trapinithart();   // install kernel trap vector
+    80000e72:	5b6010ef          	jal	80002428 <trapinithart>
+    plicinithart();   // ask PLIC for device interrupts
+    80000e76:	592040ef          	jal	80005408 <plicinithart>
+  }
+
+  scheduler();        
+    80000e7a:	6d9000ef          	jal	80001d52 <scheduler>
+    consoleinit();
+    80000e7e:	da6ff0ef          	jal	80000424 <consoleinit>
+    printfinit();
+    80000e82:	99bff0ef          	jal	8000081c <printfinit>
+    printf("\n");
+    80000e86:	00006517          	auipc	a0,0x6
+    80000e8a:	1f250513          	addi	a0,a0,498 # 80007078 <etext+0x78>
+    80000e8e:	e6cff0ef          	jal	800004fa <printf>
+    printf("xv6 kernel is booting\n");
+    80000e92:	00006517          	auipc	a0,0x6
+    80000e96:	1ee50513          	addi	a0,a0,494 # 80007080 <etext+0x80>
+    80000e9a:	e60ff0ef          	jal	800004fa <printf>
+    printf("\n");
+    80000e9e:	00006517          	auipc	a0,0x6
+    80000ea2:	1da50513          	addi	a0,a0,474 # 80007078 <etext+0x78>
+    80000ea6:	e54ff0ef          	jal	800004fa <printf>
+    kinit();         // physical page allocator
+    80000eaa:	c21ff0ef          	jal	80000aca <kinit>
+    kvminit();       // create kernel page table
+    80000eae:	2ca000ef          	jal	80001178 <kvminit>
+    kvminithart();   // turn on paging
+    80000eb2:	03c000ef          	jal	80000eee <kvminithart>
+    procinit();      // process table
+    80000eb6:	137000ef          	jal	800017ec <procinit>
+    trapinit();      // trap vectors
+    80000eba:	54a010ef          	jal	80002404 <trapinit>
+    trapinithart();  // install kernel trap vector
+    80000ebe:	56a010ef          	jal	80002428 <trapinithart>
+    plicinit();      // set up interrupt controller
+    80000ec2:	52c040ef          	jal	800053ee <plicinit>
+    plicinithart();  // ask PLIC for device interrupts
+    80000ec6:	542040ef          	jal	80005408 <plicinithart>
+    binit();         // buffer cache
+    80000eca:	3e5010ef          	jal	80002aae <binit>
+    iinit();         // inode table
+    80000ece:	16a020ef          	jal	80003038 <iinit>
+    fileinit();      // file table
+    80000ed2:	05c030ef          	jal	80003f2e <fileinit>
+    virtio_disk_init(); // emulated hard disk
+    80000ed6:	622040ef          	jal	800054f8 <virtio_disk_init>
+    userinit();      // first user process
+    80000eda:	4df000ef          	jal	80001bb8 <userinit>
+    __sync_synchronize();
+    80000ede:	0330000f          	fence	rw,rw
+    started = 1;
+    80000ee2:	4785                	li	a5,1
+    80000ee4:	00009717          	auipc	a4,0x9
+    80000ee8:	2ef72623          	sw	a5,748(a4) # 8000a1d0 <started>
+    80000eec:	b779                	j	80000e7a <main+0x3e>
+
+0000000080000eee <kvminithart>:
+
+// Switch the current CPU's h/w page table register to
+// the kernel's page table, and enable paging.
+void
+kvminithart()
+{
+    80000eee:	1141                	addi	sp,sp,-16
+    80000ef0:	e422                	sd	s0,8(sp)
+    80000ef2:	0800                	addi	s0,sp,16
+// flush the TLB.
+static inline void
+sfence_vma()
+{
+  // the zero, zero means flush all TLB entries.
+  asm volatile("sfence.vma zero, zero");
+    80000ef4:	12000073          	sfence.vma
+  // wait for any previous writes to the page table memory to finish.
+  sfence_vma();
+
+  w_satp(MAKE_SATP(kernel_pagetable));
+    80000ef8:	00009797          	auipc	a5,0x9
+    80000efc:	2e07b783          	ld	a5,736(a5) # 8000a1d8 <kernel_pagetable>
+    80000f00:	83b1                	srli	a5,a5,0xc
+    80000f02:	577d                	li	a4,-1
+    80000f04:	177e                	slli	a4,a4,0x3f
+    80000f06:	8fd9                	or	a5,a5,a4
+  asm volatile("csrw satp, %0" : : "r" (x));
+    80000f08:	18079073          	csrw	satp,a5
+  asm volatile("sfence.vma zero, zero");
+    80000f0c:	12000073          	sfence.vma
+
+  // flush stale entries from the TLB.
+  sfence_vma();
+}
+    80000f10:	6422                	ld	s0,8(sp)
+    80000f12:	0141                	addi	sp,sp,16
+    80000f14:	8082                	ret
+
+0000000080000f16 <walk>:
+//   21..29 -- 9 bits of level-1 index.
+//   12..20 -- 9 bits of level-0 index.
+//    0..11 -- 12 bits of byte offset within the page.
+pte_t *
+walk(pagetable_t pagetable, uint64 va, int alloc)
+{
+    80000f16:	7139                	addi	sp,sp,-64
+    80000f18:	fc06                	sd	ra,56(sp)
+    80000f1a:	f822                	sd	s0,48(sp)
+    80000f1c:	f426                	sd	s1,40(sp)
+    80000f1e:	f04a                	sd	s2,32(sp)
+    80000f20:	ec4e                	sd	s3,24(sp)
+    80000f22:	e852                	sd	s4,16(sp)
+    80000f24:	e456                	sd	s5,8(sp)
+    80000f26:	e05a                	sd	s6,0(sp)
+    80000f28:	0080                	addi	s0,sp,64
+    80000f2a:	84aa                	mv	s1,a0
+    80000f2c:	89ae                	mv	s3,a1
+    80000f2e:	8ab2                	mv	s5,a2
+  if(va >= MAXVA)
+    80000f30:	57fd                	li	a5,-1
+    80000f32:	83e9                	srli	a5,a5,0x1a
+    80000f34:	4a79                	li	s4,30
+    panic("walk");
+
+  for(int level = 2; level > 0; level--) {
+    80000f36:	4b31                	li	s6,12
+  if(va >= MAXVA)
+    80000f38:	02b7fc63          	bgeu	a5,a1,80000f70 <walk+0x5a>
+    panic("walk");
+    80000f3c:	00006517          	auipc	a0,0x6
+    80000f40:	17450513          	addi	a0,a0,372 # 800070b0 <etext+0xb0>
+    80000f44:	89dff0ef          	jal	800007e0 <panic>
+    pte_t *pte = &pagetable[PX(level, va)];
+    if(*pte & PTE_V) {
+      pagetable = (pagetable_t)PTE2PA(*pte);
+    } else {
+      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+    80000f48:	060a8263          	beqz	s5,80000fac <walk+0x96>
+    80000f4c:	bb3ff0ef          	jal	80000afe <kalloc>
+    80000f50:	84aa                	mv	s1,a0
+    80000f52:	c139                	beqz	a0,80000f98 <walk+0x82>
+        return 0;
+      memset(pagetable, 0, PGSIZE);
+    80000f54:	6605                	lui	a2,0x1
+    80000f56:	4581                	li	a1,0
+    80000f58:	d4bff0ef          	jal	80000ca2 <memset>
+      *pte = PA2PTE(pagetable) | PTE_V;
+    80000f5c:	00c4d793          	srli	a5,s1,0xc
+    80000f60:	07aa                	slli	a5,a5,0xa
+    80000f62:	0017e793          	ori	a5,a5,1
+    80000f66:	00f93023          	sd	a5,0(s2)
+  for(int level = 2; level > 0; level--) {
+    80000f6a:	3a5d                	addiw	s4,s4,-9 # ffffffffffffeff7 <end+0xffffffff7ffdb0ef>
+    80000f6c:	036a0063          	beq	s4,s6,80000f8c <walk+0x76>
+    pte_t *pte = &pagetable[PX(level, va)];
+    80000f70:	0149d933          	srl	s2,s3,s4
+    80000f74:	1ff97913          	andi	s2,s2,511
+    80000f78:	090e                	slli	s2,s2,0x3
+    80000f7a:	9926                	add	s2,s2,s1
+    if(*pte & PTE_V) {
+    80000f7c:	00093483          	ld	s1,0(s2)
+    80000f80:	0014f793          	andi	a5,s1,1
+    80000f84:	d3f1                	beqz	a5,80000f48 <walk+0x32>
+      pagetable = (pagetable_t)PTE2PA(*pte);
+    80000f86:	80a9                	srli	s1,s1,0xa
+    80000f88:	04b2                	slli	s1,s1,0xc
+    80000f8a:	b7c5                	j	80000f6a <walk+0x54>
+    }
+  }
+  return &pagetable[PX(0, va)];
+    80000f8c:	00c9d513          	srli	a0,s3,0xc
+    80000f90:	1ff57513          	andi	a0,a0,511
+    80000f94:	050e                	slli	a0,a0,0x3
+    80000f96:	9526                	add	a0,a0,s1
+}
+    80000f98:	70e2                	ld	ra,56(sp)
+    80000f9a:	7442                	ld	s0,48(sp)
+    80000f9c:	74a2                	ld	s1,40(sp)
+    80000f9e:	7902                	ld	s2,32(sp)
+    80000fa0:	69e2                	ld	s3,24(sp)
+    80000fa2:	6a42                	ld	s4,16(sp)
+    80000fa4:	6aa2                	ld	s5,8(sp)
+    80000fa6:	6b02                	ld	s6,0(sp)
+    80000fa8:	6121                	addi	sp,sp,64
+    80000faa:	8082                	ret
+        return 0;
+    80000fac:	4501                	li	a0,0
+    80000fae:	b7ed                	j	80000f98 <walk+0x82>
+
+0000000080000fb0 <walkaddr>:
+walkaddr(pagetable_t pagetable, uint64 va)
+{
+  pte_t *pte;
+  uint64 pa;
+
+  if(va >= MAXVA)
+    80000fb0:	57fd                	li	a5,-1
+    80000fb2:	83e9                	srli	a5,a5,0x1a
+    80000fb4:	00b7f463          	bgeu	a5,a1,80000fbc <walkaddr+0xc>
+    return 0;
+    80000fb8:	4501                	li	a0,0
+    return 0;
+  if((*pte & PTE_U) == 0)
+    return 0;
+  pa = PTE2PA(*pte);
+  return pa;
+}
+    80000fba:	8082                	ret
+{
+    80000fbc:	1141                	addi	sp,sp,-16
+    80000fbe:	e406                	sd	ra,8(sp)
+    80000fc0:	e022                	sd	s0,0(sp)
+    80000fc2:	0800                	addi	s0,sp,16
+  pte = walk(pagetable, va, 0);
+    80000fc4:	4601                	li	a2,0
+    80000fc6:	f51ff0ef          	jal	80000f16 <walk>
+  if(pte == 0)
+    80000fca:	c105                	beqz	a0,80000fea <walkaddr+0x3a>
+  if((*pte & PTE_V) == 0)
+    80000fcc:	611c                	ld	a5,0(a0)
+  if((*pte & PTE_U) == 0)
+    80000fce:	0117f693          	andi	a3,a5,17
+    80000fd2:	4745                	li	a4,17
+    return 0;
+    80000fd4:	4501                	li	a0,0
+  if((*pte & PTE_U) == 0)
+    80000fd6:	00e68663          	beq	a3,a4,80000fe2 <walkaddr+0x32>
+}
+    80000fda:	60a2                	ld	ra,8(sp)
+    80000fdc:	6402                	ld	s0,0(sp)
+    80000fde:	0141                	addi	sp,sp,16
+    80000fe0:	8082                	ret
+  pa = PTE2PA(*pte);
+    80000fe2:	83a9                	srli	a5,a5,0xa
+    80000fe4:	00c79513          	slli	a0,a5,0xc
+  return pa;
+    80000fe8:	bfcd                	j	80000fda <walkaddr+0x2a>
+    return 0;
+    80000fea:	4501                	li	a0,0
+    80000fec:	b7fd                	j	80000fda <walkaddr+0x2a>
+
+0000000080000fee <mappages>:
+// va and size MUST be page-aligned.
+// Returns 0 on success, -1 if walk() couldn't
+// allocate a needed page-table page.
+int
+mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+{
+    80000fee:	715d                	addi	sp,sp,-80
+    80000ff0:	e486                	sd	ra,72(sp)
+    80000ff2:	e0a2                	sd	s0,64(sp)
+    80000ff4:	fc26                	sd	s1,56(sp)
+    80000ff6:	f84a                	sd	s2,48(sp)
+    80000ff8:	f44e                	sd	s3,40(sp)
+    80000ffa:	f052                	sd	s4,32(sp)
+    80000ffc:	ec56                	sd	s5,24(sp)
+    80000ffe:	e85a                	sd	s6,16(sp)
+    80001000:	e45e                	sd	s7,8(sp)
+    80001002:	0880                	addi	s0,sp,80
+  uint64 a, last;
+  pte_t *pte;
+
+  if((va % PGSIZE) != 0)
+    80001004:	03459793          	slli	a5,a1,0x34
+    80001008:	e7a9                	bnez	a5,80001052 <mappages+0x64>
+    8000100a:	8aaa                	mv	s5,a0
+    8000100c:	8b3a                	mv	s6,a4
+    panic("mappages: va not aligned");
+
+  if((size % PGSIZE) != 0)
+    8000100e:	03461793          	slli	a5,a2,0x34
+    80001012:	e7b1                	bnez	a5,8000105e <mappages+0x70>
+    panic("mappages: size not aligned");
+
+  if(size == 0)
+    80001014:	ca39                	beqz	a2,8000106a <mappages+0x7c>
+    panic("mappages: size");
+  
+  a = va;
+  last = va + size - PGSIZE;
+    80001016:	77fd                	lui	a5,0xfffff
+    80001018:	963e                	add	a2,a2,a5
+    8000101a:	00b609b3          	add	s3,a2,a1
+  a = va;
+    8000101e:	892e                	mv	s2,a1
+    80001020:	40b68a33          	sub	s4,a3,a1
+    if(*pte & PTE_V)
+      panic("mappages: remap");
+    *pte = PA2PTE(pa) | perm | PTE_V;
+    if(a == last)
+      break;
+    a += PGSIZE;
+    80001024:	6b85                	lui	s7,0x1
+    80001026:	014904b3          	add	s1,s2,s4
+    if((pte = walk(pagetable, a, 1)) == 0)
+    8000102a:	4605                	li	a2,1
+    8000102c:	85ca                	mv	a1,s2
+    8000102e:	8556                	mv	a0,s5
+    80001030:	ee7ff0ef          	jal	80000f16 <walk>
+    80001034:	c539                	beqz	a0,80001082 <mappages+0x94>
+    if(*pte & PTE_V)
+    80001036:	611c                	ld	a5,0(a0)
+    80001038:	8b85                	andi	a5,a5,1
+    8000103a:	ef95                	bnez	a5,80001076 <mappages+0x88>
+    *pte = PA2PTE(pa) | perm | PTE_V;
+    8000103c:	80b1                	srli	s1,s1,0xc
+    8000103e:	04aa                	slli	s1,s1,0xa
+    80001040:	0164e4b3          	or	s1,s1,s6
+    80001044:	0014e493          	ori	s1,s1,1
+    80001048:	e104                	sd	s1,0(a0)
+    if(a == last)
+    8000104a:	05390863          	beq	s2,s3,8000109a <mappages+0xac>
+    a += PGSIZE;
+    8000104e:	995e                	add	s2,s2,s7
+    if((pte = walk(pagetable, a, 1)) == 0)
+    80001050:	bfd9                	j	80001026 <mappages+0x38>
+    panic("mappages: va not aligned");
+    80001052:	00006517          	auipc	a0,0x6
+    80001056:	06650513          	addi	a0,a0,102 # 800070b8 <etext+0xb8>
+    8000105a:	f86ff0ef          	jal	800007e0 <panic>
+    panic("mappages: size not aligned");
+    8000105e:	00006517          	auipc	a0,0x6
+    80001062:	07a50513          	addi	a0,a0,122 # 800070d8 <etext+0xd8>
+    80001066:	f7aff0ef          	jal	800007e0 <panic>
+    panic("mappages: size");
+    8000106a:	00006517          	auipc	a0,0x6
+    8000106e:	08e50513          	addi	a0,a0,142 # 800070f8 <etext+0xf8>
+    80001072:	f6eff0ef          	jal	800007e0 <panic>
+      panic("mappages: remap");
+    80001076:	00006517          	auipc	a0,0x6
+    8000107a:	09250513          	addi	a0,a0,146 # 80007108 <etext+0x108>
+    8000107e:	f62ff0ef          	jal	800007e0 <panic>
+      return -1;
+    80001082:	557d                	li	a0,-1
+    pa += PGSIZE;
+  }
+  return 0;
+}
+    80001084:	60a6                	ld	ra,72(sp)
+    80001086:	6406                	ld	s0,64(sp)
+    80001088:	74e2                	ld	s1,56(sp)
+    8000108a:	7942                	ld	s2,48(sp)
+    8000108c:	79a2                	ld	s3,40(sp)
+    8000108e:	7a02                	ld	s4,32(sp)
+    80001090:	6ae2                	ld	s5,24(sp)
+    80001092:	6b42                	ld	s6,16(sp)
+    80001094:	6ba2                	ld	s7,8(sp)
+    80001096:	6161                	addi	sp,sp,80
+    80001098:	8082                	ret
+  return 0;
+    8000109a:	4501                	li	a0,0
+    8000109c:	b7e5                	j	80001084 <mappages+0x96>
+
+000000008000109e <kvmmap>:
+{
+    8000109e:	1141                	addi	sp,sp,-16
+    800010a0:	e406                	sd	ra,8(sp)
+    800010a2:	e022                	sd	s0,0(sp)
+    800010a4:	0800                	addi	s0,sp,16
+    800010a6:	87b6                	mv	a5,a3
+  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+    800010a8:	86b2                	mv	a3,a2
+    800010aa:	863e                	mv	a2,a5
+    800010ac:	f43ff0ef          	jal	80000fee <mappages>
+    800010b0:	e509                	bnez	a0,800010ba <kvmmap+0x1c>
+}
+    800010b2:	60a2                	ld	ra,8(sp)
+    800010b4:	6402                	ld	s0,0(sp)
+    800010b6:	0141                	addi	sp,sp,16
+    800010b8:	8082                	ret
+    panic("kvmmap");
+    800010ba:	00006517          	auipc	a0,0x6
+    800010be:	05e50513          	addi	a0,a0,94 # 80007118 <etext+0x118>
+    800010c2:	f1eff0ef          	jal	800007e0 <panic>
+
+00000000800010c6 <kvmmake>:
+{
+    800010c6:	1101                	addi	sp,sp,-32
+    800010c8:	ec06                	sd	ra,24(sp)
+    800010ca:	e822                	sd	s0,16(sp)
+    800010cc:	e426                	sd	s1,8(sp)
+    800010ce:	e04a                	sd	s2,0(sp)
+    800010d0:	1000                	addi	s0,sp,32
+  kpgtbl = (pagetable_t) kalloc();
+    800010d2:	a2dff0ef          	jal	80000afe <kalloc>
+    800010d6:	84aa                	mv	s1,a0
+  memset(kpgtbl, 0, PGSIZE);
+    800010d8:	6605                	lui	a2,0x1
+    800010da:	4581                	li	a1,0
+    800010dc:	bc7ff0ef          	jal	80000ca2 <memset>
+  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+    800010e0:	4719                	li	a4,6
+    800010e2:	6685                	lui	a3,0x1
+    800010e4:	10000637          	lui	a2,0x10000
+    800010e8:	100005b7          	lui	a1,0x10000
+    800010ec:	8526                	mv	a0,s1
+    800010ee:	fb1ff0ef          	jal	8000109e <kvmmap>
+  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+    800010f2:	4719                	li	a4,6
+    800010f4:	6685                	lui	a3,0x1
+    800010f6:	10001637          	lui	a2,0x10001
+    800010fa:	100015b7          	lui	a1,0x10001
+    800010fe:	8526                	mv	a0,s1
+    80001100:	f9fff0ef          	jal	8000109e <kvmmap>
+  kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);
+    80001104:	4719                	li	a4,6
+    80001106:	040006b7          	lui	a3,0x4000
+    8000110a:	0c000637          	lui	a2,0xc000
+    8000110e:	0c0005b7          	lui	a1,0xc000
+    80001112:	8526                	mv	a0,s1
+    80001114:	f8bff0ef          	jal	8000109e <kvmmap>
+  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+    80001118:	00006917          	auipc	s2,0x6
+    8000111c:	ee890913          	addi	s2,s2,-280 # 80007000 <etext>
+    80001120:	4729                	li	a4,10
+    80001122:	80006697          	auipc	a3,0x80006
+    80001126:	ede68693          	addi	a3,a3,-290 # 7000 <_entry-0x7fff9000>
+    8000112a:	4605                	li	a2,1
+    8000112c:	067e                	slli	a2,a2,0x1f
+    8000112e:	85b2                	mv	a1,a2
+    80001130:	8526                	mv	a0,s1
+    80001132:	f6dff0ef          	jal	8000109e <kvmmap>
+  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+    80001136:	46c5                	li	a3,17
+    80001138:	06ee                	slli	a3,a3,0x1b
+    8000113a:	4719                	li	a4,6
+    8000113c:	412686b3          	sub	a3,a3,s2
+    80001140:	864a                	mv	a2,s2
+    80001142:	85ca                	mv	a1,s2
+    80001144:	8526                	mv	a0,s1
+    80001146:	f59ff0ef          	jal	8000109e <kvmmap>
+  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+    8000114a:	4729                	li	a4,10
+    8000114c:	6685                	lui	a3,0x1
+    8000114e:	00005617          	auipc	a2,0x5
+    80001152:	eb260613          	addi	a2,a2,-334 # 80006000 <_trampoline>
+    80001156:	040005b7          	lui	a1,0x4000
+    8000115a:	15fd                	addi	a1,a1,-1 # 3ffffff <_entry-0x7c000001>
+    8000115c:	05b2                	slli	a1,a1,0xc
+    8000115e:	8526                	mv	a0,s1
+    80001160:	f3fff0ef          	jal	8000109e <kvmmap>
+  proc_mapstacks(kpgtbl);
+    80001164:	8526                	mv	a0,s1
+    80001166:	5ee000ef          	jal	80001754 <proc_mapstacks>
+}
+    8000116a:	8526                	mv	a0,s1
+    8000116c:	60e2                	ld	ra,24(sp)
+    8000116e:	6442                	ld	s0,16(sp)
+    80001170:	64a2                	ld	s1,8(sp)
+    80001172:	6902                	ld	s2,0(sp)
+    80001174:	6105                	addi	sp,sp,32
+    80001176:	8082                	ret
+
+0000000080001178 <kvminit>:
+{
+    80001178:	1141                	addi	sp,sp,-16
+    8000117a:	e406                	sd	ra,8(sp)
+    8000117c:	e022                	sd	s0,0(sp)
+    8000117e:	0800                	addi	s0,sp,16
+  kernel_pagetable = kvmmake();
+    80001180:	f47ff0ef          	jal	800010c6 <kvmmake>
+    80001184:	00009797          	auipc	a5,0x9
+    80001188:	04a7ba23          	sd	a0,84(a5) # 8000a1d8 <kernel_pagetable>
+}
+    8000118c:	60a2                	ld	ra,8(sp)
+    8000118e:	6402                	ld	s0,0(sp)
+    80001190:	0141                	addi	sp,sp,16
+    80001192:	8082                	ret
+
+0000000080001194 <uvmcreate>:
+
+// create an empty user page table.
+// returns 0 if out of memory.
+pagetable_t
+uvmcreate()
+{
+    80001194:	1101                	addi	sp,sp,-32
+    80001196:	ec06                	sd	ra,24(sp)
+    80001198:	e822                	sd	s0,16(sp)
+    8000119a:	e426                	sd	s1,8(sp)
+    8000119c:	1000                	addi	s0,sp,32
+  pagetable_t pagetable;
+  pagetable = (pagetable_t) kalloc();
+    8000119e:	961ff0ef          	jal	80000afe <kalloc>
+    800011a2:	84aa                	mv	s1,a0
+  if(pagetable == 0)
+    800011a4:	c509                	beqz	a0,800011ae <uvmcreate+0x1a>
+    return 0;
+  memset(pagetable, 0, PGSIZE);
+    800011a6:	6605                	lui	a2,0x1
+    800011a8:	4581                	li	a1,0
+    800011aa:	af9ff0ef          	jal	80000ca2 <memset>
+  return pagetable;
+}
+    800011ae:	8526                	mv	a0,s1
+    800011b0:	60e2                	ld	ra,24(sp)
+    800011b2:	6442                	ld	s0,16(sp)
+    800011b4:	64a2                	ld	s1,8(sp)
+    800011b6:	6105                	addi	sp,sp,32
+    800011b8:	8082                	ret
+
+00000000800011ba <uvmunmap>:
+// Remove npages of mappings starting from va. va must be
+// page-aligned. It's OK if the mappings don't exist.
+// Optionally free the physical memory.
+void
+uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+{
+    800011ba:	7139                	addi	sp,sp,-64
+    800011bc:	fc06                	sd	ra,56(sp)
+    800011be:	f822                	sd	s0,48(sp)
+    800011c0:	0080                	addi	s0,sp,64
+  uint64 a;
+  pte_t *pte;
+
+  if((va % PGSIZE) != 0)
+    800011c2:	03459793          	slli	a5,a1,0x34
+    800011c6:	e38d                	bnez	a5,800011e8 <uvmunmap+0x2e>
+    800011c8:	f04a                	sd	s2,32(sp)
+    800011ca:	ec4e                	sd	s3,24(sp)
+    800011cc:	e852                	sd	s4,16(sp)
+    800011ce:	e456                	sd	s5,8(sp)
+    800011d0:	e05a                	sd	s6,0(sp)
+    800011d2:	8a2a                	mv	s4,a0
+    800011d4:	892e                	mv	s2,a1
+    800011d6:	8ab6                	mv	s5,a3
+    panic("uvmunmap: not aligned");
+
+  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+    800011d8:	0632                	slli	a2,a2,0xc
+    800011da:	00b609b3          	add	s3,a2,a1
+    800011de:	6b05                	lui	s6,0x1
+    800011e0:	0535f963          	bgeu	a1,s3,80001232 <uvmunmap+0x78>
+    800011e4:	f426                	sd	s1,40(sp)
+    800011e6:	a015                	j	8000120a <uvmunmap+0x50>
+    800011e8:	f426                	sd	s1,40(sp)
+    800011ea:	f04a                	sd	s2,32(sp)
+    800011ec:	ec4e                	sd	s3,24(sp)
+    800011ee:	e852                	sd	s4,16(sp)
+    800011f0:	e456                	sd	s5,8(sp)
+    800011f2:	e05a                	sd	s6,0(sp)
+    panic("uvmunmap: not aligned");
+    800011f4:	00006517          	auipc	a0,0x6
+    800011f8:	f2c50513          	addi	a0,a0,-212 # 80007120 <etext+0x120>
+    800011fc:	de4ff0ef          	jal	800007e0 <panic>
+      continue;
+    if(do_free){
+      uint64 pa = PTE2PA(*pte);
+      kfree((void*)pa);
+    }
+    *pte = 0;
+    80001200:	0004b023          	sd	zero,0(s1)
+  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+    80001204:	995a                	add	s2,s2,s6
+    80001206:	03397563          	bgeu	s2,s3,80001230 <uvmunmap+0x76>
+    if((pte = walk(pagetable, a, 0)) == 0) // leaf page table entry allocated?
+    8000120a:	4601                	li	a2,0
+    8000120c:	85ca                	mv	a1,s2
+    8000120e:	8552                	mv	a0,s4
+    80001210:	d07ff0ef          	jal	80000f16 <walk>
+    80001214:	84aa                	mv	s1,a0
+    80001216:	d57d                	beqz	a0,80001204 <uvmunmap+0x4a>
+    if((*pte & PTE_V) == 0)  // has physical page been allocated?
+    80001218:	611c                	ld	a5,0(a0)
+    8000121a:	0017f713          	andi	a4,a5,1
+    8000121e:	d37d                	beqz	a4,80001204 <uvmunmap+0x4a>
+    if(do_free){
+    80001220:	fe0a80e3          	beqz	s5,80001200 <uvmunmap+0x46>
+      uint64 pa = PTE2PA(*pte);
+    80001224:	83a9                	srli	a5,a5,0xa
+      kfree((void*)pa);
+    80001226:	00c79513          	slli	a0,a5,0xc
+    8000122a:	ff2ff0ef          	jal	80000a1c <kfree>
+    8000122e:	bfc9                	j	80001200 <uvmunmap+0x46>
+    80001230:	74a2                	ld	s1,40(sp)
+    80001232:	7902                	ld	s2,32(sp)
+    80001234:	69e2                	ld	s3,24(sp)
+    80001236:	6a42                	ld	s4,16(sp)
+    80001238:	6aa2                	ld	s5,8(sp)
+    8000123a:	6b02                	ld	s6,0(sp)
+  }
+}
+    8000123c:	70e2                	ld	ra,56(sp)
+    8000123e:	7442                	ld	s0,48(sp)
+    80001240:	6121                	addi	sp,sp,64
+    80001242:	8082                	ret
+
+0000000080001244 <uvmdealloc>:
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+uint64
+uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+{
+    80001244:	1101                	addi	sp,sp,-32
+    80001246:	ec06                	sd	ra,24(sp)
+    80001248:	e822                	sd	s0,16(sp)
+    8000124a:	e426                	sd	s1,8(sp)
+    8000124c:	1000                	addi	s0,sp,32
+  if(newsz >= oldsz)
+    return oldsz;
+    8000124e:	84ae                	mv	s1,a1
+  if(newsz >= oldsz)
+    80001250:	00b67d63          	bgeu	a2,a1,8000126a <uvmdealloc+0x26>
+    80001254:	84b2                	mv	s1,a2
+
+  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+    80001256:	6785                	lui	a5,0x1
+    80001258:	17fd                	addi	a5,a5,-1 # fff <_entry-0x7ffff001>
+    8000125a:	00f60733          	add	a4,a2,a5
+    8000125e:	76fd                	lui	a3,0xfffff
+    80001260:	8f75                	and	a4,a4,a3
+    80001262:	97ae                	add	a5,a5,a1
+    80001264:	8ff5                	and	a5,a5,a3
+    80001266:	00f76863          	bltu	a4,a5,80001276 <uvmdealloc+0x32>
+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+  }
+
+  return newsz;
+}
+    8000126a:	8526                	mv	a0,s1
+    8000126c:	60e2                	ld	ra,24(sp)
+    8000126e:	6442                	ld	s0,16(sp)
+    80001270:	64a2                	ld	s1,8(sp)
+    80001272:	6105                	addi	sp,sp,32
+    80001274:	8082                	ret
+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+    80001276:	8f99                	sub	a5,a5,a4
+    80001278:	83b1                	srli	a5,a5,0xc
+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+    8000127a:	4685                	li	a3,1
+    8000127c:	0007861b          	sext.w	a2,a5
+    80001280:	85ba                	mv	a1,a4
+    80001282:	f39ff0ef          	jal	800011ba <uvmunmap>
+    80001286:	b7d5                	j	8000126a <uvmdealloc+0x26>
+
+0000000080001288 <uvmalloc>:
+  if(newsz < oldsz)
+    80001288:	08b66f63          	bltu	a2,a1,80001326 <uvmalloc+0x9e>
+{
+    8000128c:	7139                	addi	sp,sp,-64
+    8000128e:	fc06                	sd	ra,56(sp)
+    80001290:	f822                	sd	s0,48(sp)
+    80001292:	ec4e                	sd	s3,24(sp)
+    80001294:	e852                	sd	s4,16(sp)
+    80001296:	e456                	sd	s5,8(sp)
+    80001298:	0080                	addi	s0,sp,64
+    8000129a:	8aaa                	mv	s5,a0
+    8000129c:	8a32                	mv	s4,a2
+  oldsz = PGROUNDUP(oldsz);
+    8000129e:	6785                	lui	a5,0x1
+    800012a0:	17fd                	addi	a5,a5,-1 # fff <_entry-0x7ffff001>
+    800012a2:	95be                	add	a1,a1,a5
+    800012a4:	77fd                	lui	a5,0xfffff
+    800012a6:	00f5f9b3          	and	s3,a1,a5
+  for(a = oldsz; a < newsz; a += PGSIZE){
+    800012aa:	08c9f063          	bgeu	s3,a2,8000132a <uvmalloc+0xa2>
+    800012ae:	f426                	sd	s1,40(sp)
+    800012b0:	f04a                	sd	s2,32(sp)
+    800012b2:	e05a                	sd	s6,0(sp)
+    800012b4:	894e                	mv	s2,s3
+    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+    800012b6:	0126eb13          	ori	s6,a3,18
+    mem = kalloc();
+    800012ba:	845ff0ef          	jal	80000afe <kalloc>
+    800012be:	84aa                	mv	s1,a0
+    if(mem == 0){
+    800012c0:	c515                	beqz	a0,800012ec <uvmalloc+0x64>
+    memset(mem, 0, PGSIZE);
+    800012c2:	6605                	lui	a2,0x1
+    800012c4:	4581                	li	a1,0
+    800012c6:	9ddff0ef          	jal	80000ca2 <memset>
+    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+    800012ca:	875a                	mv	a4,s6
+    800012cc:	86a6                	mv	a3,s1
+    800012ce:	6605                	lui	a2,0x1
+    800012d0:	85ca                	mv	a1,s2
+    800012d2:	8556                	mv	a0,s5
+    800012d4:	d1bff0ef          	jal	80000fee <mappages>
+    800012d8:	e915                	bnez	a0,8000130c <uvmalloc+0x84>
+  for(a = oldsz; a < newsz; a += PGSIZE){
+    800012da:	6785                	lui	a5,0x1
+    800012dc:	993e                	add	s2,s2,a5
+    800012de:	fd496ee3          	bltu	s2,s4,800012ba <uvmalloc+0x32>
+  return newsz;
+    800012e2:	8552                	mv	a0,s4
+    800012e4:	74a2                	ld	s1,40(sp)
+    800012e6:	7902                	ld	s2,32(sp)
+    800012e8:	6b02                	ld	s6,0(sp)
+    800012ea:	a811                	j	800012fe <uvmalloc+0x76>
+      uvmdealloc(pagetable, a, oldsz);
+    800012ec:	864e                	mv	a2,s3
+    800012ee:	85ca                	mv	a1,s2
+    800012f0:	8556                	mv	a0,s5
+    800012f2:	f53ff0ef          	jal	80001244 <uvmdealloc>
+      return 0;
+    800012f6:	4501                	li	a0,0
+    800012f8:	74a2                	ld	s1,40(sp)
+    800012fa:	7902                	ld	s2,32(sp)
+    800012fc:	6b02                	ld	s6,0(sp)
+}
+    800012fe:	70e2                	ld	ra,56(sp)
+    80001300:	7442                	ld	s0,48(sp)
+    80001302:	69e2                	ld	s3,24(sp)
+    80001304:	6a42                	ld	s4,16(sp)
+    80001306:	6aa2                	ld	s5,8(sp)
+    80001308:	6121                	addi	sp,sp,64
+    8000130a:	8082                	ret
+      kfree(mem);
+    8000130c:	8526                	mv	a0,s1
+    8000130e:	f0eff0ef          	jal	80000a1c <kfree>
+      uvmdealloc(pagetable, a, oldsz);
+    80001312:	864e                	mv	a2,s3
+    80001314:	85ca                	mv	a1,s2
+    80001316:	8556                	mv	a0,s5
+    80001318:	f2dff0ef          	jal	80001244 <uvmdealloc>
+      return 0;
+    8000131c:	4501                	li	a0,0
+    8000131e:	74a2                	ld	s1,40(sp)
+    80001320:	7902                	ld	s2,32(sp)
+    80001322:	6b02                	ld	s6,0(sp)
+    80001324:	bfe9                	j	800012fe <uvmalloc+0x76>
+    return oldsz;
+    80001326:	852e                	mv	a0,a1
+}
+    80001328:	8082                	ret
+  return newsz;
+    8000132a:	8532                	mv	a0,a2
+    8000132c:	bfc9                	j	800012fe <uvmalloc+0x76>
+
+000000008000132e <freewalk>:
+
+// Recursively free page-table pages.
+// All leaf mappings must already have been removed.
+void
+freewalk(pagetable_t pagetable)
+{
+    8000132e:	7179                	addi	sp,sp,-48
+    80001330:	f406                	sd	ra,40(sp)
+    80001332:	f022                	sd	s0,32(sp)
+    80001334:	ec26                	sd	s1,24(sp)
+    80001336:	e84a                	sd	s2,16(sp)
+    80001338:	e44e                	sd	s3,8(sp)
+    8000133a:	e052                	sd	s4,0(sp)
+    8000133c:	1800                	addi	s0,sp,48
+    8000133e:	8a2a                	mv	s4,a0
+  // there are 2^9 = 512 PTEs in a page table.
+  for(int i = 0; i < 512; i++){
+    80001340:	84aa                	mv	s1,a0
+    80001342:	6905                	lui	s2,0x1
+    80001344:	992a                	add	s2,s2,a0
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+    80001346:	4985                	li	s3,1
+    80001348:	a819                	j	8000135e <freewalk+0x30>
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte);
+    8000134a:	83a9                	srli	a5,a5,0xa
+      freewalk((pagetable_t)child);
+    8000134c:	00c79513          	slli	a0,a5,0xc
+    80001350:	fdfff0ef          	jal	8000132e <freewalk>
+      pagetable[i] = 0;
+    80001354:	0004b023          	sd	zero,0(s1)
+  for(int i = 0; i < 512; i++){
+    80001358:	04a1                	addi	s1,s1,8
+    8000135a:	01248f63          	beq	s1,s2,80001378 <freewalk+0x4a>
+    pte_t pte = pagetable[i];
+    8000135e:	609c                	ld	a5,0(s1)
+    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+    80001360:	00f7f713          	andi	a4,a5,15
+    80001364:	ff3703e3          	beq	a4,s3,8000134a <freewalk+0x1c>
+    } else if(pte & PTE_V){
+    80001368:	8b85                	andi	a5,a5,1
+    8000136a:	d7fd                	beqz	a5,80001358 <freewalk+0x2a>
+      panic("freewalk: leaf");
+    8000136c:	00006517          	auipc	a0,0x6
+    80001370:	dcc50513          	addi	a0,a0,-564 # 80007138 <etext+0x138>
+    80001374:	c6cff0ef          	jal	800007e0 <panic>
+    }
+  }
+  kfree((void*)pagetable);
+    80001378:	8552                	mv	a0,s4
+    8000137a:	ea2ff0ef          	jal	80000a1c <kfree>
+}
+    8000137e:	70a2                	ld	ra,40(sp)
+    80001380:	7402                	ld	s0,32(sp)
+    80001382:	64e2                	ld	s1,24(sp)
+    80001384:	6942                	ld	s2,16(sp)
+    80001386:	69a2                	ld	s3,8(sp)
+    80001388:	6a02                	ld	s4,0(sp)
+    8000138a:	6145                	addi	sp,sp,48
+    8000138c:	8082                	ret
+
+000000008000138e <uvmfree>:
+
+// Free user memory pages,
+// then free page-table pages.
+void
+uvmfree(pagetable_t pagetable, uint64 sz)
+{
+    8000138e:	1101                	addi	sp,sp,-32
+    80001390:	ec06                	sd	ra,24(sp)
+    80001392:	e822                	sd	s0,16(sp)
+    80001394:	e426                	sd	s1,8(sp)
+    80001396:	1000                	addi	s0,sp,32
+    80001398:	84aa                	mv	s1,a0
+  if(sz > 0)
+    8000139a:	e989                	bnez	a1,800013ac <uvmfree+0x1e>
+    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+  freewalk(pagetable);
+    8000139c:	8526                	mv	a0,s1
+    8000139e:	f91ff0ef          	jal	8000132e <freewalk>
+}
+    800013a2:	60e2                	ld	ra,24(sp)
+    800013a4:	6442                	ld	s0,16(sp)
+    800013a6:	64a2                	ld	s1,8(sp)
+    800013a8:	6105                	addi	sp,sp,32
+    800013aa:	8082                	ret
+    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+    800013ac:	6785                	lui	a5,0x1
+    800013ae:	17fd                	addi	a5,a5,-1 # fff <_entry-0x7ffff001>
+    800013b0:	95be                	add	a1,a1,a5
+    800013b2:	4685                	li	a3,1
+    800013b4:	00c5d613          	srli	a2,a1,0xc
+    800013b8:	4581                	li	a1,0
+    800013ba:	e01ff0ef          	jal	800011ba <uvmunmap>
+    800013be:	bff9                	j	8000139c <uvmfree+0xe>
+
+00000000800013c0 <uvmcopy>:
+  pte_t *pte;
+  uint64 pa, i;
+  uint flags;
+  char *mem;
+
+  for(i = 0; i < sz; i += PGSIZE){
+    800013c0:	ce49                	beqz	a2,8000145a <uvmcopy+0x9a>
+{
+    800013c2:	715d                	addi	sp,sp,-80
+    800013c4:	e486                	sd	ra,72(sp)
+    800013c6:	e0a2                	sd	s0,64(sp)
+    800013c8:	fc26                	sd	s1,56(sp)
+    800013ca:	f84a                	sd	s2,48(sp)
+    800013cc:	f44e                	sd	s3,40(sp)
+    800013ce:	f052                	sd	s4,32(sp)
+    800013d0:	ec56                	sd	s5,24(sp)
+    800013d2:	e85a                	sd	s6,16(sp)
+    800013d4:	e45e                	sd	s7,8(sp)
+    800013d6:	0880                	addi	s0,sp,80
+    800013d8:	8aaa                	mv	s5,a0
+    800013da:	8b2e                	mv	s6,a1
+    800013dc:	8a32                	mv	s4,a2
+  for(i = 0; i < sz; i += PGSIZE){
+    800013de:	4481                	li	s1,0
+    800013e0:	a029                	j	800013ea <uvmcopy+0x2a>
+    800013e2:	6785                	lui	a5,0x1
+    800013e4:	94be                	add	s1,s1,a5
+    800013e6:	0544fe63          	bgeu	s1,s4,80001442 <uvmcopy+0x82>
+    if((pte = walk(old, i, 0)) == 0)
+    800013ea:	4601                	li	a2,0
+    800013ec:	85a6                	mv	a1,s1
+    800013ee:	8556                	mv	a0,s5
+    800013f0:	b27ff0ef          	jal	80000f16 <walk>
+    800013f4:	d57d                	beqz	a0,800013e2 <uvmcopy+0x22>
+      continue;   // page table entry hasn't been allocated
+    if((*pte & PTE_V) == 0)
+    800013f6:	6118                	ld	a4,0(a0)
+    800013f8:	00177793          	andi	a5,a4,1
+    800013fc:	d3fd                	beqz	a5,800013e2 <uvmcopy+0x22>
+      continue;   // physical page hasn't been allocated
+    pa = PTE2PA(*pte);
+    800013fe:	00a75593          	srli	a1,a4,0xa
+    80001402:	00c59b93          	slli	s7,a1,0xc
+    flags = PTE_FLAGS(*pte);
+    80001406:	3ff77913          	andi	s2,a4,1023
+    if((mem = kalloc()) == 0)
+    8000140a:	ef4ff0ef          	jal	80000afe <kalloc>
+    8000140e:	89aa                	mv	s3,a0
+    80001410:	c105                	beqz	a0,80001430 <uvmcopy+0x70>
+      goto err;
+    memmove(mem, (char*)pa, PGSIZE);
+    80001412:	6605                	lui	a2,0x1
+    80001414:	85de                	mv	a1,s7
+    80001416:	8e9ff0ef          	jal	80000cfe <memmove>
+    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+    8000141a:	874a                	mv	a4,s2
+    8000141c:	86ce                	mv	a3,s3
+    8000141e:	6605                	lui	a2,0x1
+    80001420:	85a6                	mv	a1,s1
+    80001422:	855a                	mv	a0,s6
+    80001424:	bcbff0ef          	jal	80000fee <mappages>
+    80001428:	dd4d                	beqz	a0,800013e2 <uvmcopy+0x22>
+      kfree(mem);
+    8000142a:	854e                	mv	a0,s3
+    8000142c:	df0ff0ef          	jal	80000a1c <kfree>
+    }
+  }
+  return 0;
+
+ err:
+  uvmunmap(new, 0, i / PGSIZE, 1);
+    80001430:	4685                	li	a3,1
+    80001432:	00c4d613          	srli	a2,s1,0xc
+    80001436:	4581                	li	a1,0
+    80001438:	855a                	mv	a0,s6
+    8000143a:	d81ff0ef          	jal	800011ba <uvmunmap>
+  return -1;
+    8000143e:	557d                	li	a0,-1
+    80001440:	a011                	j	80001444 <uvmcopy+0x84>
+  return 0;
+    80001442:	4501                	li	a0,0
+}
+    80001444:	60a6                	ld	ra,72(sp)
+    80001446:	6406                	ld	s0,64(sp)
+    80001448:	74e2                	ld	s1,56(sp)
+    8000144a:	7942                	ld	s2,48(sp)
+    8000144c:	79a2                	ld	s3,40(sp)
+    8000144e:	7a02                	ld	s4,32(sp)
+    80001450:	6ae2                	ld	s5,24(sp)
+    80001452:	6b42                	ld	s6,16(sp)
+    80001454:	6ba2                	ld	s7,8(sp)
+    80001456:	6161                	addi	sp,sp,80
+    80001458:	8082                	ret
+  return 0;
+    8000145a:	4501                	li	a0,0
+}
+    8000145c:	8082                	ret
+
+000000008000145e <uvmclear>:
+
+// mark a PTE invalid for user access.
+// used by exec for the user stack guard page.
+void
+uvmclear(pagetable_t pagetable, uint64 va)
+{
+    8000145e:	1141                	addi	sp,sp,-16
+    80001460:	e406                	sd	ra,8(sp)
+    80001462:	e022                	sd	s0,0(sp)
+    80001464:	0800                	addi	s0,sp,16
+  pte_t *pte;
+  
+  pte = walk(pagetable, va, 0);
+    80001466:	4601                	li	a2,0
+    80001468:	aafff0ef          	jal	80000f16 <walk>
+  if(pte == 0)
+    8000146c:	c901                	beqz	a0,8000147c <uvmclear+0x1e>
+    panic("uvmclear");
+  *pte &= ~PTE_U;
+    8000146e:	611c                	ld	a5,0(a0)
+    80001470:	9bbd                	andi	a5,a5,-17
+    80001472:	e11c                	sd	a5,0(a0)
+}
+    80001474:	60a2                	ld	ra,8(sp)
+    80001476:	6402                	ld	s0,0(sp)
+    80001478:	0141                	addi	sp,sp,16
+    8000147a:	8082                	ret
+    panic("uvmclear");
+    8000147c:	00006517          	auipc	a0,0x6
+    80001480:	ccc50513          	addi	a0,a0,-820 # 80007148 <etext+0x148>
+    80001484:	b5cff0ef          	jal	800007e0 <panic>
+
+0000000080001488 <copyinstr>:
+copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+{
+  uint64 n, va0, pa0;
+  int got_null = 0;
+
+  while(got_null == 0 && max > 0){
+    80001488:	c6dd                	beqz	a3,80001536 <copyinstr+0xae>
+{
+    8000148a:	715d                	addi	sp,sp,-80
+    8000148c:	e486                	sd	ra,72(sp)
+    8000148e:	e0a2                	sd	s0,64(sp)
+    80001490:	fc26                	sd	s1,56(sp)
+    80001492:	f84a                	sd	s2,48(sp)
+    80001494:	f44e                	sd	s3,40(sp)
+    80001496:	f052                	sd	s4,32(sp)
+    80001498:	ec56                	sd	s5,24(sp)
+    8000149a:	e85a                	sd	s6,16(sp)
+    8000149c:	e45e                	sd	s7,8(sp)
+    8000149e:	0880                	addi	s0,sp,80
+    800014a0:	8a2a                	mv	s4,a0
+    800014a2:	8b2e                	mv	s6,a1
+    800014a4:	8bb2                	mv	s7,a2
+    800014a6:	8936                	mv	s2,a3
+    va0 = PGROUNDDOWN(srcva);
+    800014a8:	7afd                	lui	s5,0xfffff
+    pa0 = walkaddr(pagetable, va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (srcva - va0);
+    800014aa:	6985                	lui	s3,0x1
+    800014ac:	a825                	j	800014e4 <copyinstr+0x5c>
+      n = max;
+
+    char *p = (char *) (pa0 + (srcva - va0));
+    while(n > 0){
+      if(*p == '\0'){
+        *dst = '\0';
+    800014ae:	00078023          	sb	zero,0(a5) # 1000 <_entry-0x7ffff000>
+    800014b2:	4785                	li	a5,1
+      dst++;
+    }
+
+    srcva = va0 + PGSIZE;
+  }
+  if(got_null){
+    800014b4:	37fd                	addiw	a5,a5,-1
+    800014b6:	0007851b          	sext.w	a0,a5
+    return 0;
+  } else {
+    return -1;
+  }
+}
+    800014ba:	60a6                	ld	ra,72(sp)
+    800014bc:	6406                	ld	s0,64(sp)
+    800014be:	74e2                	ld	s1,56(sp)
+    800014c0:	7942                	ld	s2,48(sp)
+    800014c2:	79a2                	ld	s3,40(sp)
+    800014c4:	7a02                	ld	s4,32(sp)
+    800014c6:	6ae2                	ld	s5,24(sp)
+    800014c8:	6b42                	ld	s6,16(sp)
+    800014ca:	6ba2                	ld	s7,8(sp)
+    800014cc:	6161                	addi	sp,sp,80
+    800014ce:	8082                	ret
+    800014d0:	fff90713          	addi	a4,s2,-1 # fff <_entry-0x7ffff001>
+    800014d4:	9742                	add	a4,a4,a6
+      --max;
+    800014d6:	40b70933          	sub	s2,a4,a1
+    srcva = va0 + PGSIZE;
+    800014da:	01348bb3          	add	s7,s1,s3
+  while(got_null == 0 && max > 0){
+    800014de:	04e58463          	beq	a1,a4,80001526 <copyinstr+0x9e>
+{
+    800014e2:	8b3e                	mv	s6,a5
+    va0 = PGROUNDDOWN(srcva);
+    800014e4:	015bf4b3          	and	s1,s7,s5
+    pa0 = walkaddr(pagetable, va0);
+    800014e8:	85a6                	mv	a1,s1
+    800014ea:	8552                	mv	a0,s4
+    800014ec:	ac5ff0ef          	jal	80000fb0 <walkaddr>
+    if(pa0 == 0)
+    800014f0:	cd0d                	beqz	a0,8000152a <copyinstr+0xa2>
+    n = PGSIZE - (srcva - va0);
+    800014f2:	417486b3          	sub	a3,s1,s7
+    800014f6:	96ce                	add	a3,a3,s3
+    if(n > max)
+    800014f8:	00d97363          	bgeu	s2,a3,800014fe <copyinstr+0x76>
+    800014fc:	86ca                	mv	a3,s2
+    char *p = (char *) (pa0 + (srcva - va0));
+    800014fe:	955e                	add	a0,a0,s7
+    80001500:	8d05                	sub	a0,a0,s1
+    while(n > 0){
+    80001502:	c695                	beqz	a3,8000152e <copyinstr+0xa6>
+    80001504:	87da                	mv	a5,s6
+    80001506:	885a                	mv	a6,s6
+      if(*p == '\0'){
+    80001508:	41650633          	sub	a2,a0,s6
+    while(n > 0){
+    8000150c:	96da                	add	a3,a3,s6
+    8000150e:	85be                	mv	a1,a5
+      if(*p == '\0'){
+    80001510:	00f60733          	add	a4,a2,a5
+    80001514:	00074703          	lbu	a4,0(a4)
+    80001518:	db59                	beqz	a4,800014ae <copyinstr+0x26>
+        *dst = *p;
+    8000151a:	00e78023          	sb	a4,0(a5)
+      dst++;
+    8000151e:	0785                	addi	a5,a5,1
+    while(n > 0){
+    80001520:	fed797e3          	bne	a5,a3,8000150e <copyinstr+0x86>
+    80001524:	b775                	j	800014d0 <copyinstr+0x48>
+    80001526:	4781                	li	a5,0
+    80001528:	b771                	j	800014b4 <copyinstr+0x2c>
+      return -1;
+    8000152a:	557d                	li	a0,-1
+    8000152c:	b779                	j	800014ba <copyinstr+0x32>
+    srcva = va0 + PGSIZE;
+    8000152e:	6b85                	lui	s7,0x1
+    80001530:	9ba6                	add	s7,s7,s1
+    80001532:	87da                	mv	a5,s6
+    80001534:	b77d                	j	800014e2 <copyinstr+0x5a>
+  int got_null = 0;
+    80001536:	4781                	li	a5,0
+  if(got_null){
+    80001538:	37fd                	addiw	a5,a5,-1
+    8000153a:	0007851b          	sext.w	a0,a5
+}
+    8000153e:	8082                	ret
+
+0000000080001540 <ismapped>:
+  return mem;
+}
+
+int
+ismapped(pagetable_t pagetable, uint64 va)
+{
+    80001540:	1141                	addi	sp,sp,-16
+    80001542:	e406                	sd	ra,8(sp)
+    80001544:	e022                	sd	s0,0(sp)
+    80001546:	0800                	addi	s0,sp,16
+  pte_t *pte = walk(pagetable, va, 0);
+    80001548:	4601                	li	a2,0
+    8000154a:	9cdff0ef          	jal	80000f16 <walk>
+  if (pte == 0) {
+    8000154e:	c519                	beqz	a0,8000155c <ismapped+0x1c>
+    return 0;
+  }
+  if (*pte & PTE_V){
+    80001550:	6108                	ld	a0,0(a0)
+    80001552:	8905                	andi	a0,a0,1
+    return 1;
+  }
+  return 0;
+}
+    80001554:	60a2                	ld	ra,8(sp)
+    80001556:	6402                	ld	s0,0(sp)
+    80001558:	0141                	addi	sp,sp,16
+    8000155a:	8082                	ret
+    return 0;
+    8000155c:	4501                	li	a0,0
+    8000155e:	bfdd                	j	80001554 <ismapped+0x14>
+
+0000000080001560 <vmfault>:
+{
+    80001560:	7179                	addi	sp,sp,-48
+    80001562:	f406                	sd	ra,40(sp)
+    80001564:	f022                	sd	s0,32(sp)
+    80001566:	ec26                	sd	s1,24(sp)
+    80001568:	e44e                	sd	s3,8(sp)
+    8000156a:	1800                	addi	s0,sp,48
+    8000156c:	89aa                	mv	s3,a0
+    8000156e:	84ae                	mv	s1,a1
+  struct proc *p = myproc();
+    80001570:	35e000ef          	jal	800018ce <myproc>
+  if (va >= p->sz)
+    80001574:	653c                	ld	a5,72(a0)
+    80001576:	00f4ea63          	bltu	s1,a5,8000158a <vmfault+0x2a>
+    return 0;
+    8000157a:	4981                	li	s3,0
+}
+    8000157c:	854e                	mv	a0,s3
+    8000157e:	70a2                	ld	ra,40(sp)
+    80001580:	7402                	ld	s0,32(sp)
+    80001582:	64e2                	ld	s1,24(sp)
+    80001584:	69a2                	ld	s3,8(sp)
+    80001586:	6145                	addi	sp,sp,48
+    80001588:	8082                	ret
+    8000158a:	e84a                	sd	s2,16(sp)
+    8000158c:	892a                	mv	s2,a0
+  va = PGROUNDDOWN(va);
+    8000158e:	77fd                	lui	a5,0xfffff
+    80001590:	8cfd                	and	s1,s1,a5
+  if(ismapped(pagetable, va)) {
+    80001592:	85a6                	mv	a1,s1
+    80001594:	854e                	mv	a0,s3
+    80001596:	fabff0ef          	jal	80001540 <ismapped>
+    return 0;
+    8000159a:	4981                	li	s3,0
+  if(ismapped(pagetable, va)) {
+    8000159c:	c119                	beqz	a0,800015a2 <vmfault+0x42>
+    8000159e:	6942                	ld	s2,16(sp)
+    800015a0:	bff1                	j	8000157c <vmfault+0x1c>
+    800015a2:	e052                	sd	s4,0(sp)
+  mem = (uint64) kalloc();
+    800015a4:	d5aff0ef          	jal	80000afe <kalloc>
+    800015a8:	8a2a                	mv	s4,a0
+  if(mem == 0)
+    800015aa:	c90d                	beqz	a0,800015dc <vmfault+0x7c>
+  mem = (uint64) kalloc();
+    800015ac:	89aa                	mv	s3,a0
+  memset((void *) mem, 0, PGSIZE);
+    800015ae:	6605                	lui	a2,0x1
+    800015b0:	4581                	li	a1,0
+    800015b2:	ef0ff0ef          	jal	80000ca2 <memset>
+  if (mappages(p->pagetable, va, PGSIZE, mem, PTE_W|PTE_U|PTE_R) != 0) {
+    800015b6:	4759                	li	a4,22
+    800015b8:	86d2                	mv	a3,s4
+    800015ba:	6605                	lui	a2,0x1
+    800015bc:	85a6                	mv	a1,s1
+    800015be:	05093503          	ld	a0,80(s2)
+    800015c2:	a2dff0ef          	jal	80000fee <mappages>
+    800015c6:	e501                	bnez	a0,800015ce <vmfault+0x6e>
+    800015c8:	6942                	ld	s2,16(sp)
+    800015ca:	6a02                	ld	s4,0(sp)
+    800015cc:	bf45                	j	8000157c <vmfault+0x1c>
+    kfree((void *)mem);
+    800015ce:	8552                	mv	a0,s4
+    800015d0:	c4cff0ef          	jal	80000a1c <kfree>
+    return 0;
+    800015d4:	4981                	li	s3,0
+    800015d6:	6942                	ld	s2,16(sp)
+    800015d8:	6a02                	ld	s4,0(sp)
+    800015da:	b74d                	j	8000157c <vmfault+0x1c>
+    800015dc:	6942                	ld	s2,16(sp)
+    800015de:	6a02                	ld	s4,0(sp)
+    800015e0:	bf71                	j	8000157c <vmfault+0x1c>
+
+00000000800015e2 <copyout>:
+  while(len > 0){
+    800015e2:	c2cd                	beqz	a3,80001684 <copyout+0xa2>
+{
+    800015e4:	711d                	addi	sp,sp,-96
+    800015e6:	ec86                	sd	ra,88(sp)
+    800015e8:	e8a2                	sd	s0,80(sp)
+    800015ea:	e4a6                	sd	s1,72(sp)
+    800015ec:	f852                	sd	s4,48(sp)
+    800015ee:	f05a                	sd	s6,32(sp)
+    800015f0:	ec5e                	sd	s7,24(sp)
+    800015f2:	e862                	sd	s8,16(sp)
+    800015f4:	1080                	addi	s0,sp,96
+    800015f6:	8c2a                	mv	s8,a0
+    800015f8:	8b2e                	mv	s6,a1
+    800015fa:	8bb2                	mv	s7,a2
+    800015fc:	8a36                	mv	s4,a3
+    va0 = PGROUNDDOWN(dstva);
+    800015fe:	74fd                	lui	s1,0xfffff
+    80001600:	8ced                	and	s1,s1,a1
+    if(va0 >= MAXVA)
+    80001602:	57fd                	li	a5,-1
+    80001604:	83e9                	srli	a5,a5,0x1a
+    80001606:	0897e163          	bltu	a5,s1,80001688 <copyout+0xa6>
+    8000160a:	e0ca                	sd	s2,64(sp)
+    8000160c:	fc4e                	sd	s3,56(sp)
+    8000160e:	f456                	sd	s5,40(sp)
+    80001610:	e466                	sd	s9,8(sp)
+    80001612:	e06a                	sd	s10,0(sp)
+    80001614:	6d05                	lui	s10,0x1
+    80001616:	8cbe                	mv	s9,a5
+    80001618:	a015                	j	8000163c <copyout+0x5a>
+    memmove((void *)(pa0 + (dstva - va0)), src, n);
+    8000161a:	409b0533          	sub	a0,s6,s1
+    8000161e:	0009861b          	sext.w	a2,s3
+    80001622:	85de                	mv	a1,s7
+    80001624:	954a                	add	a0,a0,s2
+    80001626:	ed8ff0ef          	jal	80000cfe <memmove>
+    len -= n;
+    8000162a:	413a0a33          	sub	s4,s4,s3
+    src += n;
+    8000162e:	9bce                	add	s7,s7,s3
+  while(len > 0){
+    80001630:	040a0363          	beqz	s4,80001676 <copyout+0x94>
+    if(va0 >= MAXVA)
+    80001634:	055cec63          	bltu	s9,s5,8000168c <copyout+0xaa>
+    80001638:	84d6                	mv	s1,s5
+    8000163a:	8b56                	mv	s6,s5
+    pa0 = walkaddr(pagetable, va0);
+    8000163c:	85a6                	mv	a1,s1
+    8000163e:	8562                	mv	a0,s8
+    80001640:	971ff0ef          	jal	80000fb0 <walkaddr>
+    80001644:	892a                	mv	s2,a0
+    if(pa0 == 0) {
+    80001646:	e901                	bnez	a0,80001656 <copyout+0x74>
+      if((pa0 = vmfault(pagetable, va0, 0)) == 0) {
+    80001648:	4601                	li	a2,0
+    8000164a:	85a6                	mv	a1,s1
+    8000164c:	8562                	mv	a0,s8
+    8000164e:	f13ff0ef          	jal	80001560 <vmfault>
+    80001652:	892a                	mv	s2,a0
+    80001654:	c139                	beqz	a0,8000169a <copyout+0xb8>
+    pte = walk(pagetable, va0, 0);
+    80001656:	4601                	li	a2,0
+    80001658:	85a6                	mv	a1,s1
+    8000165a:	8562                	mv	a0,s8
+    8000165c:	8bbff0ef          	jal	80000f16 <walk>
+    if((*pte & PTE_W) == 0)
+    80001660:	611c                	ld	a5,0(a0)
+    80001662:	8b91                	andi	a5,a5,4
+    80001664:	c3b1                	beqz	a5,800016a8 <copyout+0xc6>
+    n = PGSIZE - (dstva - va0);
+    80001666:	01a48ab3          	add	s5,s1,s10
+    8000166a:	416a89b3          	sub	s3,s5,s6
+    if(n > len)
+    8000166e:	fb3a76e3          	bgeu	s4,s3,8000161a <copyout+0x38>
+    80001672:	89d2                	mv	s3,s4
+    80001674:	b75d                	j	8000161a <copyout+0x38>
+  return 0;
+    80001676:	4501                	li	a0,0
+    80001678:	6906                	ld	s2,64(sp)
+    8000167a:	79e2                	ld	s3,56(sp)
+    8000167c:	7aa2                	ld	s5,40(sp)
+    8000167e:	6ca2                	ld	s9,8(sp)
+    80001680:	6d02                	ld	s10,0(sp)
+    80001682:	a80d                	j	800016b4 <copyout+0xd2>
+    80001684:	4501                	li	a0,0
+}
+    80001686:	8082                	ret
+      return -1;
+    80001688:	557d                	li	a0,-1
+    8000168a:	a02d                	j	800016b4 <copyout+0xd2>
+    8000168c:	557d                	li	a0,-1
+    8000168e:	6906                	ld	s2,64(sp)
+    80001690:	79e2                	ld	s3,56(sp)
+    80001692:	7aa2                	ld	s5,40(sp)
+    80001694:	6ca2                	ld	s9,8(sp)
+    80001696:	6d02                	ld	s10,0(sp)
+    80001698:	a831                	j	800016b4 <copyout+0xd2>
+        return -1;
+    8000169a:	557d                	li	a0,-1
+    8000169c:	6906                	ld	s2,64(sp)
+    8000169e:	79e2                	ld	s3,56(sp)
+    800016a0:	7aa2                	ld	s5,40(sp)
+    800016a2:	6ca2                	ld	s9,8(sp)
+    800016a4:	6d02                	ld	s10,0(sp)
+    800016a6:	a039                	j	800016b4 <copyout+0xd2>
+      return -1;
+    800016a8:	557d                	li	a0,-1
+    800016aa:	6906                	ld	s2,64(sp)
+    800016ac:	79e2                	ld	s3,56(sp)
+    800016ae:	7aa2                	ld	s5,40(sp)
+    800016b0:	6ca2                	ld	s9,8(sp)
+    800016b2:	6d02                	ld	s10,0(sp)
+}
+    800016b4:	60e6                	ld	ra,88(sp)
+    800016b6:	6446                	ld	s0,80(sp)
+    800016b8:	64a6                	ld	s1,72(sp)
+    800016ba:	7a42                	ld	s4,48(sp)
+    800016bc:	7b02                	ld	s6,32(sp)
+    800016be:	6be2                	ld	s7,24(sp)
+    800016c0:	6c42                	ld	s8,16(sp)
+    800016c2:	6125                	addi	sp,sp,96
+    800016c4:	8082                	ret
+
+00000000800016c6 <copyin>:
+  while(len > 0){
+    800016c6:	c6c9                	beqz	a3,80001750 <copyin+0x8a>
+{
+    800016c8:	715d                	addi	sp,sp,-80
+    800016ca:	e486                	sd	ra,72(sp)
+    800016cc:	e0a2                	sd	s0,64(sp)
+    800016ce:	fc26                	sd	s1,56(sp)
+    800016d0:	f84a                	sd	s2,48(sp)
+    800016d2:	f44e                	sd	s3,40(sp)
+    800016d4:	f052                	sd	s4,32(sp)
+    800016d6:	ec56                	sd	s5,24(sp)
+    800016d8:	e85a                	sd	s6,16(sp)
+    800016da:	e45e                	sd	s7,8(sp)
+    800016dc:	e062                	sd	s8,0(sp)
+    800016de:	0880                	addi	s0,sp,80
+    800016e0:	8baa                	mv	s7,a0
+    800016e2:	8aae                	mv	s5,a1
+    800016e4:	8932                	mv	s2,a2
+    800016e6:	8a36                	mv	s4,a3
+    va0 = PGROUNDDOWN(srcva);
+    800016e8:	7c7d                	lui	s8,0xfffff
+    n = PGSIZE - (srcva - va0);
+    800016ea:	6b05                	lui	s6,0x1
+    800016ec:	a035                	j	80001718 <copyin+0x52>
+    800016ee:	412984b3          	sub	s1,s3,s2
+    800016f2:	94da                	add	s1,s1,s6
+    if(n > len)
+    800016f4:	009a7363          	bgeu	s4,s1,800016fa <copyin+0x34>
+    800016f8:	84d2                	mv	s1,s4
+    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+    800016fa:	413905b3          	sub	a1,s2,s3
+    800016fe:	0004861b          	sext.w	a2,s1
+    80001702:	95aa                	add	a1,a1,a0
+    80001704:	8556                	mv	a0,s5
+    80001706:	df8ff0ef          	jal	80000cfe <memmove>
+    len -= n;
+    8000170a:	409a0a33          	sub	s4,s4,s1
+    dst += n;
+    8000170e:	9aa6                	add	s5,s5,s1
+    srcva = va0 + PGSIZE;
+    80001710:	01698933          	add	s2,s3,s6
+  while(len > 0){
+    80001714:	020a0163          	beqz	s4,80001736 <copyin+0x70>
+    va0 = PGROUNDDOWN(srcva);
+    80001718:	018979b3          	and	s3,s2,s8
+    pa0 = walkaddr(pagetable, va0);
+    8000171c:	85ce                	mv	a1,s3
+    8000171e:	855e                	mv	a0,s7
+    80001720:	891ff0ef          	jal	80000fb0 <walkaddr>
+    if(pa0 == 0) {
+    80001724:	f569                	bnez	a0,800016ee <copyin+0x28>
+      if((pa0 = vmfault(pagetable, va0, 0)) == 0) {
+    80001726:	4601                	li	a2,0
+    80001728:	85ce                	mv	a1,s3
+    8000172a:	855e                	mv	a0,s7
+    8000172c:	e35ff0ef          	jal	80001560 <vmfault>
+    80001730:	fd5d                	bnez	a0,800016ee <copyin+0x28>
+        return -1;
+    80001732:	557d                	li	a0,-1
+    80001734:	a011                	j	80001738 <copyin+0x72>
+  return 0;
+    80001736:	4501                	li	a0,0
+}
+    80001738:	60a6                	ld	ra,72(sp)
+    8000173a:	6406                	ld	s0,64(sp)
+    8000173c:	74e2                	ld	s1,56(sp)
+    8000173e:	7942                	ld	s2,48(sp)
+    80001740:	79a2                	ld	s3,40(sp)
+    80001742:	7a02                	ld	s4,32(sp)
+    80001744:	6ae2                	ld	s5,24(sp)
+    80001746:	6b42                	ld	s6,16(sp)
+    80001748:	6ba2                	ld	s7,8(sp)
+    8000174a:	6c02                	ld	s8,0(sp)
+    8000174c:	6161                	addi	sp,sp,80
+    8000174e:	8082                	ret
+  return 0;
+    80001750:	4501                	li	a0,0
+}
+    80001752:	8082                	ret
+
+0000000080001754 <proc_mapstacks>:
+// Allocate a page for each process's kernel stack.
+// Map it high in memory, followed by an invalid
+// guard page.
+void
+proc_mapstacks(pagetable_t kpgtbl)
+{
+    80001754:	7139                	addi	sp,sp,-64
+    80001756:	fc06                	sd	ra,56(sp)
+    80001758:	f822                	sd	s0,48(sp)
+    8000175a:	f426                	sd	s1,40(sp)
+    8000175c:	f04a                	sd	s2,32(sp)
+    8000175e:	ec4e                	sd	s3,24(sp)
+    80001760:	e852                	sd	s4,16(sp)
+    80001762:	e456                	sd	s5,8(sp)
+    80001764:	e05a                	sd	s6,0(sp)
+    80001766:	0080                	addi	s0,sp,64
+    80001768:	8a2a                	mv	s4,a0
+  struct proc *p;
+  
+  for(p = proc; p < &proc[NPROC]; p++) {
+    8000176a:	00011497          	auipc	s1,0x11
+    8000176e:	fbe48493          	addi	s1,s1,-66 # 80012728 <proc>
+    char *pa = kalloc();
+    if(pa == 0)
+      panic("kalloc");
+    uint64 va = KSTACK((int) (p - proc));
+    80001772:	8b26                	mv	s6,s1
+    80001774:	ff8f6937          	lui	s2,0xff8f6
+    80001778:	c2990913          	addi	s2,s2,-983 # ffffffffff8f5c29 <end+0xffffffff7f8d1d21>
+    8000177c:	093e                	slli	s2,s2,0xf
+    8000177e:	ae190913          	addi	s2,s2,-1311
+    80001782:	0932                	slli	s2,s2,0xc
+    80001784:	47b90913          	addi	s2,s2,1147
+    80001788:	0936                	slli	s2,s2,0xd
+    8000178a:	c2990913          	addi	s2,s2,-983
+    8000178e:	040009b7          	lui	s3,0x4000
+    80001792:	19fd                	addi	s3,s3,-1 # 3ffffff <_entry-0x7c000001>
+    80001794:	09b2                	slli	s3,s3,0xc
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001796:	00017a97          	auipc	s5,0x17
+    8000179a:	392a8a93          	addi	s5,s5,914 # 80018b28 <tickslock>
+    char *pa = kalloc();
+    8000179e:	b60ff0ef          	jal	80000afe <kalloc>
+    800017a2:	862a                	mv	a2,a0
+    if(pa == 0)
+    800017a4:	cd15                	beqz	a0,800017e0 <proc_mapstacks+0x8c>
+    uint64 va = KSTACK((int) (p - proc));
+    800017a6:	416485b3          	sub	a1,s1,s6
+    800017aa:	8591                	srai	a1,a1,0x4
+    800017ac:	032585b3          	mul	a1,a1,s2
+    800017b0:	2585                	addiw	a1,a1,1
+    800017b2:	00d5959b          	slliw	a1,a1,0xd
+    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+    800017b6:	4719                	li	a4,6
+    800017b8:	6685                	lui	a3,0x1
+    800017ba:	40b985b3          	sub	a1,s3,a1
+    800017be:	8552                	mv	a0,s4
+    800017c0:	8dfff0ef          	jal	8000109e <kvmmap>
+  for(p = proc; p < &proc[NPROC]; p++) {
+    800017c4:	19048493          	addi	s1,s1,400
+    800017c8:	fd549be3          	bne	s1,s5,8000179e <proc_mapstacks+0x4a>
+  }
+}
+    800017cc:	70e2                	ld	ra,56(sp)
+    800017ce:	7442                	ld	s0,48(sp)
+    800017d0:	74a2                	ld	s1,40(sp)
+    800017d2:	7902                	ld	s2,32(sp)
+    800017d4:	69e2                	ld	s3,24(sp)
+    800017d6:	6a42                	ld	s4,16(sp)
+    800017d8:	6aa2                	ld	s5,8(sp)
+    800017da:	6b02                	ld	s6,0(sp)
+    800017dc:	6121                	addi	sp,sp,64
+    800017de:	8082                	ret
+      panic("kalloc");
+    800017e0:	00006517          	auipc	a0,0x6
+    800017e4:	97850513          	addi	a0,a0,-1672 # 80007158 <etext+0x158>
+    800017e8:	ff9fe0ef          	jal	800007e0 <panic>
+
+00000000800017ec <procinit>:
+
+// initialize the proc table.
+void
+procinit(void)
+{
+    800017ec:	7139                	addi	sp,sp,-64
+    800017ee:	fc06                	sd	ra,56(sp)
+    800017f0:	f822                	sd	s0,48(sp)
+    800017f2:	f426                	sd	s1,40(sp)
+    800017f4:	f04a                	sd	s2,32(sp)
+    800017f6:	ec4e                	sd	s3,24(sp)
+    800017f8:	e852                	sd	s4,16(sp)
+    800017fa:	e456                	sd	s5,8(sp)
+    800017fc:	e05a                	sd	s6,0(sp)
+    800017fe:	0080                	addi	s0,sp,64
+  struct proc *p;
+  
+  initlock(&pid_lock, "nextpid");
+    80001800:	00006597          	auipc	a1,0x6
+    80001804:	96058593          	addi	a1,a1,-1696 # 80007160 <etext+0x160>
+    80001808:	00011517          	auipc	a0,0x11
+    8000180c:	af050513          	addi	a0,a0,-1296 # 800122f8 <pid_lock>
+    80001810:	b3eff0ef          	jal	80000b4e <initlock>
+  initlock(&wait_lock, "wait_lock");
+    80001814:	00006597          	auipc	a1,0x6
+    80001818:	95458593          	addi	a1,a1,-1708 # 80007168 <etext+0x168>
+    8000181c:	00011517          	auipc	a0,0x11
+    80001820:	af450513          	addi	a0,a0,-1292 # 80012310 <wait_lock>
+    80001824:	b2aff0ef          	jal	80000b4e <initlock>
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001828:	00011497          	auipc	s1,0x11
+    8000182c:	f0048493          	addi	s1,s1,-256 # 80012728 <proc>
+      initlock(&p->lock, "proc");
+    80001830:	00006b17          	auipc	s6,0x6
+    80001834:	948b0b13          	addi	s6,s6,-1720 # 80007178 <etext+0x178>
+      p->state = UNUSED;
+      p->kstack = KSTACK((int) (p - proc));
+    80001838:	8aa6                	mv	s5,s1
+    8000183a:	ff8f6937          	lui	s2,0xff8f6
+    8000183e:	c2990913          	addi	s2,s2,-983 # ffffffffff8f5c29 <end+0xffffffff7f8d1d21>
+    80001842:	093e                	slli	s2,s2,0xf
+    80001844:	ae190913          	addi	s2,s2,-1311
+    80001848:	0932                	slli	s2,s2,0xc
+    8000184a:	47b90913          	addi	s2,s2,1147
+    8000184e:	0936                	slli	s2,s2,0xd
+    80001850:	c2990913          	addi	s2,s2,-983
+    80001854:	040009b7          	lui	s3,0x4000
+    80001858:	19fd                	addi	s3,s3,-1 # 3ffffff <_entry-0x7c000001>
+    8000185a:	09b2                	slli	s3,s3,0xc
+  for(p = proc; p < &proc[NPROC]; p++) {
+    8000185c:	00017a17          	auipc	s4,0x17
+    80001860:	2cca0a13          	addi	s4,s4,716 # 80018b28 <tickslock>
+      initlock(&p->lock, "proc");
+    80001864:	85da                	mv	a1,s6
+    80001866:	8526                	mv	a0,s1
+    80001868:	ae6ff0ef          	jal	80000b4e <initlock>
+      p->state = UNUSED;
+    8000186c:	0004ac23          	sw	zero,24(s1)
+      p->kstack = KSTACK((int) (p - proc));
+    80001870:	415487b3          	sub	a5,s1,s5
+    80001874:	8791                	srai	a5,a5,0x4
+    80001876:	032787b3          	mul	a5,a5,s2
+    8000187a:	2785                	addiw	a5,a5,1 # fffffffffffff001 <end+0xffffffff7ffdb0f9>
+    8000187c:	00d7979b          	slliw	a5,a5,0xd
+    80001880:	40f987b3          	sub	a5,s3,a5
+    80001884:	e0bc                	sd	a5,64(s1)
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001886:	19048493          	addi	s1,s1,400
+    8000188a:	fd449de3          	bne	s1,s4,80001864 <procinit+0x78>
+  }
+}
+    8000188e:	70e2                	ld	ra,56(sp)
+    80001890:	7442                	ld	s0,48(sp)
+    80001892:	74a2                	ld	s1,40(sp)
+    80001894:	7902                	ld	s2,32(sp)
+    80001896:	69e2                	ld	s3,24(sp)
+    80001898:	6a42                	ld	s4,16(sp)
+    8000189a:	6aa2                	ld	s5,8(sp)
+    8000189c:	6b02                	ld	s6,0(sp)
+    8000189e:	6121                	addi	sp,sp,64
+    800018a0:	8082                	ret
+
+00000000800018a2 <cpuid>:
+// Must be called with interrupts disabled,
+// to prevent race with process being moved
+// to a different CPU.
+int
+cpuid()
+{
+    800018a2:	1141                	addi	sp,sp,-16
+    800018a4:	e422                	sd	s0,8(sp)
+    800018a6:	0800                	addi	s0,sp,16
+  asm volatile("mv %0, tp" : "=r" (x) );
+    800018a8:	8512                	mv	a0,tp
+  int id = r_tp();
+  return id;
+}
+    800018aa:	2501                	sext.w	a0,a0
+    800018ac:	6422                	ld	s0,8(sp)
+    800018ae:	0141                	addi	sp,sp,16
+    800018b0:	8082                	ret
+
+00000000800018b2 <mycpu>:
+
+// Return this CPU's cpu struct.
+// Interrupts must be disabled.
+struct cpu*
+mycpu(void)
+{
+    800018b2:	1141                	addi	sp,sp,-16
+    800018b4:	e422                	sd	s0,8(sp)
+    800018b6:	0800                	addi	s0,sp,16
+    800018b8:	8792                	mv	a5,tp
+  int id = cpuid();
+  struct cpu *c = &cpus[id];
+    800018ba:	2781                	sext.w	a5,a5
+    800018bc:	079e                	slli	a5,a5,0x7
+  return c;
+}
+    800018be:	00011517          	auipc	a0,0x11
+    800018c2:	a6a50513          	addi	a0,a0,-1430 # 80012328 <cpus>
+    800018c6:	953e                	add	a0,a0,a5
+    800018c8:	6422                	ld	s0,8(sp)
+    800018ca:	0141                	addi	sp,sp,16
+    800018cc:	8082                	ret
+
+00000000800018ce <myproc>:
+
+// Return the current struct proc *, or zero if none.
+struct proc*
+myproc(void)
+{
+    800018ce:	1101                	addi	sp,sp,-32
+    800018d0:	ec06                	sd	ra,24(sp)
+    800018d2:	e822                	sd	s0,16(sp)
+    800018d4:	e426                	sd	s1,8(sp)
+    800018d6:	1000                	addi	s0,sp,32
+  push_off();
+    800018d8:	ab6ff0ef          	jal	80000b8e <push_off>
+    800018dc:	8792                	mv	a5,tp
+  struct cpu *c = mycpu();
+  struct proc *p = c->proc;
+    800018de:	2781                	sext.w	a5,a5
+    800018e0:	079e                	slli	a5,a5,0x7
+    800018e2:	00011717          	auipc	a4,0x11
+    800018e6:	a1670713          	addi	a4,a4,-1514 # 800122f8 <pid_lock>
+    800018ea:	97ba                	add	a5,a5,a4
+    800018ec:	7b84                	ld	s1,48(a5)
+  pop_off();
+    800018ee:	b24ff0ef          	jal	80000c12 <pop_off>
+  return p;
+}
+    800018f2:	8526                	mv	a0,s1
+    800018f4:	60e2                	ld	ra,24(sp)
+    800018f6:	6442                	ld	s0,16(sp)
+    800018f8:	64a2                	ld	s1,8(sp)
+    800018fa:	6105                	addi	sp,sp,32
+    800018fc:	8082                	ret
+
+00000000800018fe <forkret>:
+
+// A fork child's very first scheduling by scheduler()
+// will swtch to forkret.
+void
+forkret(void)
+{
+    800018fe:	7179                	addi	sp,sp,-48
+    80001900:	f406                	sd	ra,40(sp)
+    80001902:	f022                	sd	s0,32(sp)
+    80001904:	ec26                	sd	s1,24(sp)
+    80001906:	1800                	addi	s0,sp,48
+  extern char userret[];
+  static int first = 1;
+  struct proc *p = myproc();
+    80001908:	fc7ff0ef          	jal	800018ce <myproc>
+    8000190c:	84aa                	mv	s1,a0
+
+  // Still holding p->lock from scheduler.
+  release(&p->lock);
+    8000190e:	b58ff0ef          	jal	80000c66 <release>
+
+  if (first) {
+    80001912:	00009797          	auipc	a5,0x9
+    80001916:	87e7a783          	lw	a5,-1922(a5) # 8000a190 <first.1>
+    8000191a:	cf8d                	beqz	a5,80001954 <forkret+0x56>
+    // File system initialization must be run in the context of a
+    // regular process (e.g., because it calls sleep), and thus cannot
+    // be run from main().
+    fsinit(ROOTDEV);
+    8000191c:	4505                	li	a0,1
+    8000191e:	3d7010ef          	jal	800034f4 <fsinit>
+
+    first = 0;
+    80001922:	00009797          	auipc	a5,0x9
+    80001926:	8607a723          	sw	zero,-1938(a5) # 8000a190 <first.1>
+    // ensure other cores see first=0.
+    __sync_synchronize();
+    8000192a:	0330000f          	fence	rw,rw
+
+    // We can invoke kexec() now that file system is initialized.
+    // Put the return value (argc) of kexec into a0.
+    p->trapframe->a0 = kexec("/init", (char *[]){ "/init", 0 });
+    8000192e:	00006517          	auipc	a0,0x6
+    80001932:	85250513          	addi	a0,a0,-1966 # 80007180 <etext+0x180>
+    80001936:	fca43823          	sd	a0,-48(s0)
+    8000193a:	fc043c23          	sd	zero,-40(s0)
+    8000193e:	fd040593          	addi	a1,s0,-48
+    80001942:	4b3020ef          	jal	800045f4 <kexec>
+    80001946:	6cbc                	ld	a5,88(s1)
+    80001948:	fba8                	sd	a0,112(a5)
+    if (p->trapframe->a0 == -1) {
+    8000194a:	6cbc                	ld	a5,88(s1)
+    8000194c:	7bb8                	ld	a4,112(a5)
+    8000194e:	57fd                	li	a5,-1
+    80001950:	02f70d63          	beq	a4,a5,8000198a <forkret+0x8c>
+      panic("exec");
+    }
+  }
+
+  // return to user space, mimicing usertrap()'s return.
+  prepare_return();
+    80001954:	2ed000ef          	jal	80002440 <prepare_return>
+  uint64 satp = MAKE_SATP(p->pagetable);
+    80001958:	68a8                	ld	a0,80(s1)
+    8000195a:	8131                	srli	a0,a0,0xc
+  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
+    8000195c:	04000737          	lui	a4,0x4000
+    80001960:	177d                	addi	a4,a4,-1 # 3ffffff <_entry-0x7c000001>
+    80001962:	0732                	slli	a4,a4,0xc
+    80001964:	00004797          	auipc	a5,0x4
+    80001968:	73878793          	addi	a5,a5,1848 # 8000609c <userret>
+    8000196c:	00004697          	auipc	a3,0x4
+    80001970:	69468693          	addi	a3,a3,1684 # 80006000 <_trampoline>
+    80001974:	8f95                	sub	a5,a5,a3
+    80001976:	97ba                	add	a5,a5,a4
+  ((void (*)(uint64))trampoline_userret)(satp);
+    80001978:	577d                	li	a4,-1
+    8000197a:	177e                	slli	a4,a4,0x3f
+    8000197c:	8d59                	or	a0,a0,a4
+    8000197e:	9782                	jalr	a5
+}
+    80001980:	70a2                	ld	ra,40(sp)
+    80001982:	7402                	ld	s0,32(sp)
+    80001984:	64e2                	ld	s1,24(sp)
+    80001986:	6145                	addi	sp,sp,48
+    80001988:	8082                	ret
+      panic("exec");
+    8000198a:	00005517          	auipc	a0,0x5
+    8000198e:	7fe50513          	addi	a0,a0,2046 # 80007188 <etext+0x188>
+    80001992:	e4ffe0ef          	jal	800007e0 <panic>
+
+0000000080001996 <allocpid>:
+{
+    80001996:	1101                	addi	sp,sp,-32
+    80001998:	ec06                	sd	ra,24(sp)
+    8000199a:	e822                	sd	s0,16(sp)
+    8000199c:	e426                	sd	s1,8(sp)
+    8000199e:	e04a                	sd	s2,0(sp)
+    800019a0:	1000                	addi	s0,sp,32
+  acquire(&pid_lock);
+    800019a2:	00011917          	auipc	s2,0x11
+    800019a6:	95690913          	addi	s2,s2,-1706 # 800122f8 <pid_lock>
+    800019aa:	854a                	mv	a0,s2
+    800019ac:	a22ff0ef          	jal	80000bce <acquire>
+  pid = nextpid;
+    800019b0:	00008797          	auipc	a5,0x8
+    800019b4:	7e478793          	addi	a5,a5,2020 # 8000a194 <nextpid>
+    800019b8:	4384                	lw	s1,0(a5)
+  nextpid = nextpid + 1;
+    800019ba:	0014871b          	addiw	a4,s1,1
+    800019be:	c398                	sw	a4,0(a5)
+  release(&pid_lock);
+    800019c0:	854a                	mv	a0,s2
+    800019c2:	aa4ff0ef          	jal	80000c66 <release>
+}
+    800019c6:	8526                	mv	a0,s1
+    800019c8:	60e2                	ld	ra,24(sp)
+    800019ca:	6442                	ld	s0,16(sp)
+    800019cc:	64a2                	ld	s1,8(sp)
+    800019ce:	6902                	ld	s2,0(sp)
+    800019d0:	6105                	addi	sp,sp,32
+    800019d2:	8082                	ret
+
+00000000800019d4 <proc_pagetable>:
+{
+    800019d4:	1101                	addi	sp,sp,-32
+    800019d6:	ec06                	sd	ra,24(sp)
+    800019d8:	e822                	sd	s0,16(sp)
+    800019da:	e426                	sd	s1,8(sp)
+    800019dc:	e04a                	sd	s2,0(sp)
+    800019de:	1000                	addi	s0,sp,32
+    800019e0:	892a                	mv	s2,a0
+  pagetable = uvmcreate();
+    800019e2:	fb2ff0ef          	jal	80001194 <uvmcreate>
+    800019e6:	84aa                	mv	s1,a0
+  if(pagetable == 0)
+    800019e8:	cd05                	beqz	a0,80001a20 <proc_pagetable+0x4c>
+  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
+    800019ea:	4729                	li	a4,10
+    800019ec:	00004697          	auipc	a3,0x4
+    800019f0:	61468693          	addi	a3,a3,1556 # 80006000 <_trampoline>
+    800019f4:	6605                	lui	a2,0x1
+    800019f6:	040005b7          	lui	a1,0x4000
+    800019fa:	15fd                	addi	a1,a1,-1 # 3ffffff <_entry-0x7c000001>
+    800019fc:	05b2                	slli	a1,a1,0xc
+    800019fe:	df0ff0ef          	jal	80000fee <mappages>
+    80001a02:	02054663          	bltz	a0,80001a2e <proc_pagetable+0x5a>
+  if(mappages(pagetable, TRAPFRAME, PGSIZE,
+    80001a06:	4719                	li	a4,6
+    80001a08:	05893683          	ld	a3,88(s2)
+    80001a0c:	6605                	lui	a2,0x1
+    80001a0e:	020005b7          	lui	a1,0x2000
+    80001a12:	15fd                	addi	a1,a1,-1 # 1ffffff <_entry-0x7e000001>
+    80001a14:	05b6                	slli	a1,a1,0xd
+    80001a16:	8526                	mv	a0,s1
+    80001a18:	dd6ff0ef          	jal	80000fee <mappages>
+    80001a1c:	00054f63          	bltz	a0,80001a3a <proc_pagetable+0x66>
+}
+    80001a20:	8526                	mv	a0,s1
+    80001a22:	60e2                	ld	ra,24(sp)
+    80001a24:	6442                	ld	s0,16(sp)
+    80001a26:	64a2                	ld	s1,8(sp)
+    80001a28:	6902                	ld	s2,0(sp)
+    80001a2a:	6105                	addi	sp,sp,32
+    80001a2c:	8082                	ret
+    uvmfree(pagetable, 0);
+    80001a2e:	4581                	li	a1,0
+    80001a30:	8526                	mv	a0,s1
+    80001a32:	95dff0ef          	jal	8000138e <uvmfree>
+    return 0;
+    80001a36:	4481                	li	s1,0
+    80001a38:	b7e5                	j	80001a20 <proc_pagetable+0x4c>
+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    80001a3a:	4681                	li	a3,0
+    80001a3c:	4605                	li	a2,1
+    80001a3e:	040005b7          	lui	a1,0x4000
+    80001a42:	15fd                	addi	a1,a1,-1 # 3ffffff <_entry-0x7c000001>
+    80001a44:	05b2                	slli	a1,a1,0xc
+    80001a46:	8526                	mv	a0,s1
+    80001a48:	f72ff0ef          	jal	800011ba <uvmunmap>
+    uvmfree(pagetable, 0);
+    80001a4c:	4581                	li	a1,0
+    80001a4e:	8526                	mv	a0,s1
+    80001a50:	93fff0ef          	jal	8000138e <uvmfree>
+    return 0;
+    80001a54:	4481                	li	s1,0
+    80001a56:	b7e9                	j	80001a20 <proc_pagetable+0x4c>
+
+0000000080001a58 <proc_freepagetable>:
+{
+    80001a58:	1101                	addi	sp,sp,-32
+    80001a5a:	ec06                	sd	ra,24(sp)
+    80001a5c:	e822                	sd	s0,16(sp)
+    80001a5e:	e426                	sd	s1,8(sp)
+    80001a60:	e04a                	sd	s2,0(sp)
+    80001a62:	1000                	addi	s0,sp,32
+    80001a64:	84aa                	mv	s1,a0
+    80001a66:	892e                	mv	s2,a1
+  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    80001a68:	4681                	li	a3,0
+    80001a6a:	4605                	li	a2,1
+    80001a6c:	040005b7          	lui	a1,0x4000
+    80001a70:	15fd                	addi	a1,a1,-1 # 3ffffff <_entry-0x7c000001>
+    80001a72:	05b2                	slli	a1,a1,0xc
+    80001a74:	f46ff0ef          	jal	800011ba <uvmunmap>
+  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+    80001a78:	4681                	li	a3,0
+    80001a7a:	4605                	li	a2,1
+    80001a7c:	020005b7          	lui	a1,0x2000
+    80001a80:	15fd                	addi	a1,a1,-1 # 1ffffff <_entry-0x7e000001>
+    80001a82:	05b6                	slli	a1,a1,0xd
+    80001a84:	8526                	mv	a0,s1
+    80001a86:	f34ff0ef          	jal	800011ba <uvmunmap>
+  uvmfree(pagetable, sz);
+    80001a8a:	85ca                	mv	a1,s2
+    80001a8c:	8526                	mv	a0,s1
+    80001a8e:	901ff0ef          	jal	8000138e <uvmfree>
+}
+    80001a92:	60e2                	ld	ra,24(sp)
+    80001a94:	6442                	ld	s0,16(sp)
+    80001a96:	64a2                	ld	s1,8(sp)
+    80001a98:	6902                	ld	s2,0(sp)
+    80001a9a:	6105                	addi	sp,sp,32
+    80001a9c:	8082                	ret
+
+0000000080001a9e <freeproc>:
+{
+    80001a9e:	1101                	addi	sp,sp,-32
+    80001aa0:	ec06                	sd	ra,24(sp)
+    80001aa2:	e822                	sd	s0,16(sp)
+    80001aa4:	e426                	sd	s1,8(sp)
+    80001aa6:	1000                	addi	s0,sp,32
+    80001aa8:	84aa                	mv	s1,a0
+  if(p->trapframe)
+    80001aaa:	6d28                	ld	a0,88(a0)
+    80001aac:	c119                	beqz	a0,80001ab2 <freeproc+0x14>
+    kfree((void*)p->trapframe);
+    80001aae:	f6ffe0ef          	jal	80000a1c <kfree>
+  p->trapframe = 0;
+    80001ab2:	0404bc23          	sd	zero,88(s1)
+  if(p->pagetable)
+    80001ab6:	68a8                	ld	a0,80(s1)
+    80001ab8:	c501                	beqz	a0,80001ac0 <freeproc+0x22>
+    proc_freepagetable(p->pagetable, p->sz);
+    80001aba:	64ac                	ld	a1,72(s1)
+    80001abc:	f9dff0ef          	jal	80001a58 <proc_freepagetable>
+  p->pagetable = 0;
+    80001ac0:	0404b823          	sd	zero,80(s1)
+  p->sz = 0;
+    80001ac4:	0404b423          	sd	zero,72(s1)
+  p->pid = 0;
+    80001ac8:	0204a823          	sw	zero,48(s1)
+  p->parent = 0;
+    80001acc:	0204bc23          	sd	zero,56(s1)
+  p->name[0] = 0;
+    80001ad0:	14048c23          	sb	zero,344(s1)
+  p->chan = 0;
+    80001ad4:	0204b023          	sd	zero,32(s1)
+  p->killed = 0;
+    80001ad8:	0204a423          	sw	zero,40(s1)
+  p->xstate = 0;
+    80001adc:	0204a623          	sw	zero,44(s1)
+  p->state = UNUSED;
+    80001ae0:	0004ac23          	sw	zero,24(s1)
+}
+    80001ae4:	60e2                	ld	ra,24(sp)
+    80001ae6:	6442                	ld	s0,16(sp)
+    80001ae8:	64a2                	ld	s1,8(sp)
+    80001aea:	6105                	addi	sp,sp,32
+    80001aec:	8082                	ret
+
+0000000080001aee <allocproc>:
+{
+    80001aee:	1101                	addi	sp,sp,-32
+    80001af0:	ec06                	sd	ra,24(sp)
+    80001af2:	e822                	sd	s0,16(sp)
+    80001af4:	e426                	sd	s1,8(sp)
+    80001af6:	e04a                	sd	s2,0(sp)
+    80001af8:	1000                	addi	s0,sp,32
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001afa:	00011497          	auipc	s1,0x11
+    80001afe:	c2e48493          	addi	s1,s1,-978 # 80012728 <proc>
+    80001b02:	00017917          	auipc	s2,0x17
+    80001b06:	02690913          	addi	s2,s2,38 # 80018b28 <tickslock>
+    acquire(&p->lock);
+    80001b0a:	8526                	mv	a0,s1
+    80001b0c:	8c2ff0ef          	jal	80000bce <acquire>
+    if(p->state == UNUSED) {
+    80001b10:	4c9c                	lw	a5,24(s1)
+    80001b12:	cb91                	beqz	a5,80001b26 <allocproc+0x38>
+      release(&p->lock);
+    80001b14:	8526                	mv	a0,s1
+    80001b16:	950ff0ef          	jal	80000c66 <release>
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001b1a:	19048493          	addi	s1,s1,400
+    80001b1e:	ff2496e3          	bne	s1,s2,80001b0a <allocproc+0x1c>
+  return 0;
+    80001b22:	4481                	li	s1,0
+    80001b24:	a09d                	j	80001b8a <allocproc+0x9c>
+  p->pid = allocpid();
+    80001b26:	e71ff0ef          	jal	80001996 <allocpid>
+    80001b2a:	d888                	sw	a0,48(s1)
+  p->state = USED;
+    80001b2c:	4785                	li	a5,1
+    80001b2e:	cc9c                	sw	a5,24(s1)
+  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+    80001b30:	fcffe0ef          	jal	80000afe <kalloc>
+    80001b34:	892a                	mv	s2,a0
+    80001b36:	eca8                	sd	a0,88(s1)
+    80001b38:	c125                	beqz	a0,80001b98 <allocproc+0xaa>
+  p->pagetable = proc_pagetable(p);
+    80001b3a:	8526                	mv	a0,s1
+    80001b3c:	e99ff0ef          	jal	800019d4 <proc_pagetable>
+    80001b40:	892a                	mv	s2,a0
+    80001b42:	e8a8                	sd	a0,80(s1)
+  if(p->pagetable == 0){
+    80001b44:	c135                	beqz	a0,80001ba8 <allocproc+0xba>
+  memset(&p->context, 0, sizeof(p->context));
+    80001b46:	07000613          	li	a2,112
+    80001b4a:	4581                	li	a1,0
+    80001b4c:	06048513          	addi	a0,s1,96
+    80001b50:	952ff0ef          	jal	80000ca2 <memset>
+  p->context.ra = (uint64)forkret;
+    80001b54:	00000797          	auipc	a5,0x0
+    80001b58:	daa78793          	addi	a5,a5,-598 # 800018fe <forkret>
+    80001b5c:	f0bc                	sd	a5,96(s1)
+  p->context.sp = p->kstack + PGSIZE;
+    80001b5e:	60bc                	ld	a5,64(s1)
+    80001b60:	6705                	lui	a4,0x1
+    80001b62:	97ba                	add	a5,a5,a4
+    80001b64:	f4bc                	sd	a5,104(s1)
+         p->creation_time = ticks;  // Set creation time
+    80001b66:	00008797          	auipc	a5,0x8
+    80001b6a:	6827a783          	lw	a5,1666(a5) # 8000a1e8 <ticks>
+    80001b6e:	16f4a423          	sw	a5,360(s1)
+         p->nice = 0;               // Default nice value
+    80001b72:	1604a623          	sw	zero,364(s1)
+         p->vruntime = 0;           // Initialize virtual runtime
+    80001b76:	1604b823          	sd	zero,368(s1)
+         p->weight = 1024;          // Default weight for non-CFS
+    80001b7a:	40000793          	li	a5,1024
+    80001b7e:	16f4bc23          	sd	a5,376(s1)
+  p->time_slice = 0;
+    80001b82:	1804b023          	sd	zero,384(s1)
+  p->slice_start = 0;
+    80001b86:	1804b423          	sd	zero,392(s1)
+}
+    80001b8a:	8526                	mv	a0,s1
+    80001b8c:	60e2                	ld	ra,24(sp)
+    80001b8e:	6442                	ld	s0,16(sp)
+    80001b90:	64a2                	ld	s1,8(sp)
+    80001b92:	6902                	ld	s2,0(sp)
+    80001b94:	6105                	addi	sp,sp,32
+    80001b96:	8082                	ret
+    freeproc(p);
+    80001b98:	8526                	mv	a0,s1
+    80001b9a:	f05ff0ef          	jal	80001a9e <freeproc>
+    release(&p->lock);
+    80001b9e:	8526                	mv	a0,s1
+    80001ba0:	8c6ff0ef          	jal	80000c66 <release>
+    return 0;
+    80001ba4:	84ca                	mv	s1,s2
+    80001ba6:	b7d5                	j	80001b8a <allocproc+0x9c>
+    freeproc(p);
+    80001ba8:	8526                	mv	a0,s1
+    80001baa:	ef5ff0ef          	jal	80001a9e <freeproc>
+    release(&p->lock);
+    80001bae:	8526                	mv	a0,s1
+    80001bb0:	8b6ff0ef          	jal	80000c66 <release>
+    return 0;
+    80001bb4:	84ca                	mv	s1,s2
+    80001bb6:	bfd1                	j	80001b8a <allocproc+0x9c>
+
+0000000080001bb8 <userinit>:
+{
+    80001bb8:	1101                	addi	sp,sp,-32
+    80001bba:	ec06                	sd	ra,24(sp)
+    80001bbc:	e822                	sd	s0,16(sp)
+    80001bbe:	e426                	sd	s1,8(sp)
+    80001bc0:	1000                	addi	s0,sp,32
+  p = allocproc();
+    80001bc2:	f2dff0ef          	jal	80001aee <allocproc>
+    80001bc6:	84aa                	mv	s1,a0
+  initproc = p;
+    80001bc8:	00008797          	auipc	a5,0x8
+    80001bcc:	60a7bc23          	sd	a0,1560(a5) # 8000a1e0 <initproc>
+  p->cwd = namei("/");
+    80001bd0:	00005517          	auipc	a0,0x5
+    80001bd4:	5c050513          	addi	a0,a0,1472 # 80007190 <etext+0x190>
+    80001bd8:	63f010ef          	jal	80003a16 <namei>
+    80001bdc:	14a4b823          	sd	a0,336(s1)
+  p->state = RUNNABLE;
+    80001be0:	478d                	li	a5,3
+    80001be2:	cc9c                	sw	a5,24(s1)
+  release(&p->lock);
+    80001be4:	8526                	mv	a0,s1
+    80001be6:	880ff0ef          	jal	80000c66 <release>
+}
+    80001bea:	60e2                	ld	ra,24(sp)
+    80001bec:	6442                	ld	s0,16(sp)
+    80001bee:	64a2                	ld	s1,8(sp)
+    80001bf0:	6105                	addi	sp,sp,32
+    80001bf2:	8082                	ret
+
+0000000080001bf4 <growproc>:
+{
+    80001bf4:	1101                	addi	sp,sp,-32
+    80001bf6:	ec06                	sd	ra,24(sp)
+    80001bf8:	e822                	sd	s0,16(sp)
+    80001bfa:	e426                	sd	s1,8(sp)
+    80001bfc:	e04a                	sd	s2,0(sp)
+    80001bfe:	1000                	addi	s0,sp,32
+    80001c00:	892a                	mv	s2,a0
+  struct proc *p = myproc();
+    80001c02:	ccdff0ef          	jal	800018ce <myproc>
+    80001c06:	84aa                	mv	s1,a0
+  sz = p->sz;
+    80001c08:	652c                	ld	a1,72(a0)
+  if(n > 0){
+    80001c0a:	01204c63          	bgtz	s2,80001c22 <growproc+0x2e>
+  } else if(n < 0){
+    80001c0e:	02094463          	bltz	s2,80001c36 <growproc+0x42>
+  p->sz = sz;
+    80001c12:	e4ac                	sd	a1,72(s1)
+  return 0;
+    80001c14:	4501                	li	a0,0
+}
+    80001c16:	60e2                	ld	ra,24(sp)
+    80001c18:	6442                	ld	s0,16(sp)
+    80001c1a:	64a2                	ld	s1,8(sp)
+    80001c1c:	6902                	ld	s2,0(sp)
+    80001c1e:	6105                	addi	sp,sp,32
+    80001c20:	8082                	ret
+    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+    80001c22:	4691                	li	a3,4
+    80001c24:	00b90633          	add	a2,s2,a1
+    80001c28:	6928                	ld	a0,80(a0)
+    80001c2a:	e5eff0ef          	jal	80001288 <uvmalloc>
+    80001c2e:	85aa                	mv	a1,a0
+    80001c30:	f16d                	bnez	a0,80001c12 <growproc+0x1e>
+      return -1;
+    80001c32:	557d                	li	a0,-1
+    80001c34:	b7cd                	j	80001c16 <growproc+0x22>
+    sz = uvmdealloc(p->pagetable, sz, sz + n);
+    80001c36:	00b90633          	add	a2,s2,a1
+    80001c3a:	6928                	ld	a0,80(a0)
+    80001c3c:	e08ff0ef          	jal	80001244 <uvmdealloc>
+    80001c40:	85aa                	mv	a1,a0
+    80001c42:	bfc1                	j	80001c12 <growproc+0x1e>
+
+0000000080001c44 <kfork>:
+{
+    80001c44:	7139                	addi	sp,sp,-64
+    80001c46:	fc06                	sd	ra,56(sp)
+    80001c48:	f822                	sd	s0,48(sp)
+    80001c4a:	f04a                	sd	s2,32(sp)
+    80001c4c:	e456                	sd	s5,8(sp)
+    80001c4e:	0080                	addi	s0,sp,64
+  struct proc *p = myproc();
+    80001c50:	c7fff0ef          	jal	800018ce <myproc>
+    80001c54:	8aaa                	mv	s5,a0
+  if((np = allocproc()) == 0){
+    80001c56:	e99ff0ef          	jal	80001aee <allocproc>
+    80001c5a:	0e050a63          	beqz	a0,80001d4e <kfork+0x10a>
+    80001c5e:	e852                	sd	s4,16(sp)
+    80001c60:	8a2a                	mv	s4,a0
+  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+    80001c62:	048ab603          	ld	a2,72(s5)
+    80001c66:	692c                	ld	a1,80(a0)
+    80001c68:	050ab503          	ld	a0,80(s5)
+    80001c6c:	f54ff0ef          	jal	800013c0 <uvmcopy>
+    80001c70:	04054a63          	bltz	a0,80001cc4 <kfork+0x80>
+    80001c74:	f426                	sd	s1,40(sp)
+    80001c76:	ec4e                	sd	s3,24(sp)
+  np->sz = p->sz;
+    80001c78:	048ab783          	ld	a5,72(s5)
+    80001c7c:	04fa3423          	sd	a5,72(s4)
+  *(np->trapframe) = *(p->trapframe);
+    80001c80:	058ab683          	ld	a3,88(s5)
+    80001c84:	87b6                	mv	a5,a3
+    80001c86:	058a3703          	ld	a4,88(s4)
+    80001c8a:	12068693          	addi	a3,a3,288
+    80001c8e:	0007b803          	ld	a6,0(a5)
+    80001c92:	6788                	ld	a0,8(a5)
+    80001c94:	6b8c                	ld	a1,16(a5)
+    80001c96:	6f90                	ld	a2,24(a5)
+    80001c98:	01073023          	sd	a6,0(a4) # 1000 <_entry-0x7ffff000>
+    80001c9c:	e708                	sd	a0,8(a4)
+    80001c9e:	eb0c                	sd	a1,16(a4)
+    80001ca0:	ef10                	sd	a2,24(a4)
+    80001ca2:	02078793          	addi	a5,a5,32
+    80001ca6:	02070713          	addi	a4,a4,32
+    80001caa:	fed792e3          	bne	a5,a3,80001c8e <kfork+0x4a>
+  np->trapframe->a0 = 0;
+    80001cae:	058a3783          	ld	a5,88(s4)
+    80001cb2:	0607b823          	sd	zero,112(a5)
+  for(i = 0; i < NOFILE; i++)
+    80001cb6:	0d0a8493          	addi	s1,s5,208
+    80001cba:	0d0a0913          	addi	s2,s4,208
+    80001cbe:	150a8993          	addi	s3,s5,336
+    80001cc2:	a831                	j	80001cde <kfork+0x9a>
+    freeproc(np);
+    80001cc4:	8552                	mv	a0,s4
+    80001cc6:	dd9ff0ef          	jal	80001a9e <freeproc>
+    release(&np->lock);
+    80001cca:	8552                	mv	a0,s4
+    80001ccc:	f9bfe0ef          	jal	80000c66 <release>
+    return -1;
+    80001cd0:	597d                	li	s2,-1
+    80001cd2:	6a42                	ld	s4,16(sp)
+    80001cd4:	a0b5                	j	80001d40 <kfork+0xfc>
+  for(i = 0; i < NOFILE; i++)
+    80001cd6:	04a1                	addi	s1,s1,8
+    80001cd8:	0921                	addi	s2,s2,8
+    80001cda:	01348963          	beq	s1,s3,80001cec <kfork+0xa8>
+    if(p->ofile[i])
+    80001cde:	6088                	ld	a0,0(s1)
+    80001ce0:	d97d                	beqz	a0,80001cd6 <kfork+0x92>
+      np->ofile[i] = filedup(p->ofile[i]);
+    80001ce2:	2ce020ef          	jal	80003fb0 <filedup>
+    80001ce6:	00a93023          	sd	a0,0(s2)
+    80001cea:	b7f5                	j	80001cd6 <kfork+0x92>
+  np->cwd = idup(p->cwd);
+    80001cec:	150ab503          	ld	a0,336(s5)
+    80001cf0:	4da010ef          	jal	800031ca <idup>
+    80001cf4:	14aa3823          	sd	a0,336(s4)
+  safestrcpy(np->name, p->name, sizeof(p->name));
+    80001cf8:	4641                	li	a2,16
+    80001cfa:	158a8593          	addi	a1,s5,344
+    80001cfe:	158a0513          	addi	a0,s4,344
+    80001d02:	8deff0ef          	jal	80000de0 <safestrcpy>
+  pid = np->pid;
+    80001d06:	030a2903          	lw	s2,48(s4)
+  release(&np->lock);
+    80001d0a:	8552                	mv	a0,s4
+    80001d0c:	f5bfe0ef          	jal	80000c66 <release>
+  acquire(&wait_lock);
+    80001d10:	00010497          	auipc	s1,0x10
+    80001d14:	60048493          	addi	s1,s1,1536 # 80012310 <wait_lock>
+    80001d18:	8526                	mv	a0,s1
+    80001d1a:	eb5fe0ef          	jal	80000bce <acquire>
+  np->parent = p;
+    80001d1e:	035a3c23          	sd	s5,56(s4)
+  release(&wait_lock);
+    80001d22:	8526                	mv	a0,s1
+    80001d24:	f43fe0ef          	jal	80000c66 <release>
+  acquire(&np->lock);
+    80001d28:	8552                	mv	a0,s4
+    80001d2a:	ea5fe0ef          	jal	80000bce <acquire>
+  np->state = RUNNABLE;
+    80001d2e:	478d                	li	a5,3
+    80001d30:	00fa2c23          	sw	a5,24(s4)
+  release(&np->lock);
+    80001d34:	8552                	mv	a0,s4
+    80001d36:	f31fe0ef          	jal	80000c66 <release>
+  return pid;
+    80001d3a:	74a2                	ld	s1,40(sp)
+    80001d3c:	69e2                	ld	s3,24(sp)
+    80001d3e:	6a42                	ld	s4,16(sp)
+}
+    80001d40:	854a                	mv	a0,s2
+    80001d42:	70e2                	ld	ra,56(sp)
+    80001d44:	7442                	ld	s0,48(sp)
+    80001d46:	7902                	ld	s2,32(sp)
+    80001d48:	6aa2                	ld	s5,8(sp)
+    80001d4a:	6121                	addi	sp,sp,64
+    80001d4c:	8082                	ret
+    return -1;
+    80001d4e:	597d                	li	s2,-1
+    80001d50:	bfc5                	j	80001d40 <kfork+0xfc>
+
+0000000080001d52 <scheduler>:
+{
+    80001d52:	7139                	addi	sp,sp,-64
+    80001d54:	fc06                	sd	ra,56(sp)
+    80001d56:	f822                	sd	s0,48(sp)
+    80001d58:	f426                	sd	s1,40(sp)
+    80001d5a:	f04a                	sd	s2,32(sp)
+    80001d5c:	ec4e                	sd	s3,24(sp)
+    80001d5e:	e852                	sd	s4,16(sp)
+    80001d60:	e456                	sd	s5,8(sp)
+    80001d62:	e05a                	sd	s6,0(sp)
+    80001d64:	0080                	addi	s0,sp,64
+    80001d66:	8792                	mv	a5,tp
+  int id = r_tp();
+    80001d68:	2781                	sext.w	a5,a5
+  c->proc = 0;
+    80001d6a:	00779a93          	slli	s5,a5,0x7
+    80001d6e:	00010717          	auipc	a4,0x10
+    80001d72:	58a70713          	addi	a4,a4,1418 # 800122f8 <pid_lock>
+    80001d76:	9756                	add	a4,a4,s5
+    80001d78:	02073823          	sd	zero,48(a4)
+                  swtch(&c->context, &p->context);
+    80001d7c:	00010717          	auipc	a4,0x10
+    80001d80:	5b470713          	addi	a4,a4,1460 # 80012330 <cpus+0x8>
+    80001d84:	9aba                	add	s5,s5,a4
+              if (p->state == RUNNABLE) {
+    80001d86:	490d                	li	s2,3
+          for (p = proc; p < &proc[NPROC]; p++) {
+    80001d88:	00017997          	auipc	s3,0x17
+    80001d8c:	da098993          	addi	s3,s3,-608 # 80018b28 <tickslock>
+                  p->state = RUNNING;
+    80001d90:	4b11                	li	s6,4
+                  c->proc = p;
+    80001d92:	079e                	slli	a5,a5,0x7
+    80001d94:	00010a17          	auipc	s4,0x10
+    80001d98:	564a0a13          	addi	s4,s4,1380 # 800122f8 <pid_lock>
+    80001d9c:	9a3e                	add	s4,s4,a5
+    80001d9e:	a839                	j	80001dbc <scheduler+0x6a>
+                  p->state = RUNNING;
+    80001da0:	0164ac23          	sw	s6,24(s1)
+                  c->proc = p;
+    80001da4:	029a3823          	sd	s1,48(s4)
+                  swtch(&c->context, &p->context);
+    80001da8:	06048593          	addi	a1,s1,96
+    80001dac:	8556                	mv	a0,s5
+    80001dae:	5ec000ef          	jal	8000239a <swtch>
+                  c->proc = 0;
+    80001db2:	020a3823          	sd	zero,48(s4)
+                  release(&p->lock);
+    80001db6:	8526                	mv	a0,s1
+    80001db8:	eaffe0ef          	jal	80000c66 <release>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80001dbc:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() | SSTATUS_SIE);
+    80001dc0:	0027e793          	ori	a5,a5,2
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80001dc4:	10079073          	csrw	sstatus,a5
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80001dc8:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+    80001dcc:	9bf5                	andi	a5,a5,-3
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80001dce:	10079073          	csrw	sstatus,a5
+          for (p = proc; p < &proc[NPROC]; p++) {
+    80001dd2:	00011497          	auipc	s1,0x11
+    80001dd6:	95648493          	addi	s1,s1,-1706 # 80012728 <proc>
+              acquire(&p->lock);
+    80001dda:	8526                	mv	a0,s1
+    80001ddc:	df3fe0ef          	jal	80000bce <acquire>
+              if (p->state == RUNNABLE) {
+    80001de0:	4c9c                	lw	a5,24(s1)
+    80001de2:	fb278fe3          	beq	a5,s2,80001da0 <scheduler+0x4e>
+              release(&p->lock);
+    80001de6:	8526                	mv	a0,s1
+    80001de8:	e7ffe0ef          	jal	80000c66 <release>
+          for (p = proc; p < &proc[NPROC]; p++) {
+    80001dec:	19048493          	addi	s1,s1,400
+    80001df0:	ff3495e3          	bne	s1,s3,80001dda <scheduler+0x88>
+    80001df4:	b7e1                	j	80001dbc <scheduler+0x6a>
+
+0000000080001df6 <sched>:
+{
+    80001df6:	7179                	addi	sp,sp,-48
+    80001df8:	f406                	sd	ra,40(sp)
+    80001dfa:	f022                	sd	s0,32(sp)
+    80001dfc:	ec26                	sd	s1,24(sp)
+    80001dfe:	e84a                	sd	s2,16(sp)
+    80001e00:	e44e                	sd	s3,8(sp)
+    80001e02:	1800                	addi	s0,sp,48
+  struct proc *p = myproc();
+    80001e04:	acbff0ef          	jal	800018ce <myproc>
+    80001e08:	84aa                	mv	s1,a0
+  if(!holding(&p->lock))
+    80001e0a:	d5bfe0ef          	jal	80000b64 <holding>
+    80001e0e:	c92d                	beqz	a0,80001e80 <sched+0x8a>
+  asm volatile("mv %0, tp" : "=r" (x) );
+    80001e10:	8792                	mv	a5,tp
+  if(mycpu()->noff != 1)
+    80001e12:	2781                	sext.w	a5,a5
+    80001e14:	079e                	slli	a5,a5,0x7
+    80001e16:	00010717          	auipc	a4,0x10
+    80001e1a:	4e270713          	addi	a4,a4,1250 # 800122f8 <pid_lock>
+    80001e1e:	97ba                	add	a5,a5,a4
+    80001e20:	0a87a703          	lw	a4,168(a5)
+    80001e24:	4785                	li	a5,1
+    80001e26:	06f71363          	bne	a4,a5,80001e8c <sched+0x96>
+  if(p->state == RUNNING)
+    80001e2a:	4c98                	lw	a4,24(s1)
+    80001e2c:	4791                	li	a5,4
+    80001e2e:	06f70563          	beq	a4,a5,80001e98 <sched+0xa2>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80001e32:	100027f3          	csrr	a5,sstatus
+  return (x & SSTATUS_SIE) != 0;
+    80001e36:	8b89                	andi	a5,a5,2
+  if(intr_get())
+    80001e38:	e7b5                	bnez	a5,80001ea4 <sched+0xae>
+  asm volatile("mv %0, tp" : "=r" (x) );
+    80001e3a:	8792                	mv	a5,tp
+  intena = mycpu()->intena;
+    80001e3c:	00010917          	auipc	s2,0x10
+    80001e40:	4bc90913          	addi	s2,s2,1212 # 800122f8 <pid_lock>
+    80001e44:	2781                	sext.w	a5,a5
+    80001e46:	079e                	slli	a5,a5,0x7
+    80001e48:	97ca                	add	a5,a5,s2
+    80001e4a:	0ac7a983          	lw	s3,172(a5)
+    80001e4e:	8792                	mv	a5,tp
+  swtch(&p->context, &mycpu()->context);
+    80001e50:	2781                	sext.w	a5,a5
+    80001e52:	079e                	slli	a5,a5,0x7
+    80001e54:	00010597          	auipc	a1,0x10
+    80001e58:	4dc58593          	addi	a1,a1,1244 # 80012330 <cpus+0x8>
+    80001e5c:	95be                	add	a1,a1,a5
+    80001e5e:	06048513          	addi	a0,s1,96
+    80001e62:	538000ef          	jal	8000239a <swtch>
+    80001e66:	8792                	mv	a5,tp
+  mycpu()->intena = intena;
+    80001e68:	2781                	sext.w	a5,a5
+    80001e6a:	079e                	slli	a5,a5,0x7
+    80001e6c:	993e                	add	s2,s2,a5
+    80001e6e:	0b392623          	sw	s3,172(s2)
+}
+    80001e72:	70a2                	ld	ra,40(sp)
+    80001e74:	7402                	ld	s0,32(sp)
+    80001e76:	64e2                	ld	s1,24(sp)
+    80001e78:	6942                	ld	s2,16(sp)
+    80001e7a:	69a2                	ld	s3,8(sp)
+    80001e7c:	6145                	addi	sp,sp,48
+    80001e7e:	8082                	ret
+    panic("sched p->lock");
+    80001e80:	00005517          	auipc	a0,0x5
+    80001e84:	31850513          	addi	a0,a0,792 # 80007198 <etext+0x198>
+    80001e88:	959fe0ef          	jal	800007e0 <panic>
+    panic("sched locks");
+    80001e8c:	00005517          	auipc	a0,0x5
+    80001e90:	31c50513          	addi	a0,a0,796 # 800071a8 <etext+0x1a8>
+    80001e94:	94dfe0ef          	jal	800007e0 <panic>
+    panic("sched RUNNING");
+    80001e98:	00005517          	auipc	a0,0x5
+    80001e9c:	32050513          	addi	a0,a0,800 # 800071b8 <etext+0x1b8>
+    80001ea0:	941fe0ef          	jal	800007e0 <panic>
+    panic("sched interruptible");
+    80001ea4:	00005517          	auipc	a0,0x5
+    80001ea8:	32450513          	addi	a0,a0,804 # 800071c8 <etext+0x1c8>
+    80001eac:	935fe0ef          	jal	800007e0 <panic>
+
+0000000080001eb0 <yield>:
+{
+    80001eb0:	1101                	addi	sp,sp,-32
+    80001eb2:	ec06                	sd	ra,24(sp)
+    80001eb4:	e822                	sd	s0,16(sp)
+    80001eb6:	e426                	sd	s1,8(sp)
+    80001eb8:	1000                	addi	s0,sp,32
+  struct proc *p = myproc();
+    80001eba:	a15ff0ef          	jal	800018ce <myproc>
+    80001ebe:	84aa                	mv	s1,a0
+  acquire(&p->lock);
+    80001ec0:	d0ffe0ef          	jal	80000bce <acquire>
+  p->state = RUNNABLE;
+    80001ec4:	478d                	li	a5,3
+    80001ec6:	cc9c                	sw	a5,24(s1)
+  sched();
+    80001ec8:	f2fff0ef          	jal	80001df6 <sched>
+  release(&p->lock);
+    80001ecc:	8526                	mv	a0,s1
+    80001ece:	d99fe0ef          	jal	80000c66 <release>
+}
+    80001ed2:	60e2                	ld	ra,24(sp)
+    80001ed4:	6442                	ld	s0,16(sp)
+    80001ed6:	64a2                	ld	s1,8(sp)
+    80001ed8:	6105                	addi	sp,sp,32
+    80001eda:	8082                	ret
+
+0000000080001edc <sleep>:
+
+// Sleep on channel chan, releasing condition lock lk.
+// Re-acquires lk when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+    80001edc:	7179                	addi	sp,sp,-48
+    80001ede:	f406                	sd	ra,40(sp)
+    80001ee0:	f022                	sd	s0,32(sp)
+    80001ee2:	ec26                	sd	s1,24(sp)
+    80001ee4:	e84a                	sd	s2,16(sp)
+    80001ee6:	e44e                	sd	s3,8(sp)
+    80001ee8:	1800                	addi	s0,sp,48
+    80001eea:	89aa                	mv	s3,a0
+    80001eec:	892e                	mv	s2,a1
+  struct proc *p = myproc();
+    80001eee:	9e1ff0ef          	jal	800018ce <myproc>
+    80001ef2:	84aa                	mv	s1,a0
+  // Once we hold p->lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup locks p->lock),
+  // so it's okay to release lk.
+
+  acquire(&p->lock);  //DOC: sleeplock1
+    80001ef4:	cdbfe0ef          	jal	80000bce <acquire>
+  release(lk);
+    80001ef8:	854a                	mv	a0,s2
+    80001efa:	d6dfe0ef          	jal	80000c66 <release>
+
+  // Go to sleep.
+  p->chan = chan;
+    80001efe:	0334b023          	sd	s3,32(s1)
+      if (ran > 0)
+        update_vruntime(p, ran);
+    }
+  #endif
+  
+  p->state = SLEEPING;
+    80001f02:	4789                	li	a5,2
+    80001f04:	cc9c                	sw	a5,24(s1)
+
+  sched();
+    80001f06:	ef1ff0ef          	jal	80001df6 <sched>
+
+  // Tidy up.
+  p->chan = 0;
+    80001f0a:	0204b023          	sd	zero,32(s1)
+
+  // Reacquire original lock.
+  release(&p->lock);
+    80001f0e:	8526                	mv	a0,s1
+    80001f10:	d57fe0ef          	jal	80000c66 <release>
+  acquire(lk);
+    80001f14:	854a                	mv	a0,s2
+    80001f16:	cb9fe0ef          	jal	80000bce <acquire>
+}
+    80001f1a:	70a2                	ld	ra,40(sp)
+    80001f1c:	7402                	ld	s0,32(sp)
+    80001f1e:	64e2                	ld	s1,24(sp)
+    80001f20:	6942                	ld	s2,16(sp)
+    80001f22:	69a2                	ld	s3,8(sp)
+    80001f24:	6145                	addi	sp,sp,48
+    80001f26:	8082                	ret
+
+0000000080001f28 <wakeup>:
+
+// Wake up all processes sleeping on channel chan.
+// Caller should hold the condition lock.
+void
+wakeup(void *chan)
+{
+    80001f28:	7139                	addi	sp,sp,-64
+    80001f2a:	fc06                	sd	ra,56(sp)
+    80001f2c:	f822                	sd	s0,48(sp)
+    80001f2e:	f426                	sd	s1,40(sp)
+    80001f30:	f04a                	sd	s2,32(sp)
+    80001f32:	ec4e                	sd	s3,24(sp)
+    80001f34:	e852                	sd	s4,16(sp)
+    80001f36:	e456                	sd	s5,8(sp)
+    80001f38:	0080                	addi	s0,sp,64
+    80001f3a:	8a2a                	mv	s4,a0
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001f3c:	00010497          	auipc	s1,0x10
+    80001f40:	7ec48493          	addi	s1,s1,2028 # 80012728 <proc>
+    if(p != myproc()){
+      acquire(&p->lock);
+      if(p->state == SLEEPING && p->chan == chan) {
+    80001f44:	4989                	li	s3,2
+        p->state = RUNNABLE;
+    80001f46:	4a8d                	li	s5,3
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001f48:	00017917          	auipc	s2,0x17
+    80001f4c:	be090913          	addi	s2,s2,-1056 # 80018b28 <tickslock>
+    80001f50:	a801                	j	80001f60 <wakeup+0x38>
+      }
+      release(&p->lock);
+    80001f52:	8526                	mv	a0,s1
+    80001f54:	d13fe0ef          	jal	80000c66 <release>
+  for(p = proc; p < &proc[NPROC]; p++) {
+    80001f58:	19048493          	addi	s1,s1,400
+    80001f5c:	03248263          	beq	s1,s2,80001f80 <wakeup+0x58>
+    if(p != myproc()){
+    80001f60:	96fff0ef          	jal	800018ce <myproc>
+    80001f64:	fea48ae3          	beq	s1,a0,80001f58 <wakeup+0x30>
+      acquire(&p->lock);
+    80001f68:	8526                	mv	a0,s1
+    80001f6a:	c65fe0ef          	jal	80000bce <acquire>
+      if(p->state == SLEEPING && p->chan == chan) {
+    80001f6e:	4c9c                	lw	a5,24(s1)
+    80001f70:	ff3791e3          	bne	a5,s3,80001f52 <wakeup+0x2a>
+    80001f74:	709c                	ld	a5,32(s1)
+    80001f76:	fd479ee3          	bne	a5,s4,80001f52 <wakeup+0x2a>
+        p->state = RUNNABLE;
+    80001f7a:	0154ac23          	sw	s5,24(s1)
+    80001f7e:	bfd1                	j	80001f52 <wakeup+0x2a>
+    }
+  }
+}
+    80001f80:	70e2                	ld	ra,56(sp)
+    80001f82:	7442                	ld	s0,48(sp)
+    80001f84:	74a2                	ld	s1,40(sp)
+    80001f86:	7902                	ld	s2,32(sp)
+    80001f88:	69e2                	ld	s3,24(sp)
+    80001f8a:	6a42                	ld	s4,16(sp)
+    80001f8c:	6aa2                	ld	s5,8(sp)
+    80001f8e:	6121                	addi	sp,sp,64
+    80001f90:	8082                	ret
+
+0000000080001f92 <reparent>:
+{
+    80001f92:	7179                	addi	sp,sp,-48
+    80001f94:	f406                	sd	ra,40(sp)
+    80001f96:	f022                	sd	s0,32(sp)
+    80001f98:	ec26                	sd	s1,24(sp)
+    80001f9a:	e84a                	sd	s2,16(sp)
+    80001f9c:	e44e                	sd	s3,8(sp)
+    80001f9e:	e052                	sd	s4,0(sp)
+    80001fa0:	1800                	addi	s0,sp,48
+    80001fa2:	892a                	mv	s2,a0
+  for(pp = proc; pp < &proc[NPROC]; pp++){
+    80001fa4:	00010497          	auipc	s1,0x10
+    80001fa8:	78448493          	addi	s1,s1,1924 # 80012728 <proc>
+      pp->parent = initproc;
+    80001fac:	00008a17          	auipc	s4,0x8
+    80001fb0:	234a0a13          	addi	s4,s4,564 # 8000a1e0 <initproc>
+  for(pp = proc; pp < &proc[NPROC]; pp++){
+    80001fb4:	00017997          	auipc	s3,0x17
+    80001fb8:	b7498993          	addi	s3,s3,-1164 # 80018b28 <tickslock>
+    80001fbc:	a029                	j	80001fc6 <reparent+0x34>
+    80001fbe:	19048493          	addi	s1,s1,400
+    80001fc2:	01348b63          	beq	s1,s3,80001fd8 <reparent+0x46>
+    if(pp->parent == p){
+    80001fc6:	7c9c                	ld	a5,56(s1)
+    80001fc8:	ff279be3          	bne	a5,s2,80001fbe <reparent+0x2c>
+      pp->parent = initproc;
+    80001fcc:	000a3503          	ld	a0,0(s4)
+    80001fd0:	fc88                	sd	a0,56(s1)
+      wakeup(initproc);
+    80001fd2:	f57ff0ef          	jal	80001f28 <wakeup>
+    80001fd6:	b7e5                	j	80001fbe <reparent+0x2c>
+}
+    80001fd8:	70a2                	ld	ra,40(sp)
+    80001fda:	7402                	ld	s0,32(sp)
+    80001fdc:	64e2                	ld	s1,24(sp)
+    80001fde:	6942                	ld	s2,16(sp)
+    80001fe0:	69a2                	ld	s3,8(sp)
+    80001fe2:	6a02                	ld	s4,0(sp)
+    80001fe4:	6145                	addi	sp,sp,48
+    80001fe6:	8082                	ret
+
+0000000080001fe8 <kexit>:
+{
+    80001fe8:	7179                	addi	sp,sp,-48
+    80001fea:	f406                	sd	ra,40(sp)
+    80001fec:	f022                	sd	s0,32(sp)
+    80001fee:	ec26                	sd	s1,24(sp)
+    80001ff0:	e84a                	sd	s2,16(sp)
+    80001ff2:	e44e                	sd	s3,8(sp)
+    80001ff4:	e052                	sd	s4,0(sp)
+    80001ff6:	1800                	addi	s0,sp,48
+    80001ff8:	8a2a                	mv	s4,a0
+  struct proc *p = myproc();
+    80001ffa:	8d5ff0ef          	jal	800018ce <myproc>
+    80001ffe:	89aa                	mv	s3,a0
+  if(p == initproc)
+    80002000:	00008797          	auipc	a5,0x8
+    80002004:	1e07b783          	ld	a5,480(a5) # 8000a1e0 <initproc>
+    80002008:	0d050493          	addi	s1,a0,208
+    8000200c:	15050913          	addi	s2,a0,336
+    80002010:	00a79f63          	bne	a5,a0,8000202e <kexit+0x46>
+    panic("init exiting");
+    80002014:	00005517          	auipc	a0,0x5
+    80002018:	1cc50513          	addi	a0,a0,460 # 800071e0 <etext+0x1e0>
+    8000201c:	fc4fe0ef          	jal	800007e0 <panic>
+      fileclose(f);
+    80002020:	7d7010ef          	jal	80003ff6 <fileclose>
+      p->ofile[fd] = 0;
+    80002024:	0004b023          	sd	zero,0(s1)
+  for(int fd = 0; fd < NOFILE; fd++){
+    80002028:	04a1                	addi	s1,s1,8
+    8000202a:	01248563          	beq	s1,s2,80002034 <kexit+0x4c>
+    if(p->ofile[fd]){
+    8000202e:	6088                	ld	a0,0(s1)
+    80002030:	f965                	bnez	a0,80002020 <kexit+0x38>
+    80002032:	bfdd                	j	80002028 <kexit+0x40>
+  begin_op();
+    80002034:	3b7010ef          	jal	80003bea <begin_op>
+  iput(p->cwd);
+    80002038:	1509b503          	ld	a0,336(s3)
+    8000203c:	346010ef          	jal	80003382 <iput>
+  end_op();
+    80002040:	415010ef          	jal	80003c54 <end_op>
+  p->cwd = 0;
+    80002044:	1409b823          	sd	zero,336(s3)
+  acquire(&wait_lock);
+    80002048:	00010497          	auipc	s1,0x10
+    8000204c:	2c848493          	addi	s1,s1,712 # 80012310 <wait_lock>
+    80002050:	8526                	mv	a0,s1
+    80002052:	b7dfe0ef          	jal	80000bce <acquire>
+  reparent(p);
+    80002056:	854e                	mv	a0,s3
+    80002058:	f3bff0ef          	jal	80001f92 <reparent>
+  wakeup(p->parent);
+    8000205c:	0389b503          	ld	a0,56(s3)
+    80002060:	ec9ff0ef          	jal	80001f28 <wakeup>
+  acquire(&p->lock);
+    80002064:	854e                	mv	a0,s3
+    80002066:	b69fe0ef          	jal	80000bce <acquire>
+  p->xstate = status;
+    8000206a:	0349a623          	sw	s4,44(s3)
+  p->state = ZOMBIE;
+    8000206e:	4795                	li	a5,5
+    80002070:	00f9ac23          	sw	a5,24(s3)
+  release(&wait_lock);
+    80002074:	8526                	mv	a0,s1
+    80002076:	bf1fe0ef          	jal	80000c66 <release>
+  sched();
+    8000207a:	d7dff0ef          	jal	80001df6 <sched>
+  panic("zombie exit");
+    8000207e:	00005517          	auipc	a0,0x5
+    80002082:	17250513          	addi	a0,a0,370 # 800071f0 <etext+0x1f0>
+    80002086:	f5afe0ef          	jal	800007e0 <panic>
+
+000000008000208a <kkill>:
+// Kill the process with the given pid.
+// The victim won't exit until it tries to return
+// to user space (see usertrap() in trap.c).
+int
+kkill(int pid)
+{
+    8000208a:	7179                	addi	sp,sp,-48
+    8000208c:	f406                	sd	ra,40(sp)
+    8000208e:	f022                	sd	s0,32(sp)
+    80002090:	ec26                	sd	s1,24(sp)
+    80002092:	e84a                	sd	s2,16(sp)
+    80002094:	e44e                	sd	s3,8(sp)
+    80002096:	1800                	addi	s0,sp,48
+    80002098:	892a                	mv	s2,a0
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++){
+    8000209a:	00010497          	auipc	s1,0x10
+    8000209e:	68e48493          	addi	s1,s1,1678 # 80012728 <proc>
+    800020a2:	00017997          	auipc	s3,0x17
+    800020a6:	a8698993          	addi	s3,s3,-1402 # 80018b28 <tickslock>
+    acquire(&p->lock);
+    800020aa:	8526                	mv	a0,s1
+    800020ac:	b23fe0ef          	jal	80000bce <acquire>
+    if(p->pid == pid){
+    800020b0:	589c                	lw	a5,48(s1)
+    800020b2:	01278b63          	beq	a5,s2,800020c8 <kkill+0x3e>
+        p->state = RUNNABLE;
+      }
+      release(&p->lock);
+      return 0;
+    }
+    release(&p->lock);
+    800020b6:	8526                	mv	a0,s1
+    800020b8:	baffe0ef          	jal	80000c66 <release>
+  for(p = proc; p < &proc[NPROC]; p++){
+    800020bc:	19048493          	addi	s1,s1,400
+    800020c0:	ff3495e3          	bne	s1,s3,800020aa <kkill+0x20>
+  }
+  return -1;
+    800020c4:	557d                	li	a0,-1
+    800020c6:	a819                	j	800020dc <kkill+0x52>
+      p->killed = 1;
+    800020c8:	4785                	li	a5,1
+    800020ca:	d49c                	sw	a5,40(s1)
+      if(p->state == SLEEPING){
+    800020cc:	4c98                	lw	a4,24(s1)
+    800020ce:	4789                	li	a5,2
+    800020d0:	00f70d63          	beq	a4,a5,800020ea <kkill+0x60>
+      release(&p->lock);
+    800020d4:	8526                	mv	a0,s1
+    800020d6:	b91fe0ef          	jal	80000c66 <release>
+      return 0;
+    800020da:	4501                	li	a0,0
+}
+    800020dc:	70a2                	ld	ra,40(sp)
+    800020de:	7402                	ld	s0,32(sp)
+    800020e0:	64e2                	ld	s1,24(sp)
+    800020e2:	6942                	ld	s2,16(sp)
+    800020e4:	69a2                	ld	s3,8(sp)
+    800020e6:	6145                	addi	sp,sp,48
+    800020e8:	8082                	ret
+        p->state = RUNNABLE;
+    800020ea:	478d                	li	a5,3
+    800020ec:	cc9c                	sw	a5,24(s1)
+    800020ee:	b7dd                	j	800020d4 <kkill+0x4a>
+
+00000000800020f0 <setkilled>:
+
+void
+setkilled(struct proc *p)
+{
+    800020f0:	1101                	addi	sp,sp,-32
+    800020f2:	ec06                	sd	ra,24(sp)
+    800020f4:	e822                	sd	s0,16(sp)
+    800020f6:	e426                	sd	s1,8(sp)
+    800020f8:	1000                	addi	s0,sp,32
+    800020fa:	84aa                	mv	s1,a0
+  acquire(&p->lock);
+    800020fc:	ad3fe0ef          	jal	80000bce <acquire>
+  p->killed = 1;
+    80002100:	4785                	li	a5,1
+    80002102:	d49c                	sw	a5,40(s1)
+  release(&p->lock);
+    80002104:	8526                	mv	a0,s1
+    80002106:	b61fe0ef          	jal	80000c66 <release>
+}
+    8000210a:	60e2                	ld	ra,24(sp)
+    8000210c:	6442                	ld	s0,16(sp)
+    8000210e:	64a2                	ld	s1,8(sp)
+    80002110:	6105                	addi	sp,sp,32
+    80002112:	8082                	ret
+
+0000000080002114 <killed>:
+
+int
+killed(struct proc *p)
+{
+    80002114:	1101                	addi	sp,sp,-32
+    80002116:	ec06                	sd	ra,24(sp)
+    80002118:	e822                	sd	s0,16(sp)
+    8000211a:	e426                	sd	s1,8(sp)
+    8000211c:	e04a                	sd	s2,0(sp)
+    8000211e:	1000                	addi	s0,sp,32
+    80002120:	84aa                	mv	s1,a0
+  int k;
+  
+  acquire(&p->lock);
+    80002122:	aadfe0ef          	jal	80000bce <acquire>
+  k = p->killed;
+    80002126:	0284a903          	lw	s2,40(s1)
+  release(&p->lock);
+    8000212a:	8526                	mv	a0,s1
+    8000212c:	b3bfe0ef          	jal	80000c66 <release>
+  return k;
+}
+    80002130:	854a                	mv	a0,s2
+    80002132:	60e2                	ld	ra,24(sp)
+    80002134:	6442                	ld	s0,16(sp)
+    80002136:	64a2                	ld	s1,8(sp)
+    80002138:	6902                	ld	s2,0(sp)
+    8000213a:	6105                	addi	sp,sp,32
+    8000213c:	8082                	ret
+
+000000008000213e <kwait>:
+{
+    8000213e:	715d                	addi	sp,sp,-80
+    80002140:	e486                	sd	ra,72(sp)
+    80002142:	e0a2                	sd	s0,64(sp)
+    80002144:	fc26                	sd	s1,56(sp)
+    80002146:	f84a                	sd	s2,48(sp)
+    80002148:	f44e                	sd	s3,40(sp)
+    8000214a:	f052                	sd	s4,32(sp)
+    8000214c:	ec56                	sd	s5,24(sp)
+    8000214e:	e85a                	sd	s6,16(sp)
+    80002150:	e45e                	sd	s7,8(sp)
+    80002152:	e062                	sd	s8,0(sp)
+    80002154:	0880                	addi	s0,sp,80
+    80002156:	8b2a                	mv	s6,a0
+  struct proc *p = myproc();
+    80002158:	f76ff0ef          	jal	800018ce <myproc>
+    8000215c:	892a                	mv	s2,a0
+  acquire(&wait_lock);
+    8000215e:	00010517          	auipc	a0,0x10
+    80002162:	1b250513          	addi	a0,a0,434 # 80012310 <wait_lock>
+    80002166:	a69fe0ef          	jal	80000bce <acquire>
+    havekids = 0;
+    8000216a:	4b81                	li	s7,0
+        if(pp->state == ZOMBIE){
+    8000216c:	4a15                	li	s4,5
+        havekids = 1;
+    8000216e:	4a85                	li	s5,1
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+    80002170:	00017997          	auipc	s3,0x17
+    80002174:	9b898993          	addi	s3,s3,-1608 # 80018b28 <tickslock>
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+    80002178:	00010c17          	auipc	s8,0x10
+    8000217c:	198c0c13          	addi	s8,s8,408 # 80012310 <wait_lock>
+    80002180:	a871                	j	8000221c <kwait+0xde>
+          pid = pp->pid;
+    80002182:	0304a983          	lw	s3,48(s1)
+          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+    80002186:	000b0c63          	beqz	s6,8000219e <kwait+0x60>
+    8000218a:	4691                	li	a3,4
+    8000218c:	02c48613          	addi	a2,s1,44
+    80002190:	85da                	mv	a1,s6
+    80002192:	05093503          	ld	a0,80(s2)
+    80002196:	c4cff0ef          	jal	800015e2 <copyout>
+    8000219a:	02054b63          	bltz	a0,800021d0 <kwait+0x92>
+          freeproc(pp);
+    8000219e:	8526                	mv	a0,s1
+    800021a0:	8ffff0ef          	jal	80001a9e <freeproc>
+          release(&pp->lock);
+    800021a4:	8526                	mv	a0,s1
+    800021a6:	ac1fe0ef          	jal	80000c66 <release>
+          release(&wait_lock);
+    800021aa:	00010517          	auipc	a0,0x10
+    800021ae:	16650513          	addi	a0,a0,358 # 80012310 <wait_lock>
+    800021b2:	ab5fe0ef          	jal	80000c66 <release>
+}
+    800021b6:	854e                	mv	a0,s3
+    800021b8:	60a6                	ld	ra,72(sp)
+    800021ba:	6406                	ld	s0,64(sp)
+    800021bc:	74e2                	ld	s1,56(sp)
+    800021be:	7942                	ld	s2,48(sp)
+    800021c0:	79a2                	ld	s3,40(sp)
+    800021c2:	7a02                	ld	s4,32(sp)
+    800021c4:	6ae2                	ld	s5,24(sp)
+    800021c6:	6b42                	ld	s6,16(sp)
+    800021c8:	6ba2                	ld	s7,8(sp)
+    800021ca:	6c02                	ld	s8,0(sp)
+    800021cc:	6161                	addi	sp,sp,80
+    800021ce:	8082                	ret
+            release(&pp->lock);
+    800021d0:	8526                	mv	a0,s1
+    800021d2:	a95fe0ef          	jal	80000c66 <release>
+            release(&wait_lock);
+    800021d6:	00010517          	auipc	a0,0x10
+    800021da:	13a50513          	addi	a0,a0,314 # 80012310 <wait_lock>
+    800021de:	a89fe0ef          	jal	80000c66 <release>
+            return -1;
+    800021e2:	59fd                	li	s3,-1
+    800021e4:	bfc9                	j	800021b6 <kwait+0x78>
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+    800021e6:	19048493          	addi	s1,s1,400
+    800021ea:	03348063          	beq	s1,s3,8000220a <kwait+0xcc>
+      if(pp->parent == p){
+    800021ee:	7c9c                	ld	a5,56(s1)
+    800021f0:	ff279be3          	bne	a5,s2,800021e6 <kwait+0xa8>
+        acquire(&pp->lock);
+    800021f4:	8526                	mv	a0,s1
+    800021f6:	9d9fe0ef          	jal	80000bce <acquire>
+        if(pp->state == ZOMBIE){
+    800021fa:	4c9c                	lw	a5,24(s1)
+    800021fc:	f94783e3          	beq	a5,s4,80002182 <kwait+0x44>
+        release(&pp->lock);
+    80002200:	8526                	mv	a0,s1
+    80002202:	a65fe0ef          	jal	80000c66 <release>
+        havekids = 1;
+    80002206:	8756                	mv	a4,s5
+    80002208:	bff9                	j	800021e6 <kwait+0xa8>
+    if(!havekids || killed(p)){
+    8000220a:	cf19                	beqz	a4,80002228 <kwait+0xea>
+    8000220c:	854a                	mv	a0,s2
+    8000220e:	f07ff0ef          	jal	80002114 <killed>
+    80002212:	e919                	bnez	a0,80002228 <kwait+0xea>
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+    80002214:	85e2                	mv	a1,s8
+    80002216:	854a                	mv	a0,s2
+    80002218:	cc5ff0ef          	jal	80001edc <sleep>
+    havekids = 0;
+    8000221c:	875e                	mv	a4,s7
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+    8000221e:	00010497          	auipc	s1,0x10
+    80002222:	50a48493          	addi	s1,s1,1290 # 80012728 <proc>
+    80002226:	b7e1                	j	800021ee <kwait+0xb0>
+      release(&wait_lock);
+    80002228:	00010517          	auipc	a0,0x10
+    8000222c:	0e850513          	addi	a0,a0,232 # 80012310 <wait_lock>
+    80002230:	a37fe0ef          	jal	80000c66 <release>
+      return -1;
+    80002234:	59fd                	li	s3,-1
+    80002236:	b741                	j	800021b6 <kwait+0x78>
+
+0000000080002238 <either_copyout>:
+// Copy to either a user address, or kernel address,
+// depending on usr_dst.
+// Returns 0 on success, -1 on error.
+int
+either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+{
+    80002238:	7179                	addi	sp,sp,-48
+    8000223a:	f406                	sd	ra,40(sp)
+    8000223c:	f022                	sd	s0,32(sp)
+    8000223e:	ec26                	sd	s1,24(sp)
+    80002240:	e84a                	sd	s2,16(sp)
+    80002242:	e44e                	sd	s3,8(sp)
+    80002244:	e052                	sd	s4,0(sp)
+    80002246:	1800                	addi	s0,sp,48
+    80002248:	84aa                	mv	s1,a0
+    8000224a:	892e                	mv	s2,a1
+    8000224c:	89b2                	mv	s3,a2
+    8000224e:	8a36                	mv	s4,a3
+  struct proc *p = myproc();
+    80002250:	e7eff0ef          	jal	800018ce <myproc>
+  if(user_dst){
+    80002254:	cc99                	beqz	s1,80002272 <either_copyout+0x3a>
+    return copyout(p->pagetable, dst, src, len);
+    80002256:	86d2                	mv	a3,s4
+    80002258:	864e                	mv	a2,s3
+    8000225a:	85ca                	mv	a1,s2
+    8000225c:	6928                	ld	a0,80(a0)
+    8000225e:	b84ff0ef          	jal	800015e2 <copyout>
+  } else {
+    memmove((char *)dst, src, len);
+    return 0;
+  }
+}
+    80002262:	70a2                	ld	ra,40(sp)
+    80002264:	7402                	ld	s0,32(sp)
+    80002266:	64e2                	ld	s1,24(sp)
+    80002268:	6942                	ld	s2,16(sp)
+    8000226a:	69a2                	ld	s3,8(sp)
+    8000226c:	6a02                	ld	s4,0(sp)
+    8000226e:	6145                	addi	sp,sp,48
+    80002270:	8082                	ret
+    memmove((char *)dst, src, len);
+    80002272:	000a061b          	sext.w	a2,s4
+    80002276:	85ce                	mv	a1,s3
+    80002278:	854a                	mv	a0,s2
+    8000227a:	a85fe0ef          	jal	80000cfe <memmove>
+    return 0;
+    8000227e:	8526                	mv	a0,s1
+    80002280:	b7cd                	j	80002262 <either_copyout+0x2a>
+
+0000000080002282 <either_copyin>:
+// Copy from either a user address, or kernel address,
+// depending on usr_src.
+// Returns 0 on success, -1 on error.
+int
+either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+{
+    80002282:	7179                	addi	sp,sp,-48
+    80002284:	f406                	sd	ra,40(sp)
+    80002286:	f022                	sd	s0,32(sp)
+    80002288:	ec26                	sd	s1,24(sp)
+    8000228a:	e84a                	sd	s2,16(sp)
+    8000228c:	e44e                	sd	s3,8(sp)
+    8000228e:	e052                	sd	s4,0(sp)
+    80002290:	1800                	addi	s0,sp,48
+    80002292:	892a                	mv	s2,a0
+    80002294:	84ae                	mv	s1,a1
+    80002296:	89b2                	mv	s3,a2
+    80002298:	8a36                	mv	s4,a3
+  struct proc *p = myproc();
+    8000229a:	e34ff0ef          	jal	800018ce <myproc>
+  if(user_src){
+    8000229e:	cc99                	beqz	s1,800022bc <either_copyin+0x3a>
+    return copyin(p->pagetable, dst, src, len);
+    800022a0:	86d2                	mv	a3,s4
+    800022a2:	864e                	mv	a2,s3
+    800022a4:	85ca                	mv	a1,s2
+    800022a6:	6928                	ld	a0,80(a0)
+    800022a8:	c1eff0ef          	jal	800016c6 <copyin>
+  } else {
+    memmove(dst, (char*)src, len);
+    return 0;
+  }
+}
+    800022ac:	70a2                	ld	ra,40(sp)
+    800022ae:	7402                	ld	s0,32(sp)
+    800022b0:	64e2                	ld	s1,24(sp)
+    800022b2:	6942                	ld	s2,16(sp)
+    800022b4:	69a2                	ld	s3,8(sp)
+    800022b6:	6a02                	ld	s4,0(sp)
+    800022b8:	6145                	addi	sp,sp,48
+    800022ba:	8082                	ret
+    memmove(dst, (char*)src, len);
+    800022bc:	000a061b          	sext.w	a2,s4
+    800022c0:	85ce                	mv	a1,s3
+    800022c2:	854a                	mv	a0,s2
+    800022c4:	a3bfe0ef          	jal	80000cfe <memmove>
+    return 0;
+    800022c8:	8526                	mv	a0,s1
+    800022ca:	b7cd                	j	800022ac <either_copyin+0x2a>
+
+00000000800022cc <procdump>:
+//    }
+//  }
+
+void
+procdump(void)
+{
+    800022cc:	715d                	addi	sp,sp,-80
+    800022ce:	e486                	sd	ra,72(sp)
+    800022d0:	e0a2                	sd	s0,64(sp)
+    800022d2:	fc26                	sd	s1,56(sp)
+    800022d4:	f84a                	sd	s2,48(sp)
+    800022d6:	f44e                	sd	s3,40(sp)
+    800022d8:	f052                	sd	s4,32(sp)
+    800022da:	ec56                	sd	s5,24(sp)
+    800022dc:	e85a                	sd	s6,16(sp)
+    800022de:	e45e                	sd	s7,8(sp)
+    800022e0:	0880                	addi	s0,sp,80
+  };
+  
+  struct proc *p;
+  char *state;
+
+  printf("\n");
+    800022e2:	00005517          	auipc	a0,0x5
+    800022e6:	d9650513          	addi	a0,a0,-618 # 80007078 <etext+0x78>
+    800022ea:	a10fe0ef          	jal	800004fa <printf>
+  printf("---\t-----\t\t----\t\t-----\t-----\t\t----\t------\n");
+#elif defined(FCFS)
+  printf("PID\tSTATE\t\tNAME\t\tCREATION_TIME\n");
+  printf("---\t-----\t\t----\t\t-------------\n");
+#else
+  printf("PID\tSTATE\t\tNAME\n");
+    800022ee:	00005517          	auipc	a0,0x5
+    800022f2:	f1a50513          	addi	a0,a0,-230 # 80007208 <etext+0x208>
+    800022f6:	a04fe0ef          	jal	800004fa <printf>
+  printf("---\t-----\t\t----\n");
+    800022fa:	00005517          	auipc	a0,0x5
+    800022fe:	f2650513          	addi	a0,a0,-218 # 80007220 <etext+0x220>
+    80002302:	9f8fe0ef          	jal	800004fa <printf>
+#endif
+
+  for(p = proc; p < &proc[NPROC]; p++){
+    80002306:	00010497          	auipc	s1,0x10
+    8000230a:	42248493          	addi	s1,s1,1058 # 80012728 <proc>
+    if(p->state == UNUSED) {
+      release(&p->lock);
+      continue;
+    }
+    
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    8000230e:	4b15                	li	s6,5
+      state = states[p->state];
+    else
+      state = "???";
+    80002310:	00005a17          	auipc	s4,0x5
+    80002314:	ef0a0a13          	addi	s4,s4,-272 # 80007200 <etext+0x200>
+    printf("%d\t%s\t%s\t\t%d\t%ld\t\t%d\t%ld\n", 
+           p->pid, state, p->name, (int)p->creation_time, p->vruntime, p->nice, p->weight);
+#elif defined(FCFS)
+    printf("%d\t%s\t%s\t\t%d\n", p->pid, state, p->name, (int)p->creation_time);
+#else
+    printf("%d\t%s\t%s\n", p->pid, state, p->name);
+    80002318:	00005a97          	auipc	s5,0x5
+    8000231c:	f20a8a93          	addi	s5,s5,-224 # 80007238 <etext+0x238>
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    80002320:	00005b97          	auipc	s7,0x5
+    80002324:	438b8b93          	addi	s7,s7,1080 # 80007758 <states.0>
+  for(p = proc; p < &proc[NPROC]; p++){
+    80002328:	00017997          	auipc	s3,0x17
+    8000232c:	80098993          	addi	s3,s3,-2048 # 80018b28 <tickslock>
+    80002330:	a015                	j	80002354 <procdump+0x88>
+      release(&p->lock);
+    80002332:	8526                	mv	a0,s1
+    80002334:	933fe0ef          	jal	80000c66 <release>
+      continue;
+    80002338:	a811                	j	8000234c <procdump+0x80>
+    printf("%d\t%s\t%s\n", p->pid, state, p->name);
+    8000233a:	15890693          	addi	a3,s2,344
+    8000233e:	588c                	lw	a1,48(s1)
+    80002340:	8556                	mv	a0,s5
+    80002342:	9b8fe0ef          	jal	800004fa <printf>
+#endif
+    
+    release(&p->lock);
+    80002346:	8526                	mv	a0,s1
+    80002348:	91ffe0ef          	jal	80000c66 <release>
+  for(p = proc; p < &proc[NPROC]; p++){
+    8000234c:	19048493          	addi	s1,s1,400
+    80002350:	03348463          	beq	s1,s3,80002378 <procdump+0xac>
+    acquire(&p->lock);
+    80002354:	8926                	mv	s2,s1
+    80002356:	8526                	mv	a0,s1
+    80002358:	877fe0ef          	jal	80000bce <acquire>
+    if(p->state == UNUSED) {
+    8000235c:	4c9c                	lw	a5,24(s1)
+    8000235e:	dbf1                	beqz	a5,80002332 <procdump+0x66>
+      state = "???";
+    80002360:	8652                	mv	a2,s4
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+    80002362:	fcfb6ce3          	bltu	s6,a5,8000233a <procdump+0x6e>
+    80002366:	02079713          	slli	a4,a5,0x20
+    8000236a:	01d75793          	srli	a5,a4,0x1d
+    8000236e:	97de                	add	a5,a5,s7
+    80002370:	6390                	ld	a2,0(a5)
+    80002372:	f661                	bnez	a2,8000233a <procdump+0x6e>
+      state = "???";
+    80002374:	8652                	mv	a2,s4
+    80002376:	b7d1                	j	8000233a <procdump+0x6e>
+  }
+  printf("\n");
+    80002378:	00005517          	auipc	a0,0x5
+    8000237c:	d0050513          	addi	a0,a0,-768 # 80007078 <etext+0x78>
+    80002380:	97afe0ef          	jal	800004fa <printf>
+}
+    80002384:	60a6                	ld	ra,72(sp)
+    80002386:	6406                	ld	s0,64(sp)
+    80002388:	74e2                	ld	s1,56(sp)
+    8000238a:	7942                	ld	s2,48(sp)
+    8000238c:	79a2                	ld	s3,40(sp)
+    8000238e:	7a02                	ld	s4,32(sp)
+    80002390:	6ae2                	ld	s5,24(sp)
+    80002392:	6b42                	ld	s6,16(sp)
+    80002394:	6ba2                	ld	s7,8(sp)
+    80002396:	6161                	addi	sp,sp,80
+    80002398:	8082                	ret
+
+000000008000239a <swtch>:
+# Save current registers in old. Load from new.	
+
+
+.globl swtch
+swtch:
+        sd ra, 0(a0)
+    8000239a:	00153023          	sd	ra,0(a0)
+        sd sp, 8(a0)
+    8000239e:	00253423          	sd	sp,8(a0)
+        sd s0, 16(a0)
+    800023a2:	e900                	sd	s0,16(a0)
+        sd s1, 24(a0)
+    800023a4:	ed04                	sd	s1,24(a0)
+        sd s2, 32(a0)
+    800023a6:	03253023          	sd	s2,32(a0)
+        sd s3, 40(a0)
+    800023aa:	03353423          	sd	s3,40(a0)
+        sd s4, 48(a0)
+    800023ae:	03453823          	sd	s4,48(a0)
+        sd s5, 56(a0)
+    800023b2:	03553c23          	sd	s5,56(a0)
+        sd s6, 64(a0)
+    800023b6:	05653023          	sd	s6,64(a0)
+        sd s7, 72(a0)
+    800023ba:	05753423          	sd	s7,72(a0)
+        sd s8, 80(a0)
+    800023be:	05853823          	sd	s8,80(a0)
+        sd s9, 88(a0)
+    800023c2:	05953c23          	sd	s9,88(a0)
+        sd s10, 96(a0)
+    800023c6:	07a53023          	sd	s10,96(a0)
+        sd s11, 104(a0)
+    800023ca:	07b53423          	sd	s11,104(a0)
+
+        ld ra, 0(a1)
+    800023ce:	0005b083          	ld	ra,0(a1)
+        ld sp, 8(a1)
+    800023d2:	0085b103          	ld	sp,8(a1)
+        ld s0, 16(a1)
+    800023d6:	6980                	ld	s0,16(a1)
+        ld s1, 24(a1)
+    800023d8:	6d84                	ld	s1,24(a1)
+        ld s2, 32(a1)
+    800023da:	0205b903          	ld	s2,32(a1)
+        ld s3, 40(a1)
+    800023de:	0285b983          	ld	s3,40(a1)
+        ld s4, 48(a1)
+    800023e2:	0305ba03          	ld	s4,48(a1)
+        ld s5, 56(a1)
+    800023e6:	0385ba83          	ld	s5,56(a1)
+        ld s6, 64(a1)
+    800023ea:	0405bb03          	ld	s6,64(a1)
+        ld s7, 72(a1)
+    800023ee:	0485bb83          	ld	s7,72(a1)
+        ld s8, 80(a1)
+    800023f2:	0505bc03          	ld	s8,80(a1)
+        ld s9, 88(a1)
+    800023f6:	0585bc83          	ld	s9,88(a1)
+        ld s10, 96(a1)
+    800023fa:	0605bd03          	ld	s10,96(a1)
+        ld s11, 104(a1)
+    800023fe:	0685bd83          	ld	s11,104(a1)
+        
+        ret
+    80002402:	8082                	ret
+
+0000000080002404 <trapinit>:
+
+extern int devintr();
+
+void
+trapinit(void)
+{
+    80002404:	1141                	addi	sp,sp,-16
+    80002406:	e406                	sd	ra,8(sp)
+    80002408:	e022                	sd	s0,0(sp)
+    8000240a:	0800                	addi	s0,sp,16
+  initlock(&tickslock, "time");
+    8000240c:	00005597          	auipc	a1,0x5
+    80002410:	e6c58593          	addi	a1,a1,-404 # 80007278 <etext+0x278>
+    80002414:	00016517          	auipc	a0,0x16
+    80002418:	71450513          	addi	a0,a0,1812 # 80018b28 <tickslock>
+    8000241c:	f32fe0ef          	jal	80000b4e <initlock>
+}
+    80002420:	60a2                	ld	ra,8(sp)
+    80002422:	6402                	ld	s0,0(sp)
+    80002424:	0141                	addi	sp,sp,16
+    80002426:	8082                	ret
+
+0000000080002428 <trapinithart>:
+
+// set up to take exceptions and traps while in the kernel.
+void
+trapinithart(void)
+{
+    80002428:	1141                	addi	sp,sp,-16
+    8000242a:	e422                	sd	s0,8(sp)
+    8000242c:	0800                	addi	s0,sp,16
+  asm volatile("csrw stvec, %0" : : "r" (x));
+    8000242e:	00003797          	auipc	a5,0x3
+    80002432:	f6278793          	addi	a5,a5,-158 # 80005390 <kernelvec>
+    80002436:	10579073          	csrw	stvec,a5
+  w_stvec((uint64)kernelvec);
+}
+    8000243a:	6422                	ld	s0,8(sp)
+    8000243c:	0141                	addi	sp,sp,16
+    8000243e:	8082                	ret
+
+0000000080002440 <prepare_return>:
+//
+// set up trapframe and control registers for a return to user space
+//
+void
+prepare_return(void)
+{
+    80002440:	1141                	addi	sp,sp,-16
+    80002442:	e406                	sd	ra,8(sp)
+    80002444:	e022                	sd	s0,0(sp)
+    80002446:	0800                	addi	s0,sp,16
+  struct proc *p = myproc();
+    80002448:	c86ff0ef          	jal	800018ce <myproc>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    8000244c:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+    80002450:	9bf5                	andi	a5,a5,-3
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80002452:	10079073          	csrw	sstatus,a5
+  // kerneltrap() to usertrap(). because a trap from kernel
+  // code to usertrap would be a disaster, turn off interrupts.
+  intr_off();
+
+  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
+  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
+    80002456:	04000737          	lui	a4,0x4000
+    8000245a:	177d                	addi	a4,a4,-1 # 3ffffff <_entry-0x7c000001>
+    8000245c:	0732                	slli	a4,a4,0xc
+    8000245e:	00004797          	auipc	a5,0x4
+    80002462:	ba278793          	addi	a5,a5,-1118 # 80006000 <_trampoline>
+    80002466:	00004697          	auipc	a3,0x4
+    8000246a:	b9a68693          	addi	a3,a3,-1126 # 80006000 <_trampoline>
+    8000246e:	8f95                	sub	a5,a5,a3
+    80002470:	97ba                	add	a5,a5,a4
+  asm volatile("csrw stvec, %0" : : "r" (x));
+    80002472:	10579073          	csrw	stvec,a5
+  w_stvec(trampoline_uservec);
+
+  // set up trapframe values that uservec will need when
+  // the process next traps into the kernel.
+  p->trapframe->kernel_satp = r_satp();         // kernel page table
+    80002476:	6d3c                	ld	a5,88(a0)
+  asm volatile("csrr %0, satp" : "=r" (x) );
+    80002478:	18002773          	csrr	a4,satp
+    8000247c:	e398                	sd	a4,0(a5)
+  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
+    8000247e:	6d38                	ld	a4,88(a0)
+    80002480:	613c                	ld	a5,64(a0)
+    80002482:	6685                	lui	a3,0x1
+    80002484:	97b6                	add	a5,a5,a3
+    80002486:	e71c                	sd	a5,8(a4)
+  p->trapframe->kernel_trap = (uint64)usertrap;
+    80002488:	6d3c                	ld	a5,88(a0)
+    8000248a:	00000717          	auipc	a4,0x0
+    8000248e:	0f870713          	addi	a4,a4,248 # 80002582 <usertrap>
+    80002492:	eb98                	sd	a4,16(a5)
+  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+    80002494:	6d3c                	ld	a5,88(a0)
+  asm volatile("mv %0, tp" : "=r" (x) );
+    80002496:	8712                	mv	a4,tp
+    80002498:	f398                	sd	a4,32(a5)
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    8000249a:	100027f3          	csrr	a5,sstatus
+  // set up the registers that trampoline.S's sret will use
+  // to get to user space.
+  
+  // set S Previous Privilege mode to User.
+  unsigned long x = r_sstatus();
+  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+    8000249e:	eff7f793          	andi	a5,a5,-257
+  x |= SSTATUS_SPIE; // enable interrupts in user mode
+    800024a2:	0207e793          	ori	a5,a5,32
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    800024a6:	10079073          	csrw	sstatus,a5
+  w_sstatus(x);
+
+  // set S Exception Program Counter to the saved user pc.
+  w_sepc(p->trapframe->epc);
+    800024aa:	6d3c                	ld	a5,88(a0)
+  asm volatile("csrw sepc, %0" : : "r" (x));
+    800024ac:	6f9c                	ld	a5,24(a5)
+    800024ae:	14179073          	csrw	sepc,a5
+}
+    800024b2:	60a2                	ld	ra,8(sp)
+    800024b4:	6402                	ld	s0,0(sp)
+    800024b6:	0141                	addi	sp,sp,16
+    800024b8:	8082                	ret
+
+00000000800024ba <clockintr>:
+  w_sstatus(sstatus);
+}
+
+void
+clockintr()
+{
+    800024ba:	1101                	addi	sp,sp,-32
+    800024bc:	ec06                	sd	ra,24(sp)
+    800024be:	e822                	sd	s0,16(sp)
+    800024c0:	1000                	addi	s0,sp,32
+  if(cpuid() == 0){
+    800024c2:	be0ff0ef          	jal	800018a2 <cpuid>
+    800024c6:	cd11                	beqz	a0,800024e2 <clockintr+0x28>
+  asm volatile("csrr %0, time" : "=r" (x) );
+    800024c8:	c01027f3          	rdtime	a5
+  }
+
+  // ask for the next timer interrupt. this also clears
+  // the interrupt request. 1000000 is about a tenth
+  // of a second.
+  w_stimecmp(r_time() + 1000000);
+    800024cc:	000f4737          	lui	a4,0xf4
+    800024d0:	24070713          	addi	a4,a4,576 # f4240 <_entry-0x7ff0bdc0>
+    800024d4:	97ba                	add	a5,a5,a4
+  asm volatile("csrw 0x14d, %0" : : "r" (x));
+    800024d6:	14d79073          	csrw	stimecmp,a5
+}
+    800024da:	60e2                	ld	ra,24(sp)
+    800024dc:	6442                	ld	s0,16(sp)
+    800024de:	6105                	addi	sp,sp,32
+    800024e0:	8082                	ret
+    800024e2:	e426                	sd	s1,8(sp)
+    acquire(&tickslock);
+    800024e4:	00016497          	auipc	s1,0x16
+    800024e8:	64448493          	addi	s1,s1,1604 # 80018b28 <tickslock>
+    800024ec:	8526                	mv	a0,s1
+    800024ee:	ee0fe0ef          	jal	80000bce <acquire>
+    ticks++;
+    800024f2:	00008517          	auipc	a0,0x8
+    800024f6:	cf650513          	addi	a0,a0,-778 # 8000a1e8 <ticks>
+    800024fa:	411c                	lw	a5,0(a0)
+    800024fc:	2785                	addiw	a5,a5,1
+    800024fe:	c11c                	sw	a5,0(a0)
+    wakeup(&ticks);
+    80002500:	a29ff0ef          	jal	80001f28 <wakeup>
+    release(&tickslock);
+    80002504:	8526                	mv	a0,s1
+    80002506:	f60fe0ef          	jal	80000c66 <release>
+    8000250a:	64a2                	ld	s1,8(sp)
+    8000250c:	bf75                	j	800024c8 <clockintr+0xe>
+
+000000008000250e <devintr>:
+// returns 2 if timer interrupt,
+// 1 if other device,
+// 0 if not recognized.
+int
+devintr()
+{
+    8000250e:	1101                	addi	sp,sp,-32
+    80002510:	ec06                	sd	ra,24(sp)
+    80002512:	e822                	sd	s0,16(sp)
+    80002514:	1000                	addi	s0,sp,32
+  asm volatile("csrr %0, scause" : "=r" (x) );
+    80002516:	14202773          	csrr	a4,scause
+  uint64 scause = r_scause();
+
+  if(scause == 0x8000000000000009L){
+    8000251a:	57fd                	li	a5,-1
+    8000251c:	17fe                	slli	a5,a5,0x3f
+    8000251e:	07a5                	addi	a5,a5,9
+    80002520:	00f70c63          	beq	a4,a5,80002538 <devintr+0x2a>
+    // now allowed to interrupt again.
+    if(irq)
+      plic_complete(irq);
+
+    return 1;
+  } else if(scause == 0x8000000000000005L){
+    80002524:	57fd                	li	a5,-1
+    80002526:	17fe                	slli	a5,a5,0x3f
+    80002528:	0795                	addi	a5,a5,5
+    // timer interrupt.
+    clockintr();
+    return 2;
+  } else {
+    return 0;
+    8000252a:	4501                	li	a0,0
+  } else if(scause == 0x8000000000000005L){
+    8000252c:	04f70763          	beq	a4,a5,8000257a <devintr+0x6c>
+  }
+}
+    80002530:	60e2                	ld	ra,24(sp)
+    80002532:	6442                	ld	s0,16(sp)
+    80002534:	6105                	addi	sp,sp,32
+    80002536:	8082                	ret
+    80002538:	e426                	sd	s1,8(sp)
+    int irq = plic_claim();
+    8000253a:	703020ef          	jal	8000543c <plic_claim>
+    8000253e:	84aa                	mv	s1,a0
+    if(irq == UART0_IRQ){
+    80002540:	47a9                	li	a5,10
+    80002542:	00f50963          	beq	a0,a5,80002554 <devintr+0x46>
+    } else if(irq == VIRTIO0_IRQ){
+    80002546:	4785                	li	a5,1
+    80002548:	00f50963          	beq	a0,a5,8000255a <devintr+0x4c>
+    return 1;
+    8000254c:	4505                	li	a0,1
+    } else if(irq){
+    8000254e:	e889                	bnez	s1,80002560 <devintr+0x52>
+    80002550:	64a2                	ld	s1,8(sp)
+    80002552:	bff9                	j	80002530 <devintr+0x22>
+      uartintr();
+    80002554:	c5cfe0ef          	jal	800009b0 <uartintr>
+    if(irq)
+    80002558:	a819                	j	8000256e <devintr+0x60>
+      virtio_disk_intr();
+    8000255a:	3a8030ef          	jal	80005902 <virtio_disk_intr>
+    if(irq)
+    8000255e:	a801                	j	8000256e <devintr+0x60>
+      printf("unexpected interrupt irq=%d\n", irq);
+    80002560:	85a6                	mv	a1,s1
+    80002562:	00005517          	auipc	a0,0x5
+    80002566:	d1e50513          	addi	a0,a0,-738 # 80007280 <etext+0x280>
+    8000256a:	f91fd0ef          	jal	800004fa <printf>
+      plic_complete(irq);
+    8000256e:	8526                	mv	a0,s1
+    80002570:	6ed020ef          	jal	8000545c <plic_complete>
+    return 1;
+    80002574:	4505                	li	a0,1
+    80002576:	64a2                	ld	s1,8(sp)
+    80002578:	bf65                	j	80002530 <devintr+0x22>
+    clockintr();
+    8000257a:	f41ff0ef          	jal	800024ba <clockintr>
+    return 2;
+    8000257e:	4509                	li	a0,2
+    80002580:	bf45                	j	80002530 <devintr+0x22>
+
+0000000080002582 <usertrap>:
+{
+    80002582:	1101                	addi	sp,sp,-32
+    80002584:	ec06                	sd	ra,24(sp)
+    80002586:	e822                	sd	s0,16(sp)
+    80002588:	e426                	sd	s1,8(sp)
+    8000258a:	e04a                	sd	s2,0(sp)
+    8000258c:	1000                	addi	s0,sp,32
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    8000258e:	100027f3          	csrr	a5,sstatus
+  if((r_sstatus() & SSTATUS_SPP) != 0)
+    80002592:	1007f793          	andi	a5,a5,256
+    80002596:	eba5                	bnez	a5,80002606 <usertrap+0x84>
+  asm volatile("csrw stvec, %0" : : "r" (x));
+    80002598:	00003797          	auipc	a5,0x3
+    8000259c:	df878793          	addi	a5,a5,-520 # 80005390 <kernelvec>
+    800025a0:	10579073          	csrw	stvec,a5
+  struct proc *p = myproc();
+    800025a4:	b2aff0ef          	jal	800018ce <myproc>
+    800025a8:	84aa                	mv	s1,a0
+  p->trapframe->epc = r_sepc();
+    800025aa:	6d3c                	ld	a5,88(a0)
+  asm volatile("csrr %0, sepc" : "=r" (x) );
+    800025ac:	14102773          	csrr	a4,sepc
+    800025b0:	ef98                	sd	a4,24(a5)
+  asm volatile("csrr %0, scause" : "=r" (x) );
+    800025b2:	14202773          	csrr	a4,scause
+  if(r_scause() == 8){
+    800025b6:	47a1                	li	a5,8
+    800025b8:	04f70d63          	beq	a4,a5,80002612 <usertrap+0x90>
+  } else if((which_dev = devintr()) != 0){
+    800025bc:	f53ff0ef          	jal	8000250e <devintr>
+    800025c0:	892a                	mv	s2,a0
+    800025c2:	e945                	bnez	a0,80002672 <usertrap+0xf0>
+    800025c4:	14202773          	csrr	a4,scause
+  } else if((r_scause() == 15 || r_scause() == 13) &&
+    800025c8:	47bd                	li	a5,15
+    800025ca:	08f70863          	beq	a4,a5,8000265a <usertrap+0xd8>
+    800025ce:	14202773          	csrr	a4,scause
+    800025d2:	47b5                	li	a5,13
+    800025d4:	08f70363          	beq	a4,a5,8000265a <usertrap+0xd8>
+    800025d8:	142025f3          	csrr	a1,scause
+    printf("usertrap(): unexpected scause 0x%lx pid=%d\n", r_scause(), p->pid);
+    800025dc:	5890                	lw	a2,48(s1)
+    800025de:	00005517          	auipc	a0,0x5
+    800025e2:	ce250513          	addi	a0,a0,-798 # 800072c0 <etext+0x2c0>
+    800025e6:	f15fd0ef          	jal	800004fa <printf>
+  asm volatile("csrr %0, sepc" : "=r" (x) );
+    800025ea:	141025f3          	csrr	a1,sepc
+  asm volatile("csrr %0, stval" : "=r" (x) );
+    800025ee:	14302673          	csrr	a2,stval
+    printf("            sepc=0x%lx stval=0x%lx\n", r_sepc(), r_stval());
+    800025f2:	00005517          	auipc	a0,0x5
+    800025f6:	cfe50513          	addi	a0,a0,-770 # 800072f0 <etext+0x2f0>
+    800025fa:	f01fd0ef          	jal	800004fa <printf>
+    setkilled(p);
+    800025fe:	8526                	mv	a0,s1
+    80002600:	af1ff0ef          	jal	800020f0 <setkilled>
+    80002604:	a035                	j	80002630 <usertrap+0xae>
+    panic("usertrap: not from user mode");
+    80002606:	00005517          	auipc	a0,0x5
+    8000260a:	c9a50513          	addi	a0,a0,-870 # 800072a0 <etext+0x2a0>
+    8000260e:	9d2fe0ef          	jal	800007e0 <panic>
+    if(killed(p))
+    80002612:	b03ff0ef          	jal	80002114 <killed>
+    80002616:	ed15                	bnez	a0,80002652 <usertrap+0xd0>
+    p->trapframe->epc += 4;
+    80002618:	6cb8                	ld	a4,88(s1)
+    8000261a:	6f1c                	ld	a5,24(a4)
+    8000261c:	0791                	addi	a5,a5,4
+    8000261e:	ef1c                	sd	a5,24(a4)
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    80002620:	100027f3          	csrr	a5,sstatus
+  w_sstatus(r_sstatus() | SSTATUS_SIE);
+    80002624:	0027e793          	ori	a5,a5,2
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    80002628:	10079073          	csrw	sstatus,a5
+    syscall();
+    8000262c:	246000ef          	jal	80002872 <syscall>
+  if(killed(p))
+    80002630:	8526                	mv	a0,s1
+    80002632:	ae3ff0ef          	jal	80002114 <killed>
+    80002636:	e139                	bnez	a0,8000267c <usertrap+0xfa>
+  prepare_return();
+    80002638:	e09ff0ef          	jal	80002440 <prepare_return>
+  uint64 satp = MAKE_SATP(p->pagetable);
+    8000263c:	68a8                	ld	a0,80(s1)
+    8000263e:	8131                	srli	a0,a0,0xc
+    80002640:	57fd                	li	a5,-1
+    80002642:	17fe                	slli	a5,a5,0x3f
+    80002644:	8d5d                	or	a0,a0,a5
+}
+    80002646:	60e2                	ld	ra,24(sp)
+    80002648:	6442                	ld	s0,16(sp)
+    8000264a:	64a2                	ld	s1,8(sp)
+    8000264c:	6902                	ld	s2,0(sp)
+    8000264e:	6105                	addi	sp,sp,32
+    80002650:	8082                	ret
+      kexit(-1);
+    80002652:	557d                	li	a0,-1
+    80002654:	995ff0ef          	jal	80001fe8 <kexit>
+    80002658:	b7c1                	j	80002618 <usertrap+0x96>
+  asm volatile("csrr %0, stval" : "=r" (x) );
+    8000265a:	143025f3          	csrr	a1,stval
+  asm volatile("csrr %0, scause" : "=r" (x) );
+    8000265e:	14202673          	csrr	a2,scause
+            vmfault(p->pagetable, r_stval(), (r_scause() == 13)? 1 : 0) != 0) {
+    80002662:	164d                	addi	a2,a2,-13 # ff3 <_entry-0x7ffff00d>
+    80002664:	00163613          	seqz	a2,a2
+    80002668:	68a8                	ld	a0,80(s1)
+    8000266a:	ef7fe0ef          	jal	80001560 <vmfault>
+  } else if((r_scause() == 15 || r_scause() == 13) &&
+    8000266e:	f169                	bnez	a0,80002630 <usertrap+0xae>
+    80002670:	b7a5                	j	800025d8 <usertrap+0x56>
+  if(killed(p))
+    80002672:	8526                	mv	a0,s1
+    80002674:	aa1ff0ef          	jal	80002114 <killed>
+    80002678:	c511                	beqz	a0,80002684 <usertrap+0x102>
+    8000267a:	a011                	j	8000267e <usertrap+0xfc>
+    8000267c:	4901                	li	s2,0
+    kexit(-1);
+    8000267e:	557d                	li	a0,-1
+    80002680:	969ff0ef          	jal	80001fe8 <kexit>
+if(which_dev == 2) {
+    80002684:	4789                	li	a5,2
+    80002686:	faf919e3          	bne	s2,a5,80002638 <usertrap+0xb6>
+    yield();
+    8000268a:	827ff0ef          	jal	80001eb0 <yield>
+    8000268e:	b76d                	j	80002638 <usertrap+0xb6>
+
+0000000080002690 <kerneltrap>:
+{
+    80002690:	7179                	addi	sp,sp,-48
+    80002692:	f406                	sd	ra,40(sp)
+    80002694:	f022                	sd	s0,32(sp)
+    80002696:	ec26                	sd	s1,24(sp)
+    80002698:	e84a                	sd	s2,16(sp)
+    8000269a:	e44e                	sd	s3,8(sp)
+    8000269c:	1800                	addi	s0,sp,48
+  asm volatile("csrr %0, sepc" : "=r" (x) );
+    8000269e:	14102973          	csrr	s2,sepc
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    800026a2:	100024f3          	csrr	s1,sstatus
+  asm volatile("csrr %0, scause" : "=r" (x) );
+    800026a6:	142029f3          	csrr	s3,scause
+  if((sstatus & SSTATUS_SPP) == 0)
+    800026aa:	1004f793          	andi	a5,s1,256
+    800026ae:	c795                	beqz	a5,800026da <kerneltrap+0x4a>
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+    800026b0:	100027f3          	csrr	a5,sstatus
+  return (x & SSTATUS_SIE) != 0;
+    800026b4:	8b89                	andi	a5,a5,2
+  if(intr_get() != 0)
+    800026b6:	eb85                	bnez	a5,800026e6 <kerneltrap+0x56>
+  if((which_dev = devintr()) == 0){
+    800026b8:	e57ff0ef          	jal	8000250e <devintr>
+    800026bc:	c91d                	beqz	a0,800026f2 <kerneltrap+0x62>
+ if (which_dev == 2 && myproc() != 0) {
+    800026be:	4789                	li	a5,2
+    800026c0:	04f50a63          	beq	a0,a5,80002714 <kerneltrap+0x84>
+  asm volatile("csrw sepc, %0" : : "r" (x));
+    800026c4:	14191073          	csrw	sepc,s2
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+    800026c8:	10049073          	csrw	sstatus,s1
+}
+    800026cc:	70a2                	ld	ra,40(sp)
+    800026ce:	7402                	ld	s0,32(sp)
+    800026d0:	64e2                	ld	s1,24(sp)
+    800026d2:	6942                	ld	s2,16(sp)
+    800026d4:	69a2                	ld	s3,8(sp)
+    800026d6:	6145                	addi	sp,sp,48
+    800026d8:	8082                	ret
+    panic("kerneltrap: not from supervisor mode");
+    800026da:	00005517          	auipc	a0,0x5
+    800026de:	c3e50513          	addi	a0,a0,-962 # 80007318 <etext+0x318>
+    800026e2:	8fefe0ef          	jal	800007e0 <panic>
+    panic("kerneltrap: interrupts enabled");
+    800026e6:	00005517          	auipc	a0,0x5
+    800026ea:	c5a50513          	addi	a0,a0,-934 # 80007340 <etext+0x340>
+    800026ee:	8f2fe0ef          	jal	800007e0 <panic>
+  asm volatile("csrr %0, sepc" : "=r" (x) );
+    800026f2:	14102673          	csrr	a2,sepc
+  asm volatile("csrr %0, stval" : "=r" (x) );
+    800026f6:	143026f3          	csrr	a3,stval
+    printf("scause=0x%lx sepc=0x%lx stval=0x%lx\n", scause, r_sepc(), r_stval());
+    800026fa:	85ce                	mv	a1,s3
+    800026fc:	00005517          	auipc	a0,0x5
+    80002700:	c6450513          	addi	a0,a0,-924 # 80007360 <etext+0x360>
+    80002704:	df7fd0ef          	jal	800004fa <printf>
+    panic("kerneltrap");
+    80002708:	00005517          	auipc	a0,0x5
+    8000270c:	c8050513          	addi	a0,a0,-896 # 80007388 <etext+0x388>
+    80002710:	8d0fe0ef          	jal	800007e0 <panic>
+ if (which_dev == 2 && myproc() != 0) {
+    80002714:	9baff0ef          	jal	800018ce <myproc>
+    80002718:	d555                	beqz	a0,800026c4 <kerneltrap+0x34>
+     yield();
+    8000271a:	f96ff0ef          	jal	80001eb0 <yield>
+    8000271e:	b75d                	j	800026c4 <kerneltrap+0x34>
+
+0000000080002720 <argraw>:
+  return strlen(buf);
+}
+
+static uint64
+argraw(int n)
+{
+    80002720:	1101                	addi	sp,sp,-32
+    80002722:	ec06                	sd	ra,24(sp)
+    80002724:	e822                	sd	s0,16(sp)
+    80002726:	e426                	sd	s1,8(sp)
+    80002728:	1000                	addi	s0,sp,32
+    8000272a:	84aa                	mv	s1,a0
+  struct proc *p = myproc();
+    8000272c:	9a2ff0ef          	jal	800018ce <myproc>
+  switch (n) {
+    80002730:	4795                	li	a5,5
+    80002732:	0497e163          	bltu	a5,s1,80002774 <argraw+0x54>
+    80002736:	048a                	slli	s1,s1,0x2
+    80002738:	00005717          	auipc	a4,0x5
+    8000273c:	05070713          	addi	a4,a4,80 # 80007788 <states.0+0x30>
+    80002740:	94ba                	add	s1,s1,a4
+    80002742:	409c                	lw	a5,0(s1)
+    80002744:	97ba                	add	a5,a5,a4
+    80002746:	8782                	jr	a5
+  case 0:
+    return p->trapframe->a0;
+    80002748:	6d3c                	ld	a5,88(a0)
+    8000274a:	7ba8                	ld	a0,112(a5)
+  case 5:
+    return p->trapframe->a5;
+  }
+  panic("argraw");
+  return -1;
+}
+    8000274c:	60e2                	ld	ra,24(sp)
+    8000274e:	6442                	ld	s0,16(sp)
+    80002750:	64a2                	ld	s1,8(sp)
+    80002752:	6105                	addi	sp,sp,32
+    80002754:	8082                	ret
+    return p->trapframe->a1;
+    80002756:	6d3c                	ld	a5,88(a0)
+    80002758:	7fa8                	ld	a0,120(a5)
+    8000275a:	bfcd                	j	8000274c <argraw+0x2c>
+    return p->trapframe->a2;
+    8000275c:	6d3c                	ld	a5,88(a0)
+    8000275e:	63c8                	ld	a0,128(a5)
+    80002760:	b7f5                	j	8000274c <argraw+0x2c>
+    return p->trapframe->a3;
+    80002762:	6d3c                	ld	a5,88(a0)
+    80002764:	67c8                	ld	a0,136(a5)
+    80002766:	b7dd                	j	8000274c <argraw+0x2c>
+    return p->trapframe->a4;
+    80002768:	6d3c                	ld	a5,88(a0)
+    8000276a:	6bc8                	ld	a0,144(a5)
+    8000276c:	b7c5                	j	8000274c <argraw+0x2c>
+    return p->trapframe->a5;
+    8000276e:	6d3c                	ld	a5,88(a0)
+    80002770:	6fc8                	ld	a0,152(a5)
+    80002772:	bfe9                	j	8000274c <argraw+0x2c>
+  panic("argraw");
+    80002774:	00005517          	auipc	a0,0x5
+    80002778:	c2450513          	addi	a0,a0,-988 # 80007398 <etext+0x398>
+    8000277c:	864fe0ef          	jal	800007e0 <panic>
+
+0000000080002780 <fetchaddr>:
+{
+    80002780:	1101                	addi	sp,sp,-32
+    80002782:	ec06                	sd	ra,24(sp)
+    80002784:	e822                	sd	s0,16(sp)
+    80002786:	e426                	sd	s1,8(sp)
+    80002788:	e04a                	sd	s2,0(sp)
+    8000278a:	1000                	addi	s0,sp,32
+    8000278c:	84aa                	mv	s1,a0
+    8000278e:	892e                	mv	s2,a1
+  struct proc *p = myproc();
+    80002790:	93eff0ef          	jal	800018ce <myproc>
+  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
+    80002794:	653c                	ld	a5,72(a0)
+    80002796:	02f4f663          	bgeu	s1,a5,800027c2 <fetchaddr+0x42>
+    8000279a:	00848713          	addi	a4,s1,8
+    8000279e:	02e7e463          	bltu	a5,a4,800027c6 <fetchaddr+0x46>
+  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
+    800027a2:	46a1                	li	a3,8
+    800027a4:	8626                	mv	a2,s1
+    800027a6:	85ca                	mv	a1,s2
+    800027a8:	6928                	ld	a0,80(a0)
+    800027aa:	f1dfe0ef          	jal	800016c6 <copyin>
+    800027ae:	00a03533          	snez	a0,a0
+    800027b2:	40a00533          	neg	a0,a0
+}
+    800027b6:	60e2                	ld	ra,24(sp)
+    800027b8:	6442                	ld	s0,16(sp)
+    800027ba:	64a2                	ld	s1,8(sp)
+    800027bc:	6902                	ld	s2,0(sp)
+    800027be:	6105                	addi	sp,sp,32
+    800027c0:	8082                	ret
+    return -1;
+    800027c2:	557d                	li	a0,-1
+    800027c4:	bfcd                	j	800027b6 <fetchaddr+0x36>
+    800027c6:	557d                	li	a0,-1
+    800027c8:	b7fd                	j	800027b6 <fetchaddr+0x36>
+
+00000000800027ca <fetchstr>:
+{
+    800027ca:	7179                	addi	sp,sp,-48
+    800027cc:	f406                	sd	ra,40(sp)
+    800027ce:	f022                	sd	s0,32(sp)
+    800027d0:	ec26                	sd	s1,24(sp)
+    800027d2:	e84a                	sd	s2,16(sp)
+    800027d4:	e44e                	sd	s3,8(sp)
+    800027d6:	1800                	addi	s0,sp,48
+    800027d8:	892a                	mv	s2,a0
+    800027da:	84ae                	mv	s1,a1
+    800027dc:	89b2                	mv	s3,a2
+  struct proc *p = myproc();
+    800027de:	8f0ff0ef          	jal	800018ce <myproc>
+  if(copyinstr(p->pagetable, buf, addr, max) < 0)
+    800027e2:	86ce                	mv	a3,s3
+    800027e4:	864a                	mv	a2,s2
+    800027e6:	85a6                	mv	a1,s1
+    800027e8:	6928                	ld	a0,80(a0)
+    800027ea:	c9ffe0ef          	jal	80001488 <copyinstr>
+    800027ee:	00054c63          	bltz	a0,80002806 <fetchstr+0x3c>
+  return strlen(buf);
+    800027f2:	8526                	mv	a0,s1
+    800027f4:	e1efe0ef          	jal	80000e12 <strlen>
+}
+    800027f8:	70a2                	ld	ra,40(sp)
+    800027fa:	7402                	ld	s0,32(sp)
+    800027fc:	64e2                	ld	s1,24(sp)
+    800027fe:	6942                	ld	s2,16(sp)
+    80002800:	69a2                	ld	s3,8(sp)
+    80002802:	6145                	addi	sp,sp,48
+    80002804:	8082                	ret
+    return -1;
+    80002806:	557d                	li	a0,-1
+    80002808:	bfc5                	j	800027f8 <fetchstr+0x2e>
+
+000000008000280a <argint>:
+
+// Fetch the nth 32-bit system call argument.
+void
+argint(int n, int *ip)
+{
+    8000280a:	1101                	addi	sp,sp,-32
+    8000280c:	ec06                	sd	ra,24(sp)
+    8000280e:	e822                	sd	s0,16(sp)
+    80002810:	e426                	sd	s1,8(sp)
+    80002812:	1000                	addi	s0,sp,32
+    80002814:	84ae                	mv	s1,a1
+  *ip = argraw(n);
+    80002816:	f0bff0ef          	jal	80002720 <argraw>
+    8000281a:	c088                	sw	a0,0(s1)
+}
+    8000281c:	60e2                	ld	ra,24(sp)
+    8000281e:	6442                	ld	s0,16(sp)
+    80002820:	64a2                	ld	s1,8(sp)
+    80002822:	6105                	addi	sp,sp,32
+    80002824:	8082                	ret
+
+0000000080002826 <argaddr>:
+// Retrieve an argument as a pointer.
+// Doesn't check for legality, since
+// copyin/copyout will do that.
+void
+argaddr(int n, uint64 *ip)
+{
+    80002826:	1101                	addi	sp,sp,-32
+    80002828:	ec06                	sd	ra,24(sp)
+    8000282a:	e822                	sd	s0,16(sp)
+    8000282c:	e426                	sd	s1,8(sp)
+    8000282e:	1000                	addi	s0,sp,32
+    80002830:	84ae                	mv	s1,a1
+  *ip = argraw(n);
+    80002832:	eefff0ef          	jal	80002720 <argraw>
+    80002836:	e088                	sd	a0,0(s1)
+}
+    80002838:	60e2                	ld	ra,24(sp)
+    8000283a:	6442                	ld	s0,16(sp)
+    8000283c:	64a2                	ld	s1,8(sp)
+    8000283e:	6105                	addi	sp,sp,32
+    80002840:	8082                	ret
+
+0000000080002842 <argstr>:
+// Fetch the nth word-sized system call argument as a null-terminated string.
+// Copies into buf, at most max.
+// Returns string length if OK (including nul), -1 if error.
+int
+argstr(int n, char *buf, int max)
+{
+    80002842:	7179                	addi	sp,sp,-48
+    80002844:	f406                	sd	ra,40(sp)
+    80002846:	f022                	sd	s0,32(sp)
+    80002848:	ec26                	sd	s1,24(sp)
+    8000284a:	e84a                	sd	s2,16(sp)
+    8000284c:	1800                	addi	s0,sp,48
+    8000284e:	84ae                	mv	s1,a1
+    80002850:	8932                	mv	s2,a2
+  uint64 addr;
+  argaddr(n, &addr);
+    80002852:	fd840593          	addi	a1,s0,-40
+    80002856:	fd1ff0ef          	jal	80002826 <argaddr>
+  return fetchstr(addr, buf, max);
+    8000285a:	864a                	mv	a2,s2
+    8000285c:	85a6                	mv	a1,s1
+    8000285e:	fd843503          	ld	a0,-40(s0)
+    80002862:	f69ff0ef          	jal	800027ca <fetchstr>
+}
+    80002866:	70a2                	ld	ra,40(sp)
+    80002868:	7402                	ld	s0,32(sp)
+    8000286a:	64e2                	ld	s1,24(sp)
+    8000286c:	6942                	ld	s2,16(sp)
+    8000286e:	6145                	addi	sp,sp,48
+    80002870:	8082                	ret
+
+0000000080002872 <syscall>:
+[SYS_getreadcount] sys_getreadcount,
+};
+
+void
+syscall(void)
+{
+    80002872:	1101                	addi	sp,sp,-32
+    80002874:	ec06                	sd	ra,24(sp)
+    80002876:	e822                	sd	s0,16(sp)
+    80002878:	e426                	sd	s1,8(sp)
+    8000287a:	e04a                	sd	s2,0(sp)
+    8000287c:	1000                	addi	s0,sp,32
+  int num;
+  struct proc *p = myproc();
+    8000287e:	850ff0ef          	jal	800018ce <myproc>
+    80002882:	84aa                	mv	s1,a0
+
+  num = p->trapframe->a7;
+    80002884:	05853903          	ld	s2,88(a0)
+    80002888:	0a893783          	ld	a5,168(s2)
+    8000288c:	0007869b          	sext.w	a3,a5
+  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
+    80002890:	37fd                	addiw	a5,a5,-1
+    80002892:	4755                	li	a4,21
+    80002894:	00f76f63          	bltu	a4,a5,800028b2 <syscall+0x40>
+    80002898:	00369713          	slli	a4,a3,0x3
+    8000289c:	00005797          	auipc	a5,0x5
+    800028a0:	f0478793          	addi	a5,a5,-252 # 800077a0 <syscalls>
+    800028a4:	97ba                	add	a5,a5,a4
+    800028a6:	639c                	ld	a5,0(a5)
+    800028a8:	c789                	beqz	a5,800028b2 <syscall+0x40>
+    // Use num to lookup the system call function for num, call it,
+    // and store its return value in p->trapframe->a0
+    p->trapframe->a0 = syscalls[num]();
+    800028aa:	9782                	jalr	a5
+    800028ac:	06a93823          	sd	a0,112(s2)
+    800028b0:	a829                	j	800028ca <syscall+0x58>
+  } else {
+    printf("%d %s: unknown sys call %d\n",
+    800028b2:	15848613          	addi	a2,s1,344
+    800028b6:	588c                	lw	a1,48(s1)
+    800028b8:	00005517          	auipc	a0,0x5
+    800028bc:	ae850513          	addi	a0,a0,-1304 # 800073a0 <etext+0x3a0>
+    800028c0:	c3bfd0ef          	jal	800004fa <printf>
+            p->pid, p->name, num);
+    p->trapframe->a0 = -1;
+    800028c4:	6cbc                	ld	a5,88(s1)
+    800028c6:	577d                	li	a4,-1
+    800028c8:	fbb8                	sd	a4,112(a5)
+  }
+}
+    800028ca:	60e2                	ld	ra,24(sp)
+    800028cc:	6442                	ld	s0,16(sp)
+    800028ce:	64a2                	ld	s1,8(sp)
+    800028d0:	6902                	ld	s2,0(sp)
+    800028d2:	6105                	addi	sp,sp,32
+    800028d4:	8082                	ret
+
+00000000800028d6 <sys_exit>:
+#include "proc.h"
+#include "vm.h"
+
+uint64
+sys_exit(void)
+{
+    800028d6:	1101                	addi	sp,sp,-32
+    800028d8:	ec06                	sd	ra,24(sp)
+    800028da:	e822                	sd	s0,16(sp)
+    800028dc:	1000                	addi	s0,sp,32
+  int n;
+  argint(0, &n);
+    800028de:	fec40593          	addi	a1,s0,-20
+    800028e2:	4501                	li	a0,0
+    800028e4:	f27ff0ef          	jal	8000280a <argint>
+  kexit(n);
+    800028e8:	fec42503          	lw	a0,-20(s0)
+    800028ec:	efcff0ef          	jal	80001fe8 <kexit>
+  return 0;  // not reached
+}
+    800028f0:	4501                	li	a0,0
+    800028f2:	60e2                	ld	ra,24(sp)
+    800028f4:	6442                	ld	s0,16(sp)
+    800028f6:	6105                	addi	sp,sp,32
+    800028f8:	8082                	ret
+
+00000000800028fa <sys_getpid>:
+
+uint64
+sys_getpid(void)
+{
+    800028fa:	1141                	addi	sp,sp,-16
+    800028fc:	e406                	sd	ra,8(sp)
+    800028fe:	e022                	sd	s0,0(sp)
+    80002900:	0800                	addi	s0,sp,16
+  return myproc()->pid;
+    80002902:	fcdfe0ef          	jal	800018ce <myproc>
+}
+    80002906:	5908                	lw	a0,48(a0)
+    80002908:	60a2                	ld	ra,8(sp)
+    8000290a:	6402                	ld	s0,0(sp)
+    8000290c:	0141                	addi	sp,sp,16
+    8000290e:	8082                	ret
+
+0000000080002910 <sys_fork>:
+
+uint64
+sys_fork(void)
+{
+    80002910:	1141                	addi	sp,sp,-16
+    80002912:	e406                	sd	ra,8(sp)
+    80002914:	e022                	sd	s0,0(sp)
+    80002916:	0800                	addi	s0,sp,16
+  return kfork();
+    80002918:	b2cff0ef          	jal	80001c44 <kfork>
+}
+    8000291c:	60a2                	ld	ra,8(sp)
+    8000291e:	6402                	ld	s0,0(sp)
+    80002920:	0141                	addi	sp,sp,16
+    80002922:	8082                	ret
+
+0000000080002924 <sys_wait>:
+
+uint64
+sys_wait(void)
+{
+    80002924:	1101                	addi	sp,sp,-32
+    80002926:	ec06                	sd	ra,24(sp)
+    80002928:	e822                	sd	s0,16(sp)
+    8000292a:	1000                	addi	s0,sp,32
+  uint64 p;
+  argaddr(0, &p);
+    8000292c:	fe840593          	addi	a1,s0,-24
+    80002930:	4501                	li	a0,0
+    80002932:	ef5ff0ef          	jal	80002826 <argaddr>
+  return kwait(p);
+    80002936:	fe843503          	ld	a0,-24(s0)
+    8000293a:	805ff0ef          	jal	8000213e <kwait>
+}
+    8000293e:	60e2                	ld	ra,24(sp)
+    80002940:	6442                	ld	s0,16(sp)
+    80002942:	6105                	addi	sp,sp,32
+    80002944:	8082                	ret
+
+0000000080002946 <sys_sbrk>:
+
+uint64
+sys_sbrk(void)
+{
+    80002946:	7179                	addi	sp,sp,-48
+    80002948:	f406                	sd	ra,40(sp)
+    8000294a:	f022                	sd	s0,32(sp)
+    8000294c:	ec26                	sd	s1,24(sp)
+    8000294e:	1800                	addi	s0,sp,48
+  uint64 addr;
+  int t;
+  int n;
+
+  argint(0, &n);
+    80002950:	fd840593          	addi	a1,s0,-40
+    80002954:	4501                	li	a0,0
+    80002956:	eb5ff0ef          	jal	8000280a <argint>
+  argint(1, &t);
+    8000295a:	fdc40593          	addi	a1,s0,-36
+    8000295e:	4505                	li	a0,1
+    80002960:	eabff0ef          	jal	8000280a <argint>
+  addr = myproc()->sz;
+    80002964:	f6bfe0ef          	jal	800018ce <myproc>
+    80002968:	6524                	ld	s1,72(a0)
+
+  if(t == SBRK_EAGER || n < 0) {
+    8000296a:	fdc42703          	lw	a4,-36(s0)
+    8000296e:	4785                	li	a5,1
+    80002970:	02f70163          	beq	a4,a5,80002992 <sys_sbrk+0x4c>
+    80002974:	fd842783          	lw	a5,-40(s0)
+    80002978:	0007cd63          	bltz	a5,80002992 <sys_sbrk+0x4c>
+    }
+  } else {
+    // Lazily allocate memory for this process: increase its memory
+    // size but don't allocate memory. If the processes uses the
+    // memory, vmfault() will allocate it.
+    if(addr + n < addr)
+    8000297c:	97a6                	add	a5,a5,s1
+    8000297e:	0297e863          	bltu	a5,s1,800029ae <sys_sbrk+0x68>
+      return -1;
+    myproc()->sz += n;
+    80002982:	f4dfe0ef          	jal	800018ce <myproc>
+    80002986:	fd842703          	lw	a4,-40(s0)
+    8000298a:	653c                	ld	a5,72(a0)
+    8000298c:	97ba                	add	a5,a5,a4
+    8000298e:	e53c                	sd	a5,72(a0)
+    80002990:	a039                	j	8000299e <sys_sbrk+0x58>
+    if(growproc(n) < 0) {
+    80002992:	fd842503          	lw	a0,-40(s0)
+    80002996:	a5eff0ef          	jal	80001bf4 <growproc>
+    8000299a:	00054863          	bltz	a0,800029aa <sys_sbrk+0x64>
+  }
+  return addr;
+}
+    8000299e:	8526                	mv	a0,s1
+    800029a0:	70a2                	ld	ra,40(sp)
+    800029a2:	7402                	ld	s0,32(sp)
+    800029a4:	64e2                	ld	s1,24(sp)
+    800029a6:	6145                	addi	sp,sp,48
+    800029a8:	8082                	ret
+      return -1;
+    800029aa:	54fd                	li	s1,-1
+    800029ac:	bfcd                	j	8000299e <sys_sbrk+0x58>
+      return -1;
+    800029ae:	54fd                	li	s1,-1
+    800029b0:	b7fd                	j	8000299e <sys_sbrk+0x58>
+
+00000000800029b2 <sys_pause>:
+
+uint64
+sys_pause(void)
+{
+    800029b2:	7139                	addi	sp,sp,-64
+    800029b4:	fc06                	sd	ra,56(sp)
+    800029b6:	f822                	sd	s0,48(sp)
+    800029b8:	f04a                	sd	s2,32(sp)
+    800029ba:	0080                	addi	s0,sp,64
+  int n;
+  uint ticks0;
+
+  argint(0, &n);
+    800029bc:	fcc40593          	addi	a1,s0,-52
+    800029c0:	4501                	li	a0,0
+    800029c2:	e49ff0ef          	jal	8000280a <argint>
+  if(n < 0)
+    800029c6:	fcc42783          	lw	a5,-52(s0)
+    800029ca:	0607c763          	bltz	a5,80002a38 <sys_pause+0x86>
+    n = 0;
+  acquire(&tickslock);
+    800029ce:	00016517          	auipc	a0,0x16
+    800029d2:	15a50513          	addi	a0,a0,346 # 80018b28 <tickslock>
+    800029d6:	9f8fe0ef          	jal	80000bce <acquire>
+  ticks0 = ticks;
+    800029da:	00008917          	auipc	s2,0x8
+    800029de:	80e92903          	lw	s2,-2034(s2) # 8000a1e8 <ticks>
+  while(ticks - ticks0 < n){
+    800029e2:	fcc42783          	lw	a5,-52(s0)
+    800029e6:	cf8d                	beqz	a5,80002a20 <sys_pause+0x6e>
+    800029e8:	f426                	sd	s1,40(sp)
+    800029ea:	ec4e                	sd	s3,24(sp)
+    if(killed(myproc())){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+    800029ec:	00016997          	auipc	s3,0x16
+    800029f0:	13c98993          	addi	s3,s3,316 # 80018b28 <tickslock>
+    800029f4:	00007497          	auipc	s1,0x7
+    800029f8:	7f448493          	addi	s1,s1,2036 # 8000a1e8 <ticks>
+    if(killed(myproc())){
+    800029fc:	ed3fe0ef          	jal	800018ce <myproc>
+    80002a00:	f14ff0ef          	jal	80002114 <killed>
+    80002a04:	ed0d                	bnez	a0,80002a3e <sys_pause+0x8c>
+    sleep(&ticks, &tickslock);
+    80002a06:	85ce                	mv	a1,s3
+    80002a08:	8526                	mv	a0,s1
+    80002a0a:	cd2ff0ef          	jal	80001edc <sleep>
+  while(ticks - ticks0 < n){
+    80002a0e:	409c                	lw	a5,0(s1)
+    80002a10:	412787bb          	subw	a5,a5,s2
+    80002a14:	fcc42703          	lw	a4,-52(s0)
+    80002a18:	fee7e2e3          	bltu	a5,a4,800029fc <sys_pause+0x4a>
+    80002a1c:	74a2                	ld	s1,40(sp)
+    80002a1e:	69e2                	ld	s3,24(sp)
+  }
+  release(&tickslock);
+    80002a20:	00016517          	auipc	a0,0x16
+    80002a24:	10850513          	addi	a0,a0,264 # 80018b28 <tickslock>
+    80002a28:	a3efe0ef          	jal	80000c66 <release>
+  return 0;
+    80002a2c:	4501                	li	a0,0
+}
+    80002a2e:	70e2                	ld	ra,56(sp)
+    80002a30:	7442                	ld	s0,48(sp)
+    80002a32:	7902                	ld	s2,32(sp)
+    80002a34:	6121                	addi	sp,sp,64
+    80002a36:	8082                	ret
+    n = 0;
+    80002a38:	fc042623          	sw	zero,-52(s0)
+    80002a3c:	bf49                	j	800029ce <sys_pause+0x1c>
+      release(&tickslock);
+    80002a3e:	00016517          	auipc	a0,0x16
+    80002a42:	0ea50513          	addi	a0,a0,234 # 80018b28 <tickslock>
+    80002a46:	a20fe0ef          	jal	80000c66 <release>
+      return -1;
+    80002a4a:	557d                	li	a0,-1
+    80002a4c:	74a2                	ld	s1,40(sp)
+    80002a4e:	69e2                	ld	s3,24(sp)
+    80002a50:	bff9                	j	80002a2e <sys_pause+0x7c>
+
+0000000080002a52 <sys_kill>:
+
+uint64
+sys_kill(void)
+{
+    80002a52:	1101                	addi	sp,sp,-32
+    80002a54:	ec06                	sd	ra,24(sp)
+    80002a56:	e822                	sd	s0,16(sp)
+    80002a58:	1000                	addi	s0,sp,32
+  int pid;
+
+  argint(0, &pid);
+    80002a5a:	fec40593          	addi	a1,s0,-20
+    80002a5e:	4501                	li	a0,0
+    80002a60:	dabff0ef          	jal	8000280a <argint>
+  return kkill(pid);
+    80002a64:	fec42503          	lw	a0,-20(s0)
+    80002a68:	e22ff0ef          	jal	8000208a <kkill>
+}
+    80002a6c:	60e2                	ld	ra,24(sp)
+    80002a6e:	6442                	ld	s0,16(sp)
+    80002a70:	6105                	addi	sp,sp,32
+    80002a72:	8082                	ret
+
+0000000080002a74 <sys_uptime>:
+
+// return how many clock tick interrupts have occurred
+// since start.
+uint64
+sys_uptime(void)
+{
+    80002a74:	1101                	addi	sp,sp,-32
+    80002a76:	ec06                	sd	ra,24(sp)
+    80002a78:	e822                	sd	s0,16(sp)
+    80002a7a:	e426                	sd	s1,8(sp)
+    80002a7c:	1000                	addi	s0,sp,32
+  uint xticks;
+
+  acquire(&tickslock);
+    80002a7e:	00016517          	auipc	a0,0x16
+    80002a82:	0aa50513          	addi	a0,a0,170 # 80018b28 <tickslock>
+    80002a86:	948fe0ef          	jal	80000bce <acquire>
+  xticks = ticks;
+    80002a8a:	00007497          	auipc	s1,0x7
+    80002a8e:	75e4a483          	lw	s1,1886(s1) # 8000a1e8 <ticks>
+  release(&tickslock);
+    80002a92:	00016517          	auipc	a0,0x16
+    80002a96:	09650513          	addi	a0,a0,150 # 80018b28 <tickslock>
+    80002a9a:	9ccfe0ef          	jal	80000c66 <release>
+  return xticks;
+}
+    80002a9e:	02049513          	slli	a0,s1,0x20
+    80002aa2:	9101                	srli	a0,a0,0x20
+    80002aa4:	60e2                	ld	ra,24(sp)
+    80002aa6:	6442                	ld	s0,16(sp)
+    80002aa8:	64a2                	ld	s1,8(sp)
+    80002aaa:	6105                	addi	sp,sp,32
+    80002aac:	8082                	ret
+
+0000000080002aae <binit>:
+  struct buf head;
+} bcache;
+
+void
+binit(void)
+{
+    80002aae:	7179                	addi	sp,sp,-48
+    80002ab0:	f406                	sd	ra,40(sp)
+    80002ab2:	f022                	sd	s0,32(sp)
+    80002ab4:	ec26                	sd	s1,24(sp)
+    80002ab6:	e84a                	sd	s2,16(sp)
+    80002ab8:	e44e                	sd	s3,8(sp)
+    80002aba:	e052                	sd	s4,0(sp)
+    80002abc:	1800                	addi	s0,sp,48
+  struct buf *b;
+
+  initlock(&bcache.lock, "bcache");
+    80002abe:	00005597          	auipc	a1,0x5
+    80002ac2:	90258593          	addi	a1,a1,-1790 # 800073c0 <etext+0x3c0>
+    80002ac6:	00016517          	auipc	a0,0x16
+    80002aca:	07a50513          	addi	a0,a0,122 # 80018b40 <bcache>
+    80002ace:	880fe0ef          	jal	80000b4e <initlock>
+
+  // Create linked list of buffers
+  bcache.head.prev = &bcache.head;
+    80002ad2:	0001e797          	auipc	a5,0x1e
+    80002ad6:	06e78793          	addi	a5,a5,110 # 80020b40 <bcache+0x8000>
+    80002ada:	0001e717          	auipc	a4,0x1e
+    80002ade:	2ce70713          	addi	a4,a4,718 # 80020da8 <bcache+0x8268>
+    80002ae2:	2ae7b823          	sd	a4,688(a5)
+  bcache.head.next = &bcache.head;
+    80002ae6:	2ae7bc23          	sd	a4,696(a5)
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+    80002aea:	00016497          	auipc	s1,0x16
+    80002aee:	06e48493          	addi	s1,s1,110 # 80018b58 <bcache+0x18>
+    b->next = bcache.head.next;
+    80002af2:	893e                	mv	s2,a5
+    b->prev = &bcache.head;
+    80002af4:	89ba                	mv	s3,a4
+    initsleeplock(&b->lock, "buffer");
+    80002af6:	00005a17          	auipc	s4,0x5
+    80002afa:	8d2a0a13          	addi	s4,s4,-1838 # 800073c8 <etext+0x3c8>
+    b->next = bcache.head.next;
+    80002afe:	2b893783          	ld	a5,696(s2)
+    80002b02:	e8bc                	sd	a5,80(s1)
+    b->prev = &bcache.head;
+    80002b04:	0534b423          	sd	s3,72(s1)
+    initsleeplock(&b->lock, "buffer");
+    80002b08:	85d2                	mv	a1,s4
+    80002b0a:	01048513          	addi	a0,s1,16
+    80002b0e:	322010ef          	jal	80003e30 <initsleeplock>
+    bcache.head.next->prev = b;
+    80002b12:	2b893783          	ld	a5,696(s2)
+    80002b16:	e7a4                	sd	s1,72(a5)
+    bcache.head.next = b;
+    80002b18:	2a993c23          	sd	s1,696(s2)
+  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
+    80002b1c:	45848493          	addi	s1,s1,1112
+    80002b20:	fd349fe3          	bne	s1,s3,80002afe <binit+0x50>
+  }
+}
+    80002b24:	70a2                	ld	ra,40(sp)
+    80002b26:	7402                	ld	s0,32(sp)
+    80002b28:	64e2                	ld	s1,24(sp)
+    80002b2a:	6942                	ld	s2,16(sp)
+    80002b2c:	69a2                	ld	s3,8(sp)
+    80002b2e:	6a02                	ld	s4,0(sp)
+    80002b30:	6145                	addi	sp,sp,48
+    80002b32:	8082                	ret
+
+0000000080002b34 <bread>:
+}
+
+// Return a locked buf with the contents of the indicated block.
+struct buf*
+bread(uint dev, uint blockno)
+{
+    80002b34:	7179                	addi	sp,sp,-48
+    80002b36:	f406                	sd	ra,40(sp)
+    80002b38:	f022                	sd	s0,32(sp)
+    80002b3a:	ec26                	sd	s1,24(sp)
+    80002b3c:	e84a                	sd	s2,16(sp)
+    80002b3e:	e44e                	sd	s3,8(sp)
+    80002b40:	1800                	addi	s0,sp,48
+    80002b42:	892a                	mv	s2,a0
+    80002b44:	89ae                	mv	s3,a1
+  acquire(&bcache.lock);
+    80002b46:	00016517          	auipc	a0,0x16
+    80002b4a:	ffa50513          	addi	a0,a0,-6 # 80018b40 <bcache>
+    80002b4e:	880fe0ef          	jal	80000bce <acquire>
+  for(b = bcache.head.next; b != &bcache.head; b = b->next){
+    80002b52:	0001e497          	auipc	s1,0x1e
+    80002b56:	2a64b483          	ld	s1,678(s1) # 80020df8 <bcache+0x82b8>
+    80002b5a:	0001e797          	auipc	a5,0x1e
+    80002b5e:	24e78793          	addi	a5,a5,590 # 80020da8 <bcache+0x8268>
+    80002b62:	02f48b63          	beq	s1,a5,80002b98 <bread+0x64>
+    80002b66:	873e                	mv	a4,a5
+    80002b68:	a021                	j	80002b70 <bread+0x3c>
+    80002b6a:	68a4                	ld	s1,80(s1)
+    80002b6c:	02e48663          	beq	s1,a4,80002b98 <bread+0x64>
+    if(b->dev == dev && b->blockno == blockno){
+    80002b70:	449c                	lw	a5,8(s1)
+    80002b72:	ff279ce3          	bne	a5,s2,80002b6a <bread+0x36>
+    80002b76:	44dc                	lw	a5,12(s1)
+    80002b78:	ff3799e3          	bne	a5,s3,80002b6a <bread+0x36>
+      b->refcnt++;
+    80002b7c:	40bc                	lw	a5,64(s1)
+    80002b7e:	2785                	addiw	a5,a5,1
+    80002b80:	c0bc                	sw	a5,64(s1)
+      release(&bcache.lock);
+    80002b82:	00016517          	auipc	a0,0x16
+    80002b86:	fbe50513          	addi	a0,a0,-66 # 80018b40 <bcache>
+    80002b8a:	8dcfe0ef          	jal	80000c66 <release>
+      acquiresleep(&b->lock);
+    80002b8e:	01048513          	addi	a0,s1,16
+    80002b92:	2d4010ef          	jal	80003e66 <acquiresleep>
+      return b;
+    80002b96:	a889                	j	80002be8 <bread+0xb4>
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+    80002b98:	0001e497          	auipc	s1,0x1e
+    80002b9c:	2584b483          	ld	s1,600(s1) # 80020df0 <bcache+0x82b0>
+    80002ba0:	0001e797          	auipc	a5,0x1e
+    80002ba4:	20878793          	addi	a5,a5,520 # 80020da8 <bcache+0x8268>
+    80002ba8:	00f48863          	beq	s1,a5,80002bb8 <bread+0x84>
+    80002bac:	873e                	mv	a4,a5
+    if(b->refcnt == 0) {
+    80002bae:	40bc                	lw	a5,64(s1)
+    80002bb0:	cb91                	beqz	a5,80002bc4 <bread+0x90>
+  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
+    80002bb2:	64a4                	ld	s1,72(s1)
+    80002bb4:	fee49de3          	bne	s1,a4,80002bae <bread+0x7a>
+  panic("bget: no buffers");
+    80002bb8:	00005517          	auipc	a0,0x5
+    80002bbc:	81850513          	addi	a0,a0,-2024 # 800073d0 <etext+0x3d0>
+    80002bc0:	c21fd0ef          	jal	800007e0 <panic>
+      b->dev = dev;
+    80002bc4:	0124a423          	sw	s2,8(s1)
+      b->blockno = blockno;
+    80002bc8:	0134a623          	sw	s3,12(s1)
+      b->valid = 0;
+    80002bcc:	0004a023          	sw	zero,0(s1)
+      b->refcnt = 1;
+    80002bd0:	4785                	li	a5,1
+    80002bd2:	c0bc                	sw	a5,64(s1)
+      release(&bcache.lock);
+    80002bd4:	00016517          	auipc	a0,0x16
+    80002bd8:	f6c50513          	addi	a0,a0,-148 # 80018b40 <bcache>
+    80002bdc:	88afe0ef          	jal	80000c66 <release>
+      acquiresleep(&b->lock);
+    80002be0:	01048513          	addi	a0,s1,16
+    80002be4:	282010ef          	jal	80003e66 <acquiresleep>
+  struct buf *b;
+
+  b = bget(dev, blockno);
+  if(!b->valid) {
+    80002be8:	409c                	lw	a5,0(s1)
+    80002bea:	cb89                	beqz	a5,80002bfc <bread+0xc8>
+    virtio_disk_rw(b, 0);
+    b->valid = 1;
+  }
+  return b;
+}
+    80002bec:	8526                	mv	a0,s1
+    80002bee:	70a2                	ld	ra,40(sp)
+    80002bf0:	7402                	ld	s0,32(sp)
+    80002bf2:	64e2                	ld	s1,24(sp)
+    80002bf4:	6942                	ld	s2,16(sp)
+    80002bf6:	69a2                	ld	s3,8(sp)
+    80002bf8:	6145                	addi	sp,sp,48
+    80002bfa:	8082                	ret
+    virtio_disk_rw(b, 0);
+    80002bfc:	4581                	li	a1,0
+    80002bfe:	8526                	mv	a0,s1
+    80002c00:	2f1020ef          	jal	800056f0 <virtio_disk_rw>
+    b->valid = 1;
+    80002c04:	4785                	li	a5,1
+    80002c06:	c09c                	sw	a5,0(s1)
+  return b;
+    80002c08:	b7d5                	j	80002bec <bread+0xb8>
+
+0000000080002c0a <bwrite>:
+
+// Write b's contents to disk.  Must be locked.
+void
+bwrite(struct buf *b)
+{
+    80002c0a:	1101                	addi	sp,sp,-32
+    80002c0c:	ec06                	sd	ra,24(sp)
+    80002c0e:	e822                	sd	s0,16(sp)
+    80002c10:	e426                	sd	s1,8(sp)
+    80002c12:	1000                	addi	s0,sp,32
+    80002c14:	84aa                	mv	s1,a0
+  if(!holdingsleep(&b->lock))
+    80002c16:	0541                	addi	a0,a0,16
+    80002c18:	2cc010ef          	jal	80003ee4 <holdingsleep>
+    80002c1c:	c911                	beqz	a0,80002c30 <bwrite+0x26>
+    panic("bwrite");
+  virtio_disk_rw(b, 1);
+    80002c1e:	4585                	li	a1,1
+    80002c20:	8526                	mv	a0,s1
+    80002c22:	2cf020ef          	jal	800056f0 <virtio_disk_rw>
+}
+    80002c26:	60e2                	ld	ra,24(sp)
+    80002c28:	6442                	ld	s0,16(sp)
+    80002c2a:	64a2                	ld	s1,8(sp)
+    80002c2c:	6105                	addi	sp,sp,32
+    80002c2e:	8082                	ret
+    panic("bwrite");
+    80002c30:	00004517          	auipc	a0,0x4
+    80002c34:	7b850513          	addi	a0,a0,1976 # 800073e8 <etext+0x3e8>
+    80002c38:	ba9fd0ef          	jal	800007e0 <panic>
+
+0000000080002c3c <brelse>:
+
+// Release a locked buffer.
+// Move to the head of the most-recently-used list.
+void
+brelse(struct buf *b)
+{
+    80002c3c:	1101                	addi	sp,sp,-32
+    80002c3e:	ec06                	sd	ra,24(sp)
+    80002c40:	e822                	sd	s0,16(sp)
+    80002c42:	e426                	sd	s1,8(sp)
+    80002c44:	e04a                	sd	s2,0(sp)
+    80002c46:	1000                	addi	s0,sp,32
+    80002c48:	84aa                	mv	s1,a0
+  if(!holdingsleep(&b->lock))
+    80002c4a:	01050913          	addi	s2,a0,16
+    80002c4e:	854a                	mv	a0,s2
+    80002c50:	294010ef          	jal	80003ee4 <holdingsleep>
+    80002c54:	c135                	beqz	a0,80002cb8 <brelse+0x7c>
+    panic("brelse");
+
+  releasesleep(&b->lock);
+    80002c56:	854a                	mv	a0,s2
+    80002c58:	254010ef          	jal	80003eac <releasesleep>
+
+  acquire(&bcache.lock);
+    80002c5c:	00016517          	auipc	a0,0x16
+    80002c60:	ee450513          	addi	a0,a0,-284 # 80018b40 <bcache>
+    80002c64:	f6bfd0ef          	jal	80000bce <acquire>
+  b->refcnt--;
+    80002c68:	40bc                	lw	a5,64(s1)
+    80002c6a:	37fd                	addiw	a5,a5,-1
+    80002c6c:	0007871b          	sext.w	a4,a5
+    80002c70:	c0bc                	sw	a5,64(s1)
+  if (b->refcnt == 0) {
+    80002c72:	e71d                	bnez	a4,80002ca0 <brelse+0x64>
+    // no one is waiting for it.
+    b->next->prev = b->prev;
+    80002c74:	68b8                	ld	a4,80(s1)
+    80002c76:	64bc                	ld	a5,72(s1)
+    80002c78:	e73c                	sd	a5,72(a4)
+    b->prev->next = b->next;
+    80002c7a:	68b8                	ld	a4,80(s1)
+    80002c7c:	ebb8                	sd	a4,80(a5)
+    b->next = bcache.head.next;
+    80002c7e:	0001e797          	auipc	a5,0x1e
+    80002c82:	ec278793          	addi	a5,a5,-318 # 80020b40 <bcache+0x8000>
+    80002c86:	2b87b703          	ld	a4,696(a5)
+    80002c8a:	e8b8                	sd	a4,80(s1)
+    b->prev = &bcache.head;
+    80002c8c:	0001e717          	auipc	a4,0x1e
+    80002c90:	11c70713          	addi	a4,a4,284 # 80020da8 <bcache+0x8268>
+    80002c94:	e4b8                	sd	a4,72(s1)
+    bcache.head.next->prev = b;
+    80002c96:	2b87b703          	ld	a4,696(a5)
+    80002c9a:	e724                	sd	s1,72(a4)
+    bcache.head.next = b;
+    80002c9c:	2a97bc23          	sd	s1,696(a5)
+  }
+  
+  release(&bcache.lock);
+    80002ca0:	00016517          	auipc	a0,0x16
+    80002ca4:	ea050513          	addi	a0,a0,-352 # 80018b40 <bcache>
+    80002ca8:	fbffd0ef          	jal	80000c66 <release>
+}
+    80002cac:	60e2                	ld	ra,24(sp)
+    80002cae:	6442                	ld	s0,16(sp)
+    80002cb0:	64a2                	ld	s1,8(sp)
+    80002cb2:	6902                	ld	s2,0(sp)
+    80002cb4:	6105                	addi	sp,sp,32
+    80002cb6:	8082                	ret
+    panic("brelse");
+    80002cb8:	00004517          	auipc	a0,0x4
+    80002cbc:	73850513          	addi	a0,a0,1848 # 800073f0 <etext+0x3f0>
+    80002cc0:	b21fd0ef          	jal	800007e0 <panic>
+
+0000000080002cc4 <bpin>:
+
+void
+bpin(struct buf *b) {
+    80002cc4:	1101                	addi	sp,sp,-32
+    80002cc6:	ec06                	sd	ra,24(sp)
+    80002cc8:	e822                	sd	s0,16(sp)
+    80002cca:	e426                	sd	s1,8(sp)
+    80002ccc:	1000                	addi	s0,sp,32
+    80002cce:	84aa                	mv	s1,a0
+  acquire(&bcache.lock);
+    80002cd0:	00016517          	auipc	a0,0x16
+    80002cd4:	e7050513          	addi	a0,a0,-400 # 80018b40 <bcache>
+    80002cd8:	ef7fd0ef          	jal	80000bce <acquire>
+  b->refcnt++;
+    80002cdc:	40bc                	lw	a5,64(s1)
+    80002cde:	2785                	addiw	a5,a5,1
+    80002ce0:	c0bc                	sw	a5,64(s1)
+  release(&bcache.lock);
+    80002ce2:	00016517          	auipc	a0,0x16
+    80002ce6:	e5e50513          	addi	a0,a0,-418 # 80018b40 <bcache>
+    80002cea:	f7dfd0ef          	jal	80000c66 <release>
+}
+    80002cee:	60e2                	ld	ra,24(sp)
+    80002cf0:	6442                	ld	s0,16(sp)
+    80002cf2:	64a2                	ld	s1,8(sp)
+    80002cf4:	6105                	addi	sp,sp,32
+    80002cf6:	8082                	ret
+
+0000000080002cf8 <bunpin>:
+
+void
+bunpin(struct buf *b) {
+    80002cf8:	1101                	addi	sp,sp,-32
+    80002cfa:	ec06                	sd	ra,24(sp)
+    80002cfc:	e822                	sd	s0,16(sp)
+    80002cfe:	e426                	sd	s1,8(sp)
+    80002d00:	1000                	addi	s0,sp,32
+    80002d02:	84aa                	mv	s1,a0
+  acquire(&bcache.lock);
+    80002d04:	00016517          	auipc	a0,0x16
+    80002d08:	e3c50513          	addi	a0,a0,-452 # 80018b40 <bcache>
+    80002d0c:	ec3fd0ef          	jal	80000bce <acquire>
+  b->refcnt--;
+    80002d10:	40bc                	lw	a5,64(s1)
+    80002d12:	37fd                	addiw	a5,a5,-1
+    80002d14:	c0bc                	sw	a5,64(s1)
+  release(&bcache.lock);
+    80002d16:	00016517          	auipc	a0,0x16
+    80002d1a:	e2a50513          	addi	a0,a0,-470 # 80018b40 <bcache>
+    80002d1e:	f49fd0ef          	jal	80000c66 <release>
+}
+    80002d22:	60e2                	ld	ra,24(sp)
+    80002d24:	6442                	ld	s0,16(sp)
+    80002d26:	64a2                	ld	s1,8(sp)
+    80002d28:	6105                	addi	sp,sp,32
+    80002d2a:	8082                	ret
+
+0000000080002d2c <bfree>:
+}
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+    80002d2c:	1101                	addi	sp,sp,-32
+    80002d2e:	ec06                	sd	ra,24(sp)
+    80002d30:	e822                	sd	s0,16(sp)
+    80002d32:	e426                	sd	s1,8(sp)
+    80002d34:	e04a                	sd	s2,0(sp)
+    80002d36:	1000                	addi	s0,sp,32
+    80002d38:	84ae                	mv	s1,a1
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+    80002d3a:	00d5d59b          	srliw	a1,a1,0xd
+    80002d3e:	0001e797          	auipc	a5,0x1e
+    80002d42:	4de7a783          	lw	a5,1246(a5) # 8002121c <sb+0x1c>
+    80002d46:	9dbd                	addw	a1,a1,a5
+    80002d48:	dedff0ef          	jal	80002b34 <bread>
+  bi = b % BPB;
+  m = 1 << (bi % 8);
+    80002d4c:	0074f713          	andi	a4,s1,7
+    80002d50:	4785                	li	a5,1
+    80002d52:	00e797bb          	sllw	a5,a5,a4
+  if((bp->data[bi/8] & m) == 0)
+    80002d56:	14ce                	slli	s1,s1,0x33
+    80002d58:	90d9                	srli	s1,s1,0x36
+    80002d5a:	00950733          	add	a4,a0,s1
+    80002d5e:	05874703          	lbu	a4,88(a4)
+    80002d62:	00e7f6b3          	and	a3,a5,a4
+    80002d66:	c29d                	beqz	a3,80002d8c <bfree+0x60>
+    80002d68:	892a                	mv	s2,a0
+    panic("freeing free block");
+  bp->data[bi/8] &= ~m;
+    80002d6a:	94aa                	add	s1,s1,a0
+    80002d6c:	fff7c793          	not	a5,a5
+    80002d70:	8f7d                	and	a4,a4,a5
+    80002d72:	04e48c23          	sb	a4,88(s1)
+  log_write(bp);
+    80002d76:	7f9000ef          	jal	80003d6e <log_write>
+  brelse(bp);
+    80002d7a:	854a                	mv	a0,s2
+    80002d7c:	ec1ff0ef          	jal	80002c3c <brelse>
+}
+    80002d80:	60e2                	ld	ra,24(sp)
+    80002d82:	6442                	ld	s0,16(sp)
+    80002d84:	64a2                	ld	s1,8(sp)
+    80002d86:	6902                	ld	s2,0(sp)
+    80002d88:	6105                	addi	sp,sp,32
+    80002d8a:	8082                	ret
+    panic("freeing free block");
+    80002d8c:	00004517          	auipc	a0,0x4
+    80002d90:	66c50513          	addi	a0,a0,1644 # 800073f8 <etext+0x3f8>
+    80002d94:	a4dfd0ef          	jal	800007e0 <panic>
+
+0000000080002d98 <balloc>:
+{
+    80002d98:	711d                	addi	sp,sp,-96
+    80002d9a:	ec86                	sd	ra,88(sp)
+    80002d9c:	e8a2                	sd	s0,80(sp)
+    80002d9e:	e4a6                	sd	s1,72(sp)
+    80002da0:	1080                	addi	s0,sp,96
+  for(b = 0; b < sb.size; b += BPB){
+    80002da2:	0001e797          	auipc	a5,0x1e
+    80002da6:	4627a783          	lw	a5,1122(a5) # 80021204 <sb+0x4>
+    80002daa:	0e078f63          	beqz	a5,80002ea8 <balloc+0x110>
+    80002dae:	e0ca                	sd	s2,64(sp)
+    80002db0:	fc4e                	sd	s3,56(sp)
+    80002db2:	f852                	sd	s4,48(sp)
+    80002db4:	f456                	sd	s5,40(sp)
+    80002db6:	f05a                	sd	s6,32(sp)
+    80002db8:	ec5e                	sd	s7,24(sp)
+    80002dba:	e862                	sd	s8,16(sp)
+    80002dbc:	e466                	sd	s9,8(sp)
+    80002dbe:	8baa                	mv	s7,a0
+    80002dc0:	4a81                	li	s5,0
+    bp = bread(dev, BBLOCK(b, sb));
+    80002dc2:	0001eb17          	auipc	s6,0x1e
+    80002dc6:	43eb0b13          	addi	s6,s6,1086 # 80021200 <sb>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+    80002dca:	4c01                	li	s8,0
+      m = 1 << (bi % 8);
+    80002dcc:	4985                	li	s3,1
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+    80002dce:	6a09                	lui	s4,0x2
+  for(b = 0; b < sb.size; b += BPB){
+    80002dd0:	6c89                	lui	s9,0x2
+    80002dd2:	a0b5                	j	80002e3e <balloc+0xa6>
+        bp->data[bi/8] |= m;  // Mark block in use.
+    80002dd4:	97ca                	add	a5,a5,s2
+    80002dd6:	8e55                	or	a2,a2,a3
+    80002dd8:	04c78c23          	sb	a2,88(a5)
+        log_write(bp);
+    80002ddc:	854a                	mv	a0,s2
+    80002dde:	791000ef          	jal	80003d6e <log_write>
+        brelse(bp);
+    80002de2:	854a                	mv	a0,s2
+    80002de4:	e59ff0ef          	jal	80002c3c <brelse>
+  bp = bread(dev, bno);
+    80002de8:	85a6                	mv	a1,s1
+    80002dea:	855e                	mv	a0,s7
+    80002dec:	d49ff0ef          	jal	80002b34 <bread>
+    80002df0:	892a                	mv	s2,a0
+  memset(bp->data, 0, BSIZE);
+    80002df2:	40000613          	li	a2,1024
+    80002df6:	4581                	li	a1,0
+    80002df8:	05850513          	addi	a0,a0,88
+    80002dfc:	ea7fd0ef          	jal	80000ca2 <memset>
+  log_write(bp);
+    80002e00:	854a                	mv	a0,s2
+    80002e02:	76d000ef          	jal	80003d6e <log_write>
+  brelse(bp);
+    80002e06:	854a                	mv	a0,s2
+    80002e08:	e35ff0ef          	jal	80002c3c <brelse>
+}
+    80002e0c:	6906                	ld	s2,64(sp)
+    80002e0e:	79e2                	ld	s3,56(sp)
+    80002e10:	7a42                	ld	s4,48(sp)
+    80002e12:	7aa2                	ld	s5,40(sp)
+    80002e14:	7b02                	ld	s6,32(sp)
+    80002e16:	6be2                	ld	s7,24(sp)
+    80002e18:	6c42                	ld	s8,16(sp)
+    80002e1a:	6ca2                	ld	s9,8(sp)
+}
+    80002e1c:	8526                	mv	a0,s1
+    80002e1e:	60e6                	ld	ra,88(sp)
+    80002e20:	6446                	ld	s0,80(sp)
+    80002e22:	64a6                	ld	s1,72(sp)
+    80002e24:	6125                	addi	sp,sp,96
+    80002e26:	8082                	ret
+    brelse(bp);
+    80002e28:	854a                	mv	a0,s2
+    80002e2a:	e13ff0ef          	jal	80002c3c <brelse>
+  for(b = 0; b < sb.size; b += BPB){
+    80002e2e:	015c87bb          	addw	a5,s9,s5
+    80002e32:	00078a9b          	sext.w	s5,a5
+    80002e36:	004b2703          	lw	a4,4(s6)
+    80002e3a:	04eaff63          	bgeu	s5,a4,80002e98 <balloc+0x100>
+    bp = bread(dev, BBLOCK(b, sb));
+    80002e3e:	41fad79b          	sraiw	a5,s5,0x1f
+    80002e42:	0137d79b          	srliw	a5,a5,0x13
+    80002e46:	015787bb          	addw	a5,a5,s5
+    80002e4a:	40d7d79b          	sraiw	a5,a5,0xd
+    80002e4e:	01cb2583          	lw	a1,28(s6)
+    80002e52:	9dbd                	addw	a1,a1,a5
+    80002e54:	855e                	mv	a0,s7
+    80002e56:	cdfff0ef          	jal	80002b34 <bread>
+    80002e5a:	892a                	mv	s2,a0
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+    80002e5c:	004b2503          	lw	a0,4(s6)
+    80002e60:	000a849b          	sext.w	s1,s5
+    80002e64:	8762                	mv	a4,s8
+    80002e66:	fca4f1e3          	bgeu	s1,a0,80002e28 <balloc+0x90>
+      m = 1 << (bi % 8);
+    80002e6a:	00777693          	andi	a3,a4,7
+    80002e6e:	00d996bb          	sllw	a3,s3,a3
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+    80002e72:	41f7579b          	sraiw	a5,a4,0x1f
+    80002e76:	01d7d79b          	srliw	a5,a5,0x1d
+    80002e7a:	9fb9                	addw	a5,a5,a4
+    80002e7c:	4037d79b          	sraiw	a5,a5,0x3
+    80002e80:	00f90633          	add	a2,s2,a5
+    80002e84:	05864603          	lbu	a2,88(a2)
+    80002e88:	00c6f5b3          	and	a1,a3,a2
+    80002e8c:	d5a1                	beqz	a1,80002dd4 <balloc+0x3c>
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+    80002e8e:	2705                	addiw	a4,a4,1
+    80002e90:	2485                	addiw	s1,s1,1
+    80002e92:	fd471ae3          	bne	a4,s4,80002e66 <balloc+0xce>
+    80002e96:	bf49                	j	80002e28 <balloc+0x90>
+    80002e98:	6906                	ld	s2,64(sp)
+    80002e9a:	79e2                	ld	s3,56(sp)
+    80002e9c:	7a42                	ld	s4,48(sp)
+    80002e9e:	7aa2                	ld	s5,40(sp)
+    80002ea0:	7b02                	ld	s6,32(sp)
+    80002ea2:	6be2                	ld	s7,24(sp)
+    80002ea4:	6c42                	ld	s8,16(sp)
+    80002ea6:	6ca2                	ld	s9,8(sp)
+  printf("balloc: out of blocks\n");
+    80002ea8:	00004517          	auipc	a0,0x4
+    80002eac:	56850513          	addi	a0,a0,1384 # 80007410 <etext+0x410>
+    80002eb0:	e4afd0ef          	jal	800004fa <printf>
+  return 0;
+    80002eb4:	4481                	li	s1,0
+    80002eb6:	b79d                	j	80002e1c <balloc+0x84>
+
+0000000080002eb8 <bmap>:
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+// returns 0 if out of disk space.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+    80002eb8:	7179                	addi	sp,sp,-48
+    80002eba:	f406                	sd	ra,40(sp)
+    80002ebc:	f022                	sd	s0,32(sp)
+    80002ebe:	ec26                	sd	s1,24(sp)
+    80002ec0:	e84a                	sd	s2,16(sp)
+    80002ec2:	e44e                	sd	s3,8(sp)
+    80002ec4:	1800                	addi	s0,sp,48
+    80002ec6:	89aa                	mv	s3,a0
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+    80002ec8:	47ad                	li	a5,11
+    80002eca:	02b7e663          	bltu	a5,a1,80002ef6 <bmap+0x3e>
+    if((addr = ip->addrs[bn]) == 0){
+    80002ece:	02059793          	slli	a5,a1,0x20
+    80002ed2:	01e7d593          	srli	a1,a5,0x1e
+    80002ed6:	00b504b3          	add	s1,a0,a1
+    80002eda:	0504a903          	lw	s2,80(s1)
+    80002ede:	06091a63          	bnez	s2,80002f52 <bmap+0x9a>
+      addr = balloc(ip->dev);
+    80002ee2:	4108                	lw	a0,0(a0)
+    80002ee4:	eb5ff0ef          	jal	80002d98 <balloc>
+    80002ee8:	0005091b          	sext.w	s2,a0
+      if(addr == 0)
+    80002eec:	06090363          	beqz	s2,80002f52 <bmap+0x9a>
+        return 0;
+      ip->addrs[bn] = addr;
+    80002ef0:	0524a823          	sw	s2,80(s1)
+    80002ef4:	a8b9                	j	80002f52 <bmap+0x9a>
+    }
+    return addr;
+  }
+  bn -= NDIRECT;
+    80002ef6:	ff45849b          	addiw	s1,a1,-12
+    80002efa:	0004871b          	sext.w	a4,s1
+
+  if(bn < NINDIRECT){
+    80002efe:	0ff00793          	li	a5,255
+    80002f02:	06e7ee63          	bltu	a5,a4,80002f7e <bmap+0xc6>
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0){
+    80002f06:	08052903          	lw	s2,128(a0)
+    80002f0a:	00091d63          	bnez	s2,80002f24 <bmap+0x6c>
+      addr = balloc(ip->dev);
+    80002f0e:	4108                	lw	a0,0(a0)
+    80002f10:	e89ff0ef          	jal	80002d98 <balloc>
+    80002f14:	0005091b          	sext.w	s2,a0
+      if(addr == 0)
+    80002f18:	02090d63          	beqz	s2,80002f52 <bmap+0x9a>
+    80002f1c:	e052                	sd	s4,0(sp)
+        return 0;
+      ip->addrs[NDIRECT] = addr;
+    80002f1e:	0929a023          	sw	s2,128(s3)
+    80002f22:	a011                	j	80002f26 <bmap+0x6e>
+    80002f24:	e052                	sd	s4,0(sp)
+    }
+    bp = bread(ip->dev, addr);
+    80002f26:	85ca                	mv	a1,s2
+    80002f28:	0009a503          	lw	a0,0(s3)
+    80002f2c:	c09ff0ef          	jal	80002b34 <bread>
+    80002f30:	8a2a                	mv	s4,a0
+    a = (uint*)bp->data;
+    80002f32:	05850793          	addi	a5,a0,88
+    if((addr = a[bn]) == 0){
+    80002f36:	02049713          	slli	a4,s1,0x20
+    80002f3a:	01e75593          	srli	a1,a4,0x1e
+    80002f3e:	00b784b3          	add	s1,a5,a1
+    80002f42:	0004a903          	lw	s2,0(s1)
+    80002f46:	00090e63          	beqz	s2,80002f62 <bmap+0xaa>
+      if(addr){
+        a[bn] = addr;
+        log_write(bp);
+      }
+    }
+    brelse(bp);
+    80002f4a:	8552                	mv	a0,s4
+    80002f4c:	cf1ff0ef          	jal	80002c3c <brelse>
+    return addr;
+    80002f50:	6a02                	ld	s4,0(sp)
+  }
+
+  panic("bmap: out of range");
+}
+    80002f52:	854a                	mv	a0,s2
+    80002f54:	70a2                	ld	ra,40(sp)
+    80002f56:	7402                	ld	s0,32(sp)
+    80002f58:	64e2                	ld	s1,24(sp)
+    80002f5a:	6942                	ld	s2,16(sp)
+    80002f5c:	69a2                	ld	s3,8(sp)
+    80002f5e:	6145                	addi	sp,sp,48
+    80002f60:	8082                	ret
+      addr = balloc(ip->dev);
+    80002f62:	0009a503          	lw	a0,0(s3)
+    80002f66:	e33ff0ef          	jal	80002d98 <balloc>
+    80002f6a:	0005091b          	sext.w	s2,a0
+      if(addr){
+    80002f6e:	fc090ee3          	beqz	s2,80002f4a <bmap+0x92>
+        a[bn] = addr;
+    80002f72:	0124a023          	sw	s2,0(s1)
+        log_write(bp);
+    80002f76:	8552                	mv	a0,s4
+    80002f78:	5f7000ef          	jal	80003d6e <log_write>
+    80002f7c:	b7f9                	j	80002f4a <bmap+0x92>
+    80002f7e:	e052                	sd	s4,0(sp)
+  panic("bmap: out of range");
+    80002f80:	00004517          	auipc	a0,0x4
+    80002f84:	4a850513          	addi	a0,a0,1192 # 80007428 <etext+0x428>
+    80002f88:	859fd0ef          	jal	800007e0 <panic>
+
+0000000080002f8c <iget>:
+{
+    80002f8c:	7179                	addi	sp,sp,-48
+    80002f8e:	f406                	sd	ra,40(sp)
+    80002f90:	f022                	sd	s0,32(sp)
+    80002f92:	ec26                	sd	s1,24(sp)
+    80002f94:	e84a                	sd	s2,16(sp)
+    80002f96:	e44e                	sd	s3,8(sp)
+    80002f98:	e052                	sd	s4,0(sp)
+    80002f9a:	1800                	addi	s0,sp,48
+    80002f9c:	89aa                	mv	s3,a0
+    80002f9e:	8a2e                	mv	s4,a1
+  acquire(&itable.lock);
+    80002fa0:	0001e517          	auipc	a0,0x1e
+    80002fa4:	28050513          	addi	a0,a0,640 # 80021220 <itable>
+    80002fa8:	c27fd0ef          	jal	80000bce <acquire>
+  empty = 0;
+    80002fac:	4901                	li	s2,0
+  for(ip = &itable.inode[0]; ip < &itable.inode[NINODE]; ip++){
+    80002fae:	0001e497          	auipc	s1,0x1e
+    80002fb2:	28a48493          	addi	s1,s1,650 # 80021238 <itable+0x18>
+    80002fb6:	00020697          	auipc	a3,0x20
+    80002fba:	d1268693          	addi	a3,a3,-750 # 80022cc8 <log>
+    80002fbe:	a039                	j	80002fcc <iget+0x40>
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+    80002fc0:	02090963          	beqz	s2,80002ff2 <iget+0x66>
+  for(ip = &itable.inode[0]; ip < &itable.inode[NINODE]; ip++){
+    80002fc4:	08848493          	addi	s1,s1,136
+    80002fc8:	02d48863          	beq	s1,a3,80002ff8 <iget+0x6c>
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+    80002fcc:	449c                	lw	a5,8(s1)
+    80002fce:	fef059e3          	blez	a5,80002fc0 <iget+0x34>
+    80002fd2:	4098                	lw	a4,0(s1)
+    80002fd4:	ff3716e3          	bne	a4,s3,80002fc0 <iget+0x34>
+    80002fd8:	40d8                	lw	a4,4(s1)
+    80002fda:	ff4713e3          	bne	a4,s4,80002fc0 <iget+0x34>
+      ip->ref++;
+    80002fde:	2785                	addiw	a5,a5,1
+    80002fe0:	c49c                	sw	a5,8(s1)
+      release(&itable.lock);
+    80002fe2:	0001e517          	auipc	a0,0x1e
+    80002fe6:	23e50513          	addi	a0,a0,574 # 80021220 <itable>
+    80002fea:	c7dfd0ef          	jal	80000c66 <release>
+      return ip;
+    80002fee:	8926                	mv	s2,s1
+    80002ff0:	a02d                	j	8000301a <iget+0x8e>
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+    80002ff2:	fbe9                	bnez	a5,80002fc4 <iget+0x38>
+      empty = ip;
+    80002ff4:	8926                	mv	s2,s1
+    80002ff6:	b7f9                	j	80002fc4 <iget+0x38>
+  if(empty == 0)
+    80002ff8:	02090a63          	beqz	s2,8000302c <iget+0xa0>
+  ip->dev = dev;
+    80002ffc:	01392023          	sw	s3,0(s2)
+  ip->inum = inum;
+    80003000:	01492223          	sw	s4,4(s2)
+  ip->ref = 1;
+    80003004:	4785                	li	a5,1
+    80003006:	00f92423          	sw	a5,8(s2)
+  ip->valid = 0;
+    8000300a:	04092023          	sw	zero,64(s2)
+  release(&itable.lock);
+    8000300e:	0001e517          	auipc	a0,0x1e
+    80003012:	21250513          	addi	a0,a0,530 # 80021220 <itable>
+    80003016:	c51fd0ef          	jal	80000c66 <release>
+}
+    8000301a:	854a                	mv	a0,s2
+    8000301c:	70a2                	ld	ra,40(sp)
+    8000301e:	7402                	ld	s0,32(sp)
+    80003020:	64e2                	ld	s1,24(sp)
+    80003022:	6942                	ld	s2,16(sp)
+    80003024:	69a2                	ld	s3,8(sp)
+    80003026:	6a02                	ld	s4,0(sp)
+    80003028:	6145                	addi	sp,sp,48
+    8000302a:	8082                	ret
+    panic("iget: no inodes");
+    8000302c:	00004517          	auipc	a0,0x4
+    80003030:	41450513          	addi	a0,a0,1044 # 80007440 <etext+0x440>
+    80003034:	facfd0ef          	jal	800007e0 <panic>
+
+0000000080003038 <iinit>:
+{
+    80003038:	7179                	addi	sp,sp,-48
+    8000303a:	f406                	sd	ra,40(sp)
+    8000303c:	f022                	sd	s0,32(sp)
+    8000303e:	ec26                	sd	s1,24(sp)
+    80003040:	e84a                	sd	s2,16(sp)
+    80003042:	e44e                	sd	s3,8(sp)
+    80003044:	1800                	addi	s0,sp,48
+  initlock(&itable.lock, "itable");
+    80003046:	00004597          	auipc	a1,0x4
+    8000304a:	40a58593          	addi	a1,a1,1034 # 80007450 <etext+0x450>
+    8000304e:	0001e517          	auipc	a0,0x1e
+    80003052:	1d250513          	addi	a0,a0,466 # 80021220 <itable>
+    80003056:	af9fd0ef          	jal	80000b4e <initlock>
+  for(i = 0; i < NINODE; i++) {
+    8000305a:	0001e497          	auipc	s1,0x1e
+    8000305e:	1ee48493          	addi	s1,s1,494 # 80021248 <itable+0x28>
+    80003062:	00020997          	auipc	s3,0x20
+    80003066:	c7698993          	addi	s3,s3,-906 # 80022cd8 <log+0x10>
+    initsleeplock(&itable.inode[i].lock, "inode");
+    8000306a:	00004917          	auipc	s2,0x4
+    8000306e:	3ee90913          	addi	s2,s2,1006 # 80007458 <etext+0x458>
+    80003072:	85ca                	mv	a1,s2
+    80003074:	8526                	mv	a0,s1
+    80003076:	5bb000ef          	jal	80003e30 <initsleeplock>
+  for(i = 0; i < NINODE; i++) {
+    8000307a:	08848493          	addi	s1,s1,136
+    8000307e:	ff349ae3          	bne	s1,s3,80003072 <iinit+0x3a>
+}
+    80003082:	70a2                	ld	ra,40(sp)
+    80003084:	7402                	ld	s0,32(sp)
+    80003086:	64e2                	ld	s1,24(sp)
+    80003088:	6942                	ld	s2,16(sp)
+    8000308a:	69a2                	ld	s3,8(sp)
+    8000308c:	6145                	addi	sp,sp,48
+    8000308e:	8082                	ret
+
+0000000080003090 <ialloc>:
+{
+    80003090:	7139                	addi	sp,sp,-64
+    80003092:	fc06                	sd	ra,56(sp)
+    80003094:	f822                	sd	s0,48(sp)
+    80003096:	0080                	addi	s0,sp,64
+  for(inum = 1; inum < sb.ninodes; inum++){
+    80003098:	0001e717          	auipc	a4,0x1e
+    8000309c:	17472703          	lw	a4,372(a4) # 8002120c <sb+0xc>
+    800030a0:	4785                	li	a5,1
+    800030a2:	06e7f063          	bgeu	a5,a4,80003102 <ialloc+0x72>
+    800030a6:	f426                	sd	s1,40(sp)
+    800030a8:	f04a                	sd	s2,32(sp)
+    800030aa:	ec4e                	sd	s3,24(sp)
+    800030ac:	e852                	sd	s4,16(sp)
+    800030ae:	e456                	sd	s5,8(sp)
+    800030b0:	e05a                	sd	s6,0(sp)
+    800030b2:	8aaa                	mv	s5,a0
+    800030b4:	8b2e                	mv	s6,a1
+    800030b6:	4905                	li	s2,1
+    bp = bread(dev, IBLOCK(inum, sb));
+    800030b8:	0001ea17          	auipc	s4,0x1e
+    800030bc:	148a0a13          	addi	s4,s4,328 # 80021200 <sb>
+    800030c0:	00495593          	srli	a1,s2,0x4
+    800030c4:	018a2783          	lw	a5,24(s4)
+    800030c8:	9dbd                	addw	a1,a1,a5
+    800030ca:	8556                	mv	a0,s5
+    800030cc:	a69ff0ef          	jal	80002b34 <bread>
+    800030d0:	84aa                	mv	s1,a0
+    dip = (struct dinode*)bp->data + inum%IPB;
+    800030d2:	05850993          	addi	s3,a0,88
+    800030d6:	00f97793          	andi	a5,s2,15
+    800030da:	079a                	slli	a5,a5,0x6
+    800030dc:	99be                	add	s3,s3,a5
+    if(dip->type == 0){  // a free inode
+    800030de:	00099783          	lh	a5,0(s3)
+    800030e2:	cb9d                	beqz	a5,80003118 <ialloc+0x88>
+    brelse(bp);
+    800030e4:	b59ff0ef          	jal	80002c3c <brelse>
+  for(inum = 1; inum < sb.ninodes; inum++){
+    800030e8:	0905                	addi	s2,s2,1
+    800030ea:	00ca2703          	lw	a4,12(s4)
+    800030ee:	0009079b          	sext.w	a5,s2
+    800030f2:	fce7e7e3          	bltu	a5,a4,800030c0 <ialloc+0x30>
+    800030f6:	74a2                	ld	s1,40(sp)
+    800030f8:	7902                	ld	s2,32(sp)
+    800030fa:	69e2                	ld	s3,24(sp)
+    800030fc:	6a42                	ld	s4,16(sp)
+    800030fe:	6aa2                	ld	s5,8(sp)
+    80003100:	6b02                	ld	s6,0(sp)
+  printf("ialloc: no inodes\n");
+    80003102:	00004517          	auipc	a0,0x4
+    80003106:	35e50513          	addi	a0,a0,862 # 80007460 <etext+0x460>
+    8000310a:	bf0fd0ef          	jal	800004fa <printf>
+  return 0;
+    8000310e:	4501                	li	a0,0
+}
+    80003110:	70e2                	ld	ra,56(sp)
+    80003112:	7442                	ld	s0,48(sp)
+    80003114:	6121                	addi	sp,sp,64
+    80003116:	8082                	ret
+      memset(dip, 0, sizeof(*dip));
+    80003118:	04000613          	li	a2,64
+    8000311c:	4581                	li	a1,0
+    8000311e:	854e                	mv	a0,s3
+    80003120:	b83fd0ef          	jal	80000ca2 <memset>
+      dip->type = type;
+    80003124:	01699023          	sh	s6,0(s3)
+      log_write(bp);   // mark it allocated on the disk
+    80003128:	8526                	mv	a0,s1
+    8000312a:	445000ef          	jal	80003d6e <log_write>
+      brelse(bp);
+    8000312e:	8526                	mv	a0,s1
+    80003130:	b0dff0ef          	jal	80002c3c <brelse>
+      return iget(dev, inum);
+    80003134:	0009059b          	sext.w	a1,s2
+    80003138:	8556                	mv	a0,s5
+    8000313a:	e53ff0ef          	jal	80002f8c <iget>
+    8000313e:	74a2                	ld	s1,40(sp)
+    80003140:	7902                	ld	s2,32(sp)
+    80003142:	69e2                	ld	s3,24(sp)
+    80003144:	6a42                	ld	s4,16(sp)
+    80003146:	6aa2                	ld	s5,8(sp)
+    80003148:	6b02                	ld	s6,0(sp)
+    8000314a:	b7d9                	j	80003110 <ialloc+0x80>
+
+000000008000314c <iupdate>:
+{
+    8000314c:	1101                	addi	sp,sp,-32
+    8000314e:	ec06                	sd	ra,24(sp)
+    80003150:	e822                	sd	s0,16(sp)
+    80003152:	e426                	sd	s1,8(sp)
+    80003154:	e04a                	sd	s2,0(sp)
+    80003156:	1000                	addi	s0,sp,32
+    80003158:	84aa                	mv	s1,a0
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    8000315a:	415c                	lw	a5,4(a0)
+    8000315c:	0047d79b          	srliw	a5,a5,0x4
+    80003160:	0001e597          	auipc	a1,0x1e
+    80003164:	0b85a583          	lw	a1,184(a1) # 80021218 <sb+0x18>
+    80003168:	9dbd                	addw	a1,a1,a5
+    8000316a:	4108                	lw	a0,0(a0)
+    8000316c:	9c9ff0ef          	jal	80002b34 <bread>
+    80003170:	892a                	mv	s2,a0
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+    80003172:	05850793          	addi	a5,a0,88
+    80003176:	40d8                	lw	a4,4(s1)
+    80003178:	8b3d                	andi	a4,a4,15
+    8000317a:	071a                	slli	a4,a4,0x6
+    8000317c:	97ba                	add	a5,a5,a4
+  dip->type = ip->type;
+    8000317e:	04449703          	lh	a4,68(s1)
+    80003182:	00e79023          	sh	a4,0(a5)
+  dip->major = ip->major;
+    80003186:	04649703          	lh	a4,70(s1)
+    8000318a:	00e79123          	sh	a4,2(a5)
+  dip->minor = ip->minor;
+    8000318e:	04849703          	lh	a4,72(s1)
+    80003192:	00e79223          	sh	a4,4(a5)
+  dip->nlink = ip->nlink;
+    80003196:	04a49703          	lh	a4,74(s1)
+    8000319a:	00e79323          	sh	a4,6(a5)
+  dip->size = ip->size;
+    8000319e:	44f8                	lw	a4,76(s1)
+    800031a0:	c798                	sw	a4,8(a5)
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+    800031a2:	03400613          	li	a2,52
+    800031a6:	05048593          	addi	a1,s1,80
+    800031aa:	00c78513          	addi	a0,a5,12
+    800031ae:	b51fd0ef          	jal	80000cfe <memmove>
+  log_write(bp);
+    800031b2:	854a                	mv	a0,s2
+    800031b4:	3bb000ef          	jal	80003d6e <log_write>
+  brelse(bp);
+    800031b8:	854a                	mv	a0,s2
+    800031ba:	a83ff0ef          	jal	80002c3c <brelse>
+}
+    800031be:	60e2                	ld	ra,24(sp)
+    800031c0:	6442                	ld	s0,16(sp)
+    800031c2:	64a2                	ld	s1,8(sp)
+    800031c4:	6902                	ld	s2,0(sp)
+    800031c6:	6105                	addi	sp,sp,32
+    800031c8:	8082                	ret
+
+00000000800031ca <idup>:
+{
+    800031ca:	1101                	addi	sp,sp,-32
+    800031cc:	ec06                	sd	ra,24(sp)
+    800031ce:	e822                	sd	s0,16(sp)
+    800031d0:	e426                	sd	s1,8(sp)
+    800031d2:	1000                	addi	s0,sp,32
+    800031d4:	84aa                	mv	s1,a0
+  acquire(&itable.lock);
+    800031d6:	0001e517          	auipc	a0,0x1e
+    800031da:	04a50513          	addi	a0,a0,74 # 80021220 <itable>
+    800031de:	9f1fd0ef          	jal	80000bce <acquire>
+  ip->ref++;
+    800031e2:	449c                	lw	a5,8(s1)
+    800031e4:	2785                	addiw	a5,a5,1
+    800031e6:	c49c                	sw	a5,8(s1)
+  release(&itable.lock);
+    800031e8:	0001e517          	auipc	a0,0x1e
+    800031ec:	03850513          	addi	a0,a0,56 # 80021220 <itable>
+    800031f0:	a77fd0ef          	jal	80000c66 <release>
+}
+    800031f4:	8526                	mv	a0,s1
+    800031f6:	60e2                	ld	ra,24(sp)
+    800031f8:	6442                	ld	s0,16(sp)
+    800031fa:	64a2                	ld	s1,8(sp)
+    800031fc:	6105                	addi	sp,sp,32
+    800031fe:	8082                	ret
+
+0000000080003200 <ilock>:
+{
+    80003200:	1101                	addi	sp,sp,-32
+    80003202:	ec06                	sd	ra,24(sp)
+    80003204:	e822                	sd	s0,16(sp)
+    80003206:	e426                	sd	s1,8(sp)
+    80003208:	1000                	addi	s0,sp,32
+  if(ip == 0 || ip->ref < 1)
+    8000320a:	cd19                	beqz	a0,80003228 <ilock+0x28>
+    8000320c:	84aa                	mv	s1,a0
+    8000320e:	451c                	lw	a5,8(a0)
+    80003210:	00f05c63          	blez	a5,80003228 <ilock+0x28>
+  acquiresleep(&ip->lock);
+    80003214:	0541                	addi	a0,a0,16
+    80003216:	451000ef          	jal	80003e66 <acquiresleep>
+  if(ip->valid == 0){
+    8000321a:	40bc                	lw	a5,64(s1)
+    8000321c:	cf89                	beqz	a5,80003236 <ilock+0x36>
+}
+    8000321e:	60e2                	ld	ra,24(sp)
+    80003220:	6442                	ld	s0,16(sp)
+    80003222:	64a2                	ld	s1,8(sp)
+    80003224:	6105                	addi	sp,sp,32
+    80003226:	8082                	ret
+    80003228:	e04a                	sd	s2,0(sp)
+    panic("ilock");
+    8000322a:	00004517          	auipc	a0,0x4
+    8000322e:	24e50513          	addi	a0,a0,590 # 80007478 <etext+0x478>
+    80003232:	daefd0ef          	jal	800007e0 <panic>
+    80003236:	e04a                	sd	s2,0(sp)
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    80003238:	40dc                	lw	a5,4(s1)
+    8000323a:	0047d79b          	srliw	a5,a5,0x4
+    8000323e:	0001e597          	auipc	a1,0x1e
+    80003242:	fda5a583          	lw	a1,-38(a1) # 80021218 <sb+0x18>
+    80003246:	9dbd                	addw	a1,a1,a5
+    80003248:	4088                	lw	a0,0(s1)
+    8000324a:	8ebff0ef          	jal	80002b34 <bread>
+    8000324e:	892a                	mv	s2,a0
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+    80003250:	05850593          	addi	a1,a0,88
+    80003254:	40dc                	lw	a5,4(s1)
+    80003256:	8bbd                	andi	a5,a5,15
+    80003258:	079a                	slli	a5,a5,0x6
+    8000325a:	95be                	add	a1,a1,a5
+    ip->type = dip->type;
+    8000325c:	00059783          	lh	a5,0(a1)
+    80003260:	04f49223          	sh	a5,68(s1)
+    ip->major = dip->major;
+    80003264:	00259783          	lh	a5,2(a1)
+    80003268:	04f49323          	sh	a5,70(s1)
+    ip->minor = dip->minor;
+    8000326c:	00459783          	lh	a5,4(a1)
+    80003270:	04f49423          	sh	a5,72(s1)
+    ip->nlink = dip->nlink;
+    80003274:	00659783          	lh	a5,6(a1)
+    80003278:	04f49523          	sh	a5,74(s1)
+    ip->size = dip->size;
+    8000327c:	459c                	lw	a5,8(a1)
+    8000327e:	c4fc                	sw	a5,76(s1)
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+    80003280:	03400613          	li	a2,52
+    80003284:	05b1                	addi	a1,a1,12
+    80003286:	05048513          	addi	a0,s1,80
+    8000328a:	a75fd0ef          	jal	80000cfe <memmove>
+    brelse(bp);
+    8000328e:	854a                	mv	a0,s2
+    80003290:	9adff0ef          	jal	80002c3c <brelse>
+    ip->valid = 1;
+    80003294:	4785                	li	a5,1
+    80003296:	c0bc                	sw	a5,64(s1)
+    if(ip->type == 0)
+    80003298:	04449783          	lh	a5,68(s1)
+    8000329c:	c399                	beqz	a5,800032a2 <ilock+0xa2>
+    8000329e:	6902                	ld	s2,0(sp)
+    800032a0:	bfbd                	j	8000321e <ilock+0x1e>
+      panic("ilock: no type");
+    800032a2:	00004517          	auipc	a0,0x4
+    800032a6:	1de50513          	addi	a0,a0,478 # 80007480 <etext+0x480>
+    800032aa:	d36fd0ef          	jal	800007e0 <panic>
+
+00000000800032ae <iunlock>:
+{
+    800032ae:	1101                	addi	sp,sp,-32
+    800032b0:	ec06                	sd	ra,24(sp)
+    800032b2:	e822                	sd	s0,16(sp)
+    800032b4:	e426                	sd	s1,8(sp)
+    800032b6:	e04a                	sd	s2,0(sp)
+    800032b8:	1000                	addi	s0,sp,32
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+    800032ba:	c505                	beqz	a0,800032e2 <iunlock+0x34>
+    800032bc:	84aa                	mv	s1,a0
+    800032be:	01050913          	addi	s2,a0,16
+    800032c2:	854a                	mv	a0,s2
+    800032c4:	421000ef          	jal	80003ee4 <holdingsleep>
+    800032c8:	cd09                	beqz	a0,800032e2 <iunlock+0x34>
+    800032ca:	449c                	lw	a5,8(s1)
+    800032cc:	00f05b63          	blez	a5,800032e2 <iunlock+0x34>
+  releasesleep(&ip->lock);
+    800032d0:	854a                	mv	a0,s2
+    800032d2:	3db000ef          	jal	80003eac <releasesleep>
+}
+    800032d6:	60e2                	ld	ra,24(sp)
+    800032d8:	6442                	ld	s0,16(sp)
+    800032da:	64a2                	ld	s1,8(sp)
+    800032dc:	6902                	ld	s2,0(sp)
+    800032de:	6105                	addi	sp,sp,32
+    800032e0:	8082                	ret
+    panic("iunlock");
+    800032e2:	00004517          	auipc	a0,0x4
+    800032e6:	1ae50513          	addi	a0,a0,430 # 80007490 <etext+0x490>
+    800032ea:	cf6fd0ef          	jal	800007e0 <panic>
+
+00000000800032ee <itrunc>:
+
+// Truncate inode (discard contents).
+// Caller must hold ip->lock.
+void
+itrunc(struct inode *ip)
+{
+    800032ee:	7179                	addi	sp,sp,-48
+    800032f0:	f406                	sd	ra,40(sp)
+    800032f2:	f022                	sd	s0,32(sp)
+    800032f4:	ec26                	sd	s1,24(sp)
+    800032f6:	e84a                	sd	s2,16(sp)
+    800032f8:	e44e                	sd	s3,8(sp)
+    800032fa:	1800                	addi	s0,sp,48
+    800032fc:	89aa                	mv	s3,a0
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+    800032fe:	05050493          	addi	s1,a0,80
+    80003302:	08050913          	addi	s2,a0,128
+    80003306:	a021                	j	8000330e <itrunc+0x20>
+    80003308:	0491                	addi	s1,s1,4
+    8000330a:	01248b63          	beq	s1,s2,80003320 <itrunc+0x32>
+    if(ip->addrs[i]){
+    8000330e:	408c                	lw	a1,0(s1)
+    80003310:	dde5                	beqz	a1,80003308 <itrunc+0x1a>
+      bfree(ip->dev, ip->addrs[i]);
+    80003312:	0009a503          	lw	a0,0(s3)
+    80003316:	a17ff0ef          	jal	80002d2c <bfree>
+      ip->addrs[i] = 0;
+    8000331a:	0004a023          	sw	zero,0(s1)
+    8000331e:	b7ed                	j	80003308 <itrunc+0x1a>
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+    80003320:	0809a583          	lw	a1,128(s3)
+    80003324:	ed89                	bnez	a1,8000333e <itrunc+0x50>
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+    80003326:	0409a623          	sw	zero,76(s3)
+  iupdate(ip);
+    8000332a:	854e                	mv	a0,s3
+    8000332c:	e21ff0ef          	jal	8000314c <iupdate>
+}
+    80003330:	70a2                	ld	ra,40(sp)
+    80003332:	7402                	ld	s0,32(sp)
+    80003334:	64e2                	ld	s1,24(sp)
+    80003336:	6942                	ld	s2,16(sp)
+    80003338:	69a2                	ld	s3,8(sp)
+    8000333a:	6145                	addi	sp,sp,48
+    8000333c:	8082                	ret
+    8000333e:	e052                	sd	s4,0(sp)
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+    80003340:	0009a503          	lw	a0,0(s3)
+    80003344:	ff0ff0ef          	jal	80002b34 <bread>
+    80003348:	8a2a                	mv	s4,a0
+    for(j = 0; j < NINDIRECT; j++){
+    8000334a:	05850493          	addi	s1,a0,88
+    8000334e:	45850913          	addi	s2,a0,1112
+    80003352:	a021                	j	8000335a <itrunc+0x6c>
+    80003354:	0491                	addi	s1,s1,4
+    80003356:	01248963          	beq	s1,s2,80003368 <itrunc+0x7a>
+      if(a[j])
+    8000335a:	408c                	lw	a1,0(s1)
+    8000335c:	dde5                	beqz	a1,80003354 <itrunc+0x66>
+        bfree(ip->dev, a[j]);
+    8000335e:	0009a503          	lw	a0,0(s3)
+    80003362:	9cbff0ef          	jal	80002d2c <bfree>
+    80003366:	b7fd                	j	80003354 <itrunc+0x66>
+    brelse(bp);
+    80003368:	8552                	mv	a0,s4
+    8000336a:	8d3ff0ef          	jal	80002c3c <brelse>
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    8000336e:	0809a583          	lw	a1,128(s3)
+    80003372:	0009a503          	lw	a0,0(s3)
+    80003376:	9b7ff0ef          	jal	80002d2c <bfree>
+    ip->addrs[NDIRECT] = 0;
+    8000337a:	0809a023          	sw	zero,128(s3)
+    8000337e:	6a02                	ld	s4,0(sp)
+    80003380:	b75d                	j	80003326 <itrunc+0x38>
+
+0000000080003382 <iput>:
+{
+    80003382:	1101                	addi	sp,sp,-32
+    80003384:	ec06                	sd	ra,24(sp)
+    80003386:	e822                	sd	s0,16(sp)
+    80003388:	e426                	sd	s1,8(sp)
+    8000338a:	1000                	addi	s0,sp,32
+    8000338c:	84aa                	mv	s1,a0
+  acquire(&itable.lock);
+    8000338e:	0001e517          	auipc	a0,0x1e
+    80003392:	e9250513          	addi	a0,a0,-366 # 80021220 <itable>
+    80003396:	839fd0ef          	jal	80000bce <acquire>
+  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
+    8000339a:	4498                	lw	a4,8(s1)
+    8000339c:	4785                	li	a5,1
+    8000339e:	02f70063          	beq	a4,a5,800033be <iput+0x3c>
+  ip->ref--;
+    800033a2:	449c                	lw	a5,8(s1)
+    800033a4:	37fd                	addiw	a5,a5,-1
+    800033a6:	c49c                	sw	a5,8(s1)
+  release(&itable.lock);
+    800033a8:	0001e517          	auipc	a0,0x1e
+    800033ac:	e7850513          	addi	a0,a0,-392 # 80021220 <itable>
+    800033b0:	8b7fd0ef          	jal	80000c66 <release>
+}
+    800033b4:	60e2                	ld	ra,24(sp)
+    800033b6:	6442                	ld	s0,16(sp)
+    800033b8:	64a2                	ld	s1,8(sp)
+    800033ba:	6105                	addi	sp,sp,32
+    800033bc:	8082                	ret
+  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
+    800033be:	40bc                	lw	a5,64(s1)
+    800033c0:	d3ed                	beqz	a5,800033a2 <iput+0x20>
+    800033c2:	04a49783          	lh	a5,74(s1)
+    800033c6:	fff1                	bnez	a5,800033a2 <iput+0x20>
+    800033c8:	e04a                	sd	s2,0(sp)
+    acquiresleep(&ip->lock);
+    800033ca:	01048913          	addi	s2,s1,16
+    800033ce:	854a                	mv	a0,s2
+    800033d0:	297000ef          	jal	80003e66 <acquiresleep>
+    release(&itable.lock);
+    800033d4:	0001e517          	auipc	a0,0x1e
+    800033d8:	e4c50513          	addi	a0,a0,-436 # 80021220 <itable>
+    800033dc:	88bfd0ef          	jal	80000c66 <release>
+    itrunc(ip);
+    800033e0:	8526                	mv	a0,s1
+    800033e2:	f0dff0ef          	jal	800032ee <itrunc>
+    ip->type = 0;
+    800033e6:	04049223          	sh	zero,68(s1)
+    iupdate(ip);
+    800033ea:	8526                	mv	a0,s1
+    800033ec:	d61ff0ef          	jal	8000314c <iupdate>
+    ip->valid = 0;
+    800033f0:	0404a023          	sw	zero,64(s1)
+    releasesleep(&ip->lock);
+    800033f4:	854a                	mv	a0,s2
+    800033f6:	2b7000ef          	jal	80003eac <releasesleep>
+    acquire(&itable.lock);
+    800033fa:	0001e517          	auipc	a0,0x1e
+    800033fe:	e2650513          	addi	a0,a0,-474 # 80021220 <itable>
+    80003402:	fccfd0ef          	jal	80000bce <acquire>
+    80003406:	6902                	ld	s2,0(sp)
+    80003408:	bf69                	j	800033a2 <iput+0x20>
+
+000000008000340a <iunlockput>:
+{
+    8000340a:	1101                	addi	sp,sp,-32
+    8000340c:	ec06                	sd	ra,24(sp)
+    8000340e:	e822                	sd	s0,16(sp)
+    80003410:	e426                	sd	s1,8(sp)
+    80003412:	1000                	addi	s0,sp,32
+    80003414:	84aa                	mv	s1,a0
+  iunlock(ip);
+    80003416:	e99ff0ef          	jal	800032ae <iunlock>
+  iput(ip);
+    8000341a:	8526                	mv	a0,s1
+    8000341c:	f67ff0ef          	jal	80003382 <iput>
+}
+    80003420:	60e2                	ld	ra,24(sp)
+    80003422:	6442                	ld	s0,16(sp)
+    80003424:	64a2                	ld	s1,8(sp)
+    80003426:	6105                	addi	sp,sp,32
+    80003428:	8082                	ret
+
+000000008000342a <ireclaim>:
+  for (int inum = 1; inum < sb.ninodes; inum++) {
+    8000342a:	0001e717          	auipc	a4,0x1e
+    8000342e:	de272703          	lw	a4,-542(a4) # 8002120c <sb+0xc>
+    80003432:	4785                	li	a5,1
+    80003434:	0ae7ff63          	bgeu	a5,a4,800034f2 <ireclaim+0xc8>
+{
+    80003438:	7139                	addi	sp,sp,-64
+    8000343a:	fc06                	sd	ra,56(sp)
+    8000343c:	f822                	sd	s0,48(sp)
+    8000343e:	f426                	sd	s1,40(sp)
+    80003440:	f04a                	sd	s2,32(sp)
+    80003442:	ec4e                	sd	s3,24(sp)
+    80003444:	e852                	sd	s4,16(sp)
+    80003446:	e456                	sd	s5,8(sp)
+    80003448:	e05a                	sd	s6,0(sp)
+    8000344a:	0080                	addi	s0,sp,64
+  for (int inum = 1; inum < sb.ninodes; inum++) {
+    8000344c:	4485                	li	s1,1
+    struct buf *bp = bread(dev, IBLOCK(inum, sb));
+    8000344e:	00050a1b          	sext.w	s4,a0
+    80003452:	0001ea97          	auipc	s5,0x1e
+    80003456:	daea8a93          	addi	s5,s5,-594 # 80021200 <sb>
+      printf("ireclaim: orphaned inode %d\n", inum);
+    8000345a:	00004b17          	auipc	s6,0x4
+    8000345e:	03eb0b13          	addi	s6,s6,62 # 80007498 <etext+0x498>
+    80003462:	a099                	j	800034a8 <ireclaim+0x7e>
+    80003464:	85ce                	mv	a1,s3
+    80003466:	855a                	mv	a0,s6
+    80003468:	892fd0ef          	jal	800004fa <printf>
+      ip = iget(dev, inum);
+    8000346c:	85ce                	mv	a1,s3
+    8000346e:	8552                	mv	a0,s4
+    80003470:	b1dff0ef          	jal	80002f8c <iget>
+    80003474:	89aa                	mv	s3,a0
+    brelse(bp);
+    80003476:	854a                	mv	a0,s2
+    80003478:	fc4ff0ef          	jal	80002c3c <brelse>
+    if (ip) {
+    8000347c:	00098f63          	beqz	s3,8000349a <ireclaim+0x70>
+      begin_op();
+    80003480:	76a000ef          	jal	80003bea <begin_op>
+      ilock(ip);
+    80003484:	854e                	mv	a0,s3
+    80003486:	d7bff0ef          	jal	80003200 <ilock>
+      iunlock(ip);
+    8000348a:	854e                	mv	a0,s3
+    8000348c:	e23ff0ef          	jal	800032ae <iunlock>
+      iput(ip);
+    80003490:	854e                	mv	a0,s3
+    80003492:	ef1ff0ef          	jal	80003382 <iput>
+      end_op();
+    80003496:	7be000ef          	jal	80003c54 <end_op>
+  for (int inum = 1; inum < sb.ninodes; inum++) {
+    8000349a:	0485                	addi	s1,s1,1
+    8000349c:	00caa703          	lw	a4,12(s5)
+    800034a0:	0004879b          	sext.w	a5,s1
+    800034a4:	02e7fd63          	bgeu	a5,a4,800034de <ireclaim+0xb4>
+    800034a8:	0004899b          	sext.w	s3,s1
+    struct buf *bp = bread(dev, IBLOCK(inum, sb));
+    800034ac:	0044d593          	srli	a1,s1,0x4
+    800034b0:	018aa783          	lw	a5,24(s5)
+    800034b4:	9dbd                	addw	a1,a1,a5
+    800034b6:	8552                	mv	a0,s4
+    800034b8:	e7cff0ef          	jal	80002b34 <bread>
+    800034bc:	892a                	mv	s2,a0
+    struct dinode *dip = (struct dinode *)bp->data + inum % IPB;
+    800034be:	05850793          	addi	a5,a0,88
+    800034c2:	00f9f713          	andi	a4,s3,15
+    800034c6:	071a                	slli	a4,a4,0x6
+    800034c8:	97ba                	add	a5,a5,a4
+    if (dip->type != 0 && dip->nlink == 0) {  // is an orphaned inode
+    800034ca:	00079703          	lh	a4,0(a5)
+    800034ce:	c701                	beqz	a4,800034d6 <ireclaim+0xac>
+    800034d0:	00679783          	lh	a5,6(a5)
+    800034d4:	dbc1                	beqz	a5,80003464 <ireclaim+0x3a>
+    brelse(bp);
+    800034d6:	854a                	mv	a0,s2
+    800034d8:	f64ff0ef          	jal	80002c3c <brelse>
+    if (ip) {
+    800034dc:	bf7d                	j	8000349a <ireclaim+0x70>
+}
+    800034de:	70e2                	ld	ra,56(sp)
+    800034e0:	7442                	ld	s0,48(sp)
+    800034e2:	74a2                	ld	s1,40(sp)
+    800034e4:	7902                	ld	s2,32(sp)
+    800034e6:	69e2                	ld	s3,24(sp)
+    800034e8:	6a42                	ld	s4,16(sp)
+    800034ea:	6aa2                	ld	s5,8(sp)
+    800034ec:	6b02                	ld	s6,0(sp)
+    800034ee:	6121                	addi	sp,sp,64
+    800034f0:	8082                	ret
+    800034f2:	8082                	ret
+
+00000000800034f4 <fsinit>:
+fsinit(int dev) {
+    800034f4:	7179                	addi	sp,sp,-48
+    800034f6:	f406                	sd	ra,40(sp)
+    800034f8:	f022                	sd	s0,32(sp)
+    800034fa:	ec26                	sd	s1,24(sp)
+    800034fc:	e84a                	sd	s2,16(sp)
+    800034fe:	e44e                	sd	s3,8(sp)
+    80003500:	1800                	addi	s0,sp,48
+    80003502:	84aa                	mv	s1,a0
+  bp = bread(dev, 1);
+    80003504:	4585                	li	a1,1
+    80003506:	e2eff0ef          	jal	80002b34 <bread>
+    8000350a:	892a                	mv	s2,a0
+  memmove(sb, bp->data, sizeof(*sb));
+    8000350c:	0001e997          	auipc	s3,0x1e
+    80003510:	cf498993          	addi	s3,s3,-780 # 80021200 <sb>
+    80003514:	02000613          	li	a2,32
+    80003518:	05850593          	addi	a1,a0,88
+    8000351c:	854e                	mv	a0,s3
+    8000351e:	fe0fd0ef          	jal	80000cfe <memmove>
+  brelse(bp);
+    80003522:	854a                	mv	a0,s2
+    80003524:	f18ff0ef          	jal	80002c3c <brelse>
+  if(sb.magic != FSMAGIC)
+    80003528:	0009a703          	lw	a4,0(s3)
+    8000352c:	102037b7          	lui	a5,0x10203
+    80003530:	04078793          	addi	a5,a5,64 # 10203040 <_entry-0x6fdfcfc0>
+    80003534:	02f71363          	bne	a4,a5,8000355a <fsinit+0x66>
+  initlog(dev, &sb);
+    80003538:	0001e597          	auipc	a1,0x1e
+    8000353c:	cc858593          	addi	a1,a1,-824 # 80021200 <sb>
+    80003540:	8526                	mv	a0,s1
+    80003542:	62a000ef          	jal	80003b6c <initlog>
+  ireclaim(dev);
+    80003546:	8526                	mv	a0,s1
+    80003548:	ee3ff0ef          	jal	8000342a <ireclaim>
+}
+    8000354c:	70a2                	ld	ra,40(sp)
+    8000354e:	7402                	ld	s0,32(sp)
+    80003550:	64e2                	ld	s1,24(sp)
+    80003552:	6942                	ld	s2,16(sp)
+    80003554:	69a2                	ld	s3,8(sp)
+    80003556:	6145                	addi	sp,sp,48
+    80003558:	8082                	ret
+    panic("invalid file system");
+    8000355a:	00004517          	auipc	a0,0x4
+    8000355e:	f5e50513          	addi	a0,a0,-162 # 800074b8 <etext+0x4b8>
+    80003562:	a7efd0ef          	jal	800007e0 <panic>
+
+0000000080003566 <stati>:
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+    80003566:	1141                	addi	sp,sp,-16
+    80003568:	e422                	sd	s0,8(sp)
+    8000356a:	0800                	addi	s0,sp,16
+  st->dev = ip->dev;
+    8000356c:	411c                	lw	a5,0(a0)
+    8000356e:	c19c                	sw	a5,0(a1)
+  st->ino = ip->inum;
+    80003570:	415c                	lw	a5,4(a0)
+    80003572:	c1dc                	sw	a5,4(a1)
+  st->type = ip->type;
+    80003574:	04451783          	lh	a5,68(a0)
+    80003578:	00f59423          	sh	a5,8(a1)
+  st->nlink = ip->nlink;
+    8000357c:	04a51783          	lh	a5,74(a0)
+    80003580:	00f59523          	sh	a5,10(a1)
+  st->size = ip->size;
+    80003584:	04c56783          	lwu	a5,76(a0)
+    80003588:	e99c                	sd	a5,16(a1)
+}
+    8000358a:	6422                	ld	s0,8(sp)
+    8000358c:	0141                	addi	sp,sp,16
+    8000358e:	8082                	ret
+
+0000000080003590 <readi>:
+readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(off > ip->size || off + n < off)
+    80003590:	457c                	lw	a5,76(a0)
+    80003592:	0ed7eb63          	bltu	a5,a3,80003688 <readi+0xf8>
+{
+    80003596:	7159                	addi	sp,sp,-112
+    80003598:	f486                	sd	ra,104(sp)
+    8000359a:	f0a2                	sd	s0,96(sp)
+    8000359c:	eca6                	sd	s1,88(sp)
+    8000359e:	e0d2                	sd	s4,64(sp)
+    800035a0:	fc56                	sd	s5,56(sp)
+    800035a2:	f85a                	sd	s6,48(sp)
+    800035a4:	f45e                	sd	s7,40(sp)
+    800035a6:	1880                	addi	s0,sp,112
+    800035a8:	8b2a                	mv	s6,a0
+    800035aa:	8bae                	mv	s7,a1
+    800035ac:	8a32                	mv	s4,a2
+    800035ae:	84b6                	mv	s1,a3
+    800035b0:	8aba                	mv	s5,a4
+  if(off > ip->size || off + n < off)
+    800035b2:	9f35                	addw	a4,a4,a3
+    return 0;
+    800035b4:	4501                	li	a0,0
+  if(off > ip->size || off + n < off)
+    800035b6:	0cd76063          	bltu	a4,a3,80003676 <readi+0xe6>
+    800035ba:	e4ce                	sd	s3,72(sp)
+  if(off + n > ip->size)
+    800035bc:	00e7f463          	bgeu	a5,a4,800035c4 <readi+0x34>
+    n = ip->size - off;
+    800035c0:	40d78abb          	subw	s5,a5,a3
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    800035c4:	080a8f63          	beqz	s5,80003662 <readi+0xd2>
+    800035c8:	e8ca                	sd	s2,80(sp)
+    800035ca:	f062                	sd	s8,32(sp)
+    800035cc:	ec66                	sd	s9,24(sp)
+    800035ce:	e86a                	sd	s10,16(sp)
+    800035d0:	e46e                	sd	s11,8(sp)
+    800035d2:	4981                	li	s3,0
+    uint addr = bmap(ip, off/BSIZE);
+    if(addr == 0)
+      break;
+    bp = bread(ip->dev, addr);
+    m = min(n - tot, BSIZE - off%BSIZE);
+    800035d4:	40000c93          	li	s9,1024
+    if(either_copyout(user_dst, dst, bp->data + (off % BSIZE), m) == -1) {
+    800035d8:	5c7d                	li	s8,-1
+    800035da:	a80d                	j	8000360c <readi+0x7c>
+    800035dc:	020d1d93          	slli	s11,s10,0x20
+    800035e0:	020ddd93          	srli	s11,s11,0x20
+    800035e4:	05890613          	addi	a2,s2,88
+    800035e8:	86ee                	mv	a3,s11
+    800035ea:	963a                	add	a2,a2,a4
+    800035ec:	85d2                	mv	a1,s4
+    800035ee:	855e                	mv	a0,s7
+    800035f0:	c49fe0ef          	jal	80002238 <either_copyout>
+    800035f4:	05850763          	beq	a0,s8,80003642 <readi+0xb2>
+      brelse(bp);
+      tot = -1;
+      break;
+    }
+    brelse(bp);
+    800035f8:	854a                	mv	a0,s2
+    800035fa:	e42ff0ef          	jal	80002c3c <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    800035fe:	013d09bb          	addw	s3,s10,s3
+    80003602:	009d04bb          	addw	s1,s10,s1
+    80003606:	9a6e                	add	s4,s4,s11
+    80003608:	0559f763          	bgeu	s3,s5,80003656 <readi+0xc6>
+    uint addr = bmap(ip, off/BSIZE);
+    8000360c:	00a4d59b          	srliw	a1,s1,0xa
+    80003610:	855a                	mv	a0,s6
+    80003612:	8a7ff0ef          	jal	80002eb8 <bmap>
+    80003616:	0005059b          	sext.w	a1,a0
+    if(addr == 0)
+    8000361a:	c5b1                	beqz	a1,80003666 <readi+0xd6>
+    bp = bread(ip->dev, addr);
+    8000361c:	000b2503          	lw	a0,0(s6)
+    80003620:	d14ff0ef          	jal	80002b34 <bread>
+    80003624:	892a                	mv	s2,a0
+    m = min(n - tot, BSIZE - off%BSIZE);
+    80003626:	3ff4f713          	andi	a4,s1,1023
+    8000362a:	40ec87bb          	subw	a5,s9,a4
+    8000362e:	413a86bb          	subw	a3,s5,s3
+    80003632:	8d3e                	mv	s10,a5
+    80003634:	2781                	sext.w	a5,a5
+    80003636:	0006861b          	sext.w	a2,a3
+    8000363a:	faf671e3          	bgeu	a2,a5,800035dc <readi+0x4c>
+    8000363e:	8d36                	mv	s10,a3
+    80003640:	bf71                	j	800035dc <readi+0x4c>
+      brelse(bp);
+    80003642:	854a                	mv	a0,s2
+    80003644:	df8ff0ef          	jal	80002c3c <brelse>
+      tot = -1;
+    80003648:	59fd                	li	s3,-1
+      break;
+    8000364a:	6946                	ld	s2,80(sp)
+    8000364c:	7c02                	ld	s8,32(sp)
+    8000364e:	6ce2                	ld	s9,24(sp)
+    80003650:	6d42                	ld	s10,16(sp)
+    80003652:	6da2                	ld	s11,8(sp)
+    80003654:	a831                	j	80003670 <readi+0xe0>
+    80003656:	6946                	ld	s2,80(sp)
+    80003658:	7c02                	ld	s8,32(sp)
+    8000365a:	6ce2                	ld	s9,24(sp)
+    8000365c:	6d42                	ld	s10,16(sp)
+    8000365e:	6da2                	ld	s11,8(sp)
+    80003660:	a801                	j	80003670 <readi+0xe0>
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    80003662:	89d6                	mv	s3,s5
+    80003664:	a031                	j	80003670 <readi+0xe0>
+    80003666:	6946                	ld	s2,80(sp)
+    80003668:	7c02                	ld	s8,32(sp)
+    8000366a:	6ce2                	ld	s9,24(sp)
+    8000366c:	6d42                	ld	s10,16(sp)
+    8000366e:	6da2                	ld	s11,8(sp)
+  }
+  return tot;
+    80003670:	0009851b          	sext.w	a0,s3
+    80003674:	69a6                	ld	s3,72(sp)
+}
+    80003676:	70a6                	ld	ra,104(sp)
+    80003678:	7406                	ld	s0,96(sp)
+    8000367a:	64e6                	ld	s1,88(sp)
+    8000367c:	6a06                	ld	s4,64(sp)
+    8000367e:	7ae2                	ld	s5,56(sp)
+    80003680:	7b42                	ld	s6,48(sp)
+    80003682:	7ba2                	ld	s7,40(sp)
+    80003684:	6165                	addi	sp,sp,112
+    80003686:	8082                	ret
+    return 0;
+    80003688:	4501                	li	a0,0
+}
+    8000368a:	8082                	ret
+
+000000008000368c <writei>:
+writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(off > ip->size || off + n < off)
+    8000368c:	457c                	lw	a5,76(a0)
+    8000368e:	10d7e063          	bltu	a5,a3,8000378e <writei+0x102>
+{
+    80003692:	7159                	addi	sp,sp,-112
+    80003694:	f486                	sd	ra,104(sp)
+    80003696:	f0a2                	sd	s0,96(sp)
+    80003698:	e8ca                	sd	s2,80(sp)
+    8000369a:	e0d2                	sd	s4,64(sp)
+    8000369c:	fc56                	sd	s5,56(sp)
+    8000369e:	f85a                	sd	s6,48(sp)
+    800036a0:	f45e                	sd	s7,40(sp)
+    800036a2:	1880                	addi	s0,sp,112
+    800036a4:	8aaa                	mv	s5,a0
+    800036a6:	8bae                	mv	s7,a1
+    800036a8:	8a32                	mv	s4,a2
+    800036aa:	8936                	mv	s2,a3
+    800036ac:	8b3a                	mv	s6,a4
+  if(off > ip->size || off + n < off)
+    800036ae:	00e687bb          	addw	a5,a3,a4
+    800036b2:	0ed7e063          	bltu	a5,a3,80003792 <writei+0x106>
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+    800036b6:	00043737          	lui	a4,0x43
+    800036ba:	0cf76e63          	bltu	a4,a5,80003796 <writei+0x10a>
+    800036be:	e4ce                	sd	s3,72(sp)
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    800036c0:	0a0b0f63          	beqz	s6,8000377e <writei+0xf2>
+    800036c4:	eca6                	sd	s1,88(sp)
+    800036c6:	f062                	sd	s8,32(sp)
+    800036c8:	ec66                	sd	s9,24(sp)
+    800036ca:	e86a                	sd	s10,16(sp)
+    800036cc:	e46e                	sd	s11,8(sp)
+    800036ce:	4981                	li	s3,0
+    uint addr = bmap(ip, off/BSIZE);
+    if(addr == 0)
+      break;
+    bp = bread(ip->dev, addr);
+    m = min(n - tot, BSIZE - off%BSIZE);
+    800036d0:	40000c93          	li	s9,1024
+    if(either_copyin(bp->data + (off % BSIZE), user_src, src, m) == -1) {
+    800036d4:	5c7d                	li	s8,-1
+    800036d6:	a825                	j	8000370e <writei+0x82>
+    800036d8:	020d1d93          	slli	s11,s10,0x20
+    800036dc:	020ddd93          	srli	s11,s11,0x20
+    800036e0:	05848513          	addi	a0,s1,88
+    800036e4:	86ee                	mv	a3,s11
+    800036e6:	8652                	mv	a2,s4
+    800036e8:	85de                	mv	a1,s7
+    800036ea:	953a                	add	a0,a0,a4
+    800036ec:	b97fe0ef          	jal	80002282 <either_copyin>
+    800036f0:	05850a63          	beq	a0,s8,80003744 <writei+0xb8>
+      brelse(bp);
+      break;
+    }
+    log_write(bp);
+    800036f4:	8526                	mv	a0,s1
+    800036f6:	678000ef          	jal	80003d6e <log_write>
+    brelse(bp);
+    800036fa:	8526                	mv	a0,s1
+    800036fc:	d40ff0ef          	jal	80002c3c <brelse>
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    80003700:	013d09bb          	addw	s3,s10,s3
+    80003704:	012d093b          	addw	s2,s10,s2
+    80003708:	9a6e                	add	s4,s4,s11
+    8000370a:	0569f063          	bgeu	s3,s6,8000374a <writei+0xbe>
+    uint addr = bmap(ip, off/BSIZE);
+    8000370e:	00a9559b          	srliw	a1,s2,0xa
+    80003712:	8556                	mv	a0,s5
+    80003714:	fa4ff0ef          	jal	80002eb8 <bmap>
+    80003718:	0005059b          	sext.w	a1,a0
+    if(addr == 0)
+    8000371c:	c59d                	beqz	a1,8000374a <writei+0xbe>
+    bp = bread(ip->dev, addr);
+    8000371e:	000aa503          	lw	a0,0(s5)
+    80003722:	c12ff0ef          	jal	80002b34 <bread>
+    80003726:	84aa                	mv	s1,a0
+    m = min(n - tot, BSIZE - off%BSIZE);
+    80003728:	3ff97713          	andi	a4,s2,1023
+    8000372c:	40ec87bb          	subw	a5,s9,a4
+    80003730:	413b06bb          	subw	a3,s6,s3
+    80003734:	8d3e                	mv	s10,a5
+    80003736:	2781                	sext.w	a5,a5
+    80003738:	0006861b          	sext.w	a2,a3
+    8000373c:	f8f67ee3          	bgeu	a2,a5,800036d8 <writei+0x4c>
+    80003740:	8d36                	mv	s10,a3
+    80003742:	bf59                	j	800036d8 <writei+0x4c>
+      brelse(bp);
+    80003744:	8526                	mv	a0,s1
+    80003746:	cf6ff0ef          	jal	80002c3c <brelse>
+  }
+
+  if(off > ip->size)
+    8000374a:	04caa783          	lw	a5,76(s5)
+    8000374e:	0327fa63          	bgeu	a5,s2,80003782 <writei+0xf6>
+    ip->size = off;
+    80003752:	052aa623          	sw	s2,76(s5)
+    80003756:	64e6                	ld	s1,88(sp)
+    80003758:	7c02                	ld	s8,32(sp)
+    8000375a:	6ce2                	ld	s9,24(sp)
+    8000375c:	6d42                	ld	s10,16(sp)
+    8000375e:	6da2                	ld	s11,8(sp)
+
+  // write the i-node back to disk even if the size didn't change
+  // because the loop above might have called bmap() and added a new
+  // block to ip->addrs[].
+  iupdate(ip);
+    80003760:	8556                	mv	a0,s5
+    80003762:	9ebff0ef          	jal	8000314c <iupdate>
+
+  return tot;
+    80003766:	0009851b          	sext.w	a0,s3
+    8000376a:	69a6                	ld	s3,72(sp)
+}
+    8000376c:	70a6                	ld	ra,104(sp)
+    8000376e:	7406                	ld	s0,96(sp)
+    80003770:	6946                	ld	s2,80(sp)
+    80003772:	6a06                	ld	s4,64(sp)
+    80003774:	7ae2                	ld	s5,56(sp)
+    80003776:	7b42                	ld	s6,48(sp)
+    80003778:	7ba2                	ld	s7,40(sp)
+    8000377a:	6165                	addi	sp,sp,112
+    8000377c:	8082                	ret
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    8000377e:	89da                	mv	s3,s6
+    80003780:	b7c5                	j	80003760 <writei+0xd4>
+    80003782:	64e6                	ld	s1,88(sp)
+    80003784:	7c02                	ld	s8,32(sp)
+    80003786:	6ce2                	ld	s9,24(sp)
+    80003788:	6d42                	ld	s10,16(sp)
+    8000378a:	6da2                	ld	s11,8(sp)
+    8000378c:	bfd1                	j	80003760 <writei+0xd4>
+    return -1;
+    8000378e:	557d                	li	a0,-1
+}
+    80003790:	8082                	ret
+    return -1;
+    80003792:	557d                	li	a0,-1
+    80003794:	bfe1                	j	8000376c <writei+0xe0>
+    return -1;
+    80003796:	557d                	li	a0,-1
+    80003798:	bfd1                	j	8000376c <writei+0xe0>
+
+000000008000379a <namecmp>:
+
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+    8000379a:	1141                	addi	sp,sp,-16
+    8000379c:	e406                	sd	ra,8(sp)
+    8000379e:	e022                	sd	s0,0(sp)
+    800037a0:	0800                	addi	s0,sp,16
+  return strncmp(s, t, DIRSIZ);
+    800037a2:	4639                	li	a2,14
+    800037a4:	dcafd0ef          	jal	80000d6e <strncmp>
+}
+    800037a8:	60a2                	ld	ra,8(sp)
+    800037aa:	6402                	ld	s0,0(sp)
+    800037ac:	0141                	addi	sp,sp,16
+    800037ae:	8082                	ret
+
+00000000800037b0 <dirlookup>:
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+    800037b0:	7139                	addi	sp,sp,-64
+    800037b2:	fc06                	sd	ra,56(sp)
+    800037b4:	f822                	sd	s0,48(sp)
+    800037b6:	f426                	sd	s1,40(sp)
+    800037b8:	f04a                	sd	s2,32(sp)
+    800037ba:	ec4e                	sd	s3,24(sp)
+    800037bc:	e852                	sd	s4,16(sp)
+    800037be:	0080                	addi	s0,sp,64
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+    800037c0:	04451703          	lh	a4,68(a0)
+    800037c4:	4785                	li	a5,1
+    800037c6:	00f71a63          	bne	a4,a5,800037da <dirlookup+0x2a>
+    800037ca:	892a                	mv	s2,a0
+    800037cc:	89ae                	mv	s3,a1
+    800037ce:	8a32                	mv	s4,a2
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    800037d0:	457c                	lw	a5,76(a0)
+    800037d2:	4481                	li	s1,0
+      inum = de.inum;
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+    800037d4:	4501                	li	a0,0
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    800037d6:	e39d                	bnez	a5,800037fc <dirlookup+0x4c>
+    800037d8:	a095                	j	8000383c <dirlookup+0x8c>
+    panic("dirlookup not DIR");
+    800037da:	00004517          	auipc	a0,0x4
+    800037de:	cf650513          	addi	a0,a0,-778 # 800074d0 <etext+0x4d0>
+    800037e2:	ffffc0ef          	jal	800007e0 <panic>
+      panic("dirlookup read");
+    800037e6:	00004517          	auipc	a0,0x4
+    800037ea:	d0250513          	addi	a0,a0,-766 # 800074e8 <etext+0x4e8>
+    800037ee:	ff3fc0ef          	jal	800007e0 <panic>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    800037f2:	24c1                	addiw	s1,s1,16
+    800037f4:	04c92783          	lw	a5,76(s2)
+    800037f8:	04f4f163          	bgeu	s1,a5,8000383a <dirlookup+0x8a>
+    if(readi(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+    800037fc:	4741                	li	a4,16
+    800037fe:	86a6                	mv	a3,s1
+    80003800:	fc040613          	addi	a2,s0,-64
+    80003804:	4581                	li	a1,0
+    80003806:	854a                	mv	a0,s2
+    80003808:	d89ff0ef          	jal	80003590 <readi>
+    8000380c:	47c1                	li	a5,16
+    8000380e:	fcf51ce3          	bne	a0,a5,800037e6 <dirlookup+0x36>
+    if(de.inum == 0)
+    80003812:	fc045783          	lhu	a5,-64(s0)
+    80003816:	dff1                	beqz	a5,800037f2 <dirlookup+0x42>
+    if(namecmp(name, de.name) == 0){
+    80003818:	fc240593          	addi	a1,s0,-62
+    8000381c:	854e                	mv	a0,s3
+    8000381e:	f7dff0ef          	jal	8000379a <namecmp>
+    80003822:	f961                	bnez	a0,800037f2 <dirlookup+0x42>
+      if(poff)
+    80003824:	000a0463          	beqz	s4,8000382c <dirlookup+0x7c>
+        *poff = off;
+    80003828:	009a2023          	sw	s1,0(s4)
+      return iget(dp->dev, inum);
+    8000382c:	fc045583          	lhu	a1,-64(s0)
+    80003830:	00092503          	lw	a0,0(s2)
+    80003834:	f58ff0ef          	jal	80002f8c <iget>
+    80003838:	a011                	j	8000383c <dirlookup+0x8c>
+  return 0;
+    8000383a:	4501                	li	a0,0
+}
+    8000383c:	70e2                	ld	ra,56(sp)
+    8000383e:	7442                	ld	s0,48(sp)
+    80003840:	74a2                	ld	s1,40(sp)
+    80003842:	7902                	ld	s2,32(sp)
+    80003844:	69e2                	ld	s3,24(sp)
+    80003846:	6a42                	ld	s4,16(sp)
+    80003848:	6121                	addi	sp,sp,64
+    8000384a:	8082                	ret
+
+000000008000384c <namex>:
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+    8000384c:	711d                	addi	sp,sp,-96
+    8000384e:	ec86                	sd	ra,88(sp)
+    80003850:	e8a2                	sd	s0,80(sp)
+    80003852:	e4a6                	sd	s1,72(sp)
+    80003854:	e0ca                	sd	s2,64(sp)
+    80003856:	fc4e                	sd	s3,56(sp)
+    80003858:	f852                	sd	s4,48(sp)
+    8000385a:	f456                	sd	s5,40(sp)
+    8000385c:	f05a                	sd	s6,32(sp)
+    8000385e:	ec5e                	sd	s7,24(sp)
+    80003860:	e862                	sd	s8,16(sp)
+    80003862:	e466                	sd	s9,8(sp)
+    80003864:	1080                	addi	s0,sp,96
+    80003866:	84aa                	mv	s1,a0
+    80003868:	8b2e                	mv	s6,a1
+    8000386a:	8ab2                	mv	s5,a2
+  struct inode *ip, *next;
+
+  if(*path == '/')
+    8000386c:	00054703          	lbu	a4,0(a0)
+    80003870:	02f00793          	li	a5,47
+    80003874:	00f70e63          	beq	a4,a5,80003890 <namex+0x44>
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+    80003878:	856fe0ef          	jal	800018ce <myproc>
+    8000387c:	15053503          	ld	a0,336(a0)
+    80003880:	94bff0ef          	jal	800031ca <idup>
+    80003884:	8a2a                	mv	s4,a0
+  while(*path == '/')
+    80003886:	02f00913          	li	s2,47
+  if(len >= DIRSIZ)
+    8000388a:	4c35                	li	s8,13
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+    if(ip->type != T_DIR){
+    8000388c:	4b85                	li	s7,1
+    8000388e:	a871                	j	8000392a <namex+0xde>
+    ip = iget(ROOTDEV, ROOTINO);
+    80003890:	4585                	li	a1,1
+    80003892:	4505                	li	a0,1
+    80003894:	ef8ff0ef          	jal	80002f8c <iget>
+    80003898:	8a2a                	mv	s4,a0
+    8000389a:	b7f5                	j	80003886 <namex+0x3a>
+      iunlockput(ip);
+    8000389c:	8552                	mv	a0,s4
+    8000389e:	b6dff0ef          	jal	8000340a <iunlockput>
+      return 0;
+    800038a2:	4a01                	li	s4,0
+  if(nameiparent){
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+    800038a4:	8552                	mv	a0,s4
+    800038a6:	60e6                	ld	ra,88(sp)
+    800038a8:	6446                	ld	s0,80(sp)
+    800038aa:	64a6                	ld	s1,72(sp)
+    800038ac:	6906                	ld	s2,64(sp)
+    800038ae:	79e2                	ld	s3,56(sp)
+    800038b0:	7a42                	ld	s4,48(sp)
+    800038b2:	7aa2                	ld	s5,40(sp)
+    800038b4:	7b02                	ld	s6,32(sp)
+    800038b6:	6be2                	ld	s7,24(sp)
+    800038b8:	6c42                	ld	s8,16(sp)
+    800038ba:	6ca2                	ld	s9,8(sp)
+    800038bc:	6125                	addi	sp,sp,96
+    800038be:	8082                	ret
+      iunlock(ip);
+    800038c0:	8552                	mv	a0,s4
+    800038c2:	9edff0ef          	jal	800032ae <iunlock>
+      return ip;
+    800038c6:	bff9                	j	800038a4 <namex+0x58>
+      iunlockput(ip);
+    800038c8:	8552                	mv	a0,s4
+    800038ca:	b41ff0ef          	jal	8000340a <iunlockput>
+      return 0;
+    800038ce:	8a4e                	mv	s4,s3
+    800038d0:	bfd1                	j	800038a4 <namex+0x58>
+  len = path - s;
+    800038d2:	40998633          	sub	a2,s3,s1
+    800038d6:	00060c9b          	sext.w	s9,a2
+  if(len >= DIRSIZ)
+    800038da:	099c5063          	bge	s8,s9,8000395a <namex+0x10e>
+    memmove(name, s, DIRSIZ);
+    800038de:	4639                	li	a2,14
+    800038e0:	85a6                	mv	a1,s1
+    800038e2:	8556                	mv	a0,s5
+    800038e4:	c1afd0ef          	jal	80000cfe <memmove>
+    800038e8:	84ce                	mv	s1,s3
+  while(*path == '/')
+    800038ea:	0004c783          	lbu	a5,0(s1)
+    800038ee:	01279763          	bne	a5,s2,800038fc <namex+0xb0>
+    path++;
+    800038f2:	0485                	addi	s1,s1,1
+  while(*path == '/')
+    800038f4:	0004c783          	lbu	a5,0(s1)
+    800038f8:	ff278de3          	beq	a5,s2,800038f2 <namex+0xa6>
+    ilock(ip);
+    800038fc:	8552                	mv	a0,s4
+    800038fe:	903ff0ef          	jal	80003200 <ilock>
+    if(ip->type != T_DIR){
+    80003902:	044a1783          	lh	a5,68(s4)
+    80003906:	f9779be3          	bne	a5,s7,8000389c <namex+0x50>
+    if(nameiparent && *path == '\0'){
+    8000390a:	000b0563          	beqz	s6,80003914 <namex+0xc8>
+    8000390e:	0004c783          	lbu	a5,0(s1)
+    80003912:	d7dd                	beqz	a5,800038c0 <namex+0x74>
+    if((next = dirlookup(ip, name, 0)) == 0){
+    80003914:	4601                	li	a2,0
+    80003916:	85d6                	mv	a1,s5
+    80003918:	8552                	mv	a0,s4
+    8000391a:	e97ff0ef          	jal	800037b0 <dirlookup>
+    8000391e:	89aa                	mv	s3,a0
+    80003920:	d545                	beqz	a0,800038c8 <namex+0x7c>
+    iunlockput(ip);
+    80003922:	8552                	mv	a0,s4
+    80003924:	ae7ff0ef          	jal	8000340a <iunlockput>
+    ip = next;
+    80003928:	8a4e                	mv	s4,s3
+  while(*path == '/')
+    8000392a:	0004c783          	lbu	a5,0(s1)
+    8000392e:	01279763          	bne	a5,s2,8000393c <namex+0xf0>
+    path++;
+    80003932:	0485                	addi	s1,s1,1
+  while(*path == '/')
+    80003934:	0004c783          	lbu	a5,0(s1)
+    80003938:	ff278de3          	beq	a5,s2,80003932 <namex+0xe6>
+  if(*path == 0)
+    8000393c:	cb8d                	beqz	a5,8000396e <namex+0x122>
+  while(*path != '/' && *path != 0)
+    8000393e:	0004c783          	lbu	a5,0(s1)
+    80003942:	89a6                	mv	s3,s1
+  len = path - s;
+    80003944:	4c81                	li	s9,0
+    80003946:	4601                	li	a2,0
+  while(*path != '/' && *path != 0)
+    80003948:	01278963          	beq	a5,s2,8000395a <namex+0x10e>
+    8000394c:	d3d9                	beqz	a5,800038d2 <namex+0x86>
+    path++;
+    8000394e:	0985                	addi	s3,s3,1
+  while(*path != '/' && *path != 0)
+    80003950:	0009c783          	lbu	a5,0(s3)
+    80003954:	ff279ce3          	bne	a5,s2,8000394c <namex+0x100>
+    80003958:	bfad                	j	800038d2 <namex+0x86>
+    memmove(name, s, len);
+    8000395a:	2601                	sext.w	a2,a2
+    8000395c:	85a6                	mv	a1,s1
+    8000395e:	8556                	mv	a0,s5
+    80003960:	b9efd0ef          	jal	80000cfe <memmove>
+    name[len] = 0;
+    80003964:	9cd6                	add	s9,s9,s5
+    80003966:	000c8023          	sb	zero,0(s9) # 2000 <_entry-0x7fffe000>
+    8000396a:	84ce                	mv	s1,s3
+    8000396c:	bfbd                	j	800038ea <namex+0x9e>
+  if(nameiparent){
+    8000396e:	f20b0be3          	beqz	s6,800038a4 <namex+0x58>
+    iput(ip);
+    80003972:	8552                	mv	a0,s4
+    80003974:	a0fff0ef          	jal	80003382 <iput>
+    return 0;
+    80003978:	4a01                	li	s4,0
+    8000397a:	b72d                	j	800038a4 <namex+0x58>
+
+000000008000397c <dirlink>:
+{
+    8000397c:	7139                	addi	sp,sp,-64
+    8000397e:	fc06                	sd	ra,56(sp)
+    80003980:	f822                	sd	s0,48(sp)
+    80003982:	f04a                	sd	s2,32(sp)
+    80003984:	ec4e                	sd	s3,24(sp)
+    80003986:	e852                	sd	s4,16(sp)
+    80003988:	0080                	addi	s0,sp,64
+    8000398a:	892a                	mv	s2,a0
+    8000398c:	8a2e                	mv	s4,a1
+    8000398e:	89b2                	mv	s3,a2
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    80003990:	4601                	li	a2,0
+    80003992:	e1fff0ef          	jal	800037b0 <dirlookup>
+    80003996:	e535                	bnez	a0,80003a02 <dirlink+0x86>
+    80003998:	f426                	sd	s1,40(sp)
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    8000399a:	04c92483          	lw	s1,76(s2)
+    8000399e:	c48d                	beqz	s1,800039c8 <dirlink+0x4c>
+    800039a0:	4481                	li	s1,0
+    if(readi(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+    800039a2:	4741                	li	a4,16
+    800039a4:	86a6                	mv	a3,s1
+    800039a6:	fc040613          	addi	a2,s0,-64
+    800039aa:	4581                	li	a1,0
+    800039ac:	854a                	mv	a0,s2
+    800039ae:	be3ff0ef          	jal	80003590 <readi>
+    800039b2:	47c1                	li	a5,16
+    800039b4:	04f51b63          	bne	a0,a5,80003a0a <dirlink+0x8e>
+    if(de.inum == 0)
+    800039b8:	fc045783          	lhu	a5,-64(s0)
+    800039bc:	c791                	beqz	a5,800039c8 <dirlink+0x4c>
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    800039be:	24c1                	addiw	s1,s1,16
+    800039c0:	04c92783          	lw	a5,76(s2)
+    800039c4:	fcf4efe3          	bltu	s1,a5,800039a2 <dirlink+0x26>
+  strncpy(de.name, name, DIRSIZ);
+    800039c8:	4639                	li	a2,14
+    800039ca:	85d2                	mv	a1,s4
+    800039cc:	fc240513          	addi	a0,s0,-62
+    800039d0:	bd4fd0ef          	jal	80000da4 <strncpy>
+  de.inum = inum;
+    800039d4:	fd341023          	sh	s3,-64(s0)
+  if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+    800039d8:	4741                	li	a4,16
+    800039da:	86a6                	mv	a3,s1
+    800039dc:	fc040613          	addi	a2,s0,-64
+    800039e0:	4581                	li	a1,0
+    800039e2:	854a                	mv	a0,s2
+    800039e4:	ca9ff0ef          	jal	8000368c <writei>
+    800039e8:	1541                	addi	a0,a0,-16
+    800039ea:	00a03533          	snez	a0,a0
+    800039ee:	40a00533          	neg	a0,a0
+    800039f2:	74a2                	ld	s1,40(sp)
+}
+    800039f4:	70e2                	ld	ra,56(sp)
+    800039f6:	7442                	ld	s0,48(sp)
+    800039f8:	7902                	ld	s2,32(sp)
+    800039fa:	69e2                	ld	s3,24(sp)
+    800039fc:	6a42                	ld	s4,16(sp)
+    800039fe:	6121                	addi	sp,sp,64
+    80003a00:	8082                	ret
+    iput(ip);
+    80003a02:	981ff0ef          	jal	80003382 <iput>
+    return -1;
+    80003a06:	557d                	li	a0,-1
+    80003a08:	b7f5                	j	800039f4 <dirlink+0x78>
+      panic("dirlink read");
+    80003a0a:	00004517          	auipc	a0,0x4
+    80003a0e:	aee50513          	addi	a0,a0,-1298 # 800074f8 <etext+0x4f8>
+    80003a12:	dcffc0ef          	jal	800007e0 <panic>
+
+0000000080003a16 <namei>:
+
+struct inode*
+namei(char *path)
+{
+    80003a16:	1101                	addi	sp,sp,-32
+    80003a18:	ec06                	sd	ra,24(sp)
+    80003a1a:	e822                	sd	s0,16(sp)
+    80003a1c:	1000                	addi	s0,sp,32
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+    80003a1e:	fe040613          	addi	a2,s0,-32
+    80003a22:	4581                	li	a1,0
+    80003a24:	e29ff0ef          	jal	8000384c <namex>
+}
+    80003a28:	60e2                	ld	ra,24(sp)
+    80003a2a:	6442                	ld	s0,16(sp)
+    80003a2c:	6105                	addi	sp,sp,32
+    80003a2e:	8082                	ret
+
+0000000080003a30 <nameiparent>:
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+    80003a30:	1141                	addi	sp,sp,-16
+    80003a32:	e406                	sd	ra,8(sp)
+    80003a34:	e022                	sd	s0,0(sp)
+    80003a36:	0800                	addi	s0,sp,16
+    80003a38:	862e                	mv	a2,a1
+  return namex(path, 1, name);
+    80003a3a:	4585                	li	a1,1
+    80003a3c:	e11ff0ef          	jal	8000384c <namex>
+}
+    80003a40:	60a2                	ld	ra,8(sp)
+    80003a42:	6402                	ld	s0,0(sp)
+    80003a44:	0141                	addi	sp,sp,16
+    80003a46:	8082                	ret
+
+0000000080003a48 <write_head>:
+// Write in-memory log header to disk.
+// This is the true point at which the
+// current transaction commits.
+static void
+write_head(void)
+{
+    80003a48:	1101                	addi	sp,sp,-32
+    80003a4a:	ec06                	sd	ra,24(sp)
+    80003a4c:	e822                	sd	s0,16(sp)
+    80003a4e:	e426                	sd	s1,8(sp)
+    80003a50:	e04a                	sd	s2,0(sp)
+    80003a52:	1000                	addi	s0,sp,32
+  struct buf *buf = bread(log.dev, log.start);
+    80003a54:	0001f917          	auipc	s2,0x1f
+    80003a58:	27490913          	addi	s2,s2,628 # 80022cc8 <log>
+    80003a5c:	01892583          	lw	a1,24(s2)
+    80003a60:	02492503          	lw	a0,36(s2)
+    80003a64:	8d0ff0ef          	jal	80002b34 <bread>
+    80003a68:	84aa                	mv	s1,a0
+  struct logheader *hb = (struct logheader *) (buf->data);
+  int i;
+  hb->n = log.lh.n;
+    80003a6a:	02892603          	lw	a2,40(s2)
+    80003a6e:	cd30                	sw	a2,88(a0)
+  for (i = 0; i < log.lh.n; i++) {
+    80003a70:	00c05f63          	blez	a2,80003a8e <write_head+0x46>
+    80003a74:	0001f717          	auipc	a4,0x1f
+    80003a78:	28070713          	addi	a4,a4,640 # 80022cf4 <log+0x2c>
+    80003a7c:	87aa                	mv	a5,a0
+    80003a7e:	060a                	slli	a2,a2,0x2
+    80003a80:	962a                	add	a2,a2,a0
+    hb->block[i] = log.lh.block[i];
+    80003a82:	4314                	lw	a3,0(a4)
+    80003a84:	cff4                	sw	a3,92(a5)
+  for (i = 0; i < log.lh.n; i++) {
+    80003a86:	0711                	addi	a4,a4,4
+    80003a88:	0791                	addi	a5,a5,4
+    80003a8a:	fec79ce3          	bne	a5,a2,80003a82 <write_head+0x3a>
+  }
+  bwrite(buf);
+    80003a8e:	8526                	mv	a0,s1
+    80003a90:	97aff0ef          	jal	80002c0a <bwrite>
+  brelse(buf);
+    80003a94:	8526                	mv	a0,s1
+    80003a96:	9a6ff0ef          	jal	80002c3c <brelse>
+}
+    80003a9a:	60e2                	ld	ra,24(sp)
+    80003a9c:	6442                	ld	s0,16(sp)
+    80003a9e:	64a2                	ld	s1,8(sp)
+    80003aa0:	6902                	ld	s2,0(sp)
+    80003aa2:	6105                	addi	sp,sp,32
+    80003aa4:	8082                	ret
+
+0000000080003aa6 <install_trans>:
+  for (tail = 0; tail < log.lh.n; tail++) {
+    80003aa6:	0001f797          	auipc	a5,0x1f
+    80003aaa:	24a7a783          	lw	a5,586(a5) # 80022cf0 <log+0x28>
+    80003aae:	0af05e63          	blez	a5,80003b6a <install_trans+0xc4>
+{
+    80003ab2:	715d                	addi	sp,sp,-80
+    80003ab4:	e486                	sd	ra,72(sp)
+    80003ab6:	e0a2                	sd	s0,64(sp)
+    80003ab8:	fc26                	sd	s1,56(sp)
+    80003aba:	f84a                	sd	s2,48(sp)
+    80003abc:	f44e                	sd	s3,40(sp)
+    80003abe:	f052                	sd	s4,32(sp)
+    80003ac0:	ec56                	sd	s5,24(sp)
+    80003ac2:	e85a                	sd	s6,16(sp)
+    80003ac4:	e45e                	sd	s7,8(sp)
+    80003ac6:	0880                	addi	s0,sp,80
+    80003ac8:	8b2a                	mv	s6,a0
+    80003aca:	0001fa97          	auipc	s5,0x1f
+    80003ace:	22aa8a93          	addi	s5,s5,554 # 80022cf4 <log+0x2c>
+  for (tail = 0; tail < log.lh.n; tail++) {
+    80003ad2:	4981                	li	s3,0
+      printf("recovering tail %d dst %d\n", tail, log.lh.block[tail]);
+    80003ad4:	00004b97          	auipc	s7,0x4
+    80003ad8:	a34b8b93          	addi	s7,s7,-1484 # 80007508 <etext+0x508>
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+    80003adc:	0001fa17          	auipc	s4,0x1f
+    80003ae0:	1eca0a13          	addi	s4,s4,492 # 80022cc8 <log>
+    80003ae4:	a025                	j	80003b0c <install_trans+0x66>
+      printf("recovering tail %d dst %d\n", tail, log.lh.block[tail]);
+    80003ae6:	000aa603          	lw	a2,0(s5)
+    80003aea:	85ce                	mv	a1,s3
+    80003aec:	855e                	mv	a0,s7
+    80003aee:	a0dfc0ef          	jal	800004fa <printf>
+    80003af2:	a839                	j	80003b10 <install_trans+0x6a>
+    brelse(lbuf);
+    80003af4:	854a                	mv	a0,s2
+    80003af6:	946ff0ef          	jal	80002c3c <brelse>
+    brelse(dbuf);
+    80003afa:	8526                	mv	a0,s1
+    80003afc:	940ff0ef          	jal	80002c3c <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+    80003b00:	2985                	addiw	s3,s3,1
+    80003b02:	0a91                	addi	s5,s5,4
+    80003b04:	028a2783          	lw	a5,40(s4)
+    80003b08:	04f9d663          	bge	s3,a5,80003b54 <install_trans+0xae>
+    if(recovering) {
+    80003b0c:	fc0b1de3          	bnez	s6,80003ae6 <install_trans+0x40>
+    struct buf *lbuf = bread(log.dev, log.start+tail+1); // read log block
+    80003b10:	018a2583          	lw	a1,24(s4)
+    80003b14:	013585bb          	addw	a1,a1,s3
+    80003b18:	2585                	addiw	a1,a1,1
+    80003b1a:	024a2503          	lw	a0,36(s4)
+    80003b1e:	816ff0ef          	jal	80002b34 <bread>
+    80003b22:	892a                	mv	s2,a0
+    struct buf *dbuf = bread(log.dev, log.lh.block[tail]); // read dst
+    80003b24:	000aa583          	lw	a1,0(s5)
+    80003b28:	024a2503          	lw	a0,36(s4)
+    80003b2c:	808ff0ef          	jal	80002b34 <bread>
+    80003b30:	84aa                	mv	s1,a0
+    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
+    80003b32:	40000613          	li	a2,1024
+    80003b36:	05890593          	addi	a1,s2,88
+    80003b3a:	05850513          	addi	a0,a0,88
+    80003b3e:	9c0fd0ef          	jal	80000cfe <memmove>
+    bwrite(dbuf);  // write dst to disk
+    80003b42:	8526                	mv	a0,s1
+    80003b44:	8c6ff0ef          	jal	80002c0a <bwrite>
+    if(recovering == 0)
+    80003b48:	fa0b16e3          	bnez	s6,80003af4 <install_trans+0x4e>
+      bunpin(dbuf);
+    80003b4c:	8526                	mv	a0,s1
+    80003b4e:	9aaff0ef          	jal	80002cf8 <bunpin>
+    80003b52:	b74d                	j	80003af4 <install_trans+0x4e>
+}
+    80003b54:	60a6                	ld	ra,72(sp)
+    80003b56:	6406                	ld	s0,64(sp)
+    80003b58:	74e2                	ld	s1,56(sp)
+    80003b5a:	7942                	ld	s2,48(sp)
+    80003b5c:	79a2                	ld	s3,40(sp)
+    80003b5e:	7a02                	ld	s4,32(sp)
+    80003b60:	6ae2                	ld	s5,24(sp)
+    80003b62:	6b42                	ld	s6,16(sp)
+    80003b64:	6ba2                	ld	s7,8(sp)
+    80003b66:	6161                	addi	sp,sp,80
+    80003b68:	8082                	ret
+    80003b6a:	8082                	ret
+
+0000000080003b6c <initlog>:
+{
+    80003b6c:	7179                	addi	sp,sp,-48
+    80003b6e:	f406                	sd	ra,40(sp)
+    80003b70:	f022                	sd	s0,32(sp)
+    80003b72:	ec26                	sd	s1,24(sp)
+    80003b74:	e84a                	sd	s2,16(sp)
+    80003b76:	e44e                	sd	s3,8(sp)
+    80003b78:	1800                	addi	s0,sp,48
+    80003b7a:	892a                	mv	s2,a0
+    80003b7c:	89ae                	mv	s3,a1
+  initlock(&log.lock, "log");
+    80003b7e:	0001f497          	auipc	s1,0x1f
+    80003b82:	14a48493          	addi	s1,s1,330 # 80022cc8 <log>
+    80003b86:	00004597          	auipc	a1,0x4
+    80003b8a:	9a258593          	addi	a1,a1,-1630 # 80007528 <etext+0x528>
+    80003b8e:	8526                	mv	a0,s1
+    80003b90:	fbffc0ef          	jal	80000b4e <initlock>
+  log.start = sb->logstart;
+    80003b94:	0149a583          	lw	a1,20(s3)
+    80003b98:	cc8c                	sw	a1,24(s1)
+  log.dev = dev;
+    80003b9a:	0324a223          	sw	s2,36(s1)
+  struct buf *buf = bread(log.dev, log.start);
+    80003b9e:	854a                	mv	a0,s2
+    80003ba0:	f95fe0ef          	jal	80002b34 <bread>
+  log.lh.n = lh->n;
+    80003ba4:	4d30                	lw	a2,88(a0)
+    80003ba6:	d490                	sw	a2,40(s1)
+  for (i = 0; i < log.lh.n; i++) {
+    80003ba8:	00c05f63          	blez	a2,80003bc6 <initlog+0x5a>
+    80003bac:	87aa                	mv	a5,a0
+    80003bae:	0001f717          	auipc	a4,0x1f
+    80003bb2:	14670713          	addi	a4,a4,326 # 80022cf4 <log+0x2c>
+    80003bb6:	060a                	slli	a2,a2,0x2
+    80003bb8:	962a                	add	a2,a2,a0
+    log.lh.block[i] = lh->block[i];
+    80003bba:	4ff4                	lw	a3,92(a5)
+    80003bbc:	c314                	sw	a3,0(a4)
+  for (i = 0; i < log.lh.n; i++) {
+    80003bbe:	0791                	addi	a5,a5,4
+    80003bc0:	0711                	addi	a4,a4,4
+    80003bc2:	fec79ce3          	bne	a5,a2,80003bba <initlog+0x4e>
+  brelse(buf);
+    80003bc6:	876ff0ef          	jal	80002c3c <brelse>
+
+static void
+recover_from_log(void)
+{
+  read_head();
+  install_trans(1); // if committed, copy from log to disk
+    80003bca:	4505                	li	a0,1
+    80003bcc:	edbff0ef          	jal	80003aa6 <install_trans>
+  log.lh.n = 0;
+    80003bd0:	0001f797          	auipc	a5,0x1f
+    80003bd4:	1207a023          	sw	zero,288(a5) # 80022cf0 <log+0x28>
+  write_head(); // clear the log
+    80003bd8:	e71ff0ef          	jal	80003a48 <write_head>
+}
+    80003bdc:	70a2                	ld	ra,40(sp)
+    80003bde:	7402                	ld	s0,32(sp)
+    80003be0:	64e2                	ld	s1,24(sp)
+    80003be2:	6942                	ld	s2,16(sp)
+    80003be4:	69a2                	ld	s3,8(sp)
+    80003be6:	6145                	addi	sp,sp,48
+    80003be8:	8082                	ret
+
+0000000080003bea <begin_op>:
+}
+
+// called at the start of each FS system call.
+void
+begin_op(void)
+{
+    80003bea:	1101                	addi	sp,sp,-32
+    80003bec:	ec06                	sd	ra,24(sp)
+    80003bee:	e822                	sd	s0,16(sp)
+    80003bf0:	e426                	sd	s1,8(sp)
+    80003bf2:	e04a                	sd	s2,0(sp)
+    80003bf4:	1000                	addi	s0,sp,32
+  acquire(&log.lock);
+    80003bf6:	0001f517          	auipc	a0,0x1f
+    80003bfa:	0d250513          	addi	a0,a0,210 # 80022cc8 <log>
+    80003bfe:	fd1fc0ef          	jal	80000bce <acquire>
+  while(1){
+    if(log.committing){
+    80003c02:	0001f497          	auipc	s1,0x1f
+    80003c06:	0c648493          	addi	s1,s1,198 # 80022cc8 <log>
+      sleep(&log, &log.lock);
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGBLOCKS){
+    80003c0a:	4979                	li	s2,30
+    80003c0c:	a029                	j	80003c16 <begin_op+0x2c>
+      sleep(&log, &log.lock);
+    80003c0e:	85a6                	mv	a1,s1
+    80003c10:	8526                	mv	a0,s1
+    80003c12:	acafe0ef          	jal	80001edc <sleep>
+    if(log.committing){
+    80003c16:	509c                	lw	a5,32(s1)
+    80003c18:	fbfd                	bnez	a5,80003c0e <begin_op+0x24>
+    } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGBLOCKS){
+    80003c1a:	4cd8                	lw	a4,28(s1)
+    80003c1c:	2705                	addiw	a4,a4,1
+    80003c1e:	0027179b          	slliw	a5,a4,0x2
+    80003c22:	9fb9                	addw	a5,a5,a4
+    80003c24:	0017979b          	slliw	a5,a5,0x1
+    80003c28:	5494                	lw	a3,40(s1)
+    80003c2a:	9fb5                	addw	a5,a5,a3
+    80003c2c:	00f95763          	bge	s2,a5,80003c3a <begin_op+0x50>
+      // this op might exhaust log space; wait for commit.
+      sleep(&log, &log.lock);
+    80003c30:	85a6                	mv	a1,s1
+    80003c32:	8526                	mv	a0,s1
+    80003c34:	aa8fe0ef          	jal	80001edc <sleep>
+    80003c38:	bff9                	j	80003c16 <begin_op+0x2c>
+    } else {
+      log.outstanding += 1;
+    80003c3a:	0001f517          	auipc	a0,0x1f
+    80003c3e:	08e50513          	addi	a0,a0,142 # 80022cc8 <log>
+    80003c42:	cd58                	sw	a4,28(a0)
+      release(&log.lock);
+    80003c44:	822fd0ef          	jal	80000c66 <release>
+      break;
+    }
+  }
+}
+    80003c48:	60e2                	ld	ra,24(sp)
+    80003c4a:	6442                	ld	s0,16(sp)
+    80003c4c:	64a2                	ld	s1,8(sp)
+    80003c4e:	6902                	ld	s2,0(sp)
+    80003c50:	6105                	addi	sp,sp,32
+    80003c52:	8082                	ret
+
+0000000080003c54 <end_op>:
+
+// called at the end of each FS system call.
+// commits if this was the last outstanding operation.
+void
+end_op(void)
+{
+    80003c54:	7139                	addi	sp,sp,-64
+    80003c56:	fc06                	sd	ra,56(sp)
+    80003c58:	f822                	sd	s0,48(sp)
+    80003c5a:	f426                	sd	s1,40(sp)
+    80003c5c:	f04a                	sd	s2,32(sp)
+    80003c5e:	0080                	addi	s0,sp,64
+  int do_commit = 0;
+
+  acquire(&log.lock);
+    80003c60:	0001f497          	auipc	s1,0x1f
+    80003c64:	06848493          	addi	s1,s1,104 # 80022cc8 <log>
+    80003c68:	8526                	mv	a0,s1
+    80003c6a:	f65fc0ef          	jal	80000bce <acquire>
+  log.outstanding -= 1;
+    80003c6e:	4cdc                	lw	a5,28(s1)
+    80003c70:	37fd                	addiw	a5,a5,-1
+    80003c72:	0007891b          	sext.w	s2,a5
+    80003c76:	ccdc                	sw	a5,28(s1)
+  if(log.committing)
+    80003c78:	509c                	lw	a5,32(s1)
+    80003c7a:	ef9d                	bnez	a5,80003cb8 <end_op+0x64>
+    panic("log.committing");
+  if(log.outstanding == 0){
+    80003c7c:	04091763          	bnez	s2,80003cca <end_op+0x76>
+    do_commit = 1;
+    log.committing = 1;
+    80003c80:	0001f497          	auipc	s1,0x1f
+    80003c84:	04848493          	addi	s1,s1,72 # 80022cc8 <log>
+    80003c88:	4785                	li	a5,1
+    80003c8a:	d09c                	sw	a5,32(s1)
+    // begin_op() may be waiting for log space,
+    // and decrementing log.outstanding has decreased
+    // the amount of reserved space.
+    wakeup(&log);
+  }
+  release(&log.lock);
+    80003c8c:	8526                	mv	a0,s1
+    80003c8e:	fd9fc0ef          	jal	80000c66 <release>
+}
+
+static void
+commit()
+{
+  if (log.lh.n > 0) {
+    80003c92:	549c                	lw	a5,40(s1)
+    80003c94:	04f04b63          	bgtz	a5,80003cea <end_op+0x96>
+    acquire(&log.lock);
+    80003c98:	0001f497          	auipc	s1,0x1f
+    80003c9c:	03048493          	addi	s1,s1,48 # 80022cc8 <log>
+    80003ca0:	8526                	mv	a0,s1
+    80003ca2:	f2dfc0ef          	jal	80000bce <acquire>
+    log.committing = 0;
+    80003ca6:	0204a023          	sw	zero,32(s1)
+    wakeup(&log);
+    80003caa:	8526                	mv	a0,s1
+    80003cac:	a7cfe0ef          	jal	80001f28 <wakeup>
+    release(&log.lock);
+    80003cb0:	8526                	mv	a0,s1
+    80003cb2:	fb5fc0ef          	jal	80000c66 <release>
+}
+    80003cb6:	a025                	j	80003cde <end_op+0x8a>
+    80003cb8:	ec4e                	sd	s3,24(sp)
+    80003cba:	e852                	sd	s4,16(sp)
+    80003cbc:	e456                	sd	s5,8(sp)
+    panic("log.committing");
+    80003cbe:	00004517          	auipc	a0,0x4
+    80003cc2:	87250513          	addi	a0,a0,-1934 # 80007530 <etext+0x530>
+    80003cc6:	b1bfc0ef          	jal	800007e0 <panic>
+    wakeup(&log);
+    80003cca:	0001f497          	auipc	s1,0x1f
+    80003cce:	ffe48493          	addi	s1,s1,-2 # 80022cc8 <log>
+    80003cd2:	8526                	mv	a0,s1
+    80003cd4:	a54fe0ef          	jal	80001f28 <wakeup>
+  release(&log.lock);
+    80003cd8:	8526                	mv	a0,s1
+    80003cda:	f8dfc0ef          	jal	80000c66 <release>
+}
+    80003cde:	70e2                	ld	ra,56(sp)
+    80003ce0:	7442                	ld	s0,48(sp)
+    80003ce2:	74a2                	ld	s1,40(sp)
+    80003ce4:	7902                	ld	s2,32(sp)
+    80003ce6:	6121                	addi	sp,sp,64
+    80003ce8:	8082                	ret
+    80003cea:	ec4e                	sd	s3,24(sp)
+    80003cec:	e852                	sd	s4,16(sp)
+    80003cee:	e456                	sd	s5,8(sp)
+  for (tail = 0; tail < log.lh.n; tail++) {
+    80003cf0:	0001fa97          	auipc	s5,0x1f
+    80003cf4:	004a8a93          	addi	s5,s5,4 # 80022cf4 <log+0x2c>
+    struct buf *to = bread(log.dev, log.start+tail+1); // log block
+    80003cf8:	0001fa17          	auipc	s4,0x1f
+    80003cfc:	fd0a0a13          	addi	s4,s4,-48 # 80022cc8 <log>
+    80003d00:	018a2583          	lw	a1,24(s4)
+    80003d04:	012585bb          	addw	a1,a1,s2
+    80003d08:	2585                	addiw	a1,a1,1
+    80003d0a:	024a2503          	lw	a0,36(s4)
+    80003d0e:	e27fe0ef          	jal	80002b34 <bread>
+    80003d12:	84aa                	mv	s1,a0
+    struct buf *from = bread(log.dev, log.lh.block[tail]); // cache block
+    80003d14:	000aa583          	lw	a1,0(s5)
+    80003d18:	024a2503          	lw	a0,36(s4)
+    80003d1c:	e19fe0ef          	jal	80002b34 <bread>
+    80003d20:	89aa                	mv	s3,a0
+    memmove(to->data, from->data, BSIZE);
+    80003d22:	40000613          	li	a2,1024
+    80003d26:	05850593          	addi	a1,a0,88
+    80003d2a:	05848513          	addi	a0,s1,88
+    80003d2e:	fd1fc0ef          	jal	80000cfe <memmove>
+    bwrite(to);  // write the log
+    80003d32:	8526                	mv	a0,s1
+    80003d34:	ed7fe0ef          	jal	80002c0a <bwrite>
+    brelse(from);
+    80003d38:	854e                	mv	a0,s3
+    80003d3a:	f03fe0ef          	jal	80002c3c <brelse>
+    brelse(to);
+    80003d3e:	8526                	mv	a0,s1
+    80003d40:	efdfe0ef          	jal	80002c3c <brelse>
+  for (tail = 0; tail < log.lh.n; tail++) {
+    80003d44:	2905                	addiw	s2,s2,1
+    80003d46:	0a91                	addi	s5,s5,4
+    80003d48:	028a2783          	lw	a5,40(s4)
+    80003d4c:	faf94ae3          	blt	s2,a5,80003d00 <end_op+0xac>
+    write_log();     // Write modified blocks from cache to log
+    write_head();    // Write header to disk -- the real commit
+    80003d50:	cf9ff0ef          	jal	80003a48 <write_head>
+    install_trans(0); // Now install writes to home locations
+    80003d54:	4501                	li	a0,0
+    80003d56:	d51ff0ef          	jal	80003aa6 <install_trans>
+    log.lh.n = 0;
+    80003d5a:	0001f797          	auipc	a5,0x1f
+    80003d5e:	f807ab23          	sw	zero,-106(a5) # 80022cf0 <log+0x28>
+    write_head();    // Erase the transaction from the log
+    80003d62:	ce7ff0ef          	jal	80003a48 <write_head>
+    80003d66:	69e2                	ld	s3,24(sp)
+    80003d68:	6a42                	ld	s4,16(sp)
+    80003d6a:	6aa2                	ld	s5,8(sp)
+    80003d6c:	b735                	j	80003c98 <end_op+0x44>
+
+0000000080003d6e <log_write>:
+//   modify bp->data[]
+//   log_write(bp)
+//   brelse(bp)
+void
+log_write(struct buf *b)
+{
+    80003d6e:	1101                	addi	sp,sp,-32
+    80003d70:	ec06                	sd	ra,24(sp)
+    80003d72:	e822                	sd	s0,16(sp)
+    80003d74:	e426                	sd	s1,8(sp)
+    80003d76:	e04a                	sd	s2,0(sp)
+    80003d78:	1000                	addi	s0,sp,32
+    80003d7a:	84aa                	mv	s1,a0
+  int i;
+
+  acquire(&log.lock);
+    80003d7c:	0001f917          	auipc	s2,0x1f
+    80003d80:	f4c90913          	addi	s2,s2,-180 # 80022cc8 <log>
+    80003d84:	854a                	mv	a0,s2
+    80003d86:	e49fc0ef          	jal	80000bce <acquire>
+  if (log.lh.n >= LOGBLOCKS)
+    80003d8a:	02892603          	lw	a2,40(s2)
+    80003d8e:	47f5                	li	a5,29
+    80003d90:	04c7cc63          	blt	a5,a2,80003de8 <log_write+0x7a>
+    panic("too big a transaction");
+  if (log.outstanding < 1)
+    80003d94:	0001f797          	auipc	a5,0x1f
+    80003d98:	f507a783          	lw	a5,-176(a5) # 80022ce4 <log+0x1c>
+    80003d9c:	04f05c63          	blez	a5,80003df4 <log_write+0x86>
+    panic("log_write outside of trans");
+
+  for (i = 0; i < log.lh.n; i++) {
+    80003da0:	4781                	li	a5,0
+    80003da2:	04c05f63          	blez	a2,80003e00 <log_write+0x92>
+    if (log.lh.block[i] == b->blockno)   // log absorption
+    80003da6:	44cc                	lw	a1,12(s1)
+    80003da8:	0001f717          	auipc	a4,0x1f
+    80003dac:	f4c70713          	addi	a4,a4,-180 # 80022cf4 <log+0x2c>
+  for (i = 0; i < log.lh.n; i++) {
+    80003db0:	4781                	li	a5,0
+    if (log.lh.block[i] == b->blockno)   // log absorption
+    80003db2:	4314                	lw	a3,0(a4)
+    80003db4:	04b68663          	beq	a3,a1,80003e00 <log_write+0x92>
+  for (i = 0; i < log.lh.n; i++) {
+    80003db8:	2785                	addiw	a5,a5,1
+    80003dba:	0711                	addi	a4,a4,4
+    80003dbc:	fef61be3          	bne	a2,a5,80003db2 <log_write+0x44>
+      break;
+  }
+  log.lh.block[i] = b->blockno;
+    80003dc0:	0621                	addi	a2,a2,8
+    80003dc2:	060a                	slli	a2,a2,0x2
+    80003dc4:	0001f797          	auipc	a5,0x1f
+    80003dc8:	f0478793          	addi	a5,a5,-252 # 80022cc8 <log>
+    80003dcc:	97b2                	add	a5,a5,a2
+    80003dce:	44d8                	lw	a4,12(s1)
+    80003dd0:	c7d8                	sw	a4,12(a5)
+  if (i == log.lh.n) {  // Add new block to log?
+    bpin(b);
+    80003dd2:	8526                	mv	a0,s1
+    80003dd4:	ef1fe0ef          	jal	80002cc4 <bpin>
+    log.lh.n++;
+    80003dd8:	0001f717          	auipc	a4,0x1f
+    80003ddc:	ef070713          	addi	a4,a4,-272 # 80022cc8 <log>
+    80003de0:	571c                	lw	a5,40(a4)
+    80003de2:	2785                	addiw	a5,a5,1
+    80003de4:	d71c                	sw	a5,40(a4)
+    80003de6:	a80d                	j	80003e18 <log_write+0xaa>
+    panic("too big a transaction");
+    80003de8:	00003517          	auipc	a0,0x3
+    80003dec:	75850513          	addi	a0,a0,1880 # 80007540 <etext+0x540>
+    80003df0:	9f1fc0ef          	jal	800007e0 <panic>
+    panic("log_write outside of trans");
+    80003df4:	00003517          	auipc	a0,0x3
+    80003df8:	76450513          	addi	a0,a0,1892 # 80007558 <etext+0x558>
+    80003dfc:	9e5fc0ef          	jal	800007e0 <panic>
+  log.lh.block[i] = b->blockno;
+    80003e00:	00878693          	addi	a3,a5,8
+    80003e04:	068a                	slli	a3,a3,0x2
+    80003e06:	0001f717          	auipc	a4,0x1f
+    80003e0a:	ec270713          	addi	a4,a4,-318 # 80022cc8 <log>
+    80003e0e:	9736                	add	a4,a4,a3
+    80003e10:	44d4                	lw	a3,12(s1)
+    80003e12:	c754                	sw	a3,12(a4)
+  if (i == log.lh.n) {  // Add new block to log?
+    80003e14:	faf60fe3          	beq	a2,a5,80003dd2 <log_write+0x64>
+  }
+  release(&log.lock);
+    80003e18:	0001f517          	auipc	a0,0x1f
+    80003e1c:	eb050513          	addi	a0,a0,-336 # 80022cc8 <log>
+    80003e20:	e47fc0ef          	jal	80000c66 <release>
+}
+    80003e24:	60e2                	ld	ra,24(sp)
+    80003e26:	6442                	ld	s0,16(sp)
+    80003e28:	64a2                	ld	s1,8(sp)
+    80003e2a:	6902                	ld	s2,0(sp)
+    80003e2c:	6105                	addi	sp,sp,32
+    80003e2e:	8082                	ret
+
+0000000080003e30 <initsleeplock>:
+#include "proc.h"
+#include "sleeplock.h"
+
+void
+initsleeplock(struct sleeplock *lk, char *name)
+{
+    80003e30:	1101                	addi	sp,sp,-32
+    80003e32:	ec06                	sd	ra,24(sp)
+    80003e34:	e822                	sd	s0,16(sp)
+    80003e36:	e426                	sd	s1,8(sp)
+    80003e38:	e04a                	sd	s2,0(sp)
+    80003e3a:	1000                	addi	s0,sp,32
+    80003e3c:	84aa                	mv	s1,a0
+    80003e3e:	892e                	mv	s2,a1
+  initlock(&lk->lk, "sleep lock");
+    80003e40:	00003597          	auipc	a1,0x3
+    80003e44:	73858593          	addi	a1,a1,1848 # 80007578 <etext+0x578>
+    80003e48:	0521                	addi	a0,a0,8
+    80003e4a:	d05fc0ef          	jal	80000b4e <initlock>
+  lk->name = name;
+    80003e4e:	0324b023          	sd	s2,32(s1)
+  lk->locked = 0;
+    80003e52:	0004a023          	sw	zero,0(s1)
+  lk->pid = 0;
+    80003e56:	0204a423          	sw	zero,40(s1)
+}
+    80003e5a:	60e2                	ld	ra,24(sp)
+    80003e5c:	6442                	ld	s0,16(sp)
+    80003e5e:	64a2                	ld	s1,8(sp)
+    80003e60:	6902                	ld	s2,0(sp)
+    80003e62:	6105                	addi	sp,sp,32
+    80003e64:	8082                	ret
+
+0000000080003e66 <acquiresleep>:
+
+void
+acquiresleep(struct sleeplock *lk)
+{
+    80003e66:	1101                	addi	sp,sp,-32
+    80003e68:	ec06                	sd	ra,24(sp)
+    80003e6a:	e822                	sd	s0,16(sp)
+    80003e6c:	e426                	sd	s1,8(sp)
+    80003e6e:	e04a                	sd	s2,0(sp)
+    80003e70:	1000                	addi	s0,sp,32
+    80003e72:	84aa                	mv	s1,a0
+  acquire(&lk->lk);
+    80003e74:	00850913          	addi	s2,a0,8
+    80003e78:	854a                	mv	a0,s2
+    80003e7a:	d55fc0ef          	jal	80000bce <acquire>
+  while (lk->locked) {
+    80003e7e:	409c                	lw	a5,0(s1)
+    80003e80:	c799                	beqz	a5,80003e8e <acquiresleep+0x28>
+    sleep(lk, &lk->lk);
+    80003e82:	85ca                	mv	a1,s2
+    80003e84:	8526                	mv	a0,s1
+    80003e86:	856fe0ef          	jal	80001edc <sleep>
+  while (lk->locked) {
+    80003e8a:	409c                	lw	a5,0(s1)
+    80003e8c:	fbfd                	bnez	a5,80003e82 <acquiresleep+0x1c>
+  }
+  lk->locked = 1;
+    80003e8e:	4785                	li	a5,1
+    80003e90:	c09c                	sw	a5,0(s1)
+  lk->pid = myproc()->pid;
+    80003e92:	a3dfd0ef          	jal	800018ce <myproc>
+    80003e96:	591c                	lw	a5,48(a0)
+    80003e98:	d49c                	sw	a5,40(s1)
+  release(&lk->lk);
+    80003e9a:	854a                	mv	a0,s2
+    80003e9c:	dcbfc0ef          	jal	80000c66 <release>
+}
+    80003ea0:	60e2                	ld	ra,24(sp)
+    80003ea2:	6442                	ld	s0,16(sp)
+    80003ea4:	64a2                	ld	s1,8(sp)
+    80003ea6:	6902                	ld	s2,0(sp)
+    80003ea8:	6105                	addi	sp,sp,32
+    80003eaa:	8082                	ret
+
+0000000080003eac <releasesleep>:
+
+void
+releasesleep(struct sleeplock *lk)
+{
+    80003eac:	1101                	addi	sp,sp,-32
+    80003eae:	ec06                	sd	ra,24(sp)
+    80003eb0:	e822                	sd	s0,16(sp)
+    80003eb2:	e426                	sd	s1,8(sp)
+    80003eb4:	e04a                	sd	s2,0(sp)
+    80003eb6:	1000                	addi	s0,sp,32
+    80003eb8:	84aa                	mv	s1,a0
+  acquire(&lk->lk);
+    80003eba:	00850913          	addi	s2,a0,8
+    80003ebe:	854a                	mv	a0,s2
+    80003ec0:	d0ffc0ef          	jal	80000bce <acquire>
+  lk->locked = 0;
+    80003ec4:	0004a023          	sw	zero,0(s1)
+  lk->pid = 0;
+    80003ec8:	0204a423          	sw	zero,40(s1)
+  wakeup(lk);
+    80003ecc:	8526                	mv	a0,s1
+    80003ece:	85afe0ef          	jal	80001f28 <wakeup>
+  release(&lk->lk);
+    80003ed2:	854a                	mv	a0,s2
+    80003ed4:	d93fc0ef          	jal	80000c66 <release>
+}
+    80003ed8:	60e2                	ld	ra,24(sp)
+    80003eda:	6442                	ld	s0,16(sp)
+    80003edc:	64a2                	ld	s1,8(sp)
+    80003ede:	6902                	ld	s2,0(sp)
+    80003ee0:	6105                	addi	sp,sp,32
+    80003ee2:	8082                	ret
+
+0000000080003ee4 <holdingsleep>:
+
+int
+holdingsleep(struct sleeplock *lk)
+{
+    80003ee4:	7179                	addi	sp,sp,-48
+    80003ee6:	f406                	sd	ra,40(sp)
+    80003ee8:	f022                	sd	s0,32(sp)
+    80003eea:	ec26                	sd	s1,24(sp)
+    80003eec:	e84a                	sd	s2,16(sp)
+    80003eee:	1800                	addi	s0,sp,48
+    80003ef0:	84aa                	mv	s1,a0
+  int r;
+  
+  acquire(&lk->lk);
+    80003ef2:	00850913          	addi	s2,a0,8
+    80003ef6:	854a                	mv	a0,s2
+    80003ef8:	cd7fc0ef          	jal	80000bce <acquire>
+  r = lk->locked && (lk->pid == myproc()->pid);
+    80003efc:	409c                	lw	a5,0(s1)
+    80003efe:	ef81                	bnez	a5,80003f16 <holdingsleep+0x32>
+    80003f00:	4481                	li	s1,0
+  release(&lk->lk);
+    80003f02:	854a                	mv	a0,s2
+    80003f04:	d63fc0ef          	jal	80000c66 <release>
+  return r;
+}
+    80003f08:	8526                	mv	a0,s1
+    80003f0a:	70a2                	ld	ra,40(sp)
+    80003f0c:	7402                	ld	s0,32(sp)
+    80003f0e:	64e2                	ld	s1,24(sp)
+    80003f10:	6942                	ld	s2,16(sp)
+    80003f12:	6145                	addi	sp,sp,48
+    80003f14:	8082                	ret
+    80003f16:	e44e                	sd	s3,8(sp)
+  r = lk->locked && (lk->pid == myproc()->pid);
+    80003f18:	0284a983          	lw	s3,40(s1)
+    80003f1c:	9b3fd0ef          	jal	800018ce <myproc>
+    80003f20:	5904                	lw	s1,48(a0)
+    80003f22:	413484b3          	sub	s1,s1,s3
+    80003f26:	0014b493          	seqz	s1,s1
+    80003f2a:	69a2                	ld	s3,8(sp)
+    80003f2c:	bfd9                	j	80003f02 <holdingsleep+0x1e>
+
+0000000080003f2e <fileinit>:
+  struct file file[NFILE];
+} ftable;
+
+void
+fileinit(void)
+{
+    80003f2e:	1141                	addi	sp,sp,-16
+    80003f30:	e406                	sd	ra,8(sp)
+    80003f32:	e022                	sd	s0,0(sp)
+    80003f34:	0800                	addi	s0,sp,16
+  initlock(&ftable.lock, "ftable");
+    80003f36:	00003597          	auipc	a1,0x3
+    80003f3a:	65258593          	addi	a1,a1,1618 # 80007588 <etext+0x588>
+    80003f3e:	0001f517          	auipc	a0,0x1f
+    80003f42:	ed250513          	addi	a0,a0,-302 # 80022e10 <ftable>
+    80003f46:	c09fc0ef          	jal	80000b4e <initlock>
+}
+    80003f4a:	60a2                	ld	ra,8(sp)
+    80003f4c:	6402                	ld	s0,0(sp)
+    80003f4e:	0141                	addi	sp,sp,16
+    80003f50:	8082                	ret
+
+0000000080003f52 <filealloc>:
+
+// Allocate a file structure.
+struct file*
+filealloc(void)
+{
+    80003f52:	1101                	addi	sp,sp,-32
+    80003f54:	ec06                	sd	ra,24(sp)
+    80003f56:	e822                	sd	s0,16(sp)
+    80003f58:	e426                	sd	s1,8(sp)
+    80003f5a:	1000                	addi	s0,sp,32
+  struct file *f;
+
+  acquire(&ftable.lock);
+    80003f5c:	0001f517          	auipc	a0,0x1f
+    80003f60:	eb450513          	addi	a0,a0,-332 # 80022e10 <ftable>
+    80003f64:	c6bfc0ef          	jal	80000bce <acquire>
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+    80003f68:	0001f497          	auipc	s1,0x1f
+    80003f6c:	ec048493          	addi	s1,s1,-320 # 80022e28 <ftable+0x18>
+    80003f70:	00020717          	auipc	a4,0x20
+    80003f74:	e5870713          	addi	a4,a4,-424 # 80023dc8 <disk>
+    if(f->ref == 0){
+    80003f78:	40dc                	lw	a5,4(s1)
+    80003f7a:	cf89                	beqz	a5,80003f94 <filealloc+0x42>
+  for(f = ftable.file; f < ftable.file + NFILE; f++){
+    80003f7c:	02848493          	addi	s1,s1,40
+    80003f80:	fee49ce3          	bne	s1,a4,80003f78 <filealloc+0x26>
+      f->ref = 1;
+      release(&ftable.lock);
+      return f;
+    }
+  }
+  release(&ftable.lock);
+    80003f84:	0001f517          	auipc	a0,0x1f
+    80003f88:	e8c50513          	addi	a0,a0,-372 # 80022e10 <ftable>
+    80003f8c:	cdbfc0ef          	jal	80000c66 <release>
+  return 0;
+    80003f90:	4481                	li	s1,0
+    80003f92:	a809                	j	80003fa4 <filealloc+0x52>
+      f->ref = 1;
+    80003f94:	4785                	li	a5,1
+    80003f96:	c0dc                	sw	a5,4(s1)
+      release(&ftable.lock);
+    80003f98:	0001f517          	auipc	a0,0x1f
+    80003f9c:	e7850513          	addi	a0,a0,-392 # 80022e10 <ftable>
+    80003fa0:	cc7fc0ef          	jal	80000c66 <release>
+}
+    80003fa4:	8526                	mv	a0,s1
+    80003fa6:	60e2                	ld	ra,24(sp)
+    80003fa8:	6442                	ld	s0,16(sp)
+    80003faa:	64a2                	ld	s1,8(sp)
+    80003fac:	6105                	addi	sp,sp,32
+    80003fae:	8082                	ret
+
+0000000080003fb0 <filedup>:
+
+// Increment ref count for file f.
+struct file*
+filedup(struct file *f)
+{
+    80003fb0:	1101                	addi	sp,sp,-32
+    80003fb2:	ec06                	sd	ra,24(sp)
+    80003fb4:	e822                	sd	s0,16(sp)
+    80003fb6:	e426                	sd	s1,8(sp)
+    80003fb8:	1000                	addi	s0,sp,32
+    80003fba:	84aa                	mv	s1,a0
+  acquire(&ftable.lock);
+    80003fbc:	0001f517          	auipc	a0,0x1f
+    80003fc0:	e5450513          	addi	a0,a0,-428 # 80022e10 <ftable>
+    80003fc4:	c0bfc0ef          	jal	80000bce <acquire>
+  if(f->ref < 1)
+    80003fc8:	40dc                	lw	a5,4(s1)
+    80003fca:	02f05063          	blez	a5,80003fea <filedup+0x3a>
+    panic("filedup");
+  f->ref++;
+    80003fce:	2785                	addiw	a5,a5,1
+    80003fd0:	c0dc                	sw	a5,4(s1)
+  release(&ftable.lock);
+    80003fd2:	0001f517          	auipc	a0,0x1f
+    80003fd6:	e3e50513          	addi	a0,a0,-450 # 80022e10 <ftable>
+    80003fda:	c8dfc0ef          	jal	80000c66 <release>
+  return f;
+}
+    80003fde:	8526                	mv	a0,s1
+    80003fe0:	60e2                	ld	ra,24(sp)
+    80003fe2:	6442                	ld	s0,16(sp)
+    80003fe4:	64a2                	ld	s1,8(sp)
+    80003fe6:	6105                	addi	sp,sp,32
+    80003fe8:	8082                	ret
+    panic("filedup");
+    80003fea:	00003517          	auipc	a0,0x3
+    80003fee:	5a650513          	addi	a0,a0,1446 # 80007590 <etext+0x590>
+    80003ff2:	feefc0ef          	jal	800007e0 <panic>
+
+0000000080003ff6 <fileclose>:
+
+// Close file f.  (Decrement ref count, close when reaches 0.)
+void
+fileclose(struct file *f)
+{
+    80003ff6:	7139                	addi	sp,sp,-64
+    80003ff8:	fc06                	sd	ra,56(sp)
+    80003ffa:	f822                	sd	s0,48(sp)
+    80003ffc:	f426                	sd	s1,40(sp)
+    80003ffe:	0080                	addi	s0,sp,64
+    80004000:	84aa                	mv	s1,a0
+  struct file ff;
+
+  acquire(&ftable.lock);
+    80004002:	0001f517          	auipc	a0,0x1f
+    80004006:	e0e50513          	addi	a0,a0,-498 # 80022e10 <ftable>
+    8000400a:	bc5fc0ef          	jal	80000bce <acquire>
+  if(f->ref < 1)
+    8000400e:	40dc                	lw	a5,4(s1)
+    80004010:	04f05a63          	blez	a5,80004064 <fileclose+0x6e>
+    panic("fileclose");
+  if(--f->ref > 0){
+    80004014:	37fd                	addiw	a5,a5,-1
+    80004016:	0007871b          	sext.w	a4,a5
+    8000401a:	c0dc                	sw	a5,4(s1)
+    8000401c:	04e04e63          	bgtz	a4,80004078 <fileclose+0x82>
+    80004020:	f04a                	sd	s2,32(sp)
+    80004022:	ec4e                	sd	s3,24(sp)
+    80004024:	e852                	sd	s4,16(sp)
+    80004026:	e456                	sd	s5,8(sp)
+    release(&ftable.lock);
+    return;
+  }
+  ff = *f;
+    80004028:	0004a903          	lw	s2,0(s1)
+    8000402c:	0094ca83          	lbu	s5,9(s1)
+    80004030:	0104ba03          	ld	s4,16(s1)
+    80004034:	0184b983          	ld	s3,24(s1)
+  f->ref = 0;
+    80004038:	0004a223          	sw	zero,4(s1)
+  f->type = FD_NONE;
+    8000403c:	0004a023          	sw	zero,0(s1)
+  release(&ftable.lock);
+    80004040:	0001f517          	auipc	a0,0x1f
+    80004044:	dd050513          	addi	a0,a0,-560 # 80022e10 <ftable>
+    80004048:	c1ffc0ef          	jal	80000c66 <release>
+
+  if(ff.type == FD_PIPE){
+    8000404c:	4785                	li	a5,1
+    8000404e:	04f90063          	beq	s2,a5,8000408e <fileclose+0x98>
+    pipeclose(ff.pipe, ff.writable);
+  } else if(ff.type == FD_INODE || ff.type == FD_DEVICE){
+    80004052:	3979                	addiw	s2,s2,-2
+    80004054:	4785                	li	a5,1
+    80004056:	0527f563          	bgeu	a5,s2,800040a0 <fileclose+0xaa>
+    8000405a:	7902                	ld	s2,32(sp)
+    8000405c:	69e2                	ld	s3,24(sp)
+    8000405e:	6a42                	ld	s4,16(sp)
+    80004060:	6aa2                	ld	s5,8(sp)
+    80004062:	a00d                	j	80004084 <fileclose+0x8e>
+    80004064:	f04a                	sd	s2,32(sp)
+    80004066:	ec4e                	sd	s3,24(sp)
+    80004068:	e852                	sd	s4,16(sp)
+    8000406a:	e456                	sd	s5,8(sp)
+    panic("fileclose");
+    8000406c:	00003517          	auipc	a0,0x3
+    80004070:	52c50513          	addi	a0,a0,1324 # 80007598 <etext+0x598>
+    80004074:	f6cfc0ef          	jal	800007e0 <panic>
+    release(&ftable.lock);
+    80004078:	0001f517          	auipc	a0,0x1f
+    8000407c:	d9850513          	addi	a0,a0,-616 # 80022e10 <ftable>
+    80004080:	be7fc0ef          	jal	80000c66 <release>
+    begin_op();
+    iput(ff.ip);
+    end_op();
+  }
+}
+    80004084:	70e2                	ld	ra,56(sp)
+    80004086:	7442                	ld	s0,48(sp)
+    80004088:	74a2                	ld	s1,40(sp)
+    8000408a:	6121                	addi	sp,sp,64
+    8000408c:	8082                	ret
+    pipeclose(ff.pipe, ff.writable);
+    8000408e:	85d6                	mv	a1,s5
+    80004090:	8552                	mv	a0,s4
+    80004092:	336000ef          	jal	800043c8 <pipeclose>
+    80004096:	7902                	ld	s2,32(sp)
+    80004098:	69e2                	ld	s3,24(sp)
+    8000409a:	6a42                	ld	s4,16(sp)
+    8000409c:	6aa2                	ld	s5,8(sp)
+    8000409e:	b7dd                	j	80004084 <fileclose+0x8e>
+    begin_op();
+    800040a0:	b4bff0ef          	jal	80003bea <begin_op>
+    iput(ff.ip);
+    800040a4:	854e                	mv	a0,s3
+    800040a6:	adcff0ef          	jal	80003382 <iput>
+    end_op();
+    800040aa:	babff0ef          	jal	80003c54 <end_op>
+    800040ae:	7902                	ld	s2,32(sp)
+    800040b0:	69e2                	ld	s3,24(sp)
+    800040b2:	6a42                	ld	s4,16(sp)
+    800040b4:	6aa2                	ld	s5,8(sp)
+    800040b6:	b7f9                	j	80004084 <fileclose+0x8e>
+
+00000000800040b8 <filestat>:
+
+// Get metadata about file f.
+// addr is a user virtual address, pointing to a struct stat.
+int
+filestat(struct file *f, uint64 addr)
+{
+    800040b8:	715d                	addi	sp,sp,-80
+    800040ba:	e486                	sd	ra,72(sp)
+    800040bc:	e0a2                	sd	s0,64(sp)
+    800040be:	fc26                	sd	s1,56(sp)
+    800040c0:	f44e                	sd	s3,40(sp)
+    800040c2:	0880                	addi	s0,sp,80
+    800040c4:	84aa                	mv	s1,a0
+    800040c6:	89ae                	mv	s3,a1
+  struct proc *p = myproc();
+    800040c8:	807fd0ef          	jal	800018ce <myproc>
+  struct stat st;
+  
+  if(f->type == FD_INODE || f->type == FD_DEVICE){
+    800040cc:	409c                	lw	a5,0(s1)
+    800040ce:	37f9                	addiw	a5,a5,-2
+    800040d0:	4705                	li	a4,1
+    800040d2:	04f76063          	bltu	a4,a5,80004112 <filestat+0x5a>
+    800040d6:	f84a                	sd	s2,48(sp)
+    800040d8:	892a                	mv	s2,a0
+    ilock(f->ip);
+    800040da:	6c88                	ld	a0,24(s1)
+    800040dc:	924ff0ef          	jal	80003200 <ilock>
+    stati(f->ip, &st);
+    800040e0:	fb840593          	addi	a1,s0,-72
+    800040e4:	6c88                	ld	a0,24(s1)
+    800040e6:	c80ff0ef          	jal	80003566 <stati>
+    iunlock(f->ip);
+    800040ea:	6c88                	ld	a0,24(s1)
+    800040ec:	9c2ff0ef          	jal	800032ae <iunlock>
+    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)
+    800040f0:	46e1                	li	a3,24
+    800040f2:	fb840613          	addi	a2,s0,-72
+    800040f6:	85ce                	mv	a1,s3
+    800040f8:	05093503          	ld	a0,80(s2)
+    800040fc:	ce6fd0ef          	jal	800015e2 <copyout>
+    80004100:	41f5551b          	sraiw	a0,a0,0x1f
+    80004104:	7942                	ld	s2,48(sp)
+      return -1;
+    return 0;
+  }
+  return -1;
+}
+    80004106:	60a6                	ld	ra,72(sp)
+    80004108:	6406                	ld	s0,64(sp)
+    8000410a:	74e2                	ld	s1,56(sp)
+    8000410c:	79a2                	ld	s3,40(sp)
+    8000410e:	6161                	addi	sp,sp,80
+    80004110:	8082                	ret
+  return -1;
+    80004112:	557d                	li	a0,-1
+    80004114:	bfcd                	j	80004106 <filestat+0x4e>
+
+0000000080004116 <fileread>:
+
+// Read from file f.
+// addr is a user virtual address.
+int
+fileread(struct file *f, uint64 addr, int n)
+{
+    80004116:	7179                	addi	sp,sp,-48
+    80004118:	f406                	sd	ra,40(sp)
+    8000411a:	f022                	sd	s0,32(sp)
+    8000411c:	e84a                	sd	s2,16(sp)
+    8000411e:	1800                	addi	s0,sp,48
+  int r = 0;
+
+  if(f->readable == 0)
+    80004120:	00854783          	lbu	a5,8(a0)
+    80004124:	cfd1                	beqz	a5,800041c0 <fileread+0xaa>
+    80004126:	ec26                	sd	s1,24(sp)
+    80004128:	e44e                	sd	s3,8(sp)
+    8000412a:	84aa                	mv	s1,a0
+    8000412c:	89ae                	mv	s3,a1
+    8000412e:	8932                	mv	s2,a2
+    return -1;
+
+  if(f->type == FD_PIPE){
+    80004130:	411c                	lw	a5,0(a0)
+    80004132:	4705                	li	a4,1
+    80004134:	04e78363          	beq	a5,a4,8000417a <fileread+0x64>
+    r = piperead(f->pipe, addr, n);
+  } else if(f->type == FD_DEVICE){
+    80004138:	470d                	li	a4,3
+    8000413a:	04e78763          	beq	a5,a4,80004188 <fileread+0x72>
+    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].read)
+      return -1;
+    r = devsw[f->major].read(1, addr, n);
+  } else if(f->type == FD_INODE){
+    8000413e:	4709                	li	a4,2
+    80004140:	06e79a63          	bne	a5,a4,800041b4 <fileread+0x9e>
+    ilock(f->ip);
+    80004144:	6d08                	ld	a0,24(a0)
+    80004146:	8baff0ef          	jal	80003200 <ilock>
+    if((r = readi(f->ip, 1, addr, f->off, n)) > 0)
+    8000414a:	874a                	mv	a4,s2
+    8000414c:	5094                	lw	a3,32(s1)
+    8000414e:	864e                	mv	a2,s3
+    80004150:	4585                	li	a1,1
+    80004152:	6c88                	ld	a0,24(s1)
+    80004154:	c3cff0ef          	jal	80003590 <readi>
+    80004158:	892a                	mv	s2,a0
+    8000415a:	00a05563          	blez	a0,80004164 <fileread+0x4e>
+      f->off += r;
+    8000415e:	509c                	lw	a5,32(s1)
+    80004160:	9fa9                	addw	a5,a5,a0
+    80004162:	d09c                	sw	a5,32(s1)
+    iunlock(f->ip);
+    80004164:	6c88                	ld	a0,24(s1)
+    80004166:	948ff0ef          	jal	800032ae <iunlock>
+    8000416a:	64e2                	ld	s1,24(sp)
+    8000416c:	69a2                	ld	s3,8(sp)
+  } else {
+    panic("fileread");
+  }
+
+  return r;
+}
+    8000416e:	854a                	mv	a0,s2
+    80004170:	70a2                	ld	ra,40(sp)
+    80004172:	7402                	ld	s0,32(sp)
+    80004174:	6942                	ld	s2,16(sp)
+    80004176:	6145                	addi	sp,sp,48
+    80004178:	8082                	ret
+    r = piperead(f->pipe, addr, n);
+    8000417a:	6908                	ld	a0,16(a0)
+    8000417c:	388000ef          	jal	80004504 <piperead>
+    80004180:	892a                	mv	s2,a0
+    80004182:	64e2                	ld	s1,24(sp)
+    80004184:	69a2                	ld	s3,8(sp)
+    80004186:	b7e5                	j	8000416e <fileread+0x58>
+    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].read)
+    80004188:	02451783          	lh	a5,36(a0)
+    8000418c:	03079693          	slli	a3,a5,0x30
+    80004190:	92c1                	srli	a3,a3,0x30
+    80004192:	4725                	li	a4,9
+    80004194:	02d76863          	bltu	a4,a3,800041c4 <fileread+0xae>
+    80004198:	0792                	slli	a5,a5,0x4
+    8000419a:	0001f717          	auipc	a4,0x1f
+    8000419e:	bd670713          	addi	a4,a4,-1066 # 80022d70 <devsw>
+    800041a2:	97ba                	add	a5,a5,a4
+    800041a4:	639c                	ld	a5,0(a5)
+    800041a6:	c39d                	beqz	a5,800041cc <fileread+0xb6>
+    r = devsw[f->major].read(1, addr, n);
+    800041a8:	4505                	li	a0,1
+    800041aa:	9782                	jalr	a5
+    800041ac:	892a                	mv	s2,a0
+    800041ae:	64e2                	ld	s1,24(sp)
+    800041b0:	69a2                	ld	s3,8(sp)
+    800041b2:	bf75                	j	8000416e <fileread+0x58>
+    panic("fileread");
+    800041b4:	00003517          	auipc	a0,0x3
+    800041b8:	3f450513          	addi	a0,a0,1012 # 800075a8 <etext+0x5a8>
+    800041bc:	e24fc0ef          	jal	800007e0 <panic>
+    return -1;
+    800041c0:	597d                	li	s2,-1
+    800041c2:	b775                	j	8000416e <fileread+0x58>
+      return -1;
+    800041c4:	597d                	li	s2,-1
+    800041c6:	64e2                	ld	s1,24(sp)
+    800041c8:	69a2                	ld	s3,8(sp)
+    800041ca:	b755                	j	8000416e <fileread+0x58>
+    800041cc:	597d                	li	s2,-1
+    800041ce:	64e2                	ld	s1,24(sp)
+    800041d0:	69a2                	ld	s3,8(sp)
+    800041d2:	bf71                	j	8000416e <fileread+0x58>
+
+00000000800041d4 <filewrite>:
+int
+filewrite(struct file *f, uint64 addr, int n)
+{
+  int r, ret = 0;
+
+  if(f->writable == 0)
+    800041d4:	00954783          	lbu	a5,9(a0)
+    800041d8:	10078b63          	beqz	a5,800042ee <filewrite+0x11a>
+{
+    800041dc:	715d                	addi	sp,sp,-80
+    800041de:	e486                	sd	ra,72(sp)
+    800041e0:	e0a2                	sd	s0,64(sp)
+    800041e2:	f84a                	sd	s2,48(sp)
+    800041e4:	f052                	sd	s4,32(sp)
+    800041e6:	e85a                	sd	s6,16(sp)
+    800041e8:	0880                	addi	s0,sp,80
+    800041ea:	892a                	mv	s2,a0
+    800041ec:	8b2e                	mv	s6,a1
+    800041ee:	8a32                	mv	s4,a2
+    return -1;
+
+  if(f->type == FD_PIPE){
+    800041f0:	411c                	lw	a5,0(a0)
+    800041f2:	4705                	li	a4,1
+    800041f4:	02e78763          	beq	a5,a4,80004222 <filewrite+0x4e>
+    ret = pipewrite(f->pipe, addr, n);
+  } else if(f->type == FD_DEVICE){
+    800041f8:	470d                	li	a4,3
+    800041fa:	02e78863          	beq	a5,a4,8000422a <filewrite+0x56>
+    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
+      return -1;
+    ret = devsw[f->major].write(1, addr, n);
+  } else if(f->type == FD_INODE){
+    800041fe:	4709                	li	a4,2
+    80004200:	0ce79c63          	bne	a5,a4,800042d8 <filewrite+0x104>
+    80004204:	f44e                	sd	s3,40(sp)
+    // the maximum log transaction size, including
+    // i-node, indirect block, allocation blocks,
+    // and 2 blocks of slop for non-aligned writes.
+    int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;
+    int i = 0;
+    while(i < n){
+    80004206:	0ac05863          	blez	a2,800042b6 <filewrite+0xe2>
+    8000420a:	fc26                	sd	s1,56(sp)
+    8000420c:	ec56                	sd	s5,24(sp)
+    8000420e:	e45e                	sd	s7,8(sp)
+    80004210:	e062                	sd	s8,0(sp)
+    int i = 0;
+    80004212:	4981                	li	s3,0
+      int n1 = n - i;
+      if(n1 > max)
+    80004214:	6b85                	lui	s7,0x1
+    80004216:	c00b8b93          	addi	s7,s7,-1024 # c00 <_entry-0x7ffff400>
+    8000421a:	6c05                	lui	s8,0x1
+    8000421c:	c00c0c1b          	addiw	s8,s8,-1024 # c00 <_entry-0x7ffff400>
+    80004220:	a8b5                	j	8000429c <filewrite+0xc8>
+    ret = pipewrite(f->pipe, addr, n);
+    80004222:	6908                	ld	a0,16(a0)
+    80004224:	1fc000ef          	jal	80004420 <pipewrite>
+    80004228:	a04d                	j	800042ca <filewrite+0xf6>
+    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
+    8000422a:	02451783          	lh	a5,36(a0)
+    8000422e:	03079693          	slli	a3,a5,0x30
+    80004232:	92c1                	srli	a3,a3,0x30
+    80004234:	4725                	li	a4,9
+    80004236:	0ad76e63          	bltu	a4,a3,800042f2 <filewrite+0x11e>
+    8000423a:	0792                	slli	a5,a5,0x4
+    8000423c:	0001f717          	auipc	a4,0x1f
+    80004240:	b3470713          	addi	a4,a4,-1228 # 80022d70 <devsw>
+    80004244:	97ba                	add	a5,a5,a4
+    80004246:	679c                	ld	a5,8(a5)
+    80004248:	c7dd                	beqz	a5,800042f6 <filewrite+0x122>
+    ret = devsw[f->major].write(1, addr, n);
+    8000424a:	4505                	li	a0,1
+    8000424c:	9782                	jalr	a5
+    8000424e:	a8b5                	j	800042ca <filewrite+0xf6>
+      if(n1 > max)
+    80004250:	00048a9b          	sext.w	s5,s1
+        n1 = max;
+
+      begin_op();
+    80004254:	997ff0ef          	jal	80003bea <begin_op>
+      ilock(f->ip);
+    80004258:	01893503          	ld	a0,24(s2)
+    8000425c:	fa5fe0ef          	jal	80003200 <ilock>
+      if ((r = writei(f->ip, 1, addr + i, f->off, n1)) > 0)
+    80004260:	8756                	mv	a4,s5
+    80004262:	02092683          	lw	a3,32(s2)
+    80004266:	01698633          	add	a2,s3,s6
+    8000426a:	4585                	li	a1,1
+    8000426c:	01893503          	ld	a0,24(s2)
+    80004270:	c1cff0ef          	jal	8000368c <writei>
+    80004274:	84aa                	mv	s1,a0
+    80004276:	00a05763          	blez	a0,80004284 <filewrite+0xb0>
+        f->off += r;
+    8000427a:	02092783          	lw	a5,32(s2)
+    8000427e:	9fa9                	addw	a5,a5,a0
+    80004280:	02f92023          	sw	a5,32(s2)
+      iunlock(f->ip);
+    80004284:	01893503          	ld	a0,24(s2)
+    80004288:	826ff0ef          	jal	800032ae <iunlock>
+      end_op();
+    8000428c:	9c9ff0ef          	jal	80003c54 <end_op>
+
+      if(r != n1){
+    80004290:	029a9563          	bne	s5,s1,800042ba <filewrite+0xe6>
+        // error from writei
+        break;
+      }
+      i += r;
+    80004294:	013489bb          	addw	s3,s1,s3
+    while(i < n){
+    80004298:	0149da63          	bge	s3,s4,800042ac <filewrite+0xd8>
+      int n1 = n - i;
+    8000429c:	413a04bb          	subw	s1,s4,s3
+      if(n1 > max)
+    800042a0:	0004879b          	sext.w	a5,s1
+    800042a4:	fafbd6e3          	bge	s7,a5,80004250 <filewrite+0x7c>
+    800042a8:	84e2                	mv	s1,s8
+    800042aa:	b75d                	j	80004250 <filewrite+0x7c>
+    800042ac:	74e2                	ld	s1,56(sp)
+    800042ae:	6ae2                	ld	s5,24(sp)
+    800042b0:	6ba2                	ld	s7,8(sp)
+    800042b2:	6c02                	ld	s8,0(sp)
+    800042b4:	a039                	j	800042c2 <filewrite+0xee>
+    int i = 0;
+    800042b6:	4981                	li	s3,0
+    800042b8:	a029                	j	800042c2 <filewrite+0xee>
+    800042ba:	74e2                	ld	s1,56(sp)
+    800042bc:	6ae2                	ld	s5,24(sp)
+    800042be:	6ba2                	ld	s7,8(sp)
+    800042c0:	6c02                	ld	s8,0(sp)
+    }
+    ret = (i == n ? n : -1);
+    800042c2:	033a1c63          	bne	s4,s3,800042fa <filewrite+0x126>
+    800042c6:	8552                	mv	a0,s4
+    800042c8:	79a2                	ld	s3,40(sp)
+  } else {
+    panic("filewrite");
+  }
+
+  return ret;
+}
+    800042ca:	60a6                	ld	ra,72(sp)
+    800042cc:	6406                	ld	s0,64(sp)
+    800042ce:	7942                	ld	s2,48(sp)
+    800042d0:	7a02                	ld	s4,32(sp)
+    800042d2:	6b42                	ld	s6,16(sp)
+    800042d4:	6161                	addi	sp,sp,80
+    800042d6:	8082                	ret
+    800042d8:	fc26                	sd	s1,56(sp)
+    800042da:	f44e                	sd	s3,40(sp)
+    800042dc:	ec56                	sd	s5,24(sp)
+    800042de:	e45e                	sd	s7,8(sp)
+    800042e0:	e062                	sd	s8,0(sp)
+    panic("filewrite");
+    800042e2:	00003517          	auipc	a0,0x3
+    800042e6:	2d650513          	addi	a0,a0,726 # 800075b8 <etext+0x5b8>
+    800042ea:	cf6fc0ef          	jal	800007e0 <panic>
+    return -1;
+    800042ee:	557d                	li	a0,-1
+}
+    800042f0:	8082                	ret
+      return -1;
+    800042f2:	557d                	li	a0,-1
+    800042f4:	bfd9                	j	800042ca <filewrite+0xf6>
+    800042f6:	557d                	li	a0,-1
+    800042f8:	bfc9                	j	800042ca <filewrite+0xf6>
+    ret = (i == n ? n : -1);
+    800042fa:	557d                	li	a0,-1
+    800042fc:	79a2                	ld	s3,40(sp)
+    800042fe:	b7f1                	j	800042ca <filewrite+0xf6>
+
+0000000080004300 <pipealloc>:
+  int writeopen;  // write fd is still open
+};
+
+int
+pipealloc(struct file **f0, struct file **f1)
+{
+    80004300:	7179                	addi	sp,sp,-48
+    80004302:	f406                	sd	ra,40(sp)
+    80004304:	f022                	sd	s0,32(sp)
+    80004306:	ec26                	sd	s1,24(sp)
+    80004308:	e052                	sd	s4,0(sp)
+    8000430a:	1800                	addi	s0,sp,48
+    8000430c:	84aa                	mv	s1,a0
+    8000430e:	8a2e                	mv	s4,a1
+  struct pipe *pi;
+
+  pi = 0;
+  *f0 = *f1 = 0;
+    80004310:	0005b023          	sd	zero,0(a1)
+    80004314:	00053023          	sd	zero,0(a0)
+  if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
+    80004318:	c3bff0ef          	jal	80003f52 <filealloc>
+    8000431c:	e088                	sd	a0,0(s1)
+    8000431e:	c549                	beqz	a0,800043a8 <pipealloc+0xa8>
+    80004320:	c33ff0ef          	jal	80003f52 <filealloc>
+    80004324:	00aa3023          	sd	a0,0(s4)
+    80004328:	cd25                	beqz	a0,800043a0 <pipealloc+0xa0>
+    8000432a:	e84a                	sd	s2,16(sp)
+    goto bad;
+  if((pi = (struct pipe*)kalloc()) == 0)
+    8000432c:	fd2fc0ef          	jal	80000afe <kalloc>
+    80004330:	892a                	mv	s2,a0
+    80004332:	c12d                	beqz	a0,80004394 <pipealloc+0x94>
+    80004334:	e44e                	sd	s3,8(sp)
+    goto bad;
+  pi->readopen = 1;
+    80004336:	4985                	li	s3,1
+    80004338:	23352023          	sw	s3,544(a0)
+  pi->writeopen = 1;
+    8000433c:	23352223          	sw	s3,548(a0)
+  pi->nwrite = 0;
+    80004340:	20052e23          	sw	zero,540(a0)
+  pi->nread = 0;
+    80004344:	20052c23          	sw	zero,536(a0)
+  initlock(&pi->lock, "pipe");
+    80004348:	00003597          	auipc	a1,0x3
+    8000434c:	28058593          	addi	a1,a1,640 # 800075c8 <etext+0x5c8>
+    80004350:	ffefc0ef          	jal	80000b4e <initlock>
+  (*f0)->type = FD_PIPE;
+    80004354:	609c                	ld	a5,0(s1)
+    80004356:	0137a023          	sw	s3,0(a5)
+  (*f0)->readable = 1;
+    8000435a:	609c                	ld	a5,0(s1)
+    8000435c:	01378423          	sb	s3,8(a5)
+  (*f0)->writable = 0;
+    80004360:	609c                	ld	a5,0(s1)
+    80004362:	000784a3          	sb	zero,9(a5)
+  (*f0)->pipe = pi;
+    80004366:	609c                	ld	a5,0(s1)
+    80004368:	0127b823          	sd	s2,16(a5)
+  (*f1)->type = FD_PIPE;
+    8000436c:	000a3783          	ld	a5,0(s4)
+    80004370:	0137a023          	sw	s3,0(a5)
+  (*f1)->readable = 0;
+    80004374:	000a3783          	ld	a5,0(s4)
+    80004378:	00078423          	sb	zero,8(a5)
+  (*f1)->writable = 1;
+    8000437c:	000a3783          	ld	a5,0(s4)
+    80004380:	013784a3          	sb	s3,9(a5)
+  (*f1)->pipe = pi;
+    80004384:	000a3783          	ld	a5,0(s4)
+    80004388:	0127b823          	sd	s2,16(a5)
+  return 0;
+    8000438c:	4501                	li	a0,0
+    8000438e:	6942                	ld	s2,16(sp)
+    80004390:	69a2                	ld	s3,8(sp)
+    80004392:	a01d                	j	800043b8 <pipealloc+0xb8>
+
+ bad:
+  if(pi)
+    kfree((char*)pi);
+  if(*f0)
+    80004394:	6088                	ld	a0,0(s1)
+    80004396:	c119                	beqz	a0,8000439c <pipealloc+0x9c>
+    80004398:	6942                	ld	s2,16(sp)
+    8000439a:	a029                	j	800043a4 <pipealloc+0xa4>
+    8000439c:	6942                	ld	s2,16(sp)
+    8000439e:	a029                	j	800043a8 <pipealloc+0xa8>
+    800043a0:	6088                	ld	a0,0(s1)
+    800043a2:	c10d                	beqz	a0,800043c4 <pipealloc+0xc4>
+    fileclose(*f0);
+    800043a4:	c53ff0ef          	jal	80003ff6 <fileclose>
+  if(*f1)
+    800043a8:	000a3783          	ld	a5,0(s4)
+    fileclose(*f1);
+  return -1;
+    800043ac:	557d                	li	a0,-1
+  if(*f1)
+    800043ae:	c789                	beqz	a5,800043b8 <pipealloc+0xb8>
+    fileclose(*f1);
+    800043b0:	853e                	mv	a0,a5
+    800043b2:	c45ff0ef          	jal	80003ff6 <fileclose>
+  return -1;
+    800043b6:	557d                	li	a0,-1
+}
+    800043b8:	70a2                	ld	ra,40(sp)
+    800043ba:	7402                	ld	s0,32(sp)
+    800043bc:	64e2                	ld	s1,24(sp)
+    800043be:	6a02                	ld	s4,0(sp)
+    800043c0:	6145                	addi	sp,sp,48
+    800043c2:	8082                	ret
+  return -1;
+    800043c4:	557d                	li	a0,-1
+    800043c6:	bfcd                	j	800043b8 <pipealloc+0xb8>
+
+00000000800043c8 <pipeclose>:
+
+void
+pipeclose(struct pipe *pi, int writable)
+{
+    800043c8:	1101                	addi	sp,sp,-32
+    800043ca:	ec06                	sd	ra,24(sp)
+    800043cc:	e822                	sd	s0,16(sp)
+    800043ce:	e426                	sd	s1,8(sp)
+    800043d0:	e04a                	sd	s2,0(sp)
+    800043d2:	1000                	addi	s0,sp,32
+    800043d4:	84aa                	mv	s1,a0
+    800043d6:	892e                	mv	s2,a1
+  acquire(&pi->lock);
+    800043d8:	ff6fc0ef          	jal	80000bce <acquire>
+  if(writable){
+    800043dc:	02090763          	beqz	s2,8000440a <pipeclose+0x42>
+    pi->writeopen = 0;
+    800043e0:	2204a223          	sw	zero,548(s1)
+    wakeup(&pi->nread);
+    800043e4:	21848513          	addi	a0,s1,536
+    800043e8:	b41fd0ef          	jal	80001f28 <wakeup>
+  } else {
+    pi->readopen = 0;
+    wakeup(&pi->nwrite);
+  }
+  if(pi->readopen == 0 && pi->writeopen == 0){
+    800043ec:	2204b783          	ld	a5,544(s1)
+    800043f0:	e785                	bnez	a5,80004418 <pipeclose+0x50>
+    release(&pi->lock);
+    800043f2:	8526                	mv	a0,s1
+    800043f4:	873fc0ef          	jal	80000c66 <release>
+    kfree((char*)pi);
+    800043f8:	8526                	mv	a0,s1
+    800043fa:	e22fc0ef          	jal	80000a1c <kfree>
+  } else
+    release(&pi->lock);
+}
+    800043fe:	60e2                	ld	ra,24(sp)
+    80004400:	6442                	ld	s0,16(sp)
+    80004402:	64a2                	ld	s1,8(sp)
+    80004404:	6902                	ld	s2,0(sp)
+    80004406:	6105                	addi	sp,sp,32
+    80004408:	8082                	ret
+    pi->readopen = 0;
+    8000440a:	2204a023          	sw	zero,544(s1)
+    wakeup(&pi->nwrite);
+    8000440e:	21c48513          	addi	a0,s1,540
+    80004412:	b17fd0ef          	jal	80001f28 <wakeup>
+    80004416:	bfd9                	j	800043ec <pipeclose+0x24>
+    release(&pi->lock);
+    80004418:	8526                	mv	a0,s1
+    8000441a:	84dfc0ef          	jal	80000c66 <release>
+}
+    8000441e:	b7c5                	j	800043fe <pipeclose+0x36>
+
+0000000080004420 <pipewrite>:
+
+int
+pipewrite(struct pipe *pi, uint64 addr, int n)
+{
+    80004420:	711d                	addi	sp,sp,-96
+    80004422:	ec86                	sd	ra,88(sp)
+    80004424:	e8a2                	sd	s0,80(sp)
+    80004426:	e4a6                	sd	s1,72(sp)
+    80004428:	e0ca                	sd	s2,64(sp)
+    8000442a:	fc4e                	sd	s3,56(sp)
+    8000442c:	f852                	sd	s4,48(sp)
+    8000442e:	f456                	sd	s5,40(sp)
+    80004430:	1080                	addi	s0,sp,96
+    80004432:	84aa                	mv	s1,a0
+    80004434:	8aae                	mv	s5,a1
+    80004436:	8a32                	mv	s4,a2
+  int i = 0;
+  struct proc *pr = myproc();
+    80004438:	c96fd0ef          	jal	800018ce <myproc>
+    8000443c:	89aa                	mv	s3,a0
+
+  acquire(&pi->lock);
+    8000443e:	8526                	mv	a0,s1
+    80004440:	f8efc0ef          	jal	80000bce <acquire>
+  while(i < n){
+    80004444:	0b405a63          	blez	s4,800044f8 <pipewrite+0xd8>
+    80004448:	f05a                	sd	s6,32(sp)
+    8000444a:	ec5e                	sd	s7,24(sp)
+    8000444c:	e862                	sd	s8,16(sp)
+  int i = 0;
+    8000444e:	4901                	li	s2,0
+    if(pi->nwrite == pi->nread + PIPESIZE){ //DOC: pipewrite-full
+      wakeup(&pi->nread);
+      sleep(&pi->nwrite, &pi->lock);
+    } else {
+      char ch;
+      if(copyin(pr->pagetable, &ch, addr + i, 1) == -1)
+    80004450:	5b7d                	li	s6,-1
+      wakeup(&pi->nread);
+    80004452:	21848c13          	addi	s8,s1,536
+      sleep(&pi->nwrite, &pi->lock);
+    80004456:	21c48b93          	addi	s7,s1,540
+    8000445a:	a81d                	j	80004490 <pipewrite+0x70>
+      release(&pi->lock);
+    8000445c:	8526                	mv	a0,s1
+    8000445e:	809fc0ef          	jal	80000c66 <release>
+      return -1;
+    80004462:	597d                	li	s2,-1
+    80004464:	7b02                	ld	s6,32(sp)
+    80004466:	6be2                	ld	s7,24(sp)
+    80004468:	6c42                	ld	s8,16(sp)
+  }
+  wakeup(&pi->nread);
+  release(&pi->lock);
+
+  return i;
+}
+    8000446a:	854a                	mv	a0,s2
+    8000446c:	60e6                	ld	ra,88(sp)
+    8000446e:	6446                	ld	s0,80(sp)
+    80004470:	64a6                	ld	s1,72(sp)
+    80004472:	6906                	ld	s2,64(sp)
+    80004474:	79e2                	ld	s3,56(sp)
+    80004476:	7a42                	ld	s4,48(sp)
+    80004478:	7aa2                	ld	s5,40(sp)
+    8000447a:	6125                	addi	sp,sp,96
+    8000447c:	8082                	ret
+      wakeup(&pi->nread);
+    8000447e:	8562                	mv	a0,s8
+    80004480:	aa9fd0ef          	jal	80001f28 <wakeup>
+      sleep(&pi->nwrite, &pi->lock);
+    80004484:	85a6                	mv	a1,s1
+    80004486:	855e                	mv	a0,s7
+    80004488:	a55fd0ef          	jal	80001edc <sleep>
+  while(i < n){
+    8000448c:	05495b63          	bge	s2,s4,800044e2 <pipewrite+0xc2>
+    if(pi->readopen == 0 || killed(pr)){
+    80004490:	2204a783          	lw	a5,544(s1)
+    80004494:	d7e1                	beqz	a5,8000445c <pipewrite+0x3c>
+    80004496:	854e                	mv	a0,s3
+    80004498:	c7dfd0ef          	jal	80002114 <killed>
+    8000449c:	f161                	bnez	a0,8000445c <pipewrite+0x3c>
+    if(pi->nwrite == pi->nread + PIPESIZE){ //DOC: pipewrite-full
+    8000449e:	2184a783          	lw	a5,536(s1)
+    800044a2:	21c4a703          	lw	a4,540(s1)
+    800044a6:	2007879b          	addiw	a5,a5,512
+    800044aa:	fcf70ae3          	beq	a4,a5,8000447e <pipewrite+0x5e>
+      if(copyin(pr->pagetable, &ch, addr + i, 1) == -1)
+    800044ae:	4685                	li	a3,1
+    800044b0:	01590633          	add	a2,s2,s5
+    800044b4:	faf40593          	addi	a1,s0,-81
+    800044b8:	0509b503          	ld	a0,80(s3)
+    800044bc:	a0afd0ef          	jal	800016c6 <copyin>
+    800044c0:	03650e63          	beq	a0,s6,800044fc <pipewrite+0xdc>
+      pi->data[pi->nwrite++ % PIPESIZE] = ch;
+    800044c4:	21c4a783          	lw	a5,540(s1)
+    800044c8:	0017871b          	addiw	a4,a5,1
+    800044cc:	20e4ae23          	sw	a4,540(s1)
+    800044d0:	1ff7f793          	andi	a5,a5,511
+    800044d4:	97a6                	add	a5,a5,s1
+    800044d6:	faf44703          	lbu	a4,-81(s0)
+    800044da:	00e78c23          	sb	a4,24(a5)
+      i++;
+    800044de:	2905                	addiw	s2,s2,1
+    800044e0:	b775                	j	8000448c <pipewrite+0x6c>
+    800044e2:	7b02                	ld	s6,32(sp)
+    800044e4:	6be2                	ld	s7,24(sp)
+    800044e6:	6c42                	ld	s8,16(sp)
+  wakeup(&pi->nread);
+    800044e8:	21848513          	addi	a0,s1,536
+    800044ec:	a3dfd0ef          	jal	80001f28 <wakeup>
+  release(&pi->lock);
+    800044f0:	8526                	mv	a0,s1
+    800044f2:	f74fc0ef          	jal	80000c66 <release>
+  return i;
+    800044f6:	bf95                	j	8000446a <pipewrite+0x4a>
+  int i = 0;
+    800044f8:	4901                	li	s2,0
+    800044fa:	b7fd                	j	800044e8 <pipewrite+0xc8>
+    800044fc:	7b02                	ld	s6,32(sp)
+    800044fe:	6be2                	ld	s7,24(sp)
+    80004500:	6c42                	ld	s8,16(sp)
+    80004502:	b7dd                	j	800044e8 <pipewrite+0xc8>
+
+0000000080004504 <piperead>:
+
+int
+piperead(struct pipe *pi, uint64 addr, int n)
+{
+    80004504:	715d                	addi	sp,sp,-80
+    80004506:	e486                	sd	ra,72(sp)
+    80004508:	e0a2                	sd	s0,64(sp)
+    8000450a:	fc26                	sd	s1,56(sp)
+    8000450c:	f84a                	sd	s2,48(sp)
+    8000450e:	f44e                	sd	s3,40(sp)
+    80004510:	f052                	sd	s4,32(sp)
+    80004512:	ec56                	sd	s5,24(sp)
+    80004514:	0880                	addi	s0,sp,80
+    80004516:	84aa                	mv	s1,a0
+    80004518:	892e                	mv	s2,a1
+    8000451a:	8ab2                	mv	s5,a2
+  int i;
+  struct proc *pr = myproc();
+    8000451c:	bb2fd0ef          	jal	800018ce <myproc>
+    80004520:	8a2a                	mv	s4,a0
+  char ch;
+
+  acquire(&pi->lock);
+    80004522:	8526                	mv	a0,s1
+    80004524:	eaafc0ef          	jal	80000bce <acquire>
+  while(pi->nread == pi->nwrite && pi->writeopen){  //DOC: pipe-empty
+    80004528:	2184a703          	lw	a4,536(s1)
+    8000452c:	21c4a783          	lw	a5,540(s1)
+    if(killed(pr)){
+      release(&pi->lock);
+      return -1;
+    }
+    sleep(&pi->nread, &pi->lock); //DOC: piperead-sleep
+    80004530:	21848993          	addi	s3,s1,536
+  while(pi->nread == pi->nwrite && pi->writeopen){  //DOC: pipe-empty
+    80004534:	02f71563          	bne	a4,a5,8000455e <piperead+0x5a>
+    80004538:	2244a783          	lw	a5,548(s1)
+    8000453c:	cb85                	beqz	a5,8000456c <piperead+0x68>
+    if(killed(pr)){
+    8000453e:	8552                	mv	a0,s4
+    80004540:	bd5fd0ef          	jal	80002114 <killed>
+    80004544:	ed19                	bnez	a0,80004562 <piperead+0x5e>
+    sleep(&pi->nread, &pi->lock); //DOC: piperead-sleep
+    80004546:	85a6                	mv	a1,s1
+    80004548:	854e                	mv	a0,s3
+    8000454a:	993fd0ef          	jal	80001edc <sleep>
+  while(pi->nread == pi->nwrite && pi->writeopen){  //DOC: pipe-empty
+    8000454e:	2184a703          	lw	a4,536(s1)
+    80004552:	21c4a783          	lw	a5,540(s1)
+    80004556:	fef701e3          	beq	a4,a5,80004538 <piperead+0x34>
+    8000455a:	e85a                	sd	s6,16(sp)
+    8000455c:	a809                	j	8000456e <piperead+0x6a>
+    8000455e:	e85a                	sd	s6,16(sp)
+    80004560:	a039                	j	8000456e <piperead+0x6a>
+      release(&pi->lock);
+    80004562:	8526                	mv	a0,s1
+    80004564:	f02fc0ef          	jal	80000c66 <release>
+      return -1;
+    80004568:	59fd                	li	s3,-1
+    8000456a:	a8b1                	j	800045c6 <piperead+0xc2>
+    8000456c:	e85a                	sd	s6,16(sp)
+  }
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+    8000456e:	4981                	li	s3,0
+    if(pi->nread == pi->nwrite)
+      break;
+    ch = pi->data[pi->nread++ % PIPESIZE];
+    if(copyout(pr->pagetable, addr + i, &ch, 1) == -1)
+    80004570:	5b7d                	li	s6,-1
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+    80004572:	05505263          	blez	s5,800045b6 <piperead+0xb2>
+    if(pi->nread == pi->nwrite)
+    80004576:	2184a783          	lw	a5,536(s1)
+    8000457a:	21c4a703          	lw	a4,540(s1)
+    8000457e:	02f70c63          	beq	a4,a5,800045b6 <piperead+0xb2>
+    ch = pi->data[pi->nread++ % PIPESIZE];
+    80004582:	0017871b          	addiw	a4,a5,1
+    80004586:	20e4ac23          	sw	a4,536(s1)
+    8000458a:	1ff7f793          	andi	a5,a5,511
+    8000458e:	97a6                	add	a5,a5,s1
+    80004590:	0187c783          	lbu	a5,24(a5)
+    80004594:	faf40fa3          	sb	a5,-65(s0)
+    if(copyout(pr->pagetable, addr + i, &ch, 1) == -1)
+    80004598:	4685                	li	a3,1
+    8000459a:	fbf40613          	addi	a2,s0,-65
+    8000459e:	85ca                	mv	a1,s2
+    800045a0:	050a3503          	ld	a0,80(s4)
+    800045a4:	83efd0ef          	jal	800015e2 <copyout>
+    800045a8:	01650763          	beq	a0,s6,800045b6 <piperead+0xb2>
+  for(i = 0; i < n; i++){  //DOC: piperead-copy
+    800045ac:	2985                	addiw	s3,s3,1
+    800045ae:	0905                	addi	s2,s2,1
+    800045b0:	fd3a93e3          	bne	s5,s3,80004576 <piperead+0x72>
+    800045b4:	89d6                	mv	s3,s5
+      break;
+  }
+  wakeup(&pi->nwrite);  //DOC: piperead-wakeup
+    800045b6:	21c48513          	addi	a0,s1,540
+    800045ba:	96ffd0ef          	jal	80001f28 <wakeup>
+  release(&pi->lock);
+    800045be:	8526                	mv	a0,s1
+    800045c0:	ea6fc0ef          	jal	80000c66 <release>
+    800045c4:	6b42                	ld	s6,16(sp)
+  return i;
+}
+    800045c6:	854e                	mv	a0,s3
+    800045c8:	60a6                	ld	ra,72(sp)
+    800045ca:	6406                	ld	s0,64(sp)
+    800045cc:	74e2                	ld	s1,56(sp)
+    800045ce:	7942                	ld	s2,48(sp)
+    800045d0:	79a2                	ld	s3,40(sp)
+    800045d2:	7a02                	ld	s4,32(sp)
+    800045d4:	6ae2                	ld	s5,24(sp)
+    800045d6:	6161                	addi	sp,sp,80
+    800045d8:	8082                	ret
+
+00000000800045da <flags2perm>:
+
+static int loadseg(pde_t *, uint64, struct inode *, uint, uint);
+
+// map ELF permissions to PTE permission bits.
+int flags2perm(int flags)
+{
+    800045da:	1141                	addi	sp,sp,-16
+    800045dc:	e422                	sd	s0,8(sp)
+    800045de:	0800                	addi	s0,sp,16
+    800045e0:	87aa                	mv	a5,a0
+    int perm = 0;
+    if(flags & 0x1)
+    800045e2:	8905                	andi	a0,a0,1
+    800045e4:	050e                	slli	a0,a0,0x3
+      perm = PTE_X;
+    if(flags & 0x2)
+    800045e6:	8b89                	andi	a5,a5,2
+    800045e8:	c399                	beqz	a5,800045ee <flags2perm+0x14>
+      perm |= PTE_W;
+    800045ea:	00456513          	ori	a0,a0,4
+    return perm;
+}
+    800045ee:	6422                	ld	s0,8(sp)
+    800045f0:	0141                	addi	sp,sp,16
+    800045f2:	8082                	ret
+
+00000000800045f4 <kexec>:
+//
+// the implementation of the exec() system call
+//
+int
+kexec(char *path, char **argv)
+{
+    800045f4:	df010113          	addi	sp,sp,-528
+    800045f8:	20113423          	sd	ra,520(sp)
+    800045fc:	20813023          	sd	s0,512(sp)
+    80004600:	ffa6                	sd	s1,504(sp)
+    80004602:	fbca                	sd	s2,496(sp)
+    80004604:	0c00                	addi	s0,sp,528
+    80004606:	892a                	mv	s2,a0
+    80004608:	dea43c23          	sd	a0,-520(s0)
+    8000460c:	e0b43023          	sd	a1,-512(s0)
+  uint64 argc, sz = 0, sp, ustack[MAXARG], stackbase;
+  struct elfhdr elf;
+  struct inode *ip;
+  struct proghdr ph;
+  pagetable_t pagetable = 0, oldpagetable;
+  struct proc *p = myproc();
+    80004610:	abefd0ef          	jal	800018ce <myproc>
+    80004614:	84aa                	mv	s1,a0
+
+  begin_op();
+    80004616:	dd4ff0ef          	jal	80003bea <begin_op>
+
+  // Open the executable file.
+  if((ip = namei(path)) == 0){
+    8000461a:	854a                	mv	a0,s2
+    8000461c:	bfaff0ef          	jal	80003a16 <namei>
+    80004620:	c931                	beqz	a0,80004674 <kexec+0x80>
+    80004622:	f3d2                	sd	s4,480(sp)
+    80004624:	8a2a                	mv	s4,a0
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+    80004626:	bdbfe0ef          	jal	80003200 <ilock>
+
+  // Read the ELF header.
+  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))
+    8000462a:	04000713          	li	a4,64
+    8000462e:	4681                	li	a3,0
+    80004630:	e5040613          	addi	a2,s0,-432
+    80004634:	4581                	li	a1,0
+    80004636:	8552                	mv	a0,s4
+    80004638:	f59fe0ef          	jal	80003590 <readi>
+    8000463c:	04000793          	li	a5,64
+    80004640:	00f51a63          	bne	a0,a5,80004654 <kexec+0x60>
+    goto bad;
+
+  // Is this really an ELF file?
+  if(elf.magic != ELF_MAGIC)
+    80004644:	e5042703          	lw	a4,-432(s0)
+    80004648:	464c47b7          	lui	a5,0x464c4
+    8000464c:	57f78793          	addi	a5,a5,1407 # 464c457f <_entry-0x39b3ba81>
+    80004650:	02f70663          	beq	a4,a5,8000467c <kexec+0x88>
+
+ bad:
+  if(pagetable)
+    proc_freepagetable(pagetable, sz);
+  if(ip){
+    iunlockput(ip);
+    80004654:	8552                	mv	a0,s4
+    80004656:	db5fe0ef          	jal	8000340a <iunlockput>
+    end_op();
+    8000465a:	dfaff0ef          	jal	80003c54 <end_op>
+  }
+  return -1;
+    8000465e:	557d                	li	a0,-1
+    80004660:	7a1e                	ld	s4,480(sp)
+}
+    80004662:	20813083          	ld	ra,520(sp)
+    80004666:	20013403          	ld	s0,512(sp)
+    8000466a:	74fe                	ld	s1,504(sp)
+    8000466c:	795e                	ld	s2,496(sp)
+    8000466e:	21010113          	addi	sp,sp,528
+    80004672:	8082                	ret
+    end_op();
+    80004674:	de0ff0ef          	jal	80003c54 <end_op>
+    return -1;
+    80004678:	557d                	li	a0,-1
+    8000467a:	b7e5                	j	80004662 <kexec+0x6e>
+    8000467c:	ebda                	sd	s6,464(sp)
+  if((pagetable = proc_pagetable(p)) == 0)
+    8000467e:	8526                	mv	a0,s1
+    80004680:	b54fd0ef          	jal	800019d4 <proc_pagetable>
+    80004684:	8b2a                	mv	s6,a0
+    80004686:	2c050b63          	beqz	a0,8000495c <kexec+0x368>
+    8000468a:	f7ce                	sd	s3,488(sp)
+    8000468c:	efd6                	sd	s5,472(sp)
+    8000468e:	e7de                	sd	s7,456(sp)
+    80004690:	e3e2                	sd	s8,448(sp)
+    80004692:	ff66                	sd	s9,440(sp)
+    80004694:	fb6a                	sd	s10,432(sp)
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    80004696:	e7042d03          	lw	s10,-400(s0)
+    8000469a:	e8845783          	lhu	a5,-376(s0)
+    8000469e:	12078963          	beqz	a5,800047d0 <kexec+0x1dc>
+    800046a2:	f76e                	sd	s11,424(sp)
+  uint64 argc, sz = 0, sp, ustack[MAXARG], stackbase;
+    800046a4:	4901                	li	s2,0
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    800046a6:	4d81                	li	s11,0
+    if(ph.vaddr % PGSIZE != 0)
+    800046a8:	6c85                	lui	s9,0x1
+    800046aa:	fffc8793          	addi	a5,s9,-1 # fff <_entry-0x7ffff001>
+    800046ae:	def43823          	sd	a5,-528(s0)
+
+  for(i = 0; i < sz; i += PGSIZE){
+    pa = walkaddr(pagetable, va + i);
+    if(pa == 0)
+      panic("loadseg: address should exist");
+    if(sz - i < PGSIZE)
+    800046b2:	6a85                	lui	s5,0x1
+    800046b4:	a085                	j	80004714 <kexec+0x120>
+      panic("loadseg: address should exist");
+    800046b6:	00003517          	auipc	a0,0x3
+    800046ba:	f1a50513          	addi	a0,a0,-230 # 800075d0 <etext+0x5d0>
+    800046be:	922fc0ef          	jal	800007e0 <panic>
+    if(sz - i < PGSIZE)
+    800046c2:	2481                	sext.w	s1,s1
+      n = sz - i;
+    else
+      n = PGSIZE;
+    if(readi(ip, 0, (uint64)pa, offset+i, n) != n)
+    800046c4:	8726                	mv	a4,s1
+    800046c6:	012c06bb          	addw	a3,s8,s2
+    800046ca:	4581                	li	a1,0
+    800046cc:	8552                	mv	a0,s4
+    800046ce:	ec3fe0ef          	jal	80003590 <readi>
+    800046d2:	2501                	sext.w	a0,a0
+    800046d4:	24a49a63          	bne	s1,a0,80004928 <kexec+0x334>
+  for(i = 0; i < sz; i += PGSIZE){
+    800046d8:	012a893b          	addw	s2,s5,s2
+    800046dc:	03397363          	bgeu	s2,s3,80004702 <kexec+0x10e>
+    pa = walkaddr(pagetable, va + i);
+    800046e0:	02091593          	slli	a1,s2,0x20
+    800046e4:	9181                	srli	a1,a1,0x20
+    800046e6:	95de                	add	a1,a1,s7
+    800046e8:	855a                	mv	a0,s6
+    800046ea:	8c7fc0ef          	jal	80000fb0 <walkaddr>
+    800046ee:	862a                	mv	a2,a0
+    if(pa == 0)
+    800046f0:	d179                	beqz	a0,800046b6 <kexec+0xc2>
+    if(sz - i < PGSIZE)
+    800046f2:	412984bb          	subw	s1,s3,s2
+    800046f6:	0004879b          	sext.w	a5,s1
+    800046fa:	fcfcf4e3          	bgeu	s9,a5,800046c2 <kexec+0xce>
+    800046fe:	84d6                	mv	s1,s5
+    80004700:	b7c9                	j	800046c2 <kexec+0xce>
+    sz = sz1;
+    80004702:	e0843903          	ld	s2,-504(s0)
+  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    80004706:	2d85                	addiw	s11,s11,1
+    80004708:	038d0d1b          	addiw	s10,s10,56 # 1038 <_entry-0x7fffefc8>
+    8000470c:	e8845783          	lhu	a5,-376(s0)
+    80004710:	08fdd063          	bge	s11,a5,80004790 <kexec+0x19c>
+    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
+    80004714:	2d01                	sext.w	s10,s10
+    80004716:	03800713          	li	a4,56
+    8000471a:	86ea                	mv	a3,s10
+    8000471c:	e1840613          	addi	a2,s0,-488
+    80004720:	4581                	li	a1,0
+    80004722:	8552                	mv	a0,s4
+    80004724:	e6dfe0ef          	jal	80003590 <readi>
+    80004728:	03800793          	li	a5,56
+    8000472c:	1cf51663          	bne	a0,a5,800048f8 <kexec+0x304>
+    if(ph.type != ELF_PROG_LOAD)
+    80004730:	e1842783          	lw	a5,-488(s0)
+    80004734:	4705                	li	a4,1
+    80004736:	fce798e3          	bne	a5,a4,80004706 <kexec+0x112>
+    if(ph.memsz < ph.filesz)
+    8000473a:	e4043483          	ld	s1,-448(s0)
+    8000473e:	e3843783          	ld	a5,-456(s0)
+    80004742:	1af4ef63          	bltu	s1,a5,80004900 <kexec+0x30c>
+    if(ph.vaddr + ph.memsz < ph.vaddr)
+    80004746:	e2843783          	ld	a5,-472(s0)
+    8000474a:	94be                	add	s1,s1,a5
+    8000474c:	1af4ee63          	bltu	s1,a5,80004908 <kexec+0x314>
+    if(ph.vaddr % PGSIZE != 0)
+    80004750:	df043703          	ld	a4,-528(s0)
+    80004754:	8ff9                	and	a5,a5,a4
+    80004756:	1a079d63          	bnez	a5,80004910 <kexec+0x31c>
+    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)
+    8000475a:	e1c42503          	lw	a0,-484(s0)
+    8000475e:	e7dff0ef          	jal	800045da <flags2perm>
+    80004762:	86aa                	mv	a3,a0
+    80004764:	8626                	mv	a2,s1
+    80004766:	85ca                	mv	a1,s2
+    80004768:	855a                	mv	a0,s6
+    8000476a:	b1ffc0ef          	jal	80001288 <uvmalloc>
+    8000476e:	e0a43423          	sd	a0,-504(s0)
+    80004772:	1a050363          	beqz	a0,80004918 <kexec+0x324>
+    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)
+    80004776:	e2843b83          	ld	s7,-472(s0)
+    8000477a:	e2042c03          	lw	s8,-480(s0)
+    8000477e:	e3842983          	lw	s3,-456(s0)
+  for(i = 0; i < sz; i += PGSIZE){
+    80004782:	00098463          	beqz	s3,8000478a <kexec+0x196>
+    80004786:	4901                	li	s2,0
+    80004788:	bfa1                	j	800046e0 <kexec+0xec>
+    sz = sz1;
+    8000478a:	e0843903          	ld	s2,-504(s0)
+    8000478e:	bfa5                	j	80004706 <kexec+0x112>
+    80004790:	7dba                	ld	s11,424(sp)
+  iunlockput(ip);
+    80004792:	8552                	mv	a0,s4
+    80004794:	c77fe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    80004798:	cbcff0ef          	jal	80003c54 <end_op>
+  p = myproc();
+    8000479c:	932fd0ef          	jal	800018ce <myproc>
+    800047a0:	8aaa                	mv	s5,a0
+  uint64 oldsz = p->sz;
+    800047a2:	04853c83          	ld	s9,72(a0)
+  sz = PGROUNDUP(sz);
+    800047a6:	6985                	lui	s3,0x1
+    800047a8:	19fd                	addi	s3,s3,-1 # fff <_entry-0x7ffff001>
+    800047aa:	99ca                	add	s3,s3,s2
+    800047ac:	77fd                	lui	a5,0xfffff
+    800047ae:	00f9f9b3          	and	s3,s3,a5
+  if((sz1 = uvmalloc(pagetable, sz, sz + (USERSTACK+1)*PGSIZE, PTE_W)) == 0)
+    800047b2:	4691                	li	a3,4
+    800047b4:	6609                	lui	a2,0x2
+    800047b6:	964e                	add	a2,a2,s3
+    800047b8:	85ce                	mv	a1,s3
+    800047ba:	855a                	mv	a0,s6
+    800047bc:	acdfc0ef          	jal	80001288 <uvmalloc>
+    800047c0:	892a                	mv	s2,a0
+    800047c2:	e0a43423          	sd	a0,-504(s0)
+    800047c6:	e519                	bnez	a0,800047d4 <kexec+0x1e0>
+  if(pagetable)
+    800047c8:	e1343423          	sd	s3,-504(s0)
+    800047cc:	4a01                	li	s4,0
+    800047ce:	aab1                	j	8000492a <kexec+0x336>
+  uint64 argc, sz = 0, sp, ustack[MAXARG], stackbase;
+    800047d0:	4901                	li	s2,0
+    800047d2:	b7c1                	j	80004792 <kexec+0x19e>
+  uvmclear(pagetable, sz-(USERSTACK+1)*PGSIZE);
+    800047d4:	75f9                	lui	a1,0xffffe
+    800047d6:	95aa                	add	a1,a1,a0
+    800047d8:	855a                	mv	a0,s6
+    800047da:	c85fc0ef          	jal	8000145e <uvmclear>
+  stackbase = sp - USERSTACK*PGSIZE;
+    800047de:	7bfd                	lui	s7,0xfffff
+    800047e0:	9bca                	add	s7,s7,s2
+  for(argc = 0; argv[argc]; argc++) {
+    800047e2:	e0043783          	ld	a5,-512(s0)
+    800047e6:	6388                	ld	a0,0(a5)
+    800047e8:	cd39                	beqz	a0,80004846 <kexec+0x252>
+    800047ea:	e9040993          	addi	s3,s0,-368
+    800047ee:	f9040c13          	addi	s8,s0,-112
+    800047f2:	4481                	li	s1,0
+    sp -= strlen(argv[argc]) + 1;
+    800047f4:	e1efc0ef          	jal	80000e12 <strlen>
+    800047f8:	0015079b          	addiw	a5,a0,1
+    800047fc:	40f907b3          	sub	a5,s2,a5
+    sp -= sp % 16; // riscv sp must be 16-byte aligned
+    80004800:	ff07f913          	andi	s2,a5,-16
+    if(sp < stackbase)
+    80004804:	11796e63          	bltu	s2,s7,80004920 <kexec+0x32c>
+    if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
+    80004808:	e0043d03          	ld	s10,-512(s0)
+    8000480c:	000d3a03          	ld	s4,0(s10)
+    80004810:	8552                	mv	a0,s4
+    80004812:	e00fc0ef          	jal	80000e12 <strlen>
+    80004816:	0015069b          	addiw	a3,a0,1
+    8000481a:	8652                	mv	a2,s4
+    8000481c:	85ca                	mv	a1,s2
+    8000481e:	855a                	mv	a0,s6
+    80004820:	dc3fc0ef          	jal	800015e2 <copyout>
+    80004824:	10054063          	bltz	a0,80004924 <kexec+0x330>
+    ustack[argc] = sp;
+    80004828:	0129b023          	sd	s2,0(s3)
+  for(argc = 0; argv[argc]; argc++) {
+    8000482c:	0485                	addi	s1,s1,1
+    8000482e:	008d0793          	addi	a5,s10,8
+    80004832:	e0f43023          	sd	a5,-512(s0)
+    80004836:	008d3503          	ld	a0,8(s10)
+    8000483a:	c909                	beqz	a0,8000484c <kexec+0x258>
+    if(argc >= MAXARG)
+    8000483c:	09a1                	addi	s3,s3,8
+    8000483e:	fb899be3          	bne	s3,s8,800047f4 <kexec+0x200>
+  ip = 0;
+    80004842:	4a01                	li	s4,0
+    80004844:	a0dd                	j	8000492a <kexec+0x336>
+  sp = sz;
+    80004846:	e0843903          	ld	s2,-504(s0)
+  for(argc = 0; argv[argc]; argc++) {
+    8000484a:	4481                	li	s1,0
+  ustack[argc] = 0;
+    8000484c:	00349793          	slli	a5,s1,0x3
+    80004850:	f9078793          	addi	a5,a5,-112 # ffffffffffffef90 <end+0xffffffff7ffdb088>
+    80004854:	97a2                	add	a5,a5,s0
+    80004856:	f007b023          	sd	zero,-256(a5)
+  sp -= (argc+1) * sizeof(uint64);
+    8000485a:	00148693          	addi	a3,s1,1
+    8000485e:	068e                	slli	a3,a3,0x3
+    80004860:	40d90933          	sub	s2,s2,a3
+  sp -= sp % 16;
+    80004864:	ff097913          	andi	s2,s2,-16
+  sz = sz1;
+    80004868:	e0843983          	ld	s3,-504(s0)
+  if(sp < stackbase)
+    8000486c:	f5796ee3          	bltu	s2,s7,800047c8 <kexec+0x1d4>
+  if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
+    80004870:	e9040613          	addi	a2,s0,-368
+    80004874:	85ca                	mv	a1,s2
+    80004876:	855a                	mv	a0,s6
+    80004878:	d6bfc0ef          	jal	800015e2 <copyout>
+    8000487c:	0e054263          	bltz	a0,80004960 <kexec+0x36c>
+  p->trapframe->a1 = sp;
+    80004880:	058ab783          	ld	a5,88(s5) # 1058 <_entry-0x7fffefa8>
+    80004884:	0727bc23          	sd	s2,120(a5)
+  for(last=s=path; *s; s++)
+    80004888:	df843783          	ld	a5,-520(s0)
+    8000488c:	0007c703          	lbu	a4,0(a5)
+    80004890:	cf11                	beqz	a4,800048ac <kexec+0x2b8>
+    80004892:	0785                	addi	a5,a5,1
+    if(*s == '/')
+    80004894:	02f00693          	li	a3,47
+    80004898:	a039                	j	800048a6 <kexec+0x2b2>
+      last = s+1;
+    8000489a:	def43c23          	sd	a5,-520(s0)
+  for(last=s=path; *s; s++)
+    8000489e:	0785                	addi	a5,a5,1
+    800048a0:	fff7c703          	lbu	a4,-1(a5)
+    800048a4:	c701                	beqz	a4,800048ac <kexec+0x2b8>
+    if(*s == '/')
+    800048a6:	fed71ce3          	bne	a4,a3,8000489e <kexec+0x2aa>
+    800048aa:	bfc5                	j	8000489a <kexec+0x2a6>
+  safestrcpy(p->name, last, sizeof(p->name));
+    800048ac:	4641                	li	a2,16
+    800048ae:	df843583          	ld	a1,-520(s0)
+    800048b2:	158a8513          	addi	a0,s5,344
+    800048b6:	d2afc0ef          	jal	80000de0 <safestrcpy>
+  oldpagetable = p->pagetable;
+    800048ba:	050ab503          	ld	a0,80(s5)
+  p->pagetable = pagetable;
+    800048be:	056ab823          	sd	s6,80(s5)
+  p->sz = sz;
+    800048c2:	e0843783          	ld	a5,-504(s0)
+    800048c6:	04fab423          	sd	a5,72(s5)
+  p->trapframe->epc = elf.entry;  // initial program counter = main
+    800048ca:	058ab783          	ld	a5,88(s5)
+    800048ce:	e6843703          	ld	a4,-408(s0)
+    800048d2:	ef98                	sd	a4,24(a5)
+  p->trapframe->sp = sp; // initial stack pointer
+    800048d4:	058ab783          	ld	a5,88(s5)
+    800048d8:	0327b823          	sd	s2,48(a5)
+  proc_freepagetable(oldpagetable, oldsz);
+    800048dc:	85e6                	mv	a1,s9
+    800048de:	97afd0ef          	jal	80001a58 <proc_freepagetable>
+  return argc; // this ends up in a0, the first argument to main(argc, argv)
+    800048e2:	0004851b          	sext.w	a0,s1
+    800048e6:	79be                	ld	s3,488(sp)
+    800048e8:	7a1e                	ld	s4,480(sp)
+    800048ea:	6afe                	ld	s5,472(sp)
+    800048ec:	6b5e                	ld	s6,464(sp)
+    800048ee:	6bbe                	ld	s7,456(sp)
+    800048f0:	6c1e                	ld	s8,448(sp)
+    800048f2:	7cfa                	ld	s9,440(sp)
+    800048f4:	7d5a                	ld	s10,432(sp)
+    800048f6:	b3b5                	j	80004662 <kexec+0x6e>
+    800048f8:	e1243423          	sd	s2,-504(s0)
+    800048fc:	7dba                	ld	s11,424(sp)
+    800048fe:	a035                	j	8000492a <kexec+0x336>
+    80004900:	e1243423          	sd	s2,-504(s0)
+    80004904:	7dba                	ld	s11,424(sp)
+    80004906:	a015                	j	8000492a <kexec+0x336>
+    80004908:	e1243423          	sd	s2,-504(s0)
+    8000490c:	7dba                	ld	s11,424(sp)
+    8000490e:	a831                	j	8000492a <kexec+0x336>
+    80004910:	e1243423          	sd	s2,-504(s0)
+    80004914:	7dba                	ld	s11,424(sp)
+    80004916:	a811                	j	8000492a <kexec+0x336>
+    80004918:	e1243423          	sd	s2,-504(s0)
+    8000491c:	7dba                	ld	s11,424(sp)
+    8000491e:	a031                	j	8000492a <kexec+0x336>
+  ip = 0;
+    80004920:	4a01                	li	s4,0
+    80004922:	a021                	j	8000492a <kexec+0x336>
+    80004924:	4a01                	li	s4,0
+  if(pagetable)
+    80004926:	a011                	j	8000492a <kexec+0x336>
+    80004928:	7dba                	ld	s11,424(sp)
+    proc_freepagetable(pagetable, sz);
+    8000492a:	e0843583          	ld	a1,-504(s0)
+    8000492e:	855a                	mv	a0,s6
+    80004930:	928fd0ef          	jal	80001a58 <proc_freepagetable>
+  return -1;
+    80004934:	557d                	li	a0,-1
+  if(ip){
+    80004936:	000a1b63          	bnez	s4,8000494c <kexec+0x358>
+    8000493a:	79be                	ld	s3,488(sp)
+    8000493c:	7a1e                	ld	s4,480(sp)
+    8000493e:	6afe                	ld	s5,472(sp)
+    80004940:	6b5e                	ld	s6,464(sp)
+    80004942:	6bbe                	ld	s7,456(sp)
+    80004944:	6c1e                	ld	s8,448(sp)
+    80004946:	7cfa                	ld	s9,440(sp)
+    80004948:	7d5a                	ld	s10,432(sp)
+    8000494a:	bb21                	j	80004662 <kexec+0x6e>
+    8000494c:	79be                	ld	s3,488(sp)
+    8000494e:	6afe                	ld	s5,472(sp)
+    80004950:	6b5e                	ld	s6,464(sp)
+    80004952:	6bbe                	ld	s7,456(sp)
+    80004954:	6c1e                	ld	s8,448(sp)
+    80004956:	7cfa                	ld	s9,440(sp)
+    80004958:	7d5a                	ld	s10,432(sp)
+    8000495a:	b9ed                	j	80004654 <kexec+0x60>
+    8000495c:	6b5e                	ld	s6,464(sp)
+    8000495e:	b9dd                	j	80004654 <kexec+0x60>
+  sz = sz1;
+    80004960:	e0843983          	ld	s3,-504(s0)
+    80004964:	b595                	j	800047c8 <kexec+0x1d4>
+
+0000000080004966 <argfd>:
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+    80004966:	7179                	addi	sp,sp,-48
+    80004968:	f406                	sd	ra,40(sp)
+    8000496a:	f022                	sd	s0,32(sp)
+    8000496c:	ec26                	sd	s1,24(sp)
+    8000496e:	e84a                	sd	s2,16(sp)
+    80004970:	1800                	addi	s0,sp,48
+    80004972:	892e                	mv	s2,a1
+    80004974:	84b2                	mv	s1,a2
+  int fd;
+  struct file *f;
+
+  argint(n, &fd);
+    80004976:	fdc40593          	addi	a1,s0,-36
+    8000497a:	e91fd0ef          	jal	8000280a <argint>
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    8000497e:	fdc42703          	lw	a4,-36(s0)
+    80004982:	47bd                	li	a5,15
+    80004984:	02e7e963          	bltu	a5,a4,800049b6 <argfd+0x50>
+    80004988:	f47fc0ef          	jal	800018ce <myproc>
+    8000498c:	fdc42703          	lw	a4,-36(s0)
+    80004990:	01a70793          	addi	a5,a4,26
+    80004994:	078e                	slli	a5,a5,0x3
+    80004996:	953e                	add	a0,a0,a5
+    80004998:	611c                	ld	a5,0(a0)
+    8000499a:	c385                	beqz	a5,800049ba <argfd+0x54>
+    return -1;
+  if(pfd)
+    8000499c:	00090463          	beqz	s2,800049a4 <argfd+0x3e>
+    *pfd = fd;
+    800049a0:	00e92023          	sw	a4,0(s2)
+  if(pf)
+    *pf = f;
+  return 0;
+    800049a4:	4501                	li	a0,0
+  if(pf)
+    800049a6:	c091                	beqz	s1,800049aa <argfd+0x44>
+    *pf = f;
+    800049a8:	e09c                	sd	a5,0(s1)
+}
+    800049aa:	70a2                	ld	ra,40(sp)
+    800049ac:	7402                	ld	s0,32(sp)
+    800049ae:	64e2                	ld	s1,24(sp)
+    800049b0:	6942                	ld	s2,16(sp)
+    800049b2:	6145                	addi	sp,sp,48
+    800049b4:	8082                	ret
+    return -1;
+    800049b6:	557d                	li	a0,-1
+    800049b8:	bfcd                	j	800049aa <argfd+0x44>
+    800049ba:	557d                	li	a0,-1
+    800049bc:	b7fd                	j	800049aa <argfd+0x44>
+
+00000000800049be <fdalloc>:
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+    800049be:	1101                	addi	sp,sp,-32
+    800049c0:	ec06                	sd	ra,24(sp)
+    800049c2:	e822                	sd	s0,16(sp)
+    800049c4:	e426                	sd	s1,8(sp)
+    800049c6:	1000                	addi	s0,sp,32
+    800049c8:	84aa                	mv	s1,a0
+  int fd;
+  struct proc *p = myproc();
+    800049ca:	f05fc0ef          	jal	800018ce <myproc>
+    800049ce:	862a                	mv	a2,a0
+
+  for(fd = 0; fd < NOFILE; fd++){
+    800049d0:	0d050793          	addi	a5,a0,208
+    800049d4:	4501                	li	a0,0
+    800049d6:	46c1                	li	a3,16
+    if(p->ofile[fd] == 0){
+    800049d8:	6398                	ld	a4,0(a5)
+    800049da:	cb19                	beqz	a4,800049f0 <fdalloc+0x32>
+  for(fd = 0; fd < NOFILE; fd++){
+    800049dc:	2505                	addiw	a0,a0,1
+    800049de:	07a1                	addi	a5,a5,8
+    800049e0:	fed51ce3          	bne	a0,a3,800049d8 <fdalloc+0x1a>
+      p->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+    800049e4:	557d                	li	a0,-1
+}
+    800049e6:	60e2                	ld	ra,24(sp)
+    800049e8:	6442                	ld	s0,16(sp)
+    800049ea:	64a2                	ld	s1,8(sp)
+    800049ec:	6105                	addi	sp,sp,32
+    800049ee:	8082                	ret
+      p->ofile[fd] = f;
+    800049f0:	01a50793          	addi	a5,a0,26
+    800049f4:	078e                	slli	a5,a5,0x3
+    800049f6:	963e                	add	a2,a2,a5
+    800049f8:	e204                	sd	s1,0(a2)
+      return fd;
+    800049fa:	b7f5                	j	800049e6 <fdalloc+0x28>
+
+00000000800049fc <create>:
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+    800049fc:	715d                	addi	sp,sp,-80
+    800049fe:	e486                	sd	ra,72(sp)
+    80004a00:	e0a2                	sd	s0,64(sp)
+    80004a02:	fc26                	sd	s1,56(sp)
+    80004a04:	f84a                	sd	s2,48(sp)
+    80004a06:	f44e                	sd	s3,40(sp)
+    80004a08:	ec56                	sd	s5,24(sp)
+    80004a0a:	e85a                	sd	s6,16(sp)
+    80004a0c:	0880                	addi	s0,sp,80
+    80004a0e:	8b2e                	mv	s6,a1
+    80004a10:	89b2                	mv	s3,a2
+    80004a12:	8936                	mv	s2,a3
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    80004a14:	fb040593          	addi	a1,s0,-80
+    80004a18:	818ff0ef          	jal	80003a30 <nameiparent>
+    80004a1c:	84aa                	mv	s1,a0
+    80004a1e:	10050a63          	beqz	a0,80004b32 <create+0x136>
+    return 0;
+
+  ilock(dp);
+    80004a22:	fdefe0ef          	jal	80003200 <ilock>
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    80004a26:	4601                	li	a2,0
+    80004a28:	fb040593          	addi	a1,s0,-80
+    80004a2c:	8526                	mv	a0,s1
+    80004a2e:	d83fe0ef          	jal	800037b0 <dirlookup>
+    80004a32:	8aaa                	mv	s5,a0
+    80004a34:	c129                	beqz	a0,80004a76 <create+0x7a>
+    iunlockput(dp);
+    80004a36:	8526                	mv	a0,s1
+    80004a38:	9d3fe0ef          	jal	8000340a <iunlockput>
+    ilock(ip);
+    80004a3c:	8556                	mv	a0,s5
+    80004a3e:	fc2fe0ef          	jal	80003200 <ilock>
+    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))
+    80004a42:	4789                	li	a5,2
+    80004a44:	02fb1463          	bne	s6,a5,80004a6c <create+0x70>
+    80004a48:	044ad783          	lhu	a5,68(s5)
+    80004a4c:	37f9                	addiw	a5,a5,-2
+    80004a4e:	17c2                	slli	a5,a5,0x30
+    80004a50:	93c1                	srli	a5,a5,0x30
+    80004a52:	4705                	li	a4,1
+    80004a54:	00f76c63          	bltu	a4,a5,80004a6c <create+0x70>
+  ip->nlink = 0;
+  iupdate(ip);
+  iunlockput(ip);
+  iunlockput(dp);
+  return 0;
+}
+    80004a58:	8556                	mv	a0,s5
+    80004a5a:	60a6                	ld	ra,72(sp)
+    80004a5c:	6406                	ld	s0,64(sp)
+    80004a5e:	74e2                	ld	s1,56(sp)
+    80004a60:	7942                	ld	s2,48(sp)
+    80004a62:	79a2                	ld	s3,40(sp)
+    80004a64:	6ae2                	ld	s5,24(sp)
+    80004a66:	6b42                	ld	s6,16(sp)
+    80004a68:	6161                	addi	sp,sp,80
+    80004a6a:	8082                	ret
+    iunlockput(ip);
+    80004a6c:	8556                	mv	a0,s5
+    80004a6e:	99dfe0ef          	jal	8000340a <iunlockput>
+    return 0;
+    80004a72:	4a81                	li	s5,0
+    80004a74:	b7d5                	j	80004a58 <create+0x5c>
+    80004a76:	f052                	sd	s4,32(sp)
+  if((ip = ialloc(dp->dev, type)) == 0){
+    80004a78:	85da                	mv	a1,s6
+    80004a7a:	4088                	lw	a0,0(s1)
+    80004a7c:	e14fe0ef          	jal	80003090 <ialloc>
+    80004a80:	8a2a                	mv	s4,a0
+    80004a82:	cd15                	beqz	a0,80004abe <create+0xc2>
+  ilock(ip);
+    80004a84:	f7cfe0ef          	jal	80003200 <ilock>
+  ip->major = major;
+    80004a88:	053a1323          	sh	s3,70(s4)
+  ip->minor = minor;
+    80004a8c:	052a1423          	sh	s2,72(s4)
+  ip->nlink = 1;
+    80004a90:	4905                	li	s2,1
+    80004a92:	052a1523          	sh	s2,74(s4)
+  iupdate(ip);
+    80004a96:	8552                	mv	a0,s4
+    80004a98:	eb4fe0ef          	jal	8000314c <iupdate>
+  if(type == T_DIR){  // Create . and .. entries.
+    80004a9c:	032b0763          	beq	s6,s2,80004aca <create+0xce>
+  if(dirlink(dp, name, ip->inum) < 0)
+    80004aa0:	004a2603          	lw	a2,4(s4)
+    80004aa4:	fb040593          	addi	a1,s0,-80
+    80004aa8:	8526                	mv	a0,s1
+    80004aaa:	ed3fe0ef          	jal	8000397c <dirlink>
+    80004aae:	06054563          	bltz	a0,80004b18 <create+0x11c>
+  iunlockput(dp);
+    80004ab2:	8526                	mv	a0,s1
+    80004ab4:	957fe0ef          	jal	8000340a <iunlockput>
+  return ip;
+    80004ab8:	8ad2                	mv	s5,s4
+    80004aba:	7a02                	ld	s4,32(sp)
+    80004abc:	bf71                	j	80004a58 <create+0x5c>
+    iunlockput(dp);
+    80004abe:	8526                	mv	a0,s1
+    80004ac0:	94bfe0ef          	jal	8000340a <iunlockput>
+    return 0;
+    80004ac4:	8ad2                	mv	s5,s4
+    80004ac6:	7a02                	ld	s4,32(sp)
+    80004ac8:	bf41                	j	80004a58 <create+0x5c>
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+    80004aca:	004a2603          	lw	a2,4(s4)
+    80004ace:	00003597          	auipc	a1,0x3
+    80004ad2:	b2258593          	addi	a1,a1,-1246 # 800075f0 <etext+0x5f0>
+    80004ad6:	8552                	mv	a0,s4
+    80004ad8:	ea5fe0ef          	jal	8000397c <dirlink>
+    80004adc:	02054e63          	bltz	a0,80004b18 <create+0x11c>
+    80004ae0:	40d0                	lw	a2,4(s1)
+    80004ae2:	00003597          	auipc	a1,0x3
+    80004ae6:	b1658593          	addi	a1,a1,-1258 # 800075f8 <etext+0x5f8>
+    80004aea:	8552                	mv	a0,s4
+    80004aec:	e91fe0ef          	jal	8000397c <dirlink>
+    80004af0:	02054463          	bltz	a0,80004b18 <create+0x11c>
+  if(dirlink(dp, name, ip->inum) < 0)
+    80004af4:	004a2603          	lw	a2,4(s4)
+    80004af8:	fb040593          	addi	a1,s0,-80
+    80004afc:	8526                	mv	a0,s1
+    80004afe:	e7ffe0ef          	jal	8000397c <dirlink>
+    80004b02:	00054b63          	bltz	a0,80004b18 <create+0x11c>
+    dp->nlink++;  // for ".."
+    80004b06:	04a4d783          	lhu	a5,74(s1)
+    80004b0a:	2785                	addiw	a5,a5,1
+    80004b0c:	04f49523          	sh	a5,74(s1)
+    iupdate(dp);
+    80004b10:	8526                	mv	a0,s1
+    80004b12:	e3afe0ef          	jal	8000314c <iupdate>
+    80004b16:	bf71                	j	80004ab2 <create+0xb6>
+  ip->nlink = 0;
+    80004b18:	040a1523          	sh	zero,74(s4)
+  iupdate(ip);
+    80004b1c:	8552                	mv	a0,s4
+    80004b1e:	e2efe0ef          	jal	8000314c <iupdate>
+  iunlockput(ip);
+    80004b22:	8552                	mv	a0,s4
+    80004b24:	8e7fe0ef          	jal	8000340a <iunlockput>
+  iunlockput(dp);
+    80004b28:	8526                	mv	a0,s1
+    80004b2a:	8e1fe0ef          	jal	8000340a <iunlockput>
+  return 0;
+    80004b2e:	7a02                	ld	s4,32(sp)
+    80004b30:	b725                	j	80004a58 <create+0x5c>
+    return 0;
+    80004b32:	8aaa                	mv	s5,a0
+    80004b34:	b715                	j	80004a58 <create+0x5c>
+
+0000000080004b36 <sys_dup>:
+{
+    80004b36:	7179                	addi	sp,sp,-48
+    80004b38:	f406                	sd	ra,40(sp)
+    80004b3a:	f022                	sd	s0,32(sp)
+    80004b3c:	1800                	addi	s0,sp,48
+  if(argfd(0, 0, &f) < 0)
+    80004b3e:	fd840613          	addi	a2,s0,-40
+    80004b42:	4581                	li	a1,0
+    80004b44:	4501                	li	a0,0
+    80004b46:	e21ff0ef          	jal	80004966 <argfd>
+    return -1;
+    80004b4a:	57fd                	li	a5,-1
+  if(argfd(0, 0, &f) < 0)
+    80004b4c:	02054363          	bltz	a0,80004b72 <sys_dup+0x3c>
+    80004b50:	ec26                	sd	s1,24(sp)
+    80004b52:	e84a                	sd	s2,16(sp)
+  if((fd=fdalloc(f)) < 0)
+    80004b54:	fd843903          	ld	s2,-40(s0)
+    80004b58:	854a                	mv	a0,s2
+    80004b5a:	e65ff0ef          	jal	800049be <fdalloc>
+    80004b5e:	84aa                	mv	s1,a0
+    return -1;
+    80004b60:	57fd                	li	a5,-1
+  if((fd=fdalloc(f)) < 0)
+    80004b62:	00054d63          	bltz	a0,80004b7c <sys_dup+0x46>
+  filedup(f);
+    80004b66:	854a                	mv	a0,s2
+    80004b68:	c48ff0ef          	jal	80003fb0 <filedup>
+  return fd;
+    80004b6c:	87a6                	mv	a5,s1
+    80004b6e:	64e2                	ld	s1,24(sp)
+    80004b70:	6942                	ld	s2,16(sp)
+}
+    80004b72:	853e                	mv	a0,a5
+    80004b74:	70a2                	ld	ra,40(sp)
+    80004b76:	7402                	ld	s0,32(sp)
+    80004b78:	6145                	addi	sp,sp,48
+    80004b7a:	8082                	ret
+    80004b7c:	64e2                	ld	s1,24(sp)
+    80004b7e:	6942                	ld	s2,16(sp)
+    80004b80:	bfcd                	j	80004b72 <sys_dup+0x3c>
+
+0000000080004b82 <sys_read>:
+{
+    80004b82:	7179                	addi	sp,sp,-48
+    80004b84:	f406                	sd	ra,40(sp)
+    80004b86:	f022                	sd	s0,32(sp)
+    80004b88:	1800                	addi	s0,sp,48
+  argaddr(1, &p);
+    80004b8a:	fd840593          	addi	a1,s0,-40
+    80004b8e:	4505                	li	a0,1
+    80004b90:	c97fd0ef          	jal	80002826 <argaddr>
+  argint(2, &n);
+    80004b94:	fe440593          	addi	a1,s0,-28
+    80004b98:	4509                	li	a0,2
+    80004b9a:	c71fd0ef          	jal	8000280a <argint>
+  if(argfd(0, 0, &f) < 0) {
+    80004b9e:	fe840613          	addi	a2,s0,-24
+    80004ba2:	4581                	li	a1,0
+    80004ba4:	4501                	li	a0,0
+    80004ba6:	dc1ff0ef          	jal	80004966 <argfd>
+    80004baa:	87aa                	mv	a5,a0
+    return -1;
+    80004bac:	557d                	li	a0,-1
+  if(argfd(0, 0, &f) < 0) {
+    80004bae:	0207c363          	bltz	a5,80004bd4 <sys_read+0x52>
+  int r = fileread(f, p, n);
+    80004bb2:	fe442603          	lw	a2,-28(s0)
+    80004bb6:	fd843583          	ld	a1,-40(s0)
+    80004bba:	fe843503          	ld	a0,-24(s0)
+    80004bbe:	d58ff0ef          	jal	80004116 <fileread>
+  if(r > 0) {
+    80004bc2:	00a05963          	blez	a0,80004bd4 <sys_read+0x52>
+    goongng += (uint64)r;  //addition for the getreadcount guy
+    80004bc6:	00005717          	auipc	a4,0x5
+    80004bca:	62a70713          	addi	a4,a4,1578 # 8000a1f0 <goongng>
+    80004bce:	631c                	ld	a5,0(a4)
+    80004bd0:	97aa                	add	a5,a5,a0
+    80004bd2:	e31c                	sd	a5,0(a4)
+}
+    80004bd4:	70a2                	ld	ra,40(sp)
+    80004bd6:	7402                	ld	s0,32(sp)
+    80004bd8:	6145                	addi	sp,sp,48
+    80004bda:	8082                	ret
+
+0000000080004bdc <sys_getreadcount>:
+{
+    80004bdc:	1141                	addi	sp,sp,-16
+    80004bde:	e422                	sd	s0,8(sp)
+    80004be0:	0800                	addi	s0,sp,16
+}
+    80004be2:	00005517          	auipc	a0,0x5
+    80004be6:	60e53503          	ld	a0,1550(a0) # 8000a1f0 <goongng>
+    80004bea:	6422                	ld	s0,8(sp)
+    80004bec:	0141                	addi	sp,sp,16
+    80004bee:	8082                	ret
+
+0000000080004bf0 <sys_write>:
+{
+    80004bf0:	7179                	addi	sp,sp,-48
+    80004bf2:	f406                	sd	ra,40(sp)
+    80004bf4:	f022                	sd	s0,32(sp)
+    80004bf6:	1800                	addi	s0,sp,48
+  argaddr(1, &p);
+    80004bf8:	fd840593          	addi	a1,s0,-40
+    80004bfc:	4505                	li	a0,1
+    80004bfe:	c29fd0ef          	jal	80002826 <argaddr>
+  argint(2, &n);
+    80004c02:	fe440593          	addi	a1,s0,-28
+    80004c06:	4509                	li	a0,2
+    80004c08:	c03fd0ef          	jal	8000280a <argint>
+  if(argfd(0, 0, &f) < 0)
+    80004c0c:	fe840613          	addi	a2,s0,-24
+    80004c10:	4581                	li	a1,0
+    80004c12:	4501                	li	a0,0
+    80004c14:	d53ff0ef          	jal	80004966 <argfd>
+    80004c18:	87aa                	mv	a5,a0
+    return -1;
+    80004c1a:	557d                	li	a0,-1
+  if(argfd(0, 0, &f) < 0)
+    80004c1c:	0007ca63          	bltz	a5,80004c30 <sys_write+0x40>
+  return filewrite(f, p, n);
+    80004c20:	fe442603          	lw	a2,-28(s0)
+    80004c24:	fd843583          	ld	a1,-40(s0)
+    80004c28:	fe843503          	ld	a0,-24(s0)
+    80004c2c:	da8ff0ef          	jal	800041d4 <filewrite>
+}
+    80004c30:	70a2                	ld	ra,40(sp)
+    80004c32:	7402                	ld	s0,32(sp)
+    80004c34:	6145                	addi	sp,sp,48
+    80004c36:	8082                	ret
+
+0000000080004c38 <sys_close>:
+{
+    80004c38:	1101                	addi	sp,sp,-32
+    80004c3a:	ec06                	sd	ra,24(sp)
+    80004c3c:	e822                	sd	s0,16(sp)
+    80004c3e:	1000                	addi	s0,sp,32
+  if(argfd(0, &fd, &f) < 0)
+    80004c40:	fe040613          	addi	a2,s0,-32
+    80004c44:	fec40593          	addi	a1,s0,-20
+    80004c48:	4501                	li	a0,0
+    80004c4a:	d1dff0ef          	jal	80004966 <argfd>
+    return -1;
+    80004c4e:	57fd                	li	a5,-1
+  if(argfd(0, &fd, &f) < 0)
+    80004c50:	02054063          	bltz	a0,80004c70 <sys_close+0x38>
+  myproc()->ofile[fd] = 0;
+    80004c54:	c7bfc0ef          	jal	800018ce <myproc>
+    80004c58:	fec42783          	lw	a5,-20(s0)
+    80004c5c:	07e9                	addi	a5,a5,26
+    80004c5e:	078e                	slli	a5,a5,0x3
+    80004c60:	953e                	add	a0,a0,a5
+    80004c62:	00053023          	sd	zero,0(a0)
+  fileclose(f);
+    80004c66:	fe043503          	ld	a0,-32(s0)
+    80004c6a:	b8cff0ef          	jal	80003ff6 <fileclose>
+  return 0;
+    80004c6e:	4781                	li	a5,0
+}
+    80004c70:	853e                	mv	a0,a5
+    80004c72:	60e2                	ld	ra,24(sp)
+    80004c74:	6442                	ld	s0,16(sp)
+    80004c76:	6105                	addi	sp,sp,32
+    80004c78:	8082                	ret
+
+0000000080004c7a <sys_fstat>:
+{
+    80004c7a:	1101                	addi	sp,sp,-32
+    80004c7c:	ec06                	sd	ra,24(sp)
+    80004c7e:	e822                	sd	s0,16(sp)
+    80004c80:	1000                	addi	s0,sp,32
+  argaddr(1, &st);
+    80004c82:	fe040593          	addi	a1,s0,-32
+    80004c86:	4505                	li	a0,1
+    80004c88:	b9ffd0ef          	jal	80002826 <argaddr>
+  if(argfd(0, 0, &f) < 0)
+    80004c8c:	fe840613          	addi	a2,s0,-24
+    80004c90:	4581                	li	a1,0
+    80004c92:	4501                	li	a0,0
+    80004c94:	cd3ff0ef          	jal	80004966 <argfd>
+    80004c98:	87aa                	mv	a5,a0
+    return -1;
+    80004c9a:	557d                	li	a0,-1
+  if(argfd(0, 0, &f) < 0)
+    80004c9c:	0007c863          	bltz	a5,80004cac <sys_fstat+0x32>
+  return filestat(f, st);
+    80004ca0:	fe043583          	ld	a1,-32(s0)
+    80004ca4:	fe843503          	ld	a0,-24(s0)
+    80004ca8:	c10ff0ef          	jal	800040b8 <filestat>
+}
+    80004cac:	60e2                	ld	ra,24(sp)
+    80004cae:	6442                	ld	s0,16(sp)
+    80004cb0:	6105                	addi	sp,sp,32
+    80004cb2:	8082                	ret
+
+0000000080004cb4 <sys_link>:
+{
+    80004cb4:	7169                	addi	sp,sp,-304
+    80004cb6:	f606                	sd	ra,296(sp)
+    80004cb8:	f222                	sd	s0,288(sp)
+    80004cba:	1a00                	addi	s0,sp,304
+  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
+    80004cbc:	08000613          	li	a2,128
+    80004cc0:	ed040593          	addi	a1,s0,-304
+    80004cc4:	4501                	li	a0,0
+    80004cc6:	b7dfd0ef          	jal	80002842 <argstr>
+    return -1;
+    80004cca:	57fd                	li	a5,-1
+  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
+    80004ccc:	0c054e63          	bltz	a0,80004da8 <sys_link+0xf4>
+    80004cd0:	08000613          	li	a2,128
+    80004cd4:	f5040593          	addi	a1,s0,-176
+    80004cd8:	4505                	li	a0,1
+    80004cda:	b69fd0ef          	jal	80002842 <argstr>
+    return -1;
+    80004cde:	57fd                	li	a5,-1
+  if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
+    80004ce0:	0c054463          	bltz	a0,80004da8 <sys_link+0xf4>
+    80004ce4:	ee26                	sd	s1,280(sp)
+  begin_op();
+    80004ce6:	f05fe0ef          	jal	80003bea <begin_op>
+  if((ip = namei(old)) == 0){
+    80004cea:	ed040513          	addi	a0,s0,-304
+    80004cee:	d29fe0ef          	jal	80003a16 <namei>
+    80004cf2:	84aa                	mv	s1,a0
+    80004cf4:	c53d                	beqz	a0,80004d62 <sys_link+0xae>
+  ilock(ip);
+    80004cf6:	d0afe0ef          	jal	80003200 <ilock>
+  if(ip->type == T_DIR){
+    80004cfa:	04449703          	lh	a4,68(s1)
+    80004cfe:	4785                	li	a5,1
+    80004d00:	06f70663          	beq	a4,a5,80004d6c <sys_link+0xb8>
+    80004d04:	ea4a                	sd	s2,272(sp)
+  ip->nlink++;
+    80004d06:	04a4d783          	lhu	a5,74(s1)
+    80004d0a:	2785                	addiw	a5,a5,1
+    80004d0c:	04f49523          	sh	a5,74(s1)
+  iupdate(ip);
+    80004d10:	8526                	mv	a0,s1
+    80004d12:	c3afe0ef          	jal	8000314c <iupdate>
+  iunlock(ip);
+    80004d16:	8526                	mv	a0,s1
+    80004d18:	d96fe0ef          	jal	800032ae <iunlock>
+  if((dp = nameiparent(new, name)) == 0)
+    80004d1c:	fd040593          	addi	a1,s0,-48
+    80004d20:	f5040513          	addi	a0,s0,-176
+    80004d24:	d0dfe0ef          	jal	80003a30 <nameiparent>
+    80004d28:	892a                	mv	s2,a0
+    80004d2a:	cd21                	beqz	a0,80004d82 <sys_link+0xce>
+  ilock(dp);
+    80004d2c:	cd4fe0ef          	jal	80003200 <ilock>
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+    80004d30:	00092703          	lw	a4,0(s2)
+    80004d34:	409c                	lw	a5,0(s1)
+    80004d36:	04f71363          	bne	a4,a5,80004d7c <sys_link+0xc8>
+    80004d3a:	40d0                	lw	a2,4(s1)
+    80004d3c:	fd040593          	addi	a1,s0,-48
+    80004d40:	854a                	mv	a0,s2
+    80004d42:	c3bfe0ef          	jal	8000397c <dirlink>
+    80004d46:	02054b63          	bltz	a0,80004d7c <sys_link+0xc8>
+  iunlockput(dp);
+    80004d4a:	854a                	mv	a0,s2
+    80004d4c:	ebefe0ef          	jal	8000340a <iunlockput>
+  iput(ip);
+    80004d50:	8526                	mv	a0,s1
+    80004d52:	e30fe0ef          	jal	80003382 <iput>
+  end_op();
+    80004d56:	efffe0ef          	jal	80003c54 <end_op>
+  return 0;
+    80004d5a:	4781                	li	a5,0
+    80004d5c:	64f2                	ld	s1,280(sp)
+    80004d5e:	6952                	ld	s2,272(sp)
+    80004d60:	a0a1                	j	80004da8 <sys_link+0xf4>
+    end_op();
+    80004d62:	ef3fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    80004d66:	57fd                	li	a5,-1
+    80004d68:	64f2                	ld	s1,280(sp)
+    80004d6a:	a83d                	j	80004da8 <sys_link+0xf4>
+    iunlockput(ip);
+    80004d6c:	8526                	mv	a0,s1
+    80004d6e:	e9cfe0ef          	jal	8000340a <iunlockput>
+    end_op();
+    80004d72:	ee3fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    80004d76:	57fd                	li	a5,-1
+    80004d78:	64f2                	ld	s1,280(sp)
+    80004d7a:	a03d                	j	80004da8 <sys_link+0xf4>
+    iunlockput(dp);
+    80004d7c:	854a                	mv	a0,s2
+    80004d7e:	e8cfe0ef          	jal	8000340a <iunlockput>
+  ilock(ip);
+    80004d82:	8526                	mv	a0,s1
+    80004d84:	c7cfe0ef          	jal	80003200 <ilock>
+  ip->nlink--;
+    80004d88:	04a4d783          	lhu	a5,74(s1)
+    80004d8c:	37fd                	addiw	a5,a5,-1
+    80004d8e:	04f49523          	sh	a5,74(s1)
+  iupdate(ip);
+    80004d92:	8526                	mv	a0,s1
+    80004d94:	bb8fe0ef          	jal	8000314c <iupdate>
+  iunlockput(ip);
+    80004d98:	8526                	mv	a0,s1
+    80004d9a:	e70fe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    80004d9e:	eb7fe0ef          	jal	80003c54 <end_op>
+  return -1;
+    80004da2:	57fd                	li	a5,-1
+    80004da4:	64f2                	ld	s1,280(sp)
+    80004da6:	6952                	ld	s2,272(sp)
+}
+    80004da8:	853e                	mv	a0,a5
+    80004daa:	70b2                	ld	ra,296(sp)
+    80004dac:	7412                	ld	s0,288(sp)
+    80004dae:	6155                	addi	sp,sp,304
+    80004db0:	8082                	ret
+
+0000000080004db2 <sys_unlink>:
+{
+    80004db2:	7151                	addi	sp,sp,-240
+    80004db4:	f586                	sd	ra,232(sp)
+    80004db6:	f1a2                	sd	s0,224(sp)
+    80004db8:	1980                	addi	s0,sp,240
+  if(argstr(0, path, MAXPATH) < 0)
+    80004dba:	08000613          	li	a2,128
+    80004dbe:	f3040593          	addi	a1,s0,-208
+    80004dc2:	4501                	li	a0,0
+    80004dc4:	a7ffd0ef          	jal	80002842 <argstr>
+    80004dc8:	16054063          	bltz	a0,80004f28 <sys_unlink+0x176>
+    80004dcc:	eda6                	sd	s1,216(sp)
+  begin_op();
+    80004dce:	e1dfe0ef          	jal	80003bea <begin_op>
+  if((dp = nameiparent(path, name)) == 0){
+    80004dd2:	fb040593          	addi	a1,s0,-80
+    80004dd6:	f3040513          	addi	a0,s0,-208
+    80004dda:	c57fe0ef          	jal	80003a30 <nameiparent>
+    80004dde:	84aa                	mv	s1,a0
+    80004de0:	c945                	beqz	a0,80004e90 <sys_unlink+0xde>
+  ilock(dp);
+    80004de2:	c1efe0ef          	jal	80003200 <ilock>
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+    80004de6:	00003597          	auipc	a1,0x3
+    80004dea:	80a58593          	addi	a1,a1,-2038 # 800075f0 <etext+0x5f0>
+    80004dee:	fb040513          	addi	a0,s0,-80
+    80004df2:	9a9fe0ef          	jal	8000379a <namecmp>
+    80004df6:	10050e63          	beqz	a0,80004f12 <sys_unlink+0x160>
+    80004dfa:	00002597          	auipc	a1,0x2
+    80004dfe:	7fe58593          	addi	a1,a1,2046 # 800075f8 <etext+0x5f8>
+    80004e02:	fb040513          	addi	a0,s0,-80
+    80004e06:	995fe0ef          	jal	8000379a <namecmp>
+    80004e0a:	10050463          	beqz	a0,80004f12 <sys_unlink+0x160>
+    80004e0e:	e9ca                	sd	s2,208(sp)
+  if((ip = dirlookup(dp, name, &off)) == 0)
+    80004e10:	f2c40613          	addi	a2,s0,-212
+    80004e14:	fb040593          	addi	a1,s0,-80
+    80004e18:	8526                	mv	a0,s1
+    80004e1a:	997fe0ef          	jal	800037b0 <dirlookup>
+    80004e1e:	892a                	mv	s2,a0
+    80004e20:	0e050863          	beqz	a0,80004f10 <sys_unlink+0x15e>
+  ilock(ip);
+    80004e24:	bdcfe0ef          	jal	80003200 <ilock>
+  if(ip->nlink < 1)
+    80004e28:	04a91783          	lh	a5,74(s2)
+    80004e2c:	06f05763          	blez	a5,80004e9a <sys_unlink+0xe8>
+  if(ip->type == T_DIR && !isdirempty(ip)){
+    80004e30:	04491703          	lh	a4,68(s2)
+    80004e34:	4785                	li	a5,1
+    80004e36:	06f70963          	beq	a4,a5,80004ea8 <sys_unlink+0xf6>
+  memset(&de, 0, sizeof(de));
+    80004e3a:	4641                	li	a2,16
+    80004e3c:	4581                	li	a1,0
+    80004e3e:	fc040513          	addi	a0,s0,-64
+    80004e42:	e61fb0ef          	jal	80000ca2 <memset>
+  if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+    80004e46:	4741                	li	a4,16
+    80004e48:	f2c42683          	lw	a3,-212(s0)
+    80004e4c:	fc040613          	addi	a2,s0,-64
+    80004e50:	4581                	li	a1,0
+    80004e52:	8526                	mv	a0,s1
+    80004e54:	839fe0ef          	jal	8000368c <writei>
+    80004e58:	47c1                	li	a5,16
+    80004e5a:	08f51b63          	bne	a0,a5,80004ef0 <sys_unlink+0x13e>
+  if(ip->type == T_DIR){
+    80004e5e:	04491703          	lh	a4,68(s2)
+    80004e62:	4785                	li	a5,1
+    80004e64:	08f70d63          	beq	a4,a5,80004efe <sys_unlink+0x14c>
+  iunlockput(dp);
+    80004e68:	8526                	mv	a0,s1
+    80004e6a:	da0fe0ef          	jal	8000340a <iunlockput>
+  ip->nlink--;
+    80004e6e:	04a95783          	lhu	a5,74(s2)
+    80004e72:	37fd                	addiw	a5,a5,-1
+    80004e74:	04f91523          	sh	a5,74(s2)
+  iupdate(ip);
+    80004e78:	854a                	mv	a0,s2
+    80004e7a:	ad2fe0ef          	jal	8000314c <iupdate>
+  iunlockput(ip);
+    80004e7e:	854a                	mv	a0,s2
+    80004e80:	d8afe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    80004e84:	dd1fe0ef          	jal	80003c54 <end_op>
+  return 0;
+    80004e88:	4501                	li	a0,0
+    80004e8a:	64ee                	ld	s1,216(sp)
+    80004e8c:	694e                	ld	s2,208(sp)
+    80004e8e:	a849                	j	80004f20 <sys_unlink+0x16e>
+    end_op();
+    80004e90:	dc5fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    80004e94:	557d                	li	a0,-1
+    80004e96:	64ee                	ld	s1,216(sp)
+    80004e98:	a061                	j	80004f20 <sys_unlink+0x16e>
+    80004e9a:	e5ce                	sd	s3,200(sp)
+    panic("unlink: nlink < 1");
+    80004e9c:	00002517          	auipc	a0,0x2
+    80004ea0:	76450513          	addi	a0,a0,1892 # 80007600 <etext+0x600>
+    80004ea4:	93dfb0ef          	jal	800007e0 <panic>
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+    80004ea8:	04c92703          	lw	a4,76(s2)
+    80004eac:	02000793          	li	a5,32
+    80004eb0:	f8e7f5e3          	bgeu	a5,a4,80004e3a <sys_unlink+0x88>
+    80004eb4:	e5ce                	sd	s3,200(sp)
+    80004eb6:	02000993          	li	s3,32
+    if(readi(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
+    80004eba:	4741                	li	a4,16
+    80004ebc:	86ce                	mv	a3,s3
+    80004ebe:	f1840613          	addi	a2,s0,-232
+    80004ec2:	4581                	li	a1,0
+    80004ec4:	854a                	mv	a0,s2
+    80004ec6:	ecafe0ef          	jal	80003590 <readi>
+    80004eca:	47c1                	li	a5,16
+    80004ecc:	00f51c63          	bne	a0,a5,80004ee4 <sys_unlink+0x132>
+    if(de.inum != 0)
+    80004ed0:	f1845783          	lhu	a5,-232(s0)
+    80004ed4:	efa1                	bnez	a5,80004f2c <sys_unlink+0x17a>
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+    80004ed6:	29c1                	addiw	s3,s3,16
+    80004ed8:	04c92783          	lw	a5,76(s2)
+    80004edc:	fcf9efe3          	bltu	s3,a5,80004eba <sys_unlink+0x108>
+    80004ee0:	69ae                	ld	s3,200(sp)
+    80004ee2:	bfa1                	j	80004e3a <sys_unlink+0x88>
+      panic("isdirempty: readi");
+    80004ee4:	00002517          	auipc	a0,0x2
+    80004ee8:	73450513          	addi	a0,a0,1844 # 80007618 <etext+0x618>
+    80004eec:	8f5fb0ef          	jal	800007e0 <panic>
+    80004ef0:	e5ce                	sd	s3,200(sp)
+    panic("unlink: writei");
+    80004ef2:	00002517          	auipc	a0,0x2
+    80004ef6:	73e50513          	addi	a0,a0,1854 # 80007630 <etext+0x630>
+    80004efa:	8e7fb0ef          	jal	800007e0 <panic>
+    dp->nlink--;
+    80004efe:	04a4d783          	lhu	a5,74(s1)
+    80004f02:	37fd                	addiw	a5,a5,-1
+    80004f04:	04f49523          	sh	a5,74(s1)
+    iupdate(dp);
+    80004f08:	8526                	mv	a0,s1
+    80004f0a:	a42fe0ef          	jal	8000314c <iupdate>
+    80004f0e:	bfa9                	j	80004e68 <sys_unlink+0xb6>
+    80004f10:	694e                	ld	s2,208(sp)
+  iunlockput(dp);
+    80004f12:	8526                	mv	a0,s1
+    80004f14:	cf6fe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    80004f18:	d3dfe0ef          	jal	80003c54 <end_op>
+  return -1;
+    80004f1c:	557d                	li	a0,-1
+    80004f1e:	64ee                	ld	s1,216(sp)
+}
+    80004f20:	70ae                	ld	ra,232(sp)
+    80004f22:	740e                	ld	s0,224(sp)
+    80004f24:	616d                	addi	sp,sp,240
+    80004f26:	8082                	ret
+    return -1;
+    80004f28:	557d                	li	a0,-1
+    80004f2a:	bfdd                	j	80004f20 <sys_unlink+0x16e>
+    iunlockput(ip);
+    80004f2c:	854a                	mv	a0,s2
+    80004f2e:	cdcfe0ef          	jal	8000340a <iunlockput>
+    goto bad;
+    80004f32:	694e                	ld	s2,208(sp)
+    80004f34:	69ae                	ld	s3,200(sp)
+    80004f36:	bff1                	j	80004f12 <sys_unlink+0x160>
+
+0000000080004f38 <sys_open>:
+
+uint64
+sys_open(void)
+{
+    80004f38:	7131                	addi	sp,sp,-192
+    80004f3a:	fd06                	sd	ra,184(sp)
+    80004f3c:	f922                	sd	s0,176(sp)
+    80004f3e:	0180                	addi	s0,sp,192
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+  int n;
+
+  argint(1, &omode);
+    80004f40:	f4c40593          	addi	a1,s0,-180
+    80004f44:	4505                	li	a0,1
+    80004f46:	8c5fd0ef          	jal	8000280a <argint>
+  if((n = argstr(0, path, MAXPATH)) < 0)
+    80004f4a:	08000613          	li	a2,128
+    80004f4e:	f5040593          	addi	a1,s0,-176
+    80004f52:	4501                	li	a0,0
+    80004f54:	8effd0ef          	jal	80002842 <argstr>
+    80004f58:	87aa                	mv	a5,a0
+    return -1;
+    80004f5a:	557d                	li	a0,-1
+  if((n = argstr(0, path, MAXPATH)) < 0)
+    80004f5c:	0a07c263          	bltz	a5,80005000 <sys_open+0xc8>
+    80004f60:	f526                	sd	s1,168(sp)
+
+  begin_op();
+    80004f62:	c89fe0ef          	jal	80003bea <begin_op>
+
+  if(omode & O_CREATE){
+    80004f66:	f4c42783          	lw	a5,-180(s0)
+    80004f6a:	2007f793          	andi	a5,a5,512
+    80004f6e:	c3d5                	beqz	a5,80005012 <sys_open+0xda>
+    ip = create(path, T_FILE, 0, 0);
+    80004f70:	4681                	li	a3,0
+    80004f72:	4601                	li	a2,0
+    80004f74:	4589                	li	a1,2
+    80004f76:	f5040513          	addi	a0,s0,-176
+    80004f7a:	a83ff0ef          	jal	800049fc <create>
+    80004f7e:	84aa                	mv	s1,a0
+    if(ip == 0){
+    80004f80:	c541                	beqz	a0,80005008 <sys_open+0xd0>
+      end_op();
+      return -1;
+    }
+  }
+
+  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
+    80004f82:	04449703          	lh	a4,68(s1)
+    80004f86:	478d                	li	a5,3
+    80004f88:	00f71763          	bne	a4,a5,80004f96 <sys_open+0x5e>
+    80004f8c:	0464d703          	lhu	a4,70(s1)
+    80004f90:	47a5                	li	a5,9
+    80004f92:	0ae7ed63          	bltu	a5,a4,8000504c <sys_open+0x114>
+    80004f96:	f14a                	sd	s2,160(sp)
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+    80004f98:	fbbfe0ef          	jal	80003f52 <filealloc>
+    80004f9c:	892a                	mv	s2,a0
+    80004f9e:	c179                	beqz	a0,80005064 <sys_open+0x12c>
+    80004fa0:	ed4e                	sd	s3,152(sp)
+    80004fa2:	a1dff0ef          	jal	800049be <fdalloc>
+    80004fa6:	89aa                	mv	s3,a0
+    80004fa8:	0a054a63          	bltz	a0,8000505c <sys_open+0x124>
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  if(ip->type == T_DEVICE){
+    80004fac:	04449703          	lh	a4,68(s1)
+    80004fb0:	478d                	li	a5,3
+    80004fb2:	0cf70263          	beq	a4,a5,80005076 <sys_open+0x13e>
+    f->type = FD_DEVICE;
+    f->major = ip->major;
+  } else {
+    f->type = FD_INODE;
+    80004fb6:	4789                	li	a5,2
+    80004fb8:	00f92023          	sw	a5,0(s2)
+    f->off = 0;
+    80004fbc:	02092023          	sw	zero,32(s2)
+  }
+  f->ip = ip;
+    80004fc0:	00993c23          	sd	s1,24(s2)
+  f->readable = !(omode & O_WRONLY);
+    80004fc4:	f4c42783          	lw	a5,-180(s0)
+    80004fc8:	0017c713          	xori	a4,a5,1
+    80004fcc:	8b05                	andi	a4,a4,1
+    80004fce:	00e90423          	sb	a4,8(s2)
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+    80004fd2:	0037f713          	andi	a4,a5,3
+    80004fd6:	00e03733          	snez	a4,a4
+    80004fda:	00e904a3          	sb	a4,9(s2)
+
+  if((omode & O_TRUNC) && ip->type == T_FILE){
+    80004fde:	4007f793          	andi	a5,a5,1024
+    80004fe2:	c791                	beqz	a5,80004fee <sys_open+0xb6>
+    80004fe4:	04449703          	lh	a4,68(s1)
+    80004fe8:	4789                	li	a5,2
+    80004fea:	08f70d63          	beq	a4,a5,80005084 <sys_open+0x14c>
+    itrunc(ip);
+  }
+
+  iunlock(ip);
+    80004fee:	8526                	mv	a0,s1
+    80004ff0:	abefe0ef          	jal	800032ae <iunlock>
+  end_op();
+    80004ff4:	c61fe0ef          	jal	80003c54 <end_op>
+
+  return fd;
+    80004ff8:	854e                	mv	a0,s3
+    80004ffa:	74aa                	ld	s1,168(sp)
+    80004ffc:	790a                	ld	s2,160(sp)
+    80004ffe:	69ea                	ld	s3,152(sp)
+}
+    80005000:	70ea                	ld	ra,184(sp)
+    80005002:	744a                	ld	s0,176(sp)
+    80005004:	6129                	addi	sp,sp,192
+    80005006:	8082                	ret
+      end_op();
+    80005008:	c4dfe0ef          	jal	80003c54 <end_op>
+      return -1;
+    8000500c:	557d                	li	a0,-1
+    8000500e:	74aa                	ld	s1,168(sp)
+    80005010:	bfc5                	j	80005000 <sys_open+0xc8>
+    if((ip = namei(path)) == 0){
+    80005012:	f5040513          	addi	a0,s0,-176
+    80005016:	a01fe0ef          	jal	80003a16 <namei>
+    8000501a:	84aa                	mv	s1,a0
+    8000501c:	c11d                	beqz	a0,80005042 <sys_open+0x10a>
+    ilock(ip);
+    8000501e:	9e2fe0ef          	jal	80003200 <ilock>
+    if(ip->type == T_DIR && omode != O_RDONLY){
+    80005022:	04449703          	lh	a4,68(s1)
+    80005026:	4785                	li	a5,1
+    80005028:	f4f71de3          	bne	a4,a5,80004f82 <sys_open+0x4a>
+    8000502c:	f4c42783          	lw	a5,-180(s0)
+    80005030:	d3bd                	beqz	a5,80004f96 <sys_open+0x5e>
+      iunlockput(ip);
+    80005032:	8526                	mv	a0,s1
+    80005034:	bd6fe0ef          	jal	8000340a <iunlockput>
+      end_op();
+    80005038:	c1dfe0ef          	jal	80003c54 <end_op>
+      return -1;
+    8000503c:	557d                	li	a0,-1
+    8000503e:	74aa                	ld	s1,168(sp)
+    80005040:	b7c1                	j	80005000 <sys_open+0xc8>
+      end_op();
+    80005042:	c13fe0ef          	jal	80003c54 <end_op>
+      return -1;
+    80005046:	557d                	li	a0,-1
+    80005048:	74aa                	ld	s1,168(sp)
+    8000504a:	bf5d                	j	80005000 <sys_open+0xc8>
+    iunlockput(ip);
+    8000504c:	8526                	mv	a0,s1
+    8000504e:	bbcfe0ef          	jal	8000340a <iunlockput>
+    end_op();
+    80005052:	c03fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    80005056:	557d                	li	a0,-1
+    80005058:	74aa                	ld	s1,168(sp)
+    8000505a:	b75d                	j	80005000 <sys_open+0xc8>
+      fileclose(f);
+    8000505c:	854a                	mv	a0,s2
+    8000505e:	f99fe0ef          	jal	80003ff6 <fileclose>
+    80005062:	69ea                	ld	s3,152(sp)
+    iunlockput(ip);
+    80005064:	8526                	mv	a0,s1
+    80005066:	ba4fe0ef          	jal	8000340a <iunlockput>
+    end_op();
+    8000506a:	bebfe0ef          	jal	80003c54 <end_op>
+    return -1;
+    8000506e:	557d                	li	a0,-1
+    80005070:	74aa                	ld	s1,168(sp)
+    80005072:	790a                	ld	s2,160(sp)
+    80005074:	b771                	j	80005000 <sys_open+0xc8>
+    f->type = FD_DEVICE;
+    80005076:	00f92023          	sw	a5,0(s2)
+    f->major = ip->major;
+    8000507a:	04649783          	lh	a5,70(s1)
+    8000507e:	02f91223          	sh	a5,36(s2)
+    80005082:	bf3d                	j	80004fc0 <sys_open+0x88>
+    itrunc(ip);
+    80005084:	8526                	mv	a0,s1
+    80005086:	a68fe0ef          	jal	800032ee <itrunc>
+    8000508a:	b795                	j	80004fee <sys_open+0xb6>
+
+000000008000508c <sys_mkdir>:
+
+uint64
+sys_mkdir(void)
+{
+    8000508c:	7175                	addi	sp,sp,-144
+    8000508e:	e506                	sd	ra,136(sp)
+    80005090:	e122                	sd	s0,128(sp)
+    80005092:	0900                	addi	s0,sp,144
+  char path[MAXPATH];
+  struct inode *ip;
+
+  begin_op();
+    80005094:	b57fe0ef          	jal	80003bea <begin_op>
+  if(argstr(0, path, MAXPATH) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+    80005098:	08000613          	li	a2,128
+    8000509c:	f7040593          	addi	a1,s0,-144
+    800050a0:	4501                	li	a0,0
+    800050a2:	fa0fd0ef          	jal	80002842 <argstr>
+    800050a6:	02054363          	bltz	a0,800050cc <sys_mkdir+0x40>
+    800050aa:	4681                	li	a3,0
+    800050ac:	4601                	li	a2,0
+    800050ae:	4585                	li	a1,1
+    800050b0:	f7040513          	addi	a0,s0,-144
+    800050b4:	949ff0ef          	jal	800049fc <create>
+    800050b8:	c911                	beqz	a0,800050cc <sys_mkdir+0x40>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+    800050ba:	b50fe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    800050be:	b97fe0ef          	jal	80003c54 <end_op>
+  return 0;
+    800050c2:	4501                	li	a0,0
+}
+    800050c4:	60aa                	ld	ra,136(sp)
+    800050c6:	640a                	ld	s0,128(sp)
+    800050c8:	6149                	addi	sp,sp,144
+    800050ca:	8082                	ret
+    end_op();
+    800050cc:	b89fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    800050d0:	557d                	li	a0,-1
+    800050d2:	bfcd                	j	800050c4 <sys_mkdir+0x38>
+
+00000000800050d4 <sys_mknod>:
+
+uint64
+sys_mknod(void)
+{
+    800050d4:	7135                	addi	sp,sp,-160
+    800050d6:	ed06                	sd	ra,152(sp)
+    800050d8:	e922                	sd	s0,144(sp)
+    800050da:	1100                	addi	s0,sp,160
+  struct inode *ip;
+  char path[MAXPATH];
+  int major, minor;
+
+  begin_op();
+    800050dc:	b0ffe0ef          	jal	80003bea <begin_op>
+  argint(1, &major);
+    800050e0:	f6c40593          	addi	a1,s0,-148
+    800050e4:	4505                	li	a0,1
+    800050e6:	f24fd0ef          	jal	8000280a <argint>
+  argint(2, &minor);
+    800050ea:	f6840593          	addi	a1,s0,-152
+    800050ee:	4509                	li	a0,2
+    800050f0:	f1afd0ef          	jal	8000280a <argint>
+  if((argstr(0, path, MAXPATH)) < 0 ||
+    800050f4:	08000613          	li	a2,128
+    800050f8:	f7040593          	addi	a1,s0,-144
+    800050fc:	4501                	li	a0,0
+    800050fe:	f44fd0ef          	jal	80002842 <argstr>
+    80005102:	02054563          	bltz	a0,8000512c <sys_mknod+0x58>
+     (ip = create(path, T_DEVICE, major, minor)) == 0){
+    80005106:	f6841683          	lh	a3,-152(s0)
+    8000510a:	f6c41603          	lh	a2,-148(s0)
+    8000510e:	458d                	li	a1,3
+    80005110:	f7040513          	addi	a0,s0,-144
+    80005114:	8e9ff0ef          	jal	800049fc <create>
+  if((argstr(0, path, MAXPATH)) < 0 ||
+    80005118:	c911                	beqz	a0,8000512c <sys_mknod+0x58>
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+    8000511a:	af0fe0ef          	jal	8000340a <iunlockput>
+  end_op();
+    8000511e:	b37fe0ef          	jal	80003c54 <end_op>
+  return 0;
+    80005122:	4501                	li	a0,0
+}
+    80005124:	60ea                	ld	ra,152(sp)
+    80005126:	644a                	ld	s0,144(sp)
+    80005128:	610d                	addi	sp,sp,160
+    8000512a:	8082                	ret
+    end_op();
+    8000512c:	b29fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    80005130:	557d                	li	a0,-1
+    80005132:	bfcd                	j	80005124 <sys_mknod+0x50>
+
+0000000080005134 <sys_chdir>:
+
+uint64
+sys_chdir(void)
+{
+    80005134:	7135                	addi	sp,sp,-160
+    80005136:	ed06                	sd	ra,152(sp)
+    80005138:	e922                	sd	s0,144(sp)
+    8000513a:	e14a                	sd	s2,128(sp)
+    8000513c:	1100                	addi	s0,sp,160
+  char path[MAXPATH];
+  struct inode *ip;
+  struct proc *p = myproc();
+    8000513e:	f90fc0ef          	jal	800018ce <myproc>
+    80005142:	892a                	mv	s2,a0
+  
+  begin_op();
+    80005144:	aa7fe0ef          	jal	80003bea <begin_op>
+  if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){
+    80005148:	08000613          	li	a2,128
+    8000514c:	f6040593          	addi	a1,s0,-160
+    80005150:	4501                	li	a0,0
+    80005152:	ef0fd0ef          	jal	80002842 <argstr>
+    80005156:	04054363          	bltz	a0,8000519c <sys_chdir+0x68>
+    8000515a:	e526                	sd	s1,136(sp)
+    8000515c:	f6040513          	addi	a0,s0,-160
+    80005160:	8b7fe0ef          	jal	80003a16 <namei>
+    80005164:	84aa                	mv	s1,a0
+    80005166:	c915                	beqz	a0,8000519a <sys_chdir+0x66>
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+    80005168:	898fe0ef          	jal	80003200 <ilock>
+  if(ip->type != T_DIR){
+    8000516c:	04449703          	lh	a4,68(s1)
+    80005170:	4785                	li	a5,1
+    80005172:	02f71963          	bne	a4,a5,800051a4 <sys_chdir+0x70>
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+    80005176:	8526                	mv	a0,s1
+    80005178:	936fe0ef          	jal	800032ae <iunlock>
+  iput(p->cwd);
+    8000517c:	15093503          	ld	a0,336(s2)
+    80005180:	a02fe0ef          	jal	80003382 <iput>
+  end_op();
+    80005184:	ad1fe0ef          	jal	80003c54 <end_op>
+  p->cwd = ip;
+    80005188:	14993823          	sd	s1,336(s2)
+  return 0;
+    8000518c:	4501                	li	a0,0
+    8000518e:	64aa                	ld	s1,136(sp)
+}
+    80005190:	60ea                	ld	ra,152(sp)
+    80005192:	644a                	ld	s0,144(sp)
+    80005194:	690a                	ld	s2,128(sp)
+    80005196:	610d                	addi	sp,sp,160
+    80005198:	8082                	ret
+    8000519a:	64aa                	ld	s1,136(sp)
+    end_op();
+    8000519c:	ab9fe0ef          	jal	80003c54 <end_op>
+    return -1;
+    800051a0:	557d                	li	a0,-1
+    800051a2:	b7fd                	j	80005190 <sys_chdir+0x5c>
+    iunlockput(ip);
+    800051a4:	8526                	mv	a0,s1
+    800051a6:	a64fe0ef          	jal	8000340a <iunlockput>
+    end_op();
+    800051aa:	aabfe0ef          	jal	80003c54 <end_op>
+    return -1;
+    800051ae:	557d                	li	a0,-1
+    800051b0:	64aa                	ld	s1,136(sp)
+    800051b2:	bff9                	j	80005190 <sys_chdir+0x5c>
+
+00000000800051b4 <sys_exec>:
+
+uint64
+sys_exec(void)
+{
+    800051b4:	7121                	addi	sp,sp,-448
+    800051b6:	ff06                	sd	ra,440(sp)
+    800051b8:	fb22                	sd	s0,432(sp)
+    800051ba:	0380                	addi	s0,sp,448
+  char path[MAXPATH], *argv[MAXARG];
+  int i;
+  uint64 uargv, uarg;
+
+  argaddr(1, &uargv);
+    800051bc:	e4840593          	addi	a1,s0,-440
+    800051c0:	4505                	li	a0,1
+    800051c2:	e64fd0ef          	jal	80002826 <argaddr>
+  if(argstr(0, path, MAXPATH) < 0) {
+    800051c6:	08000613          	li	a2,128
+    800051ca:	f5040593          	addi	a1,s0,-176
+    800051ce:	4501                	li	a0,0
+    800051d0:	e72fd0ef          	jal	80002842 <argstr>
+    800051d4:	87aa                	mv	a5,a0
+    return -1;
+    800051d6:	557d                	li	a0,-1
+  if(argstr(0, path, MAXPATH) < 0) {
+    800051d8:	0c07c463          	bltz	a5,800052a0 <sys_exec+0xec>
+    800051dc:	f726                	sd	s1,424(sp)
+    800051de:	f34a                	sd	s2,416(sp)
+    800051e0:	ef4e                	sd	s3,408(sp)
+    800051e2:	eb52                	sd	s4,400(sp)
+  }
+  memset(argv, 0, sizeof(argv));
+    800051e4:	10000613          	li	a2,256
+    800051e8:	4581                	li	a1,0
+    800051ea:	e5040513          	addi	a0,s0,-432
+    800051ee:	ab5fb0ef          	jal	80000ca2 <memset>
+  for(i=0;; i++){
+    if(i >= NELEM(argv)){
+    800051f2:	e5040493          	addi	s1,s0,-432
+  memset(argv, 0, sizeof(argv));
+    800051f6:	89a6                	mv	s3,s1
+    800051f8:	4901                	li	s2,0
+    if(i >= NELEM(argv)){
+    800051fa:	02000a13          	li	s4,32
+      goto bad;
+    }
+    if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
+    800051fe:	00391513          	slli	a0,s2,0x3
+    80005202:	e4040593          	addi	a1,s0,-448
+    80005206:	e4843783          	ld	a5,-440(s0)
+    8000520a:	953e                	add	a0,a0,a5
+    8000520c:	d74fd0ef          	jal	80002780 <fetchaddr>
+    80005210:	02054663          	bltz	a0,8000523c <sys_exec+0x88>
+      goto bad;
+    }
+    if(uarg == 0){
+    80005214:	e4043783          	ld	a5,-448(s0)
+    80005218:	c3a9                	beqz	a5,8000525a <sys_exec+0xa6>
+      argv[i] = 0;
+      break;
+    }
+    argv[i] = kalloc();
+    8000521a:	8e5fb0ef          	jal	80000afe <kalloc>
+    8000521e:	85aa                	mv	a1,a0
+    80005220:	00a9b023          	sd	a0,0(s3)
+    if(argv[i] == 0)
+    80005224:	cd01                	beqz	a0,8000523c <sys_exec+0x88>
+      goto bad;
+    if(fetchstr(uarg, argv[i], PGSIZE) < 0)
+    80005226:	6605                	lui	a2,0x1
+    80005228:	e4043503          	ld	a0,-448(s0)
+    8000522c:	d9efd0ef          	jal	800027ca <fetchstr>
+    80005230:	00054663          	bltz	a0,8000523c <sys_exec+0x88>
+    if(i >= NELEM(argv)){
+    80005234:	0905                	addi	s2,s2,1
+    80005236:	09a1                	addi	s3,s3,8
+    80005238:	fd4913e3          	bne	s2,s4,800051fe <sys_exec+0x4a>
+    kfree(argv[i]);
+
+  return ret;
+
+ bad:
+  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
+    8000523c:	f5040913          	addi	s2,s0,-176
+    80005240:	6088                	ld	a0,0(s1)
+    80005242:	c931                	beqz	a0,80005296 <sys_exec+0xe2>
+    kfree(argv[i]);
+    80005244:	fd8fb0ef          	jal	80000a1c <kfree>
+  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
+    80005248:	04a1                	addi	s1,s1,8
+    8000524a:	ff249be3          	bne	s1,s2,80005240 <sys_exec+0x8c>
+  return -1;
+    8000524e:	557d                	li	a0,-1
+    80005250:	74ba                	ld	s1,424(sp)
+    80005252:	791a                	ld	s2,416(sp)
+    80005254:	69fa                	ld	s3,408(sp)
+    80005256:	6a5a                	ld	s4,400(sp)
+    80005258:	a0a1                	j	800052a0 <sys_exec+0xec>
+      argv[i] = 0;
+    8000525a:	0009079b          	sext.w	a5,s2
+    8000525e:	078e                	slli	a5,a5,0x3
+    80005260:	fd078793          	addi	a5,a5,-48
+    80005264:	97a2                	add	a5,a5,s0
+    80005266:	e807b023          	sd	zero,-384(a5)
+  int ret = kexec(path, argv);
+    8000526a:	e5040593          	addi	a1,s0,-432
+    8000526e:	f5040513          	addi	a0,s0,-176
+    80005272:	b82ff0ef          	jal	800045f4 <kexec>
+    80005276:	892a                	mv	s2,a0
+  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
+    80005278:	f5040993          	addi	s3,s0,-176
+    8000527c:	6088                	ld	a0,0(s1)
+    8000527e:	c511                	beqz	a0,8000528a <sys_exec+0xd6>
+    kfree(argv[i]);
+    80005280:	f9cfb0ef          	jal	80000a1c <kfree>
+  for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
+    80005284:	04a1                	addi	s1,s1,8
+    80005286:	ff349be3          	bne	s1,s3,8000527c <sys_exec+0xc8>
+  return ret;
+    8000528a:	854a                	mv	a0,s2
+    8000528c:	74ba                	ld	s1,424(sp)
+    8000528e:	791a                	ld	s2,416(sp)
+    80005290:	69fa                	ld	s3,408(sp)
+    80005292:	6a5a                	ld	s4,400(sp)
+    80005294:	a031                	j	800052a0 <sys_exec+0xec>
+  return -1;
+    80005296:	557d                	li	a0,-1
+    80005298:	74ba                	ld	s1,424(sp)
+    8000529a:	791a                	ld	s2,416(sp)
+    8000529c:	69fa                	ld	s3,408(sp)
+    8000529e:	6a5a                	ld	s4,400(sp)
+}
+    800052a0:	70fa                	ld	ra,440(sp)
+    800052a2:	745a                	ld	s0,432(sp)
+    800052a4:	6139                	addi	sp,sp,448
+    800052a6:	8082                	ret
+
+00000000800052a8 <sys_pipe>:
+
+uint64
+sys_pipe(void)
+{
+    800052a8:	7139                	addi	sp,sp,-64
+    800052aa:	fc06                	sd	ra,56(sp)
+    800052ac:	f822                	sd	s0,48(sp)
+    800052ae:	f426                	sd	s1,40(sp)
+    800052b0:	0080                	addi	s0,sp,64
+  uint64 fdarray; // user pointer to array of two integers
+  struct file *rf, *wf;
+  int fd0, fd1;
+  struct proc *p = myproc();
+    800052b2:	e1cfc0ef          	jal	800018ce <myproc>
+    800052b6:	84aa                	mv	s1,a0
+
+  argaddr(0, &fdarray);
+    800052b8:	fd840593          	addi	a1,s0,-40
+    800052bc:	4501                	li	a0,0
+    800052be:	d68fd0ef          	jal	80002826 <argaddr>
+  if(pipealloc(&rf, &wf) < 0)
+    800052c2:	fc840593          	addi	a1,s0,-56
+    800052c6:	fd040513          	addi	a0,s0,-48
+    800052ca:	836ff0ef          	jal	80004300 <pipealloc>
+    return -1;
+    800052ce:	57fd                	li	a5,-1
+  if(pipealloc(&rf, &wf) < 0)
+    800052d0:	0a054463          	bltz	a0,80005378 <sys_pipe+0xd0>
+  fd0 = -1;
+    800052d4:	fcf42223          	sw	a5,-60(s0)
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+    800052d8:	fd043503          	ld	a0,-48(s0)
+    800052dc:	ee2ff0ef          	jal	800049be <fdalloc>
+    800052e0:	fca42223          	sw	a0,-60(s0)
+    800052e4:	08054163          	bltz	a0,80005366 <sys_pipe+0xbe>
+    800052e8:	fc843503          	ld	a0,-56(s0)
+    800052ec:	ed2ff0ef          	jal	800049be <fdalloc>
+    800052f0:	fca42023          	sw	a0,-64(s0)
+    800052f4:	06054063          	bltz	a0,80005354 <sys_pipe+0xac>
+      p->ofile[fd0] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
+    800052f8:	4691                	li	a3,4
+    800052fa:	fc440613          	addi	a2,s0,-60
+    800052fe:	fd843583          	ld	a1,-40(s0)
+    80005302:	68a8                	ld	a0,80(s1)
+    80005304:	adefc0ef          	jal	800015e2 <copyout>
+    80005308:	00054e63          	bltz	a0,80005324 <sys_pipe+0x7c>
+     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
+    8000530c:	4691                	li	a3,4
+    8000530e:	fc040613          	addi	a2,s0,-64
+    80005312:	fd843583          	ld	a1,-40(s0)
+    80005316:	0591                	addi	a1,a1,4
+    80005318:	68a8                	ld	a0,80(s1)
+    8000531a:	ac8fc0ef          	jal	800015e2 <copyout>
+    p->ofile[fd1] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  return 0;
+    8000531e:	4781                	li	a5,0
+  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
+    80005320:	04055c63          	bgez	a0,80005378 <sys_pipe+0xd0>
+    p->ofile[fd0] = 0;
+    80005324:	fc442783          	lw	a5,-60(s0)
+    80005328:	07e9                	addi	a5,a5,26
+    8000532a:	078e                	slli	a5,a5,0x3
+    8000532c:	97a6                	add	a5,a5,s1
+    8000532e:	0007b023          	sd	zero,0(a5)
+    p->ofile[fd1] = 0;
+    80005332:	fc042783          	lw	a5,-64(s0)
+    80005336:	07e9                	addi	a5,a5,26
+    80005338:	078e                	slli	a5,a5,0x3
+    8000533a:	94be                	add	s1,s1,a5
+    8000533c:	0004b023          	sd	zero,0(s1)
+    fileclose(rf);
+    80005340:	fd043503          	ld	a0,-48(s0)
+    80005344:	cb3fe0ef          	jal	80003ff6 <fileclose>
+    fileclose(wf);
+    80005348:	fc843503          	ld	a0,-56(s0)
+    8000534c:	cabfe0ef          	jal	80003ff6 <fileclose>
+    return -1;
+    80005350:	57fd                	li	a5,-1
+    80005352:	a01d                	j	80005378 <sys_pipe+0xd0>
+    if(fd0 >= 0)
+    80005354:	fc442783          	lw	a5,-60(s0)
+    80005358:	0007c763          	bltz	a5,80005366 <sys_pipe+0xbe>
+      p->ofile[fd0] = 0;
+    8000535c:	07e9                	addi	a5,a5,26
+    8000535e:	078e                	slli	a5,a5,0x3
+    80005360:	97a6                	add	a5,a5,s1
+    80005362:	0007b023          	sd	zero,0(a5)
+    fileclose(rf);
+    80005366:	fd043503          	ld	a0,-48(s0)
+    8000536a:	c8dfe0ef          	jal	80003ff6 <fileclose>
+    fileclose(wf);
+    8000536e:	fc843503          	ld	a0,-56(s0)
+    80005372:	c85fe0ef          	jal	80003ff6 <fileclose>
+    return -1;
+    80005376:	57fd                	li	a5,-1
+}
+    80005378:	853e                	mv	a0,a5
+    8000537a:	70e2                	ld	ra,56(sp)
+    8000537c:	7442                	ld	s0,48(sp)
+    8000537e:	74a2                	ld	s1,40(sp)
+    80005380:	6121                	addi	sp,sp,64
+    80005382:	8082                	ret
+	...
+
+0000000080005390 <kernelvec>:
+.globl kerneltrap
+.globl kernelvec
+.align 4
+kernelvec:
+        # make room to save registers.
+        addi sp, sp, -256
+    80005390:	7111                	addi	sp,sp,-256
+
+        # save caller-saved registers.
+        sd ra, 0(sp)
+    80005392:	e006                	sd	ra,0(sp)
+        # sd sp, 8(sp)
+        sd gp, 16(sp)
+    80005394:	e80e                	sd	gp,16(sp)
+        sd tp, 24(sp)
+    80005396:	ec12                	sd	tp,24(sp)
+        sd t0, 32(sp)
+    80005398:	f016                	sd	t0,32(sp)
+        sd t1, 40(sp)
+    8000539a:	f41a                	sd	t1,40(sp)
+        sd t2, 48(sp)
+    8000539c:	f81e                	sd	t2,48(sp)
+        sd a0, 72(sp)
+    8000539e:	e4aa                	sd	a0,72(sp)
+        sd a1, 80(sp)
+    800053a0:	e8ae                	sd	a1,80(sp)
+        sd a2, 88(sp)
+    800053a2:	ecb2                	sd	a2,88(sp)
+        sd a3, 96(sp)
+    800053a4:	f0b6                	sd	a3,96(sp)
+        sd a4, 104(sp)
+    800053a6:	f4ba                	sd	a4,104(sp)
+        sd a5, 112(sp)
+    800053a8:	f8be                	sd	a5,112(sp)
+        sd a6, 120(sp)
+    800053aa:	fcc2                	sd	a6,120(sp)
+        sd a7, 128(sp)
+    800053ac:	e146                	sd	a7,128(sp)
+        sd t3, 216(sp)
+    800053ae:	edf2                	sd	t3,216(sp)
+        sd t4, 224(sp)
+    800053b0:	f1f6                	sd	t4,224(sp)
+        sd t5, 232(sp)
+    800053b2:	f5fa                	sd	t5,232(sp)
+        sd t6, 240(sp)
+    800053b4:	f9fe                	sd	t6,240(sp)
+
+        # call the C trap handler in trap.c
+        call kerneltrap
+    800053b6:	adafd0ef          	jal	80002690 <kerneltrap>
+
+        # restore registers.
+        ld ra, 0(sp)
+    800053ba:	6082                	ld	ra,0(sp)
+        # ld sp, 8(sp)
+        ld gp, 16(sp)
+    800053bc:	61c2                	ld	gp,16(sp)
+        # not tp (contains hartid), in case we moved CPUs
+        ld t0, 32(sp)
+    800053be:	7282                	ld	t0,32(sp)
+        ld t1, 40(sp)
+    800053c0:	7322                	ld	t1,40(sp)
+        ld t2, 48(sp)
+    800053c2:	73c2                	ld	t2,48(sp)
+        ld a0, 72(sp)
+    800053c4:	6526                	ld	a0,72(sp)
+        ld a1, 80(sp)
+    800053c6:	65c6                	ld	a1,80(sp)
+        ld a2, 88(sp)
+    800053c8:	6666                	ld	a2,88(sp)
+        ld a3, 96(sp)
+    800053ca:	7686                	ld	a3,96(sp)
+        ld a4, 104(sp)
+    800053cc:	7726                	ld	a4,104(sp)
+        ld a5, 112(sp)
+    800053ce:	77c6                	ld	a5,112(sp)
+        ld a6, 120(sp)
+    800053d0:	7866                	ld	a6,120(sp)
+        ld a7, 128(sp)
+    800053d2:	688a                	ld	a7,128(sp)
+        ld t3, 216(sp)
+    800053d4:	6e6e                	ld	t3,216(sp)
+        ld t4, 224(sp)
+    800053d6:	7e8e                	ld	t4,224(sp)
+        ld t5, 232(sp)
+    800053d8:	7f2e                	ld	t5,232(sp)
+        ld t6, 240(sp)
+    800053da:	7fce                	ld	t6,240(sp)
+
+        addi sp, sp, 256
+    800053dc:	6111                	addi	sp,sp,256
+
+        # return to whatever we were doing in the kernel.
+        sret
+    800053de:	10200073          	sret
+	...
+
+00000000800053ee <plicinit>:
+// the riscv Platform Level Interrupt Controller (PLIC).
+//
+
+void
+plicinit(void)
+{
+    800053ee:	1141                	addi	sp,sp,-16
+    800053f0:	e422                	sd	s0,8(sp)
+    800053f2:	0800                	addi	s0,sp,16
+  // set desired IRQ priorities non-zero (otherwise disabled).
+  *(uint32*)(PLIC + UART0_IRQ*4) = 1;
+    800053f4:	0c0007b7          	lui	a5,0xc000
+    800053f8:	4705                	li	a4,1
+    800053fa:	d798                	sw	a4,40(a5)
+  *(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
+    800053fc:	0c0007b7          	lui	a5,0xc000
+    80005400:	c3d8                	sw	a4,4(a5)
+}
+    80005402:	6422                	ld	s0,8(sp)
+    80005404:	0141                	addi	sp,sp,16
+    80005406:	8082                	ret
+
+0000000080005408 <plicinithart>:
+
+void
+plicinithart(void)
+{
+    80005408:	1141                	addi	sp,sp,-16
+    8000540a:	e406                	sd	ra,8(sp)
+    8000540c:	e022                	sd	s0,0(sp)
+    8000540e:	0800                	addi	s0,sp,16
+  int hart = cpuid();
+    80005410:	c92fc0ef          	jal	800018a2 <cpuid>
+  
+  // set enable bits for this hart's S-mode
+  // for the uart and virtio disk.
+  *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);
+    80005414:	0085171b          	slliw	a4,a0,0x8
+    80005418:	0c0027b7          	lui	a5,0xc002
+    8000541c:	97ba                	add	a5,a5,a4
+    8000541e:	40200713          	li	a4,1026
+    80005422:	08e7a023          	sw	a4,128(a5) # c002080 <_entry-0x73ffdf80>
+
+  // set this hart's S-mode priority threshold to 0.
+  *(uint32*)PLIC_SPRIORITY(hart) = 0;
+    80005426:	00d5151b          	slliw	a0,a0,0xd
+    8000542a:	0c2017b7          	lui	a5,0xc201
+    8000542e:	97aa                	add	a5,a5,a0
+    80005430:	0007a023          	sw	zero,0(a5) # c201000 <_entry-0x73dff000>
+}
+    80005434:	60a2                	ld	ra,8(sp)
+    80005436:	6402                	ld	s0,0(sp)
+    80005438:	0141                	addi	sp,sp,16
+    8000543a:	8082                	ret
+
+000000008000543c <plic_claim>:
+
+// ask the PLIC what interrupt we should serve.
+int
+plic_claim(void)
+{
+    8000543c:	1141                	addi	sp,sp,-16
+    8000543e:	e406                	sd	ra,8(sp)
+    80005440:	e022                	sd	s0,0(sp)
+    80005442:	0800                	addi	s0,sp,16
+  int hart = cpuid();
+    80005444:	c5efc0ef          	jal	800018a2 <cpuid>
+  int irq = *(uint32*)PLIC_SCLAIM(hart);
+    80005448:	00d5151b          	slliw	a0,a0,0xd
+    8000544c:	0c2017b7          	lui	a5,0xc201
+    80005450:	97aa                	add	a5,a5,a0
+  return irq;
+}
+    80005452:	43c8                	lw	a0,4(a5)
+    80005454:	60a2                	ld	ra,8(sp)
+    80005456:	6402                	ld	s0,0(sp)
+    80005458:	0141                	addi	sp,sp,16
+    8000545a:	8082                	ret
+
+000000008000545c <plic_complete>:
+
+// tell the PLIC we've served this IRQ.
+void
+plic_complete(int irq)
+{
+    8000545c:	1101                	addi	sp,sp,-32
+    8000545e:	ec06                	sd	ra,24(sp)
+    80005460:	e822                	sd	s0,16(sp)
+    80005462:	e426                	sd	s1,8(sp)
+    80005464:	1000                	addi	s0,sp,32
+    80005466:	84aa                	mv	s1,a0
+  int hart = cpuid();
+    80005468:	c3afc0ef          	jal	800018a2 <cpuid>
+  *(uint32*)PLIC_SCLAIM(hart) = irq;
+    8000546c:	00d5151b          	slliw	a0,a0,0xd
+    80005470:	0c2017b7          	lui	a5,0xc201
+    80005474:	97aa                	add	a5,a5,a0
+    80005476:	c3c4                	sw	s1,4(a5)
+}
+    80005478:	60e2                	ld	ra,24(sp)
+    8000547a:	6442                	ld	s0,16(sp)
+    8000547c:	64a2                	ld	s1,8(sp)
+    8000547e:	6105                	addi	sp,sp,32
+    80005480:	8082                	ret
+
+0000000080005482 <free_desc>:
+}
+
+// mark a descriptor as free.
+static void
+free_desc(int i)
+{
+    80005482:	1141                	addi	sp,sp,-16
+    80005484:	e406                	sd	ra,8(sp)
+    80005486:	e022                	sd	s0,0(sp)
+    80005488:	0800                	addi	s0,sp,16
+  if(i >= NUM)
+    8000548a:	479d                	li	a5,7
+    8000548c:	04a7ca63          	blt	a5,a0,800054e0 <free_desc+0x5e>
+    panic("free_desc 1");
+  if(disk.free[i])
+    80005490:	0001f797          	auipc	a5,0x1f
+    80005494:	93878793          	addi	a5,a5,-1736 # 80023dc8 <disk>
+    80005498:	97aa                	add	a5,a5,a0
+    8000549a:	0187c783          	lbu	a5,24(a5)
+    8000549e:	e7b9                	bnez	a5,800054ec <free_desc+0x6a>
+    panic("free_desc 2");
+  disk.desc[i].addr = 0;
+    800054a0:	00451693          	slli	a3,a0,0x4
+    800054a4:	0001f797          	auipc	a5,0x1f
+    800054a8:	92478793          	addi	a5,a5,-1756 # 80023dc8 <disk>
+    800054ac:	6398                	ld	a4,0(a5)
+    800054ae:	9736                	add	a4,a4,a3
+    800054b0:	00073023          	sd	zero,0(a4)
+  disk.desc[i].len = 0;
+    800054b4:	6398                	ld	a4,0(a5)
+    800054b6:	9736                	add	a4,a4,a3
+    800054b8:	00072423          	sw	zero,8(a4)
+  disk.desc[i].flags = 0;
+    800054bc:	00071623          	sh	zero,12(a4)
+  disk.desc[i].next = 0;
+    800054c0:	00071723          	sh	zero,14(a4)
+  disk.free[i] = 1;
+    800054c4:	97aa                	add	a5,a5,a0
+    800054c6:	4705                	li	a4,1
+    800054c8:	00e78c23          	sb	a4,24(a5)
+  wakeup(&disk.free[0]);
+    800054cc:	0001f517          	auipc	a0,0x1f
+    800054d0:	91450513          	addi	a0,a0,-1772 # 80023de0 <disk+0x18>
+    800054d4:	a55fc0ef          	jal	80001f28 <wakeup>
+}
+    800054d8:	60a2                	ld	ra,8(sp)
+    800054da:	6402                	ld	s0,0(sp)
+    800054dc:	0141                	addi	sp,sp,16
+    800054de:	8082                	ret
+    panic("free_desc 1");
+    800054e0:	00002517          	auipc	a0,0x2
+    800054e4:	16050513          	addi	a0,a0,352 # 80007640 <etext+0x640>
+    800054e8:	af8fb0ef          	jal	800007e0 <panic>
+    panic("free_desc 2");
+    800054ec:	00002517          	auipc	a0,0x2
+    800054f0:	16450513          	addi	a0,a0,356 # 80007650 <etext+0x650>
+    800054f4:	aecfb0ef          	jal	800007e0 <panic>
+
+00000000800054f8 <virtio_disk_init>:
+{
+    800054f8:	1101                	addi	sp,sp,-32
+    800054fa:	ec06                	sd	ra,24(sp)
+    800054fc:	e822                	sd	s0,16(sp)
+    800054fe:	e426                	sd	s1,8(sp)
+    80005500:	e04a                	sd	s2,0(sp)
+    80005502:	1000                	addi	s0,sp,32
+  initlock(&disk.vdisk_lock, "virtio_disk");
+    80005504:	00002597          	auipc	a1,0x2
+    80005508:	15c58593          	addi	a1,a1,348 # 80007660 <etext+0x660>
+    8000550c:	0001f517          	auipc	a0,0x1f
+    80005510:	9e450513          	addi	a0,a0,-1564 # 80023ef0 <disk+0x128>
+    80005514:	e3afb0ef          	jal	80000b4e <initlock>
+  if(*R(VIRTIO_MMIO_MAGIC_VALUE) != 0x74726976 ||
+    80005518:	100017b7          	lui	a5,0x10001
+    8000551c:	4398                	lw	a4,0(a5)
+    8000551e:	2701                	sext.w	a4,a4
+    80005520:	747277b7          	lui	a5,0x74727
+    80005524:	97678793          	addi	a5,a5,-1674 # 74726976 <_entry-0xb8d968a>
+    80005528:	18f71063          	bne	a4,a5,800056a8 <virtio_disk_init+0x1b0>
+     *R(VIRTIO_MMIO_VERSION) != 2 ||
+    8000552c:	100017b7          	lui	a5,0x10001
+    80005530:	0791                	addi	a5,a5,4 # 10001004 <_entry-0x6fffeffc>
+    80005532:	439c                	lw	a5,0(a5)
+    80005534:	2781                	sext.w	a5,a5
+  if(*R(VIRTIO_MMIO_MAGIC_VALUE) != 0x74726976 ||
+    80005536:	4709                	li	a4,2
+    80005538:	16e79863          	bne	a5,a4,800056a8 <virtio_disk_init+0x1b0>
+     *R(VIRTIO_MMIO_DEVICE_ID) != 2 ||
+    8000553c:	100017b7          	lui	a5,0x10001
+    80005540:	07a1                	addi	a5,a5,8 # 10001008 <_entry-0x6fffeff8>
+    80005542:	439c                	lw	a5,0(a5)
+    80005544:	2781                	sext.w	a5,a5
+     *R(VIRTIO_MMIO_VERSION) != 2 ||
+    80005546:	16e79163          	bne	a5,a4,800056a8 <virtio_disk_init+0x1b0>
+     *R(VIRTIO_MMIO_VENDOR_ID) != 0x554d4551){
+    8000554a:	100017b7          	lui	a5,0x10001
+    8000554e:	47d8                	lw	a4,12(a5)
+    80005550:	2701                	sext.w	a4,a4
+     *R(VIRTIO_MMIO_DEVICE_ID) != 2 ||
+    80005552:	554d47b7          	lui	a5,0x554d4
+    80005556:	55178793          	addi	a5,a5,1361 # 554d4551 <_entry-0x2ab2baaf>
+    8000555a:	14f71763          	bne	a4,a5,800056a8 <virtio_disk_init+0x1b0>
+  *R(VIRTIO_MMIO_STATUS) = status;
+    8000555e:	100017b7          	lui	a5,0x10001
+    80005562:	0607a823          	sw	zero,112(a5) # 10001070 <_entry-0x6fffef90>
+  *R(VIRTIO_MMIO_STATUS) = status;
+    80005566:	4705                	li	a4,1
+    80005568:	dbb8                	sw	a4,112(a5)
+  *R(VIRTIO_MMIO_STATUS) = status;
+    8000556a:	470d                	li	a4,3
+    8000556c:	dbb8                	sw	a4,112(a5)
+  uint64 features = *R(VIRTIO_MMIO_DEVICE_FEATURES);
+    8000556e:	10001737          	lui	a4,0x10001
+    80005572:	4b14                	lw	a3,16(a4)
+  features &= ~(1 << VIRTIO_RING_F_INDIRECT_DESC);
+    80005574:	c7ffe737          	lui	a4,0xc7ffe
+    80005578:	75f70713          	addi	a4,a4,1887 # ffffffffc7ffe75f <end+0xffffffff47fda857>
+  *R(VIRTIO_MMIO_DRIVER_FEATURES) = features;
+    8000557c:	8ef9                	and	a3,a3,a4
+    8000557e:	10001737          	lui	a4,0x10001
+    80005582:	d314                	sw	a3,32(a4)
+  *R(VIRTIO_MMIO_STATUS) = status;
+    80005584:	472d                	li	a4,11
+    80005586:	dbb8                	sw	a4,112(a5)
+  *R(VIRTIO_MMIO_STATUS) = status;
+    80005588:	07078793          	addi	a5,a5,112
+  status = *R(VIRTIO_MMIO_STATUS);
+    8000558c:	439c                	lw	a5,0(a5)
+    8000558e:	0007891b          	sext.w	s2,a5
+  if(!(status & VIRTIO_CONFIG_S_FEATURES_OK))
+    80005592:	8ba1                	andi	a5,a5,8
+    80005594:	12078063          	beqz	a5,800056b4 <virtio_disk_init+0x1bc>
+  *R(VIRTIO_MMIO_QUEUE_SEL) = 0;
+    80005598:	100017b7          	lui	a5,0x10001
+    8000559c:	0207a823          	sw	zero,48(a5) # 10001030 <_entry-0x6fffefd0>
+  if(*R(VIRTIO_MMIO_QUEUE_READY))
+    800055a0:	100017b7          	lui	a5,0x10001
+    800055a4:	04478793          	addi	a5,a5,68 # 10001044 <_entry-0x6fffefbc>
+    800055a8:	439c                	lw	a5,0(a5)
+    800055aa:	2781                	sext.w	a5,a5
+    800055ac:	10079a63          	bnez	a5,800056c0 <virtio_disk_init+0x1c8>
+  uint32 max = *R(VIRTIO_MMIO_QUEUE_NUM_MAX);
+    800055b0:	100017b7          	lui	a5,0x10001
+    800055b4:	03478793          	addi	a5,a5,52 # 10001034 <_entry-0x6fffefcc>
+    800055b8:	439c                	lw	a5,0(a5)
+    800055ba:	2781                	sext.w	a5,a5
+  if(max == 0)
+    800055bc:	10078863          	beqz	a5,800056cc <virtio_disk_init+0x1d4>
+  if(max < NUM)
+    800055c0:	471d                	li	a4,7
+    800055c2:	10f77b63          	bgeu	a4,a5,800056d8 <virtio_disk_init+0x1e0>
+  disk.desc = kalloc();
+    800055c6:	d38fb0ef          	jal	80000afe <kalloc>
+    800055ca:	0001e497          	auipc	s1,0x1e
+    800055ce:	7fe48493          	addi	s1,s1,2046 # 80023dc8 <disk>
+    800055d2:	e088                	sd	a0,0(s1)
+  disk.avail = kalloc();
+    800055d4:	d2afb0ef          	jal	80000afe <kalloc>
+    800055d8:	e488                	sd	a0,8(s1)
+  disk.used = kalloc();
+    800055da:	d24fb0ef          	jal	80000afe <kalloc>
+    800055de:	87aa                	mv	a5,a0
+    800055e0:	e888                	sd	a0,16(s1)
+  if(!disk.desc || !disk.avail || !disk.used)
+    800055e2:	6088                	ld	a0,0(s1)
+    800055e4:	10050063          	beqz	a0,800056e4 <virtio_disk_init+0x1ec>
+    800055e8:	0001e717          	auipc	a4,0x1e
+    800055ec:	7e873703          	ld	a4,2024(a4) # 80023dd0 <disk+0x8>
+    800055f0:	0e070a63          	beqz	a4,800056e4 <virtio_disk_init+0x1ec>
+    800055f4:	0e078863          	beqz	a5,800056e4 <virtio_disk_init+0x1ec>
+  memset(disk.desc, 0, PGSIZE);
+    800055f8:	6605                	lui	a2,0x1
+    800055fa:	4581                	li	a1,0
+    800055fc:	ea6fb0ef          	jal	80000ca2 <memset>
+  memset(disk.avail, 0, PGSIZE);
+    80005600:	0001e497          	auipc	s1,0x1e
+    80005604:	7c848493          	addi	s1,s1,1992 # 80023dc8 <disk>
+    80005608:	6605                	lui	a2,0x1
+    8000560a:	4581                	li	a1,0
+    8000560c:	6488                	ld	a0,8(s1)
+    8000560e:	e94fb0ef          	jal	80000ca2 <memset>
+  memset(disk.used, 0, PGSIZE);
+    80005612:	6605                	lui	a2,0x1
+    80005614:	4581                	li	a1,0
+    80005616:	6888                	ld	a0,16(s1)
+    80005618:	e8afb0ef          	jal	80000ca2 <memset>
+  *R(VIRTIO_MMIO_QUEUE_NUM) = NUM;
+    8000561c:	100017b7          	lui	a5,0x10001
+    80005620:	4721                	li	a4,8
+    80005622:	df98                	sw	a4,56(a5)
+  *R(VIRTIO_MMIO_QUEUE_DESC_LOW) = (uint64)disk.desc;
+    80005624:	4098                	lw	a4,0(s1)
+    80005626:	100017b7          	lui	a5,0x10001
+    8000562a:	08e7a023          	sw	a4,128(a5) # 10001080 <_entry-0x6fffef80>
+  *R(VIRTIO_MMIO_QUEUE_DESC_HIGH) = (uint64)disk.desc >> 32;
+    8000562e:	40d8                	lw	a4,4(s1)
+    80005630:	100017b7          	lui	a5,0x10001
+    80005634:	08e7a223          	sw	a4,132(a5) # 10001084 <_entry-0x6fffef7c>
+  *R(VIRTIO_MMIO_DRIVER_DESC_LOW) = (uint64)disk.avail;
+    80005638:	649c                	ld	a5,8(s1)
+    8000563a:	0007869b          	sext.w	a3,a5
+    8000563e:	10001737          	lui	a4,0x10001
+    80005642:	08d72823          	sw	a3,144(a4) # 10001090 <_entry-0x6fffef70>
+  *R(VIRTIO_MMIO_DRIVER_DESC_HIGH) = (uint64)disk.avail >> 32;
+    80005646:	9781                	srai	a5,a5,0x20
+    80005648:	10001737          	lui	a4,0x10001
+    8000564c:	08f72a23          	sw	a5,148(a4) # 10001094 <_entry-0x6fffef6c>
+  *R(VIRTIO_MMIO_DEVICE_DESC_LOW) = (uint64)disk.used;
+    80005650:	689c                	ld	a5,16(s1)
+    80005652:	0007869b          	sext.w	a3,a5
+    80005656:	10001737          	lui	a4,0x10001
+    8000565a:	0ad72023          	sw	a3,160(a4) # 100010a0 <_entry-0x6fffef60>
+  *R(VIRTIO_MMIO_DEVICE_DESC_HIGH) = (uint64)disk.used >> 32;
+    8000565e:	9781                	srai	a5,a5,0x20
+    80005660:	10001737          	lui	a4,0x10001
+    80005664:	0af72223          	sw	a5,164(a4) # 100010a4 <_entry-0x6fffef5c>
+  *R(VIRTIO_MMIO_QUEUE_READY) = 0x1;
+    80005668:	10001737          	lui	a4,0x10001
+    8000566c:	4785                	li	a5,1
+    8000566e:	c37c                	sw	a5,68(a4)
+    disk.free[i] = 1;
+    80005670:	00f48c23          	sb	a5,24(s1)
+    80005674:	00f48ca3          	sb	a5,25(s1)
+    80005678:	00f48d23          	sb	a5,26(s1)
+    8000567c:	00f48da3          	sb	a5,27(s1)
+    80005680:	00f48e23          	sb	a5,28(s1)
+    80005684:	00f48ea3          	sb	a5,29(s1)
+    80005688:	00f48f23          	sb	a5,30(s1)
+    8000568c:	00f48fa3          	sb	a5,31(s1)
+  status |= VIRTIO_CONFIG_S_DRIVER_OK;
+    80005690:	00496913          	ori	s2,s2,4
+  *R(VIRTIO_MMIO_STATUS) = status;
+    80005694:	100017b7          	lui	a5,0x10001
+    80005698:	0727a823          	sw	s2,112(a5) # 10001070 <_entry-0x6fffef90>
+}
+    8000569c:	60e2                	ld	ra,24(sp)
+    8000569e:	6442                	ld	s0,16(sp)
+    800056a0:	64a2                	ld	s1,8(sp)
+    800056a2:	6902                	ld	s2,0(sp)
+    800056a4:	6105                	addi	sp,sp,32
+    800056a6:	8082                	ret
+    panic("could not find virtio disk");
+    800056a8:	00002517          	auipc	a0,0x2
+    800056ac:	fc850513          	addi	a0,a0,-56 # 80007670 <etext+0x670>
+    800056b0:	930fb0ef          	jal	800007e0 <panic>
+    panic("virtio disk FEATURES_OK unset");
+    800056b4:	00002517          	auipc	a0,0x2
+    800056b8:	fdc50513          	addi	a0,a0,-36 # 80007690 <etext+0x690>
+    800056bc:	924fb0ef          	jal	800007e0 <panic>
+    panic("virtio disk should not be ready");
+    800056c0:	00002517          	auipc	a0,0x2
+    800056c4:	ff050513          	addi	a0,a0,-16 # 800076b0 <etext+0x6b0>
+    800056c8:	918fb0ef          	jal	800007e0 <panic>
+    panic("virtio disk has no queue 0");
+    800056cc:	00002517          	auipc	a0,0x2
+    800056d0:	00450513          	addi	a0,a0,4 # 800076d0 <etext+0x6d0>
+    800056d4:	90cfb0ef          	jal	800007e0 <panic>
+    panic("virtio disk max queue too short");
+    800056d8:	00002517          	auipc	a0,0x2
+    800056dc:	01850513          	addi	a0,a0,24 # 800076f0 <etext+0x6f0>
+    800056e0:	900fb0ef          	jal	800007e0 <panic>
+    panic("virtio disk kalloc");
+    800056e4:	00002517          	auipc	a0,0x2
+    800056e8:	02c50513          	addi	a0,a0,44 # 80007710 <etext+0x710>
+    800056ec:	8f4fb0ef          	jal	800007e0 <panic>
+
+00000000800056f0 <virtio_disk_rw>:
+  return 0;
+}
+
+void
+virtio_disk_rw(struct buf *b, int write)
+{
+    800056f0:	7159                	addi	sp,sp,-112
+    800056f2:	f486                	sd	ra,104(sp)
+    800056f4:	f0a2                	sd	s0,96(sp)
+    800056f6:	eca6                	sd	s1,88(sp)
+    800056f8:	e8ca                	sd	s2,80(sp)
+    800056fa:	e4ce                	sd	s3,72(sp)
+    800056fc:	e0d2                	sd	s4,64(sp)
+    800056fe:	fc56                	sd	s5,56(sp)
+    80005700:	f85a                	sd	s6,48(sp)
+    80005702:	f45e                	sd	s7,40(sp)
+    80005704:	f062                	sd	s8,32(sp)
+    80005706:	ec66                	sd	s9,24(sp)
+    80005708:	1880                	addi	s0,sp,112
+    8000570a:	8a2a                	mv	s4,a0
+    8000570c:	8bae                	mv	s7,a1
+  uint64 sector = b->blockno * (BSIZE / 512);
+    8000570e:	00c52c83          	lw	s9,12(a0)
+    80005712:	001c9c9b          	slliw	s9,s9,0x1
+    80005716:	1c82                	slli	s9,s9,0x20
+    80005718:	020cdc93          	srli	s9,s9,0x20
+
+  acquire(&disk.vdisk_lock);
+    8000571c:	0001e517          	auipc	a0,0x1e
+    80005720:	7d450513          	addi	a0,a0,2004 # 80023ef0 <disk+0x128>
+    80005724:	caafb0ef          	jal	80000bce <acquire>
+  for(int i = 0; i < 3; i++){
+    80005728:	4981                	li	s3,0
+  for(int i = 0; i < NUM; i++){
+    8000572a:	44a1                	li	s1,8
+      disk.free[i] = 0;
+    8000572c:	0001eb17          	auipc	s6,0x1e
+    80005730:	69cb0b13          	addi	s6,s6,1692 # 80023dc8 <disk>
+  for(int i = 0; i < 3; i++){
+    80005734:	4a8d                	li	s5,3
+  int idx[3];
+  while(1){
+    if(alloc3_desc(idx) == 0) {
+      break;
+    }
+    sleep(&disk.free[0], &disk.vdisk_lock);
+    80005736:	0001ec17          	auipc	s8,0x1e
+    8000573a:	7bac0c13          	addi	s8,s8,1978 # 80023ef0 <disk+0x128>
+    8000573e:	a8b9                	j	8000579c <virtio_disk_rw+0xac>
+      disk.free[i] = 0;
+    80005740:	00fb0733          	add	a4,s6,a5
+    80005744:	00070c23          	sb	zero,24(a4) # 10001018 <_entry-0x6fffefe8>
+    idx[i] = alloc_desc();
+    80005748:	c19c                	sw	a5,0(a1)
+    if(idx[i] < 0){
+    8000574a:	0207c563          	bltz	a5,80005774 <virtio_disk_rw+0x84>
+  for(int i = 0; i < 3; i++){
+    8000574e:	2905                	addiw	s2,s2,1
+    80005750:	0611                	addi	a2,a2,4 # 1004 <_entry-0x7fffeffc>
+    80005752:	05590963          	beq	s2,s5,800057a4 <virtio_disk_rw+0xb4>
+    idx[i] = alloc_desc();
+    80005756:	85b2                	mv	a1,a2
+  for(int i = 0; i < NUM; i++){
+    80005758:	0001e717          	auipc	a4,0x1e
+    8000575c:	67070713          	addi	a4,a4,1648 # 80023dc8 <disk>
+    80005760:	87ce                	mv	a5,s3
+    if(disk.free[i]){
+    80005762:	01874683          	lbu	a3,24(a4)
+    80005766:	fee9                	bnez	a3,80005740 <virtio_disk_rw+0x50>
+  for(int i = 0; i < NUM; i++){
+    80005768:	2785                	addiw	a5,a5,1
+    8000576a:	0705                	addi	a4,a4,1
+    8000576c:	fe979be3          	bne	a5,s1,80005762 <virtio_disk_rw+0x72>
+    idx[i] = alloc_desc();
+    80005770:	57fd                	li	a5,-1
+    80005772:	c19c                	sw	a5,0(a1)
+      for(int j = 0; j < i; j++)
+    80005774:	01205d63          	blez	s2,8000578e <virtio_disk_rw+0x9e>
+        free_desc(idx[j]);
+    80005778:	f9042503          	lw	a0,-112(s0)
+    8000577c:	d07ff0ef          	jal	80005482 <free_desc>
+      for(int j = 0; j < i; j++)
+    80005780:	4785                	li	a5,1
+    80005782:	0127d663          	bge	a5,s2,8000578e <virtio_disk_rw+0x9e>
+        free_desc(idx[j]);
+    80005786:	f9442503          	lw	a0,-108(s0)
+    8000578a:	cf9ff0ef          	jal	80005482 <free_desc>
+    sleep(&disk.free[0], &disk.vdisk_lock);
+    8000578e:	85e2                	mv	a1,s8
+    80005790:	0001e517          	auipc	a0,0x1e
+    80005794:	65050513          	addi	a0,a0,1616 # 80023de0 <disk+0x18>
+    80005798:	f44fc0ef          	jal	80001edc <sleep>
+  for(int i = 0; i < 3; i++){
+    8000579c:	f9040613          	addi	a2,s0,-112
+    800057a0:	894e                	mv	s2,s3
+    800057a2:	bf55                	j	80005756 <virtio_disk_rw+0x66>
+  }
+
+  // format the three descriptors.
+  // qemu's virtio-blk.c reads them.
+
+  struct virtio_blk_req *buf0 = &disk.ops[idx[0]];
+    800057a4:	f9042503          	lw	a0,-112(s0)
+    800057a8:	00451693          	slli	a3,a0,0x4
+
+  if(write)
+    800057ac:	0001e797          	auipc	a5,0x1e
+    800057b0:	61c78793          	addi	a5,a5,1564 # 80023dc8 <disk>
+    800057b4:	00a50713          	addi	a4,a0,10
+    800057b8:	0712                	slli	a4,a4,0x4
+    800057ba:	973e                	add	a4,a4,a5
+    800057bc:	01703633          	snez	a2,s7
+    800057c0:	c710                	sw	a2,8(a4)
+    buf0->type = VIRTIO_BLK_T_OUT; // write the disk
+  else
+    buf0->type = VIRTIO_BLK_T_IN; // read the disk
+  buf0->reserved = 0;
+    800057c2:	00072623          	sw	zero,12(a4)
+  buf0->sector = sector;
+    800057c6:	01973823          	sd	s9,16(a4)
+
+  disk.desc[idx[0]].addr = (uint64) buf0;
+    800057ca:	6398                	ld	a4,0(a5)
+    800057cc:	9736                	add	a4,a4,a3
+  struct virtio_blk_req *buf0 = &disk.ops[idx[0]];
+    800057ce:	0a868613          	addi	a2,a3,168
+    800057d2:	963e                	add	a2,a2,a5
+  disk.desc[idx[0]].addr = (uint64) buf0;
+    800057d4:	e310                	sd	a2,0(a4)
+  disk.desc[idx[0]].len = sizeof(struct virtio_blk_req);
+    800057d6:	6390                	ld	a2,0(a5)
+    800057d8:	00d605b3          	add	a1,a2,a3
+    800057dc:	4741                	li	a4,16
+    800057de:	c598                	sw	a4,8(a1)
+  disk.desc[idx[0]].flags = VRING_DESC_F_NEXT;
+    800057e0:	4805                	li	a6,1
+    800057e2:	01059623          	sh	a6,12(a1)
+  disk.desc[idx[0]].next = idx[1];
+    800057e6:	f9442703          	lw	a4,-108(s0)
+    800057ea:	00e59723          	sh	a4,14(a1)
+
+  disk.desc[idx[1]].addr = (uint64) b->data;
+    800057ee:	0712                	slli	a4,a4,0x4
+    800057f0:	963a                	add	a2,a2,a4
+    800057f2:	058a0593          	addi	a1,s4,88
+    800057f6:	e20c                	sd	a1,0(a2)
+  disk.desc[idx[1]].len = BSIZE;
+    800057f8:	0007b883          	ld	a7,0(a5)
+    800057fc:	9746                	add	a4,a4,a7
+    800057fe:	40000613          	li	a2,1024
+    80005802:	c710                	sw	a2,8(a4)
+  if(write)
+    80005804:	001bb613          	seqz	a2,s7
+    80005808:	0016161b          	slliw	a2,a2,0x1
+    disk.desc[idx[1]].flags = 0; // device reads b->data
+  else
+    disk.desc[idx[1]].flags = VRING_DESC_F_WRITE; // device writes b->data
+  disk.desc[idx[1]].flags |= VRING_DESC_F_NEXT;
+    8000580c:	00166613          	ori	a2,a2,1
+    80005810:	00c71623          	sh	a2,12(a4)
+  disk.desc[idx[1]].next = idx[2];
+    80005814:	f9842583          	lw	a1,-104(s0)
+    80005818:	00b71723          	sh	a1,14(a4)
+
+  disk.info[idx[0]].status = 0xff; // device writes 0 on success
+    8000581c:	00250613          	addi	a2,a0,2
+    80005820:	0612                	slli	a2,a2,0x4
+    80005822:	963e                	add	a2,a2,a5
+    80005824:	577d                	li	a4,-1
+    80005826:	00e60823          	sb	a4,16(a2)
+  disk.desc[idx[2]].addr = (uint64) &disk.info[idx[0]].status;
+    8000582a:	0592                	slli	a1,a1,0x4
+    8000582c:	98ae                	add	a7,a7,a1
+    8000582e:	03068713          	addi	a4,a3,48
+    80005832:	973e                	add	a4,a4,a5
+    80005834:	00e8b023          	sd	a4,0(a7)
+  disk.desc[idx[2]].len = 1;
+    80005838:	6398                	ld	a4,0(a5)
+    8000583a:	972e                	add	a4,a4,a1
+    8000583c:	01072423          	sw	a6,8(a4)
+  disk.desc[idx[2]].flags = VRING_DESC_F_WRITE; // device writes the status
+    80005840:	4689                	li	a3,2
+    80005842:	00d71623          	sh	a3,12(a4)
+  disk.desc[idx[2]].next = 0;
+    80005846:	00071723          	sh	zero,14(a4)
+
+  // record struct buf for virtio_disk_intr().
+  b->disk = 1;
+    8000584a:	010a2223          	sw	a6,4(s4)
+  disk.info[idx[0]].b = b;
+    8000584e:	01463423          	sd	s4,8(a2)
+
+  // tell the device the first index in our chain of descriptors.
+  disk.avail->ring[disk.avail->idx % NUM] = idx[0];
+    80005852:	6794                	ld	a3,8(a5)
+    80005854:	0026d703          	lhu	a4,2(a3)
+    80005858:	8b1d                	andi	a4,a4,7
+    8000585a:	0706                	slli	a4,a4,0x1
+    8000585c:	96ba                	add	a3,a3,a4
+    8000585e:	00a69223          	sh	a0,4(a3)
+
+  __sync_synchronize();
+    80005862:	0330000f          	fence	rw,rw
+
+  // tell the device another avail ring entry is available.
+  disk.avail->idx += 1; // not % NUM ...
+    80005866:	6798                	ld	a4,8(a5)
+    80005868:	00275783          	lhu	a5,2(a4)
+    8000586c:	2785                	addiw	a5,a5,1
+    8000586e:	00f71123          	sh	a5,2(a4)
+
+  __sync_synchronize();
+    80005872:	0330000f          	fence	rw,rw
+
+  *R(VIRTIO_MMIO_QUEUE_NOTIFY) = 0; // value is queue number
+    80005876:	100017b7          	lui	a5,0x10001
+    8000587a:	0407a823          	sw	zero,80(a5) # 10001050 <_entry-0x6fffefb0>
+
+  // Wait for virtio_disk_intr() to say request has finished.
+  while(b->disk == 1) {
+    8000587e:	004a2783          	lw	a5,4(s4)
+    sleep(b, &disk.vdisk_lock);
+    80005882:	0001e917          	auipc	s2,0x1e
+    80005886:	66e90913          	addi	s2,s2,1646 # 80023ef0 <disk+0x128>
+  while(b->disk == 1) {
+    8000588a:	4485                	li	s1,1
+    8000588c:	01079a63          	bne	a5,a6,800058a0 <virtio_disk_rw+0x1b0>
+    sleep(b, &disk.vdisk_lock);
+    80005890:	85ca                	mv	a1,s2
+    80005892:	8552                	mv	a0,s4
+    80005894:	e48fc0ef          	jal	80001edc <sleep>
+  while(b->disk == 1) {
+    80005898:	004a2783          	lw	a5,4(s4)
+    8000589c:	fe978ae3          	beq	a5,s1,80005890 <virtio_disk_rw+0x1a0>
+  }
+
+  disk.info[idx[0]].b = 0;
+    800058a0:	f9042903          	lw	s2,-112(s0)
+    800058a4:	00290713          	addi	a4,s2,2
+    800058a8:	0712                	slli	a4,a4,0x4
+    800058aa:	0001e797          	auipc	a5,0x1e
+    800058ae:	51e78793          	addi	a5,a5,1310 # 80023dc8 <disk>
+    800058b2:	97ba                	add	a5,a5,a4
+    800058b4:	0007b423          	sd	zero,8(a5)
+    int flag = disk.desc[i].flags;
+    800058b8:	0001e997          	auipc	s3,0x1e
+    800058bc:	51098993          	addi	s3,s3,1296 # 80023dc8 <disk>
+    800058c0:	00491713          	slli	a4,s2,0x4
+    800058c4:	0009b783          	ld	a5,0(s3)
+    800058c8:	97ba                	add	a5,a5,a4
+    800058ca:	00c7d483          	lhu	s1,12(a5)
+    int nxt = disk.desc[i].next;
+    800058ce:	854a                	mv	a0,s2
+    800058d0:	00e7d903          	lhu	s2,14(a5)
+    free_desc(i);
+    800058d4:	bafff0ef          	jal	80005482 <free_desc>
+    if(flag & VRING_DESC_F_NEXT)
+    800058d8:	8885                	andi	s1,s1,1
+    800058da:	f0fd                	bnez	s1,800058c0 <virtio_disk_rw+0x1d0>
+  free_chain(idx[0]);
+
+  release(&disk.vdisk_lock);
+    800058dc:	0001e517          	auipc	a0,0x1e
+    800058e0:	61450513          	addi	a0,a0,1556 # 80023ef0 <disk+0x128>
+    800058e4:	b82fb0ef          	jal	80000c66 <release>
+}
+    800058e8:	70a6                	ld	ra,104(sp)
+    800058ea:	7406                	ld	s0,96(sp)
+    800058ec:	64e6                	ld	s1,88(sp)
+    800058ee:	6946                	ld	s2,80(sp)
+    800058f0:	69a6                	ld	s3,72(sp)
+    800058f2:	6a06                	ld	s4,64(sp)
+    800058f4:	7ae2                	ld	s5,56(sp)
+    800058f6:	7b42                	ld	s6,48(sp)
+    800058f8:	7ba2                	ld	s7,40(sp)
+    800058fa:	7c02                	ld	s8,32(sp)
+    800058fc:	6ce2                	ld	s9,24(sp)
+    800058fe:	6165                	addi	sp,sp,112
+    80005900:	8082                	ret
+
+0000000080005902 <virtio_disk_intr>:
+
+void
+virtio_disk_intr()
+{
+    80005902:	1101                	addi	sp,sp,-32
+    80005904:	ec06                	sd	ra,24(sp)
+    80005906:	e822                	sd	s0,16(sp)
+    80005908:	e426                	sd	s1,8(sp)
+    8000590a:	1000                	addi	s0,sp,32
+  acquire(&disk.vdisk_lock);
+    8000590c:	0001e497          	auipc	s1,0x1e
+    80005910:	4bc48493          	addi	s1,s1,1212 # 80023dc8 <disk>
+    80005914:	0001e517          	auipc	a0,0x1e
+    80005918:	5dc50513          	addi	a0,a0,1500 # 80023ef0 <disk+0x128>
+    8000591c:	ab2fb0ef          	jal	80000bce <acquire>
+  // we've seen this interrupt, which the following line does.
+  // this may race with the device writing new entries to
+  // the "used" ring, in which case we may process the new
+  // completion entries in this interrupt, and have nothing to do
+  // in the next interrupt, which is harmless.
+  *R(VIRTIO_MMIO_INTERRUPT_ACK) = *R(VIRTIO_MMIO_INTERRUPT_STATUS) & 0x3;
+    80005920:	100017b7          	lui	a5,0x10001
+    80005924:	53b8                	lw	a4,96(a5)
+    80005926:	8b0d                	andi	a4,a4,3
+    80005928:	100017b7          	lui	a5,0x10001
+    8000592c:	d3f8                	sw	a4,100(a5)
+
+  __sync_synchronize();
+    8000592e:	0330000f          	fence	rw,rw
+
+  // the device increments disk.used->idx when it
+  // adds an entry to the used ring.
+
+  while(disk.used_idx != disk.used->idx){
+    80005932:	689c                	ld	a5,16(s1)
+    80005934:	0204d703          	lhu	a4,32(s1)
+    80005938:	0027d783          	lhu	a5,2(a5) # 10001002 <_entry-0x6fffeffe>
+    8000593c:	04f70663          	beq	a4,a5,80005988 <virtio_disk_intr+0x86>
+    __sync_synchronize();
+    80005940:	0330000f          	fence	rw,rw
+    int id = disk.used->ring[disk.used_idx % NUM].id;
+    80005944:	6898                	ld	a4,16(s1)
+    80005946:	0204d783          	lhu	a5,32(s1)
+    8000594a:	8b9d                	andi	a5,a5,7
+    8000594c:	078e                	slli	a5,a5,0x3
+    8000594e:	97ba                	add	a5,a5,a4
+    80005950:	43dc                	lw	a5,4(a5)
+
+    if(disk.info[id].status != 0)
+    80005952:	00278713          	addi	a4,a5,2
+    80005956:	0712                	slli	a4,a4,0x4
+    80005958:	9726                	add	a4,a4,s1
+    8000595a:	01074703          	lbu	a4,16(a4)
+    8000595e:	e321                	bnez	a4,8000599e <virtio_disk_intr+0x9c>
+      panic("virtio_disk_intr status");
+
+    struct buf *b = disk.info[id].b;
+    80005960:	0789                	addi	a5,a5,2
+    80005962:	0792                	slli	a5,a5,0x4
+    80005964:	97a6                	add	a5,a5,s1
+    80005966:	6788                	ld	a0,8(a5)
+    b->disk = 0;   // disk is done with buf
+    80005968:	00052223          	sw	zero,4(a0)
+    wakeup(b);
+    8000596c:	dbcfc0ef          	jal	80001f28 <wakeup>
+
+    disk.used_idx += 1;
+    80005970:	0204d783          	lhu	a5,32(s1)
+    80005974:	2785                	addiw	a5,a5,1
+    80005976:	17c2                	slli	a5,a5,0x30
+    80005978:	93c1                	srli	a5,a5,0x30
+    8000597a:	02f49023          	sh	a5,32(s1)
+  while(disk.used_idx != disk.used->idx){
+    8000597e:	6898                	ld	a4,16(s1)
+    80005980:	00275703          	lhu	a4,2(a4)
+    80005984:	faf71ee3          	bne	a4,a5,80005940 <virtio_disk_intr+0x3e>
+  }
+
+  release(&disk.vdisk_lock);
+    80005988:	0001e517          	auipc	a0,0x1e
+    8000598c:	56850513          	addi	a0,a0,1384 # 80023ef0 <disk+0x128>
+    80005990:	ad6fb0ef          	jal	80000c66 <release>
+}
+    80005994:	60e2                	ld	ra,24(sp)
+    80005996:	6442                	ld	s0,16(sp)
+    80005998:	64a2                	ld	s1,8(sp)
+    8000599a:	6105                	addi	sp,sp,32
+    8000599c:	8082                	ret
+      panic("virtio_disk_intr status");
+    8000599e:	00002517          	auipc	a0,0x2
+    800059a2:	d8a50513          	addi	a0,a0,-630 # 80007728 <etext+0x728>
+    800059a6:	e3bfa0ef          	jal	800007e0 <panic>
+	...
+
+0000000080006000 <_trampoline>:
+    80006000:	14051073          	csrw	sscratch,a0
+    80006004:	02000537          	lui	a0,0x2000
+    80006008:	357d                	addiw	a0,a0,-1 # 1ffffff <_entry-0x7e000001>
+    8000600a:	0536                	slli	a0,a0,0xd
+    8000600c:	02153423          	sd	ra,40(a0)
+    80006010:	02253823          	sd	sp,48(a0)
+    80006014:	02353c23          	sd	gp,56(a0)
+    80006018:	04453023          	sd	tp,64(a0)
+    8000601c:	04553423          	sd	t0,72(a0)
+    80006020:	04653823          	sd	t1,80(a0)
+    80006024:	04753c23          	sd	t2,88(a0)
+    80006028:	f120                	sd	s0,96(a0)
+    8000602a:	f524                	sd	s1,104(a0)
+    8000602c:	fd2c                	sd	a1,120(a0)
+    8000602e:	e150                	sd	a2,128(a0)
+    80006030:	e554                	sd	a3,136(a0)
+    80006032:	e958                	sd	a4,144(a0)
+    80006034:	ed5c                	sd	a5,152(a0)
+    80006036:	0b053023          	sd	a6,160(a0)
+    8000603a:	0b153423          	sd	a7,168(a0)
+    8000603e:	0b253823          	sd	s2,176(a0)
+    80006042:	0b353c23          	sd	s3,184(a0)
+    80006046:	0d453023          	sd	s4,192(a0)
+    8000604a:	0d553423          	sd	s5,200(a0)
+    8000604e:	0d653823          	sd	s6,208(a0)
+    80006052:	0d753c23          	sd	s7,216(a0)
+    80006056:	0f853023          	sd	s8,224(a0)
+    8000605a:	0f953423          	sd	s9,232(a0)
+    8000605e:	0fa53823          	sd	s10,240(a0)
+    80006062:	0fb53c23          	sd	s11,248(a0)
+    80006066:	11c53023          	sd	t3,256(a0)
+    8000606a:	11d53423          	sd	t4,264(a0)
+    8000606e:	11e53823          	sd	t5,272(a0)
+    80006072:	11f53c23          	sd	t6,280(a0)
+    80006076:	140022f3          	csrr	t0,sscratch
+    8000607a:	06553823          	sd	t0,112(a0)
+    8000607e:	00853103          	ld	sp,8(a0)
+    80006082:	02053203          	ld	tp,32(a0)
+    80006086:	01053283          	ld	t0,16(a0)
+    8000608a:	00053303          	ld	t1,0(a0)
+    8000608e:	12000073          	sfence.vma
+    80006092:	18031073          	csrw	satp,t1
+    80006096:	12000073          	sfence.vma
+    8000609a:	9282                	jalr	t0
+
+000000008000609c <userret>:
+    8000609c:	12000073          	sfence.vma
+    800060a0:	18051073          	csrw	satp,a0
+    800060a4:	12000073          	sfence.vma
+    800060a8:	02000537          	lui	a0,0x2000
+    800060ac:	357d                	addiw	a0,a0,-1 # 1ffffff <_entry-0x7e000001>
+    800060ae:	0536                	slli	a0,a0,0xd
+    800060b0:	02853083          	ld	ra,40(a0)
+    800060b4:	03053103          	ld	sp,48(a0)
+    800060b8:	03853183          	ld	gp,56(a0)
+    800060bc:	04053203          	ld	tp,64(a0)
+    800060c0:	04853283          	ld	t0,72(a0)
+    800060c4:	05053303          	ld	t1,80(a0)
+    800060c8:	05853383          	ld	t2,88(a0)
+    800060cc:	7120                	ld	s0,96(a0)
+    800060ce:	7524                	ld	s1,104(a0)
+    800060d0:	7d2c                	ld	a1,120(a0)
+    800060d2:	6150                	ld	a2,128(a0)
+    800060d4:	6554                	ld	a3,136(a0)
+    800060d6:	6958                	ld	a4,144(a0)
+    800060d8:	6d5c                	ld	a5,152(a0)
+    800060da:	0a053803          	ld	a6,160(a0)
+    800060de:	0a853883          	ld	a7,168(a0)
+    800060e2:	0b053903          	ld	s2,176(a0)
+    800060e6:	0b853983          	ld	s3,184(a0)
+    800060ea:	0c053a03          	ld	s4,192(a0)
+    800060ee:	0c853a83          	ld	s5,200(a0)
+    800060f2:	0d053b03          	ld	s6,208(a0)
+    800060f6:	0d853b83          	ld	s7,216(a0)
+    800060fa:	0e053c03          	ld	s8,224(a0)
+    800060fe:	0e853c83          	ld	s9,232(a0)
+    80006102:	0f053d03          	ld	s10,240(a0)
+    80006106:	0f853d83          	ld	s11,248(a0)
+    8000610a:	10053e03          	ld	t3,256(a0)
+    8000610e:	10853e83          	ld	t4,264(a0)
+    80006112:	11053f03          	ld	t5,272(a0)
+    80006116:	11853f83          	ld	t6,280(a0)
+    8000611a:	7928                	ld	a0,112(a0)
+    8000611c:	10200073          	sret
+	...
diff -ruN xv6-riscv/kernel/kernel.sym xv62/kernel/kernel.sym
--- xv6-riscv/kernel/kernel.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/kernel.sym	2025-09-14 12:32:49.940883507 +0000
@@ -0,0 +1,268 @@
+0000000080000000 .text
+0000000080007000 .rodata
+0000000080007858 .eh_frame
+000000008000a190 .data
+000000008000a1a0 .got
+000000008000a1b0 .got.plt
+000000008000a1c0 .bss
+0000000000000000 .riscv.attributes
+0000000000000000 .comment
+0000000000000000 .debug_line
+0000000000000000 .debug_line_str
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_aranges
+0000000000000000 .debug_str
+0000000000000000 .debug_loc
+0000000000000000 .debug_ranges
+0000000000000000 entry.o
+000000008000001a spin
+0000000000000000 start.c
+0000000000000000 console.c
+0000000000000000 printf.c
+0000000080000468 printint
+0000000080007740 digits
+00000000800122a8 pr
+0000000000000000 uart.c
+000000008000a1cc tx_busy
+000000008000a1c8 tx_chan
+00000000800122c0 tx_lock
+0000000000000000 kalloc.c
+0000000000000000 spinlock.c
+0000000000000000 string.c
+0000000000000000 main.c
+000000008000a1d0 started
+0000000000000000 vm.c
+0000000000000000 proc.c
+000000008000a190 first.1
+0000000080001a9e freeproc
+0000000080001aee allocproc
+0000000080007758 states.0
+0000000000000000 swtch.o
+0000000000000000 trap.c
+0000000000000000 syscall.c
+0000000080002720 argraw
+00000000800077a0 syscalls
+0000000000000000 sysproc.c
+0000000000000000 bio.c
+0000000000000000 fs.c
+0000000080002d2c bfree
+0000000080002d98 balloc
+0000000080002eb8 bmap
+0000000080002f8c iget
+000000008000384c namex
+0000000000000000 log.c
+0000000080003a48 write_head
+0000000080003aa6 install_trans
+0000000000000000 sleeplock.c
+0000000000000000 file.c
+0000000000000000 pipe.c
+0000000000000000 exec.c
+0000000000000000 sysfile.c
+0000000080004966 argfd
+00000000800049be fdalloc
+00000000800049fc create
+0000000000000000 kernelvec.o
+0000000000000000 plic.c
+0000000000000000 virtio_disk.c
+0000000080005482 free_desc
+0000000080023dc8 disk
+000000008000a1a0 _GLOBAL_OFFSET_TABLE_
+00000000800029b2 sys_pause
+0000000080000fee mappages
+0000000080001488 copyinstr
+000000008000016e consoleread
+0000000080000de0 safestrcpy
+0000000080004c38 sys_close
+0000000080001eb0 yield
+0000000080022cc8 log
+00000000800122d8 kmem
+0000000080000840 uartinit
+0000000080002238 either_copyout
+000000008000001c timerinit
+0000000080012728 proc
+0000000080004116 fileread
+00000000800004fa printf
+0000000080002946 sys_sbrk
+0000000080006000 trampoline
+000000008000a1c0 panicked
+000000008000543c plic_claim
+00000000800053ee plicinit
+000000008000213e kwait
+000000008000545c plic_complete
+0000000080001df6 sched
+0000000080000cfe memmove
+0000000080002872 syscall
+00000000800018a2 cpuid
+000000008000368c writei
+0000000080002910 sys_fork
+0000000080018b40 bcache
+000000008000508c sys_mkdir
+00000000800011ba uvmunmap
+000000008000379a namecmp
+0000000080005408 plicinithart
+0000000080001f92 reparent
+0000000080002842 argstr
+0000000080001244 uvmdealloc
+0000000080003fb0 filedup
+0000000080003a16 namei
+0000000080002aae binit
+000000008000145e uvmclear
+0000000080004b82 sys_read
+00000000800045f4 kexec
+00000000800034f4 fsinit
+0000000080000d5a memcpy
+000000008000109e kvmmap
+0000000080000a1c kfree
+00000000800018b2 mycpu
+0000000080003382 iput
+00000000800010c6 kvmmake
+000000008000250e devintr
+000000008000a194 nextpid
+0000000080003f2e fileinit
+000000008000609c userret
+0000000080000b4e initlock
+00000000800015e2 copyout
+0000000080001edc sleep
+0000000080005390 kernelvec
+000000008000342a ireclaim
+0000000080003566 stati
+0000000080012310 wait_lock
+0000000080002a52 sys_kill
+00000000800043c8 pipeclose
+0000000080004c7a sys_fstat
+00000000800000d0 consolewrite
+0000000080003c54 end_op
+0000000080000a82 freerange
+0000000080000eee kvminithart
+0000000080001288 uvmalloc
+00000000800013c0 uvmcopy
+000000008000a1e0 initproc
+0000000080001a58 proc_freepagetable
+0000000080001540 ismapped
+00000000800032ae iunlock
+00000000800019d4 proc_pagetable
+000000008000a200 stack0
+0000000080004bdc sys_getreadcount
+0000000080004cb4 sys_link
+0000000080003f52 filealloc
+0000000080001f28 wakeup
+00000000800054f8 virtio_disk_init
+00000000800018ce myproc
+00000000800031ca idup
+0000000080000f16 walk
+0000000080004f38 sys_open
+0000000080000898 uartwrite
+0000000080003590 readi
+00000000800002aa consoleintr
+0000000080000278 consputc
+0000000080001996 allocpid
+0000000080003090 ialloc
+0000000080001fe8 kexit
+00000000800009b0 uartintr
+00000000800016c6 copyin
+0000000080002404 trapinit
+000000008000138e uvmfree
+0000000080023f08 end
+00000000800032ee itrunc
+00000000800041d4 filewrite
+000000008000280a argint
+0000000080007000 etext
+0000000080004bf0 sys_write
+0000000080000c66 release
+00000000800027ca fetchstr
+0000000080001d52 scheduler
+0000000080006000 _trampoline
+00000000800037b0 dirlookup
+0000000080003bea begin_op
+0000000080003ff6 fileclose
+0000000080002582 usertrap
+0000000080000d6e strncmp
+0000000080018b28 tickslock
+0000000080004420 pipewrite
+000000008000a1f0 goongng
+0000000080000da4 strncpy
+0000000080022e10 ftable
+0000000080005902 virtio_disk_intr
+0000000080004b36 sys_dup
+00000000800007e0 panic
+00000000800018fe forkret
+0000000080000aca kinit
+0000000080000cc4 memcmp
+0000000080002282 either_copyin
+00000000800024ba clockintr
+0000000080012328 cpus
+0000000080003eac releasesleep
+0000000080000000 _entry
+0000000080000b64 holding
+0000000080021200 sb
+0000000080000bce acquire
+0000000080003a30 nameiparent
+0000000080002428 trapinithart
+000000008000314c iupdate
+0000000080000ca2 memset
+0000000080000e3c main
+00000000800020f0 setkilled
+000000008000208a kkill
+0000000080003d6e log_write
+0000000080003e66 acquiresleep
+0000000080004db2 sys_unlink
+0000000080006000 uservec
+0000000080001178 kvminit
+0000000080002cf8 bunpin
+0000000080002826 argaddr
+0000000080002440 prepare_return
+0000000080002a74 sys_uptime
+000000008000098a uartgetc
+000000008000081c printfinit
+0000000080001194 uvmcreate
+0000000080001bf4 growproc
+0000000080003ee4 holdingsleep
+0000000080002114 killed
+0000000080001bb8 userinit
+0000000080002b34 bread
+0000000080004504 piperead
+000000008000a1e8 ticks
+0000000080000424 consoleinit
+0000000080000fb0 walkaddr
+0000000080001560 vmfault
+00000000800022cc procdump
+0000000080002c3c brelse
+0000000080003200 ilock
+00000000800051b4 sys_exec
+000000008000239a swtch
+000000008000340a iunlockput
+0000000080000b8e push_off
+00000000800045da flags2perm
+0000000080000c12 pop_off
+0000000080002c0a bwrite
+0000000080001c44 kfork
+000000008000092c uartputc_sync
+000000008000a1c4 panicking
+000000008000132e freewalk
+0000000080002924 sys_wait
+00000000800028d6 sys_exit
+000000008000397c dirlink
+0000000080003e30 initsleeplock
+0000000080000060 start
+000000008000a1d8 kernel_pagetable
+00000000800056f0 virtio_disk_rw
+0000000080000e12 strlen
+00000000800052a8 sys_pipe
+0000000080003038 iinit
+0000000080003b6c initlog
+0000000080012200 cons
+0000000080000afe kalloc
+0000000080002780 fetchaddr
+0000000080022d70 devsw
+00000000800028fa sys_getpid
+0000000080004300 pipealloc
+0000000080005134 sys_chdir
+0000000080001754 proc_mapstacks
+0000000080002690 kerneltrap
+0000000080002cc4 bpin
+00000000800017ec procinit
+0000000080021220 itable
+00000000800050d4 sys_mknod
+00000000800040b8 filestat
+00000000800122f8 pid_lock
Binary files xv6-riscv/kernel/kernelvec.o and xv62/kernel/kernelvec.o differ
diff -ruN xv6-riscv/kernel/log.d xv62/kernel/log.d
--- xv6-riscv/kernel/log.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/log.d	2025-09-14 12:32:49.488883600 +0000
@@ -0,0 +1,3 @@
+kernel/log.o: kernel/log.c kernel/types.h kernel/riscv.h kernel/defs.h \
+ kernel/param.h kernel/spinlock.h kernel/sleeplock.h kernel/fs.h \
+ kernel/buf.h
Binary files xv6-riscv/kernel/log.o and xv62/kernel/log.o differ
diff -ruN xv6-riscv/kernel/main.d xv62/kernel/main.d
--- xv6-riscv/kernel/main.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/main.d	2025-09-14 12:32:48.844883732 +0000
@@ -0,0 +1,2 @@
+kernel/main.o: kernel/main.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/defs.h
Binary files xv6-riscv/kernel/main.o and xv62/kernel/main.o differ
diff -ruN xv6-riscv/kernel/pipe.d xv62/kernel/pipe.d
--- xv6-riscv/kernel/pipe.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/pipe.d	2025-09-14 12:32:49.612883574 +0000
@@ -0,0 +1,3 @@
+kernel/pipe.o: kernel/pipe.c kernel/types.h kernel/riscv.h kernel/defs.h \
+ kernel/param.h kernel/spinlock.h kernel/proc.h kernel/fs.h \
+ kernel/sleeplock.h kernel/file.h
Binary files xv6-riscv/kernel/pipe.o and xv62/kernel/pipe.o differ
diff -ruN xv6-riscv/kernel/plic.d xv62/kernel/plic.d
--- xv6-riscv/kernel/plic.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/plic.d	2025-09-14 12:32:49.820883532 +0000
@@ -0,0 +1,2 @@
+kernel/plic.o: kernel/plic.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/defs.h
Binary files xv6-riscv/kernel/plic.o and xv62/kernel/plic.o differ
diff -ruN xv6-riscv/kernel/printf.d xv62/kernel/printf.d
--- xv6-riscv/kernel/printf.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/printf.d	2025-09-14 12:32:48.644883773 +0000
@@ -0,0 +1,5 @@
+kernel/printf.o: kernel/printf.c \
+ /usr/lib/gcc-cross/riscv64-linux-gnu/13/include/stdarg.h kernel/types.h \
+ kernel/param.h kernel/spinlock.h kernel/sleeplock.h kernel/fs.h \
+ kernel/file.h kernel/memlayout.h kernel/riscv.h kernel/defs.h \
+ kernel/proc.h
Binary files xv6-riscv/kernel/printf.o and xv62/kernel/printf.o differ
diff -ruN xv6-riscv/kernel/proc.c xv62/kernel/proc.c
--- xv6-riscv/kernel/proc.c	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/proc.c	2025-09-14 12:29:50.168920120 +0000
@@ -106,6 +106,70 @@
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
 // If there are no free procs, or a memory allocation fails, return 0.
+#ifdef CFS
+// Calculate weight based on nice value
+// Approximation: weight = 1024 / (1.25 ^ nice)
+static uint64
+calculate_weight(int nice)
+{
+  if (nice == 0) return 1024;
+  if (nice == -20) return 88761;
+  if (nice == 19) return 15;
+  
+  // Simple approximation for other values
+  uint64 weight = 1024;
+  if (nice > 0) {
+    for (int i = 0; i < nice; i++) {
+      weight = (weight * 4) / 5; // Approximate division by 1.25
+    }
+  } else {
+    for (int i = 0; i < -nice; i++) {
+      weight = (weight * 5) / 4; // Approximate multiplication by 1.25
+    }
+  }
+  return weight > 0 ? weight : 1;
+}
+
+// Calculate time slice for a process
+static uint64
+calculate_time_slice(int runnable_count)
+{
+  const uint64 target_latency = 48;
+  const uint64 min_time_slice = 3;
+  
+  if (runnable_count <= 0) return min_time_slice;
+  
+  uint64 slice = target_latency / runnable_count;
+  return slice < min_time_slice ? min_time_slice : slice;
+}
+#endif
+
+
+#ifdef CFS
+// Update p->vruntime by ran_ticks (number of real ticks the process ran).
+static void
+update_vruntime(struct proc *p, uint64 ran_ticks)
+{
+  if (p == 0 || ran_ticks == 0)
+    return;
+
+  const uint64 NICE0 = 1024ULL;
+
+  // Multiply first to avoid truncation
+  uint64 numer = ran_ticks * NICE0;
+  uint64 delta = numer / (p->weight > 0 ? p->weight : 1);
+
+  // Optional debug print (use printf, not cprintf)
+  // printf("update_vruntime: pid=%d ran=%d weight=%d delta=%d\n",
+  //        p->pid, (int)ran_ticks, (int)p->weight, (int)delta);
+
+  p->vruntime += delta;
+
+  // Clear slice_start; scheduler will set it when next scheduled.
+  p->slice_start = 0;
+}
+#endif
+
 static struct proc*
 allocproc(void)
 {
@@ -146,9 +210,26 @@
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
+  // Initialize scheduling fields
+ // Initialize scheduling fields
+         p->creation_time = ticks;  // Set creation time
+         p->nice = 0;               // Default nice value
+         p->vruntime = 0;           // Initialize virtual runtime
+         #ifdef CFS
+         p->weight = calculate_weight(p->nice); // Use the function
+         #else
+         p->weight = 1024;          // Default weight for non-CFS
+         #endif
+         
+         #ifdef MLFQ
+         // Initialize MLFQ-specific fields
+         mlfq_init_process(p);
+         #endif
+  p->time_slice = 0;
+  p->slice_start = 0;
+
   return p;
 }
-
 // free a proc structure and the data hanging from it,
 // including user pages.
 // p->lock must be held.
@@ -417,48 +498,126 @@
 //  - choose a process to run.
 //  - swtch to start running that process.
 //  - eventually that process transfers control
-//    via swtch back to the scheduler.
+//wait aa minute lemme send you my current scheduler so you know whats happening. this one works very well so yeah dont change the current fcfs and cfs
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run.
+//  - swtch to start running that process.
+//  - eventually that process transfers control
 void
 scheduler(void)
 {
-  struct proc *p;
+ // struct proc *p;
   struct cpu *c = mycpu();
-
+  
   c->proc = 0;
   for(;;){
-    // The most recent process to run may have had interrupts
-    // turned off; enable them to avoid a deadlock if all
-    // processes are waiting. Then turn them back off
-    // to avoid a possible race between an interrupt
-    // and wfi.
     intr_on();
-    intr_off();
-
-    int found = 0;
+   intr_off();
+    
+#ifdef FCFS
+	struct proc *p;
+    // First Come First Serve Scheduler
+    struct proc *earliest = 0;
+    uint64 earliest_time = 0;
+    
+    for(p = proc; p < &proc[NPROC]; p++) {
+      acquire(&p->lock);
+      if(p->state == RUNNABLE) {
+        if(earliest == 0 || p->creation_time < earliest_time) {
+          if(earliest) release(&earliest->lock);
+          earliest = p;
+          earliest_time = p->creation_time;
+        } else {
+          release(&p->lock);
+        }
+      } else {
+        release(&p->lock);
+      }
+    }
+    
+    if(earliest) {
+      earliest->state = RUNNING;
+      c->proc = earliest;
+      swtch(&c->context, &earliest->context);
+      c->proc = 0;
+      release(&earliest->lock);
+    }
+#elif defined(CFS)
+	struct proc *p; // <-- ADD THIS LINE	
+    // Completely Fair Scheduler
+    struct proc *chosen = 0;
+    uint64 min_vruntime = ~0;
+    int runnable_count = 0;
+   // static struct proc *last_scheduled = 0; // Track last scheduled process
+    
+    // First pass: count runnable processes and find minimum vruntime
     for(p = proc; p < &proc[NPROC]; p++) {
       acquire(&p->lock);
       if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
-        found = 1;
+        runnable_count++;
+        if(p->vruntime < min_vruntime) {
+          min_vruntime = p->vruntime;
+          chosen = p;
+        }
       }
       release(&p->lock);
     }
-    if(found == 0) {
-      // nothing to run; stop running on this core until an interrupt.
-      asm volatile("wfi");
+    
+  if(chosen) {
+    // Print every scheduling decision as required by assignment
+    printf("[Scheduler Tick]\n");
+    for(p = proc; p < &proc[NPROC]; p++) {
+      acquire(&p->lock);
+      if(p->state == RUNNABLE) {
+        printf("PID: %d | vRuntime: %ld\n", p->pid, p->vruntime);
+      }
+      release(&p->lock);
     }
+    printf("--> Scheduling PID %d (lowest vRuntime)\n", chosen->pid);
+    
+    // Calculate time slice
+    chosen->time_slice = calculate_time_slice(runnable_count);
+    chosen->slice_start = ticks;
+    
+    acquire(&chosen->lock);
+    if(chosen->state == RUNNABLE) {
+      chosen->state = RUNNING;
+      c->proc = chosen;
+      swtch(&c->context, &chosen->context);
+      c->proc = 0;
+    }
+    release(&chosen->lock);
+  } else {
+    asm volatile("wfi");
+  }
+
+  #else
+          // Default Round-Robin
+          struct proc *p;
+          
+          // Loop through the processes to find a runnable one
+          for (p = proc; p < &proc[NPROC]; p++) {
+              acquire(&p->lock);
+              if (p->state == RUNNABLE) {
+                  // Found a runnable process, switch to it
+                  p->state = RUNNING;
+                  c->proc = p;
+                  swtch(&c->context, &p->context);
+  
+                  // Process has yielded or been preempted
+                  c->proc = 0;
+                  release(&p->lock);
+                  break; // Exit the inner loop
+              }
+              release(&p->lock);
+          }
+#endif
   }
 }
 
+
 // Switch to scheduler.  Must hold only p->lock
 // and have changed proc->state. Saves and restores
 // intena because intena is a property of this
@@ -492,11 +651,23 @@
 {
   struct proc *p = myproc();
   acquire(&p->lock);
+
+#ifdef CFS
+  // compute how many ticks this process actually ran in this slice
+  if (p->slice_start != 0) {
+    uint64 ran = ticks - p->slice_start;
+    if (ran > 0)
+      update_vruntime(p, ran);
+  }
+  // mark as runnable and let scheduler pick next (vruntime updated)
+#endif
+
   p->state = RUNNABLE;
   sched();
   release(&p->lock);
 }
 
+
 // A fork child's very first scheduling by scheduler()
 // will swtch to forkret.
 void
@@ -553,6 +724,14 @@
 
   // Go to sleep.
   p->chan = chan;
+  #ifdef CFS
+    if (p->slice_start != 0) {
+      uint64 ran = ticks - p->slice_start;
+      if (ran > 0)
+        update_vruntime(p, ran);
+    }
+  #endif
+  
   p->state = SLEEPING;
 
   sched();
@@ -659,6 +838,44 @@
 // Print a process listing to console.  For debugging.
 // Runs when user types ^P on console.
 // No lock to avoid wedging a stuck machine further.
+
+
+// 
+//  void
+//  procdump(void)
+//  {
+//    static char *states[] = {
+//    [UNUSED]    "unused",
+//    [USED]      "used",
+//    [SLEEPING]  "sleep ",
+//    [RUNNABLE]  "runble",
+//    [RUNNING]   "run   ",
+//    [ZOMBIE]    "zombie"
+//    };
+//   // int i;
+//    struct proc *p;
+//    char *state;
+//  
+//    printf("\n");
+//    for(p = proc; p < &proc[NPROC]; p++){
+//      if(p->state == UNUSED)
+//        continue;
+//      if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+//        state = states[p->state];
+//      else
+//        state = "???";
+//      
+//  #ifdef CFS
+//     printf("%d %s %s ctime:%d vtime:%ld nice:%d weight:%ld\n", 
+//            p->pid, state, p->name, (int)p->creation_time, p->vruntime, p->nice, p->weight);
+//  #elif defined(FCFS)
+//      printf("%d %s %s %d\n", p->pid, state, p->name, p->creation_time);
+//  #else
+//      printf("%d %s %s\n", p->pid, state, p->name);
+//  #endif
+//    }
+//  }
+
 void
 procdump(void)
 {
@@ -670,18 +887,46 @@
   [RUNNING]   "run   ",
   [ZOMBIE]    "zombie"
   };
+  
   struct proc *p;
   char *state;
 
   printf("\n");
+  
+#ifdef CFS
+  printf("PID\tSTATE\t\tNAME\t\tCTIME\tVTIME\t\tNICE\tWEIGHT\n");
+  printf("---\t-----\t\t----\t\t-----\t-----\t\t----\t------\n");
+#elif defined(FCFS)
+  printf("PID\tSTATE\t\tNAME\t\tCREATION_TIME\n");
+  printf("---\t-----\t\t----\t\t-------------\n");
+#else
+  printf("PID\tSTATE\t\tNAME\n");
+  printf("---\t-----\t\t----\n");
+#endif
+
   for(p = proc; p < &proc[NPROC]; p++){
-    if(p->state == UNUSED)
+    acquire(&p->lock);
+    
+    if(p->state == UNUSED) {
+      release(&p->lock);
       continue;
+    }
+    
     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
       state = states[p->state];
     else
       state = "???";
-    printf("%d %s %s", p->pid, state, p->name);
-    printf("\n");
+    
+#ifdef CFS
+    printf("%d\t%s\t%s\t\t%d\t%ld\t\t%d\t%ld\n", 
+           p->pid, state, p->name, (int)p->creation_time, p->vruntime, p->nice, p->weight);
+#elif defined(FCFS)
+    printf("%d\t%s\t%s\t\t%d\n", p->pid, state, p->name, (int)p->creation_time);
+#else
+    printf("%d\t%s\t%s\n", p->pid, state, p->name);
+#endif
+    
+    release(&p->lock);
   }
+  printf("\n");
 }
diff -ruN xv6-riscv/kernel/proc.d xv62/kernel/proc.d
--- xv6-riscv/kernel/proc.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/proc.d	2025-09-14 12:32:49.048883690 +0000
@@ -0,0 +1,3 @@
+kernel/proc.o: kernel/proc.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/spinlock.h kernel/proc.h \
+ kernel/defs.h
diff -ruN xv6-riscv/kernel/proc.h xv62/kernel/proc.h
--- xv6-riscv/kernel/proc.h	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/proc.h	2025-09-13 14:34:47.209963898 +0000
@@ -104,4 +104,10 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  uint creation_time;
+    int nice;                    // Nice value (-20 to 19)
+    uint64 vruntime;            // Virtual runtime for CFS
+    uint64 weight;              // Weight based on nice value
+    uint64 time_slice;          // Current time slice
+    uint64 slice_start;
 };
Binary files xv6-riscv/kernel/proc.o and xv62/kernel/proc.o differ
diff -ruN xv6-riscv/kernel/proc2.c xv62/kernel/proc2.c
--- xv6-riscv/kernel/proc2.c	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/proc2.c	2025-09-13 14:34:47.217297232 +0000
@@ -0,0 +1,693 @@
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "riscv.h"
+#include "spinlock.h"
+#include "proc.h"
+#include "defs.h"
+
+struct cpu cpus[NCPU];
+
+struct proc proc[NPROC];
+
+struct proc *initproc;
+
+int nextpid = 1;
+struct spinlock pid_lock;
+
+extern void forkret(void);
+static void freeproc(struct proc *p);
+
+extern char trampoline[]; // trampoline.S
+
+// helps ensure that wakeups of wait()ing
+// parents are not lost. helps obey the
+// memory model when using p->parent.
+// must be acquired before any p->lock.
+struct spinlock wait_lock;
+
+// Allocate a page for each process's kernel stack.
+// Map it high in memory, followed by an invalid
+// guard page.
+void
+proc_mapstacks(pagetable_t kpgtbl)
+{
+  struct proc *p;
+  
+  for(p = proc; p < &proc[NPROC]; p++) {
+    char *pa = kalloc();
+    if(pa == 0)
+      panic("kalloc");
+    uint64 va = KSTACK((int) (p - proc));
+    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+  }
+}
+
+// initialize the proc table.
+void
+procinit(void)
+{
+  struct proc *p;
+  
+  initlock(&pid_lock, "nextpid");
+  initlock(&wait_lock, "wait_lock");
+  for(p = proc; p < &proc[NPROC]; p++) {
+      initlock(&p->lock, "proc");
+      p->state = UNUSED;
+      p->kstack = KSTACK((int) (p - proc));
+  }
+}
+
+// Must be called with interrupts disabled,
+// to prevent race with process being moved
+// to a different CPU.
+int
+cpuid()
+{
+  int id = r_tp();
+  return id;
+}
+
+// Return this CPU's cpu struct.
+// Interrupts must be disabled.
+struct cpu*
+mycpu(void)
+{
+  int id = cpuid();
+  struct cpu *c = &cpus[id];
+  return c;
+}
+
+// Return the current struct proc *, or zero if none.
+struct proc*
+myproc(void)
+{
+  push_off();
+  struct cpu *c = mycpu();
+  struct proc *p = c->proc;
+  pop_off();
+  return p;
+}
+
+int
+allocpid()
+{
+  int pid;
+  
+  acquire(&pid_lock);
+  pid = nextpid;
+  nextpid = nextpid + 1;
+  release(&pid_lock);
+
+  return pid;
+}
+
+// Look in the process table for an UNUSED proc.
+// If found, initialize state required to run in the kernel,
+// and return with p->lock held.
+// If there are no free procs, or a memory allocation fails, return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    acquire(&p->lock);
+    if(p->state == UNUSED) {
+      goto found;
+    } else {
+      release(&p->lock);
+    }
+  }
+  return 0;
+
+found:
+  p->pid = allocpid();
+   p->creation_time = ticks;
+  p->state = USED;
+
+  // Allocate a trapframe page.
+  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // An empty user page table.
+  p->pagetable = proc_pagetable(p);
+  if(p->pagetable == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // Set up new context to start executing at forkret,
+  // which returns to user space.
+  memset(&p->context, 0, sizeof(p->context));
+  p->context.ra = (uint64)forkret;
+  p->context.sp = p->kstack + PGSIZE;
+
+  return p;
+}
+
+// free a proc structure and the data hanging from it,
+// including user pages.
+// p->lock must be held.
+static void
+freeproc(struct proc *p)
+{
+  if(p->trapframe)
+    kfree((void*)p->trapframe);
+  p->trapframe = 0;
+  if(p->pagetable)
+    proc_freepagetable(p->pagetable, p->sz);
+  p->pagetable = 0;
+  p->sz = 0;
+  p->pid = 0;
+  p->parent = 0;
+  p->name[0] = 0;
+  p->chan = 0;
+  p->killed = 0;
+  p->xstate = 0;
+  p->state = UNUSED;
+}
+
+// Create a user page table for a given process, with no user memory,
+// but with trampoline and trapframe pages.
+pagetable_t
+proc_pagetable(struct proc *p)
+{
+  pagetable_t pagetable;
+
+  // An empty page table.
+  pagetable = uvmcreate();
+  if(pagetable == 0)
+    return 0;
+
+  // map the trampoline code (for system call return)
+  // at the highest user virtual address.
+  // only the supervisor uses it, on the way
+  // to/from user space, so not PTE_U.
+  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
+              (uint64)trampoline, PTE_R | PTE_X) < 0){
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
+  // map the trapframe page just below the trampoline page, for
+  // trampoline.S.
+  if(mappages(pagetable, TRAPFRAME, PGSIZE,
+              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
+  return pagetable;
+}
+
+// Free a process's page table, and free the
+// physical memory it refers to.
+void
+proc_freepagetable(pagetable_t pagetable, uint64 sz)
+{
+  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmfree(pagetable, sz);
+}
+
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+
+  p = allocproc();
+  initproc = p;
+  
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+
+  release(&p->lock);
+}
+
+// Shrink user memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint64 sz;
+  struct proc *p = myproc();
+
+  sz = p->sz;
+  if(n > 0){
+    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+      return -1;
+    }
+  } else if(n < 0){
+    sz = uvmdealloc(p->pagetable, sz, sz + n);
+  }
+  p->sz = sz;
+  return 0;
+}
+
+// Create a new process, copying the parent.
+// Sets up child kernel stack to return as if from fork() system call.
+int
+kfork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
+
+  // Copy user memory from parent to child.
+  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+    freeproc(np);
+    release(&np->lock);
+    return -1;
+  }
+  np->sz = p->sz;
+
+  // copy saved user registers.
+  *(np->trapframe) = *(p->trapframe);
+
+  // Cause fork to return 0 in the child.
+  np->trapframe->a0 = 0;
+
+  // increment reference counts on open file descriptors.
+  for(i = 0; i < NOFILE; i++)
+    if(p->ofile[i])
+      np->ofile[i] = filedup(p->ofile[i]);
+  np->cwd = idup(p->cwd);
+
+  safestrcpy(np->name, p->name, sizeof(p->name));
+
+  pid = np->pid;
+
+  release(&np->lock);
+
+  acquire(&wait_lock);
+  np->parent = p;
+  release(&wait_lock);
+
+  acquire(&np->lock);
+  np->state = RUNNABLE;
+  release(&np->lock);
+
+  return pid;
+}
+
+// Pass p's abandoned children to init.
+// Caller must hold wait_lock.
+void
+reparent(struct proc *p)
+{
+  struct proc *pp;
+
+  for(pp = proc; pp < &proc[NPROC]; pp++){
+    if(pp->parent == p){
+      pp->parent = initproc;
+      wakeup(initproc);
+    }
+  }
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait().
+void
+kexit(int status)
+{
+  struct proc *p = myproc();
+
+  if(p == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(int fd = 0; fd < NOFILE; fd++){
+    if(p->ofile[fd]){
+      struct file *f = p->ofile[fd];
+      fileclose(f);
+      p->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(p->cwd);
+  end_op();
+  p->cwd = 0;
+
+  acquire(&wait_lock);
+
+  // Give any children to init.
+  reparent(p);
+
+  // Parent might be sleeping in wait().
+  wakeup(p->parent);
+  
+  acquire(&p->lock);
+
+  p->xstate = status;
+  p->state = ZOMBIE;
+
+  release(&wait_lock);
+
+  // Jump into the scheduler, never to return.
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+kwait(uint64 addr)
+{
+  struct proc *pp;
+  int havekids, pid;
+  struct proc *p = myproc();
+
+  acquire(&wait_lock);
+
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+      if(pp->parent == p){
+        // make sure the child isn't still in exit() or swtch().
+        acquire(&pp->lock);
+
+        havekids = 1;
+        if(pp->state == ZOMBIE){
+          // Found one.
+          pid = pp->pid;
+          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+                                  sizeof(pp->xstate)) < 0) {
+            release(&pp->lock);
+            release(&wait_lock);
+            return -1;
+          }
+          freeproc(pp);
+          release(&pp->lock);
+          release(&wait_lock);
+          return pid;
+        }
+        release(&pp->lock);
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || killed(p)){
+      release(&wait_lock);
+      return -1;
+    }
+    
+    // Wait for a child to exit.
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+  }
+}
+
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run.
+//  - swtch to start running that process.
+//  - eventually that process transfers control
+void
+scheduler(void)
+{
+  struct proc *p;
+  struct cpu *c = mycpu();
+
+  c->proc = 0;
+  for(;;){
+    // The most recent process to run may have had interrupts
+    // turned off; enable them to avoid a deadlock if all
+    // processes are waiting. Then turn them back off
+    // to avoid a possible race between an interrupt
+    // and wfi.
+    intr_on();
+    intr_off();
+
+    int found = 0;
+    for(p = proc; p < &proc[NPROC]; p++) {
+      acquire(&p->lock);
+      if(p->state == RUNNABLE) {
+        // Switch to chosen process.  It is the process's job
+        // to release its lock and then reacquire it
+        // before jumping back to us.
+        p->state = RUNNING;
+        c->proc = p;
+        swtch(&c->context, &p->context);
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+        found = 1;
+      }
+      release(&p->lock);
+    }
+    if(found == 0) {
+      // nothing to run; stop running on this core until an interrupt.
+      asm volatile("wfi");
+    }
+  }
+}
+
+
+
+
+
+// Switch to scheduler.  Must hold only p->lock
+// and have changed proc->state. Saves and restores
+// intena because intena is a property of this
+// kernel thread, not this CPU. It should
+// be proc->intena and proc->noff, but that would
+// break in the few places where a lock is held but
+// there's no process.
+void
+sched(void)
+{
+  int intena;
+  struct proc *p = myproc();
+
+  if(!holding(&p->lock))
+    panic("sched p->lock");
+  if(mycpu()->noff != 1)
+    panic("sched locks");
+  if(p->state == RUNNING)
+    panic("sched RUNNING");
+  if(intr_get())
+    panic("sched interruptible");
+
+  intena = mycpu()->intena;
+  swtch(&p->context, &mycpu()->context);
+  mycpu()->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  struct proc *p = myproc();
+  acquire(&p->lock);
+  p->state = RUNNABLE;
+  sched();
+  release(&p->lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch to forkret.
+void
+forkret(void)
+{
+  extern char userret[];
+  static int first = 1;
+  struct proc *p = myproc();
+
+  // Still holding p->lock from scheduler.
+  release(&p->lock);
+
+  if (first) {
+    // File system initialization must be run in the context of a
+    // regular process (e.g., because it calls sleep), and thus cannot
+    // be run from main().
+    fsinit(ROOTDEV);
+
+    first = 0;
+    // ensure other cores see first=0.
+    __sync_synchronize();
+
+    // We can invoke kexec() now that file system is initialized.
+    // Put the return value (argc) of kexec into a0.
+    p->trapframe->a0 = kexec("/init", (char *[]){ "/init", 0 });
+    if (p->trapframe->a0 == -1) {
+      panic("exec");
+    }
+  }
+
+  // return to user space, mimicing usertrap()'s return.
+  prepare_return();
+  uint64 satp = MAKE_SATP(p->pagetable);
+  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
+  ((void (*)(uint64))trampoline_userret)(satp);
+}
+
+// Sleep on channel chan, releasing condition lock lk.
+// Re-acquires lk when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  struct proc *p = myproc();
+  
+  // Must acquire p->lock in order to
+  // change p->state and then call sched.
+  // Once we hold p->lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup locks p->lock),
+  // so it's okay to release lk.
+
+  acquire(&p->lock);  //DOC: sleeplock1
+  release(lk);
+
+  // Go to sleep.
+  p->chan = chan;
+  p->state = SLEEPING;
+
+  sched();
+
+  // Tidy up.
+  p->chan = 0;
+
+  // Reacquire original lock.
+  release(&p->lock);
+  acquire(lk);
+}
+
+// Wake up all processes sleeping on channel chan.
+// Caller should hold the condition lock.
+void
+wakeup(void *chan)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    if(p != myproc()){
+      acquire(&p->lock);
+      if(p->state == SLEEPING && p->chan == chan) {
+        p->state = RUNNABLE;
+      }
+      release(&p->lock);
+    }
+  }
+}
+
+// Kill the process with the given pid.
+// The victim won't exit until it tries to return
+// to user space (see usertrap() in trap.c).
+int
+kkill(int pid)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++){
+    acquire(&p->lock);
+    if(p->pid == pid){
+      p->killed = 1;
+      if(p->state == SLEEPING){
+        // Wake process from sleep().
+        p->state = RUNNABLE;
+      }
+      release(&p->lock);
+      return 0;
+    }
+    release(&p->lock);
+  }
+  return -1;
+}
+
+void
+setkilled(struct proc *p)
+{
+  acquire(&p->lock);
+  p->killed = 1;
+  release(&p->lock);
+}
+
+int
+killed(struct proc *p)
+{
+  int k;
+  
+  acquire(&p->lock);
+  k = p->killed;
+  release(&p->lock);
+  return k;
+}
+
+// Copy to either a user address, or kernel address,
+// depending on usr_dst.
+// Returns 0 on success, -1 on error.
+int
+either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+{
+  struct proc *p = myproc();
+  if(user_dst){
+    return copyout(p->pagetable, dst, src, len);
+  } else {
+    memmove((char *)dst, src, len);
+    return 0;
+  }
+}
+
+// Copy from either a user address, or kernel address,
+// depending on usr_src.
+// Returns 0 on success, -1 on error.
+int
+either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+{
+  struct proc *p = myproc();
+  if(user_src){
+    return copyin(p->pagetable, dst, src, len);
+  } else {
+    memmove(dst, (char*)src, len);
+    return 0;
+  }
+}
+
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+
+
+void procdump(void) {
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [USED]      "used",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  struct proc *p;
+  char *state;
+
+  printf("PID\tNAME\tSTATE\tCREATION_TIME\n"); // Print header
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+
+    // Print process information including creation time
+    printf("%d\t%s\t%s\t%d\n", p->pid, p->name, state, p->creation_time);
+  }
+}
diff -ruN xv6-riscv/kernel/sleeplock.d xv62/kernel/sleeplock.d
--- xv6-riscv/kernel/sleeplock.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/sleeplock.d	2025-09-14 12:32:49.520883594 +0000
@@ -0,0 +1,3 @@
+kernel/sleeplock.o: kernel/sleeplock.c kernel/types.h kernel/riscv.h \
+ kernel/defs.h kernel/param.h kernel/memlayout.h kernel/spinlock.h \
+ kernel/proc.h kernel/sleeplock.h
Binary files xv6-riscv/kernel/sleeplock.o and xv62/kernel/sleeplock.o differ
diff -ruN xv6-riscv/kernel/spinlock.d xv62/kernel/spinlock.d
--- xv6-riscv/kernel/spinlock.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/spinlock.d	2025-09-14 12:32:48.752883751 +0000
@@ -0,0 +1,3 @@
+kernel/spinlock.o: kernel/spinlock.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/spinlock.h kernel/riscv.h kernel/proc.h \
+ kernel/defs.h
Binary files xv6-riscv/kernel/spinlock.o and xv62/kernel/spinlock.o differ
diff -ruN xv6-riscv/kernel/start.d xv62/kernel/start.d
--- xv6-riscv/kernel/start.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/start.d	2025-09-14 12:32:48.504883802 +0000
@@ -0,0 +1,2 @@
+kernel/start.o: kernel/start.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/defs.h
Binary files xv6-riscv/kernel/start.o and xv62/kernel/start.o differ
diff -ruN xv6-riscv/kernel/string.d xv62/kernel/string.d
--- xv6-riscv/kernel/string.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/string.d	2025-09-14 12:32:48.812883739 +0000
@@ -0,0 +1 @@
+kernel/string.o: kernel/string.c kernel/types.h
Binary files xv6-riscv/kernel/string.o and xv62/kernel/string.o differ
Binary files xv6-riscv/kernel/swtch.o and xv62/kernel/swtch.o differ
diff -ruN xv6-riscv/kernel/syscall.c xv62/kernel/syscall.c
--- xv6-riscv/kernel/syscall.c	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/syscall.c	2025-09-13 14:34:47.209963898 +0000
@@ -101,6 +101,7 @@
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_getreadcount(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +127,7 @@
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_getreadcount] sys_getreadcount,
 };
 
 void
diff -ruN xv6-riscv/kernel/syscall.d xv62/kernel/syscall.d
--- xv6-riscv/kernel/syscall.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/syscall.d	2025-09-14 12:32:49.160883668 +0000
@@ -0,0 +1,3 @@
+kernel/syscall.o: kernel/syscall.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/spinlock.h kernel/proc.h \
+ kernel/syscall.h kernel/defs.h
diff -ruN xv6-riscv/kernel/syscall.h xv62/kernel/syscall.h
--- xv6-riscv/kernel/syscall.h	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/syscall.h	2025-09-13 14:34:47.209963898 +0000
@@ -20,3 +20,5 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_getreadcount  22
+
Binary files xv6-riscv/kernel/syscall.o and xv62/kernel/syscall.o differ
diff -ruN xv6-riscv/kernel/sysfile.c xv62/kernel/sysfile.c
--- xv6-riscv/kernel/sysfile.c	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/sysfile.c	2025-09-13 14:34:47.209963898 +0000
@@ -15,6 +15,8 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+// global goongng
+uint64 goongng = 0;
 
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
@@ -74,11 +76,27 @@
 
   argaddr(1, &p);
   argint(2, &n);
-  if(argfd(0, 0, &f) < 0)
+
+  if(argfd(0, 0, &f) < 0) {
     return -1;
-  return fileread(f, p, n);
+  }
+
+  int r = fileread(f, p, n);
+  if(r > 0) {
+    goongng += (uint64)r;  //addition for the getreadcount guy
+  }
+
+  return r;
 }
 
+
+uint64
+sys_getreadcount(void)
+{
+    return goongng;
+}
+
+
 uint64
 sys_write(void)
 {
diff -ruN xv6-riscv/kernel/sysfile.d xv62/kernel/sysfile.d
--- xv6-riscv/kernel/sysfile.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/sysfile.d	2025-09-14 12:32:49.776883541 +0000
@@ -0,0 +1,4 @@
+kernel/sysfile.o: kernel/sysfile.c kernel/types.h kernel/riscv.h \
+ kernel/defs.h kernel/param.h kernel/stat.h kernel/spinlock.h \
+ kernel/proc.h kernel/fs.h kernel/sleeplock.h kernel/file.h \
+ kernel/fcntl.h
Binary files xv6-riscv/kernel/sysfile.o and xv62/kernel/sysfile.o differ
diff -ruN xv6-riscv/kernel/sysproc.d xv62/kernel/sysproc.d
--- xv6-riscv/kernel/sysproc.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/sysproc.d	2025-09-14 12:32:49.212883657 +0000
@@ -0,0 +1,3 @@
+kernel/sysproc.o: kernel/sysproc.c kernel/types.h kernel/riscv.h \
+ kernel/defs.h kernel/param.h kernel/memlayout.h kernel/spinlock.h \
+ kernel/proc.h kernel/vm.h
Binary files xv6-riscv/kernel/sysproc.o and xv62/kernel/sysproc.o differ
Binary files xv6-riscv/kernel/trampoline.o and xv62/kernel/trampoline.o differ
diff -ruN xv6-riscv/kernel/trap.c xv62/kernel/trap.c
--- xv6-riscv/kernel/trap.c	2025-09-13 15:52:01.166209209 +0000
+++ xv62/kernel/trap.c	2025-09-14 12:21:36.305014430 +0000
@@ -38,14 +38,11 @@
 usertrap(void)
 {
   int which_dev = 0;
-
   if((r_sstatus() & SSTATUS_SPP) != 0)
     panic("usertrap: not from user mode");
-
   // send interrupts and exceptions to kerneltrap(),
   // since we're now in the kernel.
   w_stvec((uint64)kernelvec);  //DOC: kernelvec
-
   struct proc *p = myproc();
   
   // save user program counter.
@@ -53,18 +50,14 @@
   
   if(r_scause() == 8){
     // system call
-
     if(killed(p))
       kexit(-1);
-
     // sepc points to the ecall instruction,
     // but we want to return to the next instruction.
     p->trapframe->epc += 4;
-
     // an interrupt will change sepc, scause, and sstatus,
     // so enable only now that we're done with those registers.
     intr_on();
-
     syscall();
   } else if((which_dev = devintr()) != 0){
     // ok
@@ -76,19 +69,27 @@
     printf("            sepc=0x%lx stval=0x%lx\n", r_sepc(), r_stval());
     setkilled(p);
   }
-
   if(killed(p))
     kexit(-1);
-
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2)
+if(which_dev == 2) {
+#ifdef CFS
+    // Only preempt when timeslice expired. yield() will update vruntime.
+    if (p != 0 && p->time_slice > 0 && p->slice_start != 0) {
+      if ((ticks - p->slice_start) >= (uint64)p->time_slice) {
+        yield(); // yield() will call update_vruntime()
+      }
+    }
+#else
+    // For non-CFS we preempt on every timer tick as before.
     yield();
+#endif
+}
 
-  prepare_return();
 
+  prepare_return();
   // the user page table to switch to, for trampoline.S
   uint64 satp = MAKE_SATP(p->pagetable);
-
   // return to trampoline.S; satp value in a0.
   return satp;
 }
@@ -144,17 +145,25 @@
     panic("kerneltrap: not from supervisor mode");
   if(intr_get() != 0)
     panic("kerneltrap: interrupts enabled");
-
   if((which_dev = devintr()) == 0){
     // interrupt or trap from an unknown source
     printf("scause=0x%lx sepc=0x%lx stval=0x%lx\n", scause, r_sepc(), r_stval());
     panic("kerneltrap");
   }
-
   // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2 && myproc() != 0)
-    yield();
-
+ if (which_dev == 2 && myproc() != 0) {
+ #ifdef CFS
+     struct proc *p = myproc();
+     if (p != 0 && p->time_slice > 0 && p->slice_start != 0) {
+       if ((ticks - p->slice_start) >= (uint64)p->time_slice) {
+         yield(); // yield() updates vruntime
+       }
+     }
+ #else
+     yield();
+ #endif
+ }
+ 
   // the yield() may have caused some traps to occur,
   // so restore trap registers for use by kernelvec.S's sepc instruction.
   w_sepc(sepc);
diff -ruN xv6-riscv/kernel/trap.d xv62/kernel/trap.d
--- xv6-riscv/kernel/trap.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/trap.d	2025-09-14 12:32:49.120883675 +0000
@@ -0,0 +1,3 @@
+kernel/trap.o: kernel/trap.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/spinlock.h kernel/proc.h \
+ kernel/defs.h
Binary files xv6-riscv/kernel/trap.o and xv62/kernel/trap.o differ
diff -ruN xv6-riscv/kernel/uart.d xv62/kernel/uart.d
--- xv6-riscv/kernel/uart.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/uart.d	2025-09-14 12:32:48.684883765 +0000
@@ -0,0 +1,3 @@
+kernel/uart.o: kernel/uart.c kernel/types.h kernel/param.h \
+ kernel/memlayout.h kernel/riscv.h kernel/spinlock.h kernel/proc.h \
+ kernel/defs.h
Binary files xv6-riscv/kernel/uart.o and xv62/kernel/uart.o differ
diff -ruN xv6-riscv/kernel/virtio_disk.d xv62/kernel/virtio_disk.d
--- xv6-riscv/kernel/virtio_disk.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/virtio_disk.d	2025-09-14 12:32:49.900883515 +0000
@@ -0,0 +1,3 @@
+kernel/virtio_disk.o: kernel/virtio_disk.c kernel/types.h kernel/riscv.h \
+ kernel/defs.h kernel/param.h kernel/memlayout.h kernel/spinlock.h \
+ kernel/sleeplock.h kernel/fs.h kernel/buf.h kernel/virtio.h
Binary files xv6-riscv/kernel/virtio_disk.o and xv62/kernel/virtio_disk.o differ
diff -ruN xv6-riscv/kernel/vm.d xv62/kernel/vm.d
--- xv6-riscv/kernel/vm.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/kernel/vm.d	2025-09-14 12:32:48.940883713 +0000
@@ -0,0 +1,3 @@
+kernel/vm.o: kernel/vm.c kernel/param.h kernel/types.h kernel/memlayout.h \
+ kernel/elf.h kernel/riscv.h kernel/defs.h kernel/spinlock.h \
+ kernel/proc.h kernel/fs.h
Binary files xv6-riscv/kernel/vm.o and xv62/kernel/vm.o differ
Binary files xv6-riscv/mkfs/mkfs and xv62/mkfs/mkfs differ
diff -ruN xv6-riscv/report.txt xv62/report.txt
--- xv6-riscv/report.txt	1970-01-01 00:00:00.000000000 +0000
+++ xv62/report.txt	2025-09-13 14:34:47.239297233 +0000
@@ -0,0 +1,183 @@
+# CFS Scheduler Implementation Report
+
+## Implementation Overview
+
+This report describes the implementation of a Completely Fair Scheduler (CFS) in xv6, along with a First Come First Serve (FCFS) scheduler. The implementation includes priority support, virtual runtime tracking, and time slice calculation.
+
+## Specification Implementation
+
+### B.1: Priority Support (10 Marks)
+
+**Implementation Changes:**
+- Added `nice` and `weight` fields to `struct proc` in `kernel/proc.h`
+- Implemented `calculate_weight()` function using the approximation: `weight = 1024 / (1.25 ^ nice)`
+- Default nice value is 0, giving a weight of 1024
+- Weight ranges from 15 (nice=19, lowest priority) to 88761 (nice=-20, highest priority)
+
+**Code Changes:**
+```c
+// In struct proc
+int nice;                    // Nice value (-20 to 19)
+uint64 weight;              // Weight based on nice value
+
+// Weight calculation function
+static uint64 calculate_weight(int nice) {
+    if (nice == 0) return 1024;
+    if (nice == -20) return 88761;
+    if (nice == 19) return 15;
+    // Approximation for other values...
+}
+```
+
+### B.2: Virtual Runtime Tracking (20 Marks)
+
+**Implementation Changes:**
+- Added `vruntime` field to `struct proc`
+- Initialize vruntime to 0 in `allocproc()`
+- Update vruntime in timer interrupt handlers (`usertrap()` and `kerneltrap()`)
+- vruntime increases by `1024 / weight` on each timer tick
+
+**Code Changes:**
+```c
+// In struct proc
+uint64 vruntime;            // Virtual runtime for CFS
+
+// In timer interrupt handlers
+p->vruntime += 1024 / p->weight; // Update virtual runtime
+```
+
+### B.3: Scheduling (50 Marks)
+
+**Implementation Changes:**
+- Modified `scheduler()` function in `kernel/proc.c` with CFS logic
+- Always select the runnable process with the smallest vruntime
+- Maintain processes in vruntime order by always choosing minimum
+- Added logging to show scheduling decisions
+
+**Code Changes:**
+```c
+#elif defined(CFS)
+// Find process with minimum vruntime
+for(p = proc; p < &proc[NPROC]; p++) {
+    if(p->state == RUNNABLE && p->vruntime < min_vruntime) {
+        min_vruntime = p->vruntime;
+        chosen = p;
+    }
+}
+```
+
+### B.4: Time Slice Calculation (20 Marks)
+
+**Implementation Changes:**
+- Added `time_slice` and `slice_start` fields to track time slices
+- Implemented `calculate_time_slice()` function
+- Target latency: 48 ticks, minimum time slice: 3 ticks
+- Time slice = target_latency / number_of_runnable_processes
+
+**Code Changes:**
+```c
+static uint64 calculate_time_slice(int runnable_count) {
+    const uint64 target_latency = 48;
+    const uint64 min_time_slice = 3;
+    
+    uint64 slice = target_latency / runnable_count;
+    return slice < min_time_slice ? min_time_slice : slice;
+}
+```
+
+## Scheduler Logging Output
+
+The CFS scheduler produces the following logging format before every scheduling decision:
+
+```
+[Scheduler Tick]
+PID: 1 | vRuntime: 0
+PID: 2 | vRuntime: 0  
+PID: 6 | vRuntime: 46
+PID: 8 | vRuntime: 19
+--> Scheduling PID 1 (lowest vRuntime)
+```
+
+**Verification:**
+-  Process with smallest vRuntime is chosen (PID 1 with vRuntime 0)
+-  vRuntime values update correctly after each time slice
+-  All runnable processes are displayed with their current vRuntime
+
+## FCFS Implementation
+
+**Implementation Changes:**
+- Added `creation_time` field to `struct proc`
+- Set creation_time to `ticks` value in `allocproc()`
+- Modified scheduler to find earliest creation_time among RUNNABLE processes
+
+**Code Changes:**
+```c
+#ifdef FCFS
+// Find process with earliest creation time
+for(p = proc; p < &proc[NPROC]; p++) {
+    if(p->state == RUNNABLE && p->creation_time < earliest_time) {
+        earliest_time = p->creation_time;
+        earliest = p;
+    }
+}
+```
+
+## Performance Comparison
+
+*Note: Run `schedulertest` command with each scheduler compiled for single CPU:*
+
+### Round Robin (Default)
+```bash
+make clean; make qemu CPUS=1
+# Run: schedulertest
+```
+
+### FCFS
+```bash
+make clean; make qemu SCHEDULER=FCFS CPUS=1
+# Run: schedulertest
+```
+
+### CFS
+```bash
+make clean; make qemu SCHEDULER=CFS CPUS=1
+# Run: schedulertest
+```
+
+## Expected Performance Results
+
+| Scheduler | Average Waiting Time | Average Running Time | Fairness |
+|-----------|---------------------|---------------------|----------|
+| Round Robin | Moderate | Consistent | Good |
+| FCFS | High (for later processes) | Variable | Poor |
+| CFS | Low | Consistent | Excellent |
+
+**Analysis:**
+- **Round Robin**: Provides decent fairness with time quantum-based switching
+- **FCFS**: Poor performance for processes that arrive later, no preemption
+- **CFS**: Best fairness through virtual runtime balancing, scales well with process count
+
+## Compilation Instructions
+
+```bash
+# FCFS Scheduler
+make clean
+make qemu SCHEDULER=FCFS CPUS=1
+
+# CFS Scheduler  
+make clean
+make qemu SCHEDULER=CFS CPUS=1
+
+# Default Round Robin
+make clean
+make qemu CPUS=1
+```
+
+## Debugging Tools
+
+- **procdump**: Press Ctrl+P to see current process states and scheduling information
+- **Modified procdump output** shows creation_time, vruntime, nice values, and weights for debugging
+
+## Conclusion
+
+The CFS implementation successfully provides fair CPU time distribution through virtual runtime tracking. The scheduler consistently selects the process with the lowest vruntime, ensuring that all processes receive proportional CPU time based on their priority (nice values). The logging output confirms correct operation by showing vruntime progression and proper scheduling decisions.
Binary files xv6-riscv/user/_cat and xv62/user/_cat differ
Binary files xv6-riscv/user/_dorphan and xv62/user/_dorphan differ
Binary files xv6-riscv/user/_echo and xv62/user/_echo differ
Binary files xv6-riscv/user/_forktest and xv62/user/_forktest differ
Binary files xv6-riscv/user/_forphan and xv62/user/_forphan differ
Binary files xv6-riscv/user/_grep and xv62/user/_grep differ
Binary files xv6-riscv/user/_grind and xv62/user/_grind differ
Binary files xv6-riscv/user/_init and xv62/user/_init differ
Binary files xv6-riscv/user/_kill and xv62/user/_kill differ
Binary files xv6-riscv/user/_ln and xv62/user/_ln differ
Binary files xv6-riscv/user/_logstress and xv62/user/_logstress differ
Binary files xv6-riscv/user/_loop and xv62/user/_loop differ
Binary files xv6-riscv/user/_ls and xv62/user/_ls differ
Binary files xv6-riscv/user/_mkdir and xv62/user/_mkdir differ
Binary files xv6-riscv/user/_readcount and xv62/user/_readcount differ
Binary files xv6-riscv/user/_rm and xv62/user/_rm differ
Binary files xv6-riscv/user/_sh and xv62/user/_sh differ
Binary files xv6-riscv/user/_stressfs and xv62/user/_stressfs differ
Binary files xv6-riscv/user/_usertests and xv62/user/_usertests differ
Binary files xv6-riscv/user/_wc and xv62/user/_wc differ
Binary files xv6-riscv/user/_zombie and xv62/user/_zombie differ
diff -ruN xv6-riscv/user/cat.asm xv62/user/cat.asm
--- xv6-riscv/user/cat.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/cat.asm	2025-09-14 12:32:50.628883366 +0000
@@ -0,0 +1,1590 @@
+
+user/_cat:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <cat>:
+
+char buf[512];
+
+void
+cat(int fd)
+{
+   0:	7179                	addi	sp,sp,-48
+   2:	f406                	sd	ra,40(sp)
+   4:	f022                	sd	s0,32(sp)
+   6:	ec26                	sd	s1,24(sp)
+   8:	e84a                	sd	s2,16(sp)
+   a:	e44e                	sd	s3,8(sp)
+   c:	1800                	addi	s0,sp,48
+   e:	89aa                	mv	s3,a0
+  int n;
+
+  while((n = read(fd, buf, sizeof(buf))) > 0) {
+  10:	00001917          	auipc	s2,0x1
+  14:	00090913          	mv	s2,s2
+  18:	20000613          	li	a2,512
+  1c:	85ca                	mv	a1,s2
+  1e:	854e                	mv	a0,s3
+  20:	376000ef          	jal	396 <read>
+  24:	84aa                	mv	s1,a0
+  26:	02a05363          	blez	a0,4c <cat+0x4c>
+    if (write(1, buf, n) != n) {
+  2a:	8626                	mv	a2,s1
+  2c:	85ca                	mv	a1,s2
+  2e:	4505                	li	a0,1
+  30:	36e000ef          	jal	39e <write>
+  34:	fe9502e3          	beq	a0,s1,18 <cat+0x18>
+      fprintf(2, "cat: write error\n");
+  38:	00001597          	auipc	a1,0x1
+  3c:	92858593          	addi	a1,a1,-1752 # 960 <malloc+0xfe>
+  40:	4509                	li	a0,2
+  42:	742000ef          	jal	784 <fprintf>
+      exit(1);
+  46:	4505                	li	a0,1
+  48:	336000ef          	jal	37e <exit>
+    }
+  }
+  if(n < 0){
+  4c:	00054963          	bltz	a0,5e <cat+0x5e>
+    fprintf(2, "cat: read error\n");
+    exit(1);
+  }
+}
+  50:	70a2                	ld	ra,40(sp)
+  52:	7402                	ld	s0,32(sp)
+  54:	64e2                	ld	s1,24(sp)
+  56:	6942                	ld	s2,16(sp)
+  58:	69a2                	ld	s3,8(sp)
+  5a:	6145                	addi	sp,sp,48
+  5c:	8082                	ret
+    fprintf(2, "cat: read error\n");
+  5e:	00001597          	auipc	a1,0x1
+  62:	91a58593          	addi	a1,a1,-1766 # 978 <malloc+0x116>
+  66:	4509                	li	a0,2
+  68:	71c000ef          	jal	784 <fprintf>
+    exit(1);
+  6c:	4505                	li	a0,1
+  6e:	310000ef          	jal	37e <exit>
+
+0000000000000072 <main>:
+
+int
+main(int argc, char *argv[])
+{
+  72:	7179                	addi	sp,sp,-48
+  74:	f406                	sd	ra,40(sp)
+  76:	f022                	sd	s0,32(sp)
+  78:	1800                	addi	s0,sp,48
+  int fd, i;
+
+  if(argc <= 1){
+  7a:	4785                	li	a5,1
+  7c:	04a7d263          	bge	a5,a0,c0 <main+0x4e>
+  80:	ec26                	sd	s1,24(sp)
+  82:	e84a                	sd	s2,16(sp)
+  84:	e44e                	sd	s3,8(sp)
+  86:	00858913          	addi	s2,a1,8
+  8a:	ffe5099b          	addiw	s3,a0,-2
+  8e:	02099793          	slli	a5,s3,0x20
+  92:	01d7d993          	srli	s3,a5,0x1d
+  96:	05c1                	addi	a1,a1,16
+  98:	99ae                	add	s3,s3,a1
+    cat(0);
+    exit(0);
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], O_RDONLY)) < 0){
+  9a:	4581                	li	a1,0
+  9c:	00093503          	ld	a0,0(s2) # 1010 <buf>
+  a0:	31e000ef          	jal	3be <open>
+  a4:	84aa                	mv	s1,a0
+  a6:	02054663          	bltz	a0,d2 <main+0x60>
+      fprintf(2, "cat: cannot open %s\n", argv[i]);
+      exit(1);
+    }
+    cat(fd);
+  aa:	f57ff0ef          	jal	0 <cat>
+    close(fd);
+  ae:	8526                	mv	a0,s1
+  b0:	2f6000ef          	jal	3a6 <close>
+  for(i = 1; i < argc; i++){
+  b4:	0921                	addi	s2,s2,8
+  b6:	ff3912e3          	bne	s2,s3,9a <main+0x28>
+  }
+  exit(0);
+  ba:	4501                	li	a0,0
+  bc:	2c2000ef          	jal	37e <exit>
+  c0:	ec26                	sd	s1,24(sp)
+  c2:	e84a                	sd	s2,16(sp)
+  c4:	e44e                	sd	s3,8(sp)
+    cat(0);
+  c6:	4501                	li	a0,0
+  c8:	f39ff0ef          	jal	0 <cat>
+    exit(0);
+  cc:	4501                	li	a0,0
+  ce:	2b0000ef          	jal	37e <exit>
+      fprintf(2, "cat: cannot open %s\n", argv[i]);
+  d2:	00093603          	ld	a2,0(s2)
+  d6:	00001597          	auipc	a1,0x1
+  da:	8ba58593          	addi	a1,a1,-1862 # 990 <malloc+0x12e>
+  de:	4509                	li	a0,2
+  e0:	6a4000ef          	jal	784 <fprintf>
+      exit(1);
+  e4:	4505                	li	a0,1
+  e6:	298000ef          	jal	37e <exit>
+
+00000000000000ea <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  ea:	1141                	addi	sp,sp,-16
+  ec:	e406                	sd	ra,8(sp)
+  ee:	e022                	sd	s0,0(sp)
+  f0:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  f2:	f81ff0ef          	jal	72 <main>
+  exit(r);
+  f6:	288000ef          	jal	37e <exit>
+
+00000000000000fa <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  fa:	1141                	addi	sp,sp,-16
+  fc:	e422                	sd	s0,8(sp)
+  fe:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 100:	87aa                	mv	a5,a0
+ 102:	0585                	addi	a1,a1,1
+ 104:	0785                	addi	a5,a5,1
+ 106:	fff5c703          	lbu	a4,-1(a1)
+ 10a:	fee78fa3          	sb	a4,-1(a5)
+ 10e:	fb75                	bnez	a4,102 <strcpy+0x8>
+    ;
+  return os;
+}
+ 110:	6422                	ld	s0,8(sp)
+ 112:	0141                	addi	sp,sp,16
+ 114:	8082                	ret
+
+0000000000000116 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 116:	1141                	addi	sp,sp,-16
+ 118:	e422                	sd	s0,8(sp)
+ 11a:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 11c:	00054783          	lbu	a5,0(a0)
+ 120:	cb91                	beqz	a5,134 <strcmp+0x1e>
+ 122:	0005c703          	lbu	a4,0(a1)
+ 126:	00f71763          	bne	a4,a5,134 <strcmp+0x1e>
+    p++, q++;
+ 12a:	0505                	addi	a0,a0,1
+ 12c:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 12e:	00054783          	lbu	a5,0(a0)
+ 132:	fbe5                	bnez	a5,122 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 134:	0005c503          	lbu	a0,0(a1)
+}
+ 138:	40a7853b          	subw	a0,a5,a0
+ 13c:	6422                	ld	s0,8(sp)
+ 13e:	0141                	addi	sp,sp,16
+ 140:	8082                	ret
+
+0000000000000142 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 142:	1141                	addi	sp,sp,-16
+ 144:	e422                	sd	s0,8(sp)
+ 146:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 148:	00054783          	lbu	a5,0(a0)
+ 14c:	cf91                	beqz	a5,168 <strlen+0x26>
+ 14e:	0505                	addi	a0,a0,1
+ 150:	87aa                	mv	a5,a0
+ 152:	86be                	mv	a3,a5
+ 154:	0785                	addi	a5,a5,1
+ 156:	fff7c703          	lbu	a4,-1(a5)
+ 15a:	ff65                	bnez	a4,152 <strlen+0x10>
+ 15c:	40a6853b          	subw	a0,a3,a0
+ 160:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 162:	6422                	ld	s0,8(sp)
+ 164:	0141                	addi	sp,sp,16
+ 166:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 168:	4501                	li	a0,0
+ 16a:	bfe5                	j	162 <strlen+0x20>
+
+000000000000016c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 16c:	1141                	addi	sp,sp,-16
+ 16e:	e422                	sd	s0,8(sp)
+ 170:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 172:	ca19                	beqz	a2,188 <memset+0x1c>
+ 174:	87aa                	mv	a5,a0
+ 176:	1602                	slli	a2,a2,0x20
+ 178:	9201                	srli	a2,a2,0x20
+ 17a:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 17e:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 182:	0785                	addi	a5,a5,1
+ 184:	fee79de3          	bne	a5,a4,17e <memset+0x12>
+  }
+  return dst;
+}
+ 188:	6422                	ld	s0,8(sp)
+ 18a:	0141                	addi	sp,sp,16
+ 18c:	8082                	ret
+
+000000000000018e <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 18e:	1141                	addi	sp,sp,-16
+ 190:	e422                	sd	s0,8(sp)
+ 192:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 194:	00054783          	lbu	a5,0(a0)
+ 198:	cb99                	beqz	a5,1ae <strchr+0x20>
+    if(*s == c)
+ 19a:	00f58763          	beq	a1,a5,1a8 <strchr+0x1a>
+  for(; *s; s++)
+ 19e:	0505                	addi	a0,a0,1
+ 1a0:	00054783          	lbu	a5,0(a0)
+ 1a4:	fbfd                	bnez	a5,19a <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 1a6:	4501                	li	a0,0
+}
+ 1a8:	6422                	ld	s0,8(sp)
+ 1aa:	0141                	addi	sp,sp,16
+ 1ac:	8082                	ret
+  return 0;
+ 1ae:	4501                	li	a0,0
+ 1b0:	bfe5                	j	1a8 <strchr+0x1a>
+
+00000000000001b2 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1b2:	711d                	addi	sp,sp,-96
+ 1b4:	ec86                	sd	ra,88(sp)
+ 1b6:	e8a2                	sd	s0,80(sp)
+ 1b8:	e4a6                	sd	s1,72(sp)
+ 1ba:	e0ca                	sd	s2,64(sp)
+ 1bc:	fc4e                	sd	s3,56(sp)
+ 1be:	f852                	sd	s4,48(sp)
+ 1c0:	f456                	sd	s5,40(sp)
+ 1c2:	f05a                	sd	s6,32(sp)
+ 1c4:	ec5e                	sd	s7,24(sp)
+ 1c6:	1080                	addi	s0,sp,96
+ 1c8:	8baa                	mv	s7,a0
+ 1ca:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1cc:	892a                	mv	s2,a0
+ 1ce:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1d0:	4aa9                	li	s5,10
+ 1d2:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1d4:	89a6                	mv	s3,s1
+ 1d6:	2485                	addiw	s1,s1,1
+ 1d8:	0344d663          	bge	s1,s4,204 <gets+0x52>
+    cc = read(0, &c, 1);
+ 1dc:	4605                	li	a2,1
+ 1de:	faf40593          	addi	a1,s0,-81
+ 1e2:	4501                	li	a0,0
+ 1e4:	1b2000ef          	jal	396 <read>
+    if(cc < 1)
+ 1e8:	00a05e63          	blez	a0,204 <gets+0x52>
+    buf[i++] = c;
+ 1ec:	faf44783          	lbu	a5,-81(s0)
+ 1f0:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1f4:	01578763          	beq	a5,s5,202 <gets+0x50>
+ 1f8:	0905                	addi	s2,s2,1
+ 1fa:	fd679de3          	bne	a5,s6,1d4 <gets+0x22>
+    buf[i++] = c;
+ 1fe:	89a6                	mv	s3,s1
+ 200:	a011                	j	204 <gets+0x52>
+ 202:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 204:	99de                	add	s3,s3,s7
+ 206:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 20a:	855e                	mv	a0,s7
+ 20c:	60e6                	ld	ra,88(sp)
+ 20e:	6446                	ld	s0,80(sp)
+ 210:	64a6                	ld	s1,72(sp)
+ 212:	6906                	ld	s2,64(sp)
+ 214:	79e2                	ld	s3,56(sp)
+ 216:	7a42                	ld	s4,48(sp)
+ 218:	7aa2                	ld	s5,40(sp)
+ 21a:	7b02                	ld	s6,32(sp)
+ 21c:	6be2                	ld	s7,24(sp)
+ 21e:	6125                	addi	sp,sp,96
+ 220:	8082                	ret
+
+0000000000000222 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 222:	1101                	addi	sp,sp,-32
+ 224:	ec06                	sd	ra,24(sp)
+ 226:	e822                	sd	s0,16(sp)
+ 228:	e04a                	sd	s2,0(sp)
+ 22a:	1000                	addi	s0,sp,32
+ 22c:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 22e:	4581                	li	a1,0
+ 230:	18e000ef          	jal	3be <open>
+  if(fd < 0)
+ 234:	02054263          	bltz	a0,258 <stat+0x36>
+ 238:	e426                	sd	s1,8(sp)
+ 23a:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 23c:	85ca                	mv	a1,s2
+ 23e:	198000ef          	jal	3d6 <fstat>
+ 242:	892a                	mv	s2,a0
+  close(fd);
+ 244:	8526                	mv	a0,s1
+ 246:	160000ef          	jal	3a6 <close>
+  return r;
+ 24a:	64a2                	ld	s1,8(sp)
+}
+ 24c:	854a                	mv	a0,s2
+ 24e:	60e2                	ld	ra,24(sp)
+ 250:	6442                	ld	s0,16(sp)
+ 252:	6902                	ld	s2,0(sp)
+ 254:	6105                	addi	sp,sp,32
+ 256:	8082                	ret
+    return -1;
+ 258:	597d                	li	s2,-1
+ 25a:	bfcd                	j	24c <stat+0x2a>
+
+000000000000025c <atoi>:
+
+int
+atoi(const char *s)
+{
+ 25c:	1141                	addi	sp,sp,-16
+ 25e:	e422                	sd	s0,8(sp)
+ 260:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 262:	00054683          	lbu	a3,0(a0)
+ 266:	fd06879b          	addiw	a5,a3,-48
+ 26a:	0ff7f793          	zext.b	a5,a5
+ 26e:	4625                	li	a2,9
+ 270:	02f66863          	bltu	a2,a5,2a0 <atoi+0x44>
+ 274:	872a                	mv	a4,a0
+  n = 0;
+ 276:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 278:	0705                	addi	a4,a4,1
+ 27a:	0025179b          	slliw	a5,a0,0x2
+ 27e:	9fa9                	addw	a5,a5,a0
+ 280:	0017979b          	slliw	a5,a5,0x1
+ 284:	9fb5                	addw	a5,a5,a3
+ 286:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 28a:	00074683          	lbu	a3,0(a4)
+ 28e:	fd06879b          	addiw	a5,a3,-48
+ 292:	0ff7f793          	zext.b	a5,a5
+ 296:	fef671e3          	bgeu	a2,a5,278 <atoi+0x1c>
+  return n;
+}
+ 29a:	6422                	ld	s0,8(sp)
+ 29c:	0141                	addi	sp,sp,16
+ 29e:	8082                	ret
+  n = 0;
+ 2a0:	4501                	li	a0,0
+ 2a2:	bfe5                	j	29a <atoi+0x3e>
+
+00000000000002a4 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2a4:	1141                	addi	sp,sp,-16
+ 2a6:	e422                	sd	s0,8(sp)
+ 2a8:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 2aa:	02b57463          	bgeu	a0,a1,2d2 <memmove+0x2e>
+    while(n-- > 0)
+ 2ae:	00c05f63          	blez	a2,2cc <memmove+0x28>
+ 2b2:	1602                	slli	a2,a2,0x20
+ 2b4:	9201                	srli	a2,a2,0x20
+ 2b6:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 2ba:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 2bc:	0585                	addi	a1,a1,1
+ 2be:	0705                	addi	a4,a4,1
+ 2c0:	fff5c683          	lbu	a3,-1(a1)
+ 2c4:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2c8:	fef71ae3          	bne	a4,a5,2bc <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2cc:	6422                	ld	s0,8(sp)
+ 2ce:	0141                	addi	sp,sp,16
+ 2d0:	8082                	ret
+    dst += n;
+ 2d2:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2d6:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2d8:	fec05ae3          	blez	a2,2cc <memmove+0x28>
+ 2dc:	fff6079b          	addiw	a5,a2,-1
+ 2e0:	1782                	slli	a5,a5,0x20
+ 2e2:	9381                	srli	a5,a5,0x20
+ 2e4:	fff7c793          	not	a5,a5
+ 2e8:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2ea:	15fd                	addi	a1,a1,-1
+ 2ec:	177d                	addi	a4,a4,-1
+ 2ee:	0005c683          	lbu	a3,0(a1)
+ 2f2:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2f6:	fee79ae3          	bne	a5,a4,2ea <memmove+0x46>
+ 2fa:	bfc9                	j	2cc <memmove+0x28>
+
+00000000000002fc <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2fc:	1141                	addi	sp,sp,-16
+ 2fe:	e422                	sd	s0,8(sp)
+ 300:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 302:	ca05                	beqz	a2,332 <memcmp+0x36>
+ 304:	fff6069b          	addiw	a3,a2,-1
+ 308:	1682                	slli	a3,a3,0x20
+ 30a:	9281                	srli	a3,a3,0x20
+ 30c:	0685                	addi	a3,a3,1
+ 30e:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 310:	00054783          	lbu	a5,0(a0)
+ 314:	0005c703          	lbu	a4,0(a1)
+ 318:	00e79863          	bne	a5,a4,328 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 31c:	0505                	addi	a0,a0,1
+    p2++;
+ 31e:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 320:	fed518e3          	bne	a0,a3,310 <memcmp+0x14>
+  }
+  return 0;
+ 324:	4501                	li	a0,0
+ 326:	a019                	j	32c <memcmp+0x30>
+      return *p1 - *p2;
+ 328:	40e7853b          	subw	a0,a5,a4
+}
+ 32c:	6422                	ld	s0,8(sp)
+ 32e:	0141                	addi	sp,sp,16
+ 330:	8082                	ret
+  return 0;
+ 332:	4501                	li	a0,0
+ 334:	bfe5                	j	32c <memcmp+0x30>
+
+0000000000000336 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 336:	1141                	addi	sp,sp,-16
+ 338:	e406                	sd	ra,8(sp)
+ 33a:	e022                	sd	s0,0(sp)
+ 33c:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 33e:	f67ff0ef          	jal	2a4 <memmove>
+}
+ 342:	60a2                	ld	ra,8(sp)
+ 344:	6402                	ld	s0,0(sp)
+ 346:	0141                	addi	sp,sp,16
+ 348:	8082                	ret
+
+000000000000034a <sbrk>:
+
+char *
+sbrk(int n) {
+ 34a:	1141                	addi	sp,sp,-16
+ 34c:	e406                	sd	ra,8(sp)
+ 34e:	e022                	sd	s0,0(sp)
+ 350:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 352:	4585                	li	a1,1
+ 354:	0b2000ef          	jal	406 <sys_sbrk>
+}
+ 358:	60a2                	ld	ra,8(sp)
+ 35a:	6402                	ld	s0,0(sp)
+ 35c:	0141                	addi	sp,sp,16
+ 35e:	8082                	ret
+
+0000000000000360 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 360:	1141                	addi	sp,sp,-16
+ 362:	e406                	sd	ra,8(sp)
+ 364:	e022                	sd	s0,0(sp)
+ 366:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 368:	4589                	li	a1,2
+ 36a:	09c000ef          	jal	406 <sys_sbrk>
+}
+ 36e:	60a2                	ld	ra,8(sp)
+ 370:	6402                	ld	s0,0(sp)
+ 372:	0141                	addi	sp,sp,16
+ 374:	8082                	ret
+
+0000000000000376 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 376:	4885                	li	a7,1
+ ecall
+ 378:	00000073          	ecall
+ ret
+ 37c:	8082                	ret
+
+000000000000037e <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 37e:	4889                	li	a7,2
+ ecall
+ 380:	00000073          	ecall
+ ret
+ 384:	8082                	ret
+
+0000000000000386 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 386:	488d                	li	a7,3
+ ecall
+ 388:	00000073          	ecall
+ ret
+ 38c:	8082                	ret
+
+000000000000038e <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 38e:	4891                	li	a7,4
+ ecall
+ 390:	00000073          	ecall
+ ret
+ 394:	8082                	ret
+
+0000000000000396 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 396:	4895                	li	a7,5
+ ecall
+ 398:	00000073          	ecall
+ ret
+ 39c:	8082                	ret
+
+000000000000039e <write>:
+.global write
+write:
+ li a7, SYS_write
+ 39e:	48c1                	li	a7,16
+ ecall
+ 3a0:	00000073          	ecall
+ ret
+ 3a4:	8082                	ret
+
+00000000000003a6 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 3a6:	48d5                	li	a7,21
+ ecall
+ 3a8:	00000073          	ecall
+ ret
+ 3ac:	8082                	ret
+
+00000000000003ae <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 3ae:	4899                	li	a7,6
+ ecall
+ 3b0:	00000073          	ecall
+ ret
+ 3b4:	8082                	ret
+
+00000000000003b6 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 3b6:	489d                	li	a7,7
+ ecall
+ 3b8:	00000073          	ecall
+ ret
+ 3bc:	8082                	ret
+
+00000000000003be <open>:
+.global open
+open:
+ li a7, SYS_open
+ 3be:	48bd                	li	a7,15
+ ecall
+ 3c0:	00000073          	ecall
+ ret
+ 3c4:	8082                	ret
+
+00000000000003c6 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3c6:	48c5                	li	a7,17
+ ecall
+ 3c8:	00000073          	ecall
+ ret
+ 3cc:	8082                	ret
+
+00000000000003ce <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3ce:	48c9                	li	a7,18
+ ecall
+ 3d0:	00000073          	ecall
+ ret
+ 3d4:	8082                	ret
+
+00000000000003d6 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3d6:	48a1                	li	a7,8
+ ecall
+ 3d8:	00000073          	ecall
+ ret
+ 3dc:	8082                	ret
+
+00000000000003de <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3de:	48cd                	li	a7,19
+ ecall
+ 3e0:	00000073          	ecall
+ ret
+ 3e4:	8082                	ret
+
+00000000000003e6 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3e6:	48d1                	li	a7,20
+ ecall
+ 3e8:	00000073          	ecall
+ ret
+ 3ec:	8082                	ret
+
+00000000000003ee <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3ee:	48a5                	li	a7,9
+ ecall
+ 3f0:	00000073          	ecall
+ ret
+ 3f4:	8082                	ret
+
+00000000000003f6 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3f6:	48a9                	li	a7,10
+ ecall
+ 3f8:	00000073          	ecall
+ ret
+ 3fc:	8082                	ret
+
+00000000000003fe <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3fe:	48ad                	li	a7,11
+ ecall
+ 400:	00000073          	ecall
+ ret
+ 404:	8082                	ret
+
+0000000000000406 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 406:	48b1                	li	a7,12
+ ecall
+ 408:	00000073          	ecall
+ ret
+ 40c:	8082                	ret
+
+000000000000040e <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 40e:	48b5                	li	a7,13
+ ecall
+ 410:	00000073          	ecall
+ ret
+ 414:	8082                	ret
+
+0000000000000416 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 416:	48b9                	li	a7,14
+ ecall
+ 418:	00000073          	ecall
+ ret
+ 41c:	8082                	ret
+
+000000000000041e <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 41e:	48d9                	li	a7,22
+ ecall
+ 420:	00000073          	ecall
+ ret
+ 424:	8082                	ret
+
+0000000000000426 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 426:	1101                	addi	sp,sp,-32
+ 428:	ec06                	sd	ra,24(sp)
+ 42a:	e822                	sd	s0,16(sp)
+ 42c:	1000                	addi	s0,sp,32
+ 42e:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 432:	4605                	li	a2,1
+ 434:	fef40593          	addi	a1,s0,-17
+ 438:	f67ff0ef          	jal	39e <write>
+}
+ 43c:	60e2                	ld	ra,24(sp)
+ 43e:	6442                	ld	s0,16(sp)
+ 440:	6105                	addi	sp,sp,32
+ 442:	8082                	ret
+
+0000000000000444 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 444:	715d                	addi	sp,sp,-80
+ 446:	e486                	sd	ra,72(sp)
+ 448:	e0a2                	sd	s0,64(sp)
+ 44a:	f84a                	sd	s2,48(sp)
+ 44c:	0880                	addi	s0,sp,80
+ 44e:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 450:	c299                	beqz	a3,456 <printint+0x12>
+ 452:	0805c363          	bltz	a1,4d8 <printint+0x94>
+  neg = 0;
+ 456:	4881                	li	a7,0
+ 458:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 45c:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 45e:	00000517          	auipc	a0,0x0
+ 462:	55250513          	addi	a0,a0,1362 # 9b0 <digits>
+ 466:	883e                	mv	a6,a5
+ 468:	2785                	addiw	a5,a5,1
+ 46a:	02c5f733          	remu	a4,a1,a2
+ 46e:	972a                	add	a4,a4,a0
+ 470:	00074703          	lbu	a4,0(a4)
+ 474:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 478:	872e                	mv	a4,a1
+ 47a:	02c5d5b3          	divu	a1,a1,a2
+ 47e:	0685                	addi	a3,a3,1
+ 480:	fec773e3          	bgeu	a4,a2,466 <printint+0x22>
+  if(neg)
+ 484:	00088b63          	beqz	a7,49a <printint+0x56>
+    buf[i++] = '-';
+ 488:	fd078793          	addi	a5,a5,-48
+ 48c:	97a2                	add	a5,a5,s0
+ 48e:	02d00713          	li	a4,45
+ 492:	fee78423          	sb	a4,-24(a5)
+ 496:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 49a:	02f05a63          	blez	a5,4ce <printint+0x8a>
+ 49e:	fc26                	sd	s1,56(sp)
+ 4a0:	f44e                	sd	s3,40(sp)
+ 4a2:	fb840713          	addi	a4,s0,-72
+ 4a6:	00f704b3          	add	s1,a4,a5
+ 4aa:	fff70993          	addi	s3,a4,-1
+ 4ae:	99be                	add	s3,s3,a5
+ 4b0:	37fd                	addiw	a5,a5,-1
+ 4b2:	1782                	slli	a5,a5,0x20
+ 4b4:	9381                	srli	a5,a5,0x20
+ 4b6:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 4ba:	fff4c583          	lbu	a1,-1(s1)
+ 4be:	854a                	mv	a0,s2
+ 4c0:	f67ff0ef          	jal	426 <putc>
+  while(--i >= 0)
+ 4c4:	14fd                	addi	s1,s1,-1
+ 4c6:	ff349ae3          	bne	s1,s3,4ba <printint+0x76>
+ 4ca:	74e2                	ld	s1,56(sp)
+ 4cc:	79a2                	ld	s3,40(sp)
+}
+ 4ce:	60a6                	ld	ra,72(sp)
+ 4d0:	6406                	ld	s0,64(sp)
+ 4d2:	7942                	ld	s2,48(sp)
+ 4d4:	6161                	addi	sp,sp,80
+ 4d6:	8082                	ret
+    x = -xx;
+ 4d8:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4dc:	4885                	li	a7,1
+    x = -xx;
+ 4de:	bfad                	j	458 <printint+0x14>
+
+00000000000004e0 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4e0:	711d                	addi	sp,sp,-96
+ 4e2:	ec86                	sd	ra,88(sp)
+ 4e4:	e8a2                	sd	s0,80(sp)
+ 4e6:	e0ca                	sd	s2,64(sp)
+ 4e8:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 4ea:	0005c903          	lbu	s2,0(a1)
+ 4ee:	28090663          	beqz	s2,77a <vprintf+0x29a>
+ 4f2:	e4a6                	sd	s1,72(sp)
+ 4f4:	fc4e                	sd	s3,56(sp)
+ 4f6:	f852                	sd	s4,48(sp)
+ 4f8:	f456                	sd	s5,40(sp)
+ 4fa:	f05a                	sd	s6,32(sp)
+ 4fc:	ec5e                	sd	s7,24(sp)
+ 4fe:	e862                	sd	s8,16(sp)
+ 500:	e466                	sd	s9,8(sp)
+ 502:	8b2a                	mv	s6,a0
+ 504:	8a2e                	mv	s4,a1
+ 506:	8bb2                	mv	s7,a2
+  state = 0;
+ 508:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 50a:	4481                	li	s1,0
+ 50c:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 50e:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 512:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 516:	06c00c93          	li	s9,108
+ 51a:	a005                	j	53a <vprintf+0x5a>
+        putc(fd, c0);
+ 51c:	85ca                	mv	a1,s2
+ 51e:	855a                	mv	a0,s6
+ 520:	f07ff0ef          	jal	426 <putc>
+ 524:	a019                	j	52a <vprintf+0x4a>
+    } else if(state == '%'){
+ 526:	03598263          	beq	s3,s5,54a <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 52a:	2485                	addiw	s1,s1,1
+ 52c:	8726                	mv	a4,s1
+ 52e:	009a07b3          	add	a5,s4,s1
+ 532:	0007c903          	lbu	s2,0(a5)
+ 536:	22090a63          	beqz	s2,76a <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 53a:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 53e:	fe0994e3          	bnez	s3,526 <vprintf+0x46>
+      if(c0 == '%'){
+ 542:	fd579de3          	bne	a5,s5,51c <vprintf+0x3c>
+        state = '%';
+ 546:	89be                	mv	s3,a5
+ 548:	b7cd                	j	52a <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 54a:	00ea06b3          	add	a3,s4,a4
+ 54e:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 552:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 554:	c681                	beqz	a3,55c <vprintf+0x7c>
+ 556:	9752                	add	a4,a4,s4
+ 558:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 55c:	05878363          	beq	a5,s8,5a2 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 560:	05978d63          	beq	a5,s9,5ba <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 564:	07500713          	li	a4,117
+ 568:	0ee78763          	beq	a5,a4,656 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 56c:	07800713          	li	a4,120
+ 570:	12e78963          	beq	a5,a4,6a2 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 574:	07000713          	li	a4,112
+ 578:	14e78e63          	beq	a5,a4,6d4 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 57c:	06300713          	li	a4,99
+ 580:	18e78e63          	beq	a5,a4,71c <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 584:	07300713          	li	a4,115
+ 588:	1ae78463          	beq	a5,a4,730 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 58c:	02500713          	li	a4,37
+ 590:	04e79563          	bne	a5,a4,5da <vprintf+0xfa>
+        putc(fd, '%');
+ 594:	02500593          	li	a1,37
+ 598:	855a                	mv	a0,s6
+ 59a:	e8dff0ef          	jal	426 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 59e:	4981                	li	s3,0
+ 5a0:	b769                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 5a2:	008b8913          	addi	s2,s7,8
+ 5a6:	4685                	li	a3,1
+ 5a8:	4629                	li	a2,10
+ 5aa:	000ba583          	lw	a1,0(s7)
+ 5ae:	855a                	mv	a0,s6
+ 5b0:	e95ff0ef          	jal	444 <printint>
+ 5b4:	8bca                	mv	s7,s2
+      state = 0;
+ 5b6:	4981                	li	s3,0
+ 5b8:	bf8d                	j	52a <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 5ba:	06400793          	li	a5,100
+ 5be:	02f68963          	beq	a3,a5,5f0 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5c2:	06c00793          	li	a5,108
+ 5c6:	04f68263          	beq	a3,a5,60a <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 5ca:	07500793          	li	a5,117
+ 5ce:	0af68063          	beq	a3,a5,66e <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5d2:	07800793          	li	a5,120
+ 5d6:	0ef68263          	beq	a3,a5,6ba <vprintf+0x1da>
+        putc(fd, '%');
+ 5da:	02500593          	li	a1,37
+ 5de:	855a                	mv	a0,s6
+ 5e0:	e47ff0ef          	jal	426 <putc>
+        putc(fd, c0);
+ 5e4:	85ca                	mv	a1,s2
+ 5e6:	855a                	mv	a0,s6
+ 5e8:	e3fff0ef          	jal	426 <putc>
+      state = 0;
+ 5ec:	4981                	li	s3,0
+ 5ee:	bf35                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5f0:	008b8913          	addi	s2,s7,8
+ 5f4:	4685                	li	a3,1
+ 5f6:	4629                	li	a2,10
+ 5f8:	000bb583          	ld	a1,0(s7)
+ 5fc:	855a                	mv	a0,s6
+ 5fe:	e47ff0ef          	jal	444 <printint>
+        i += 1;
+ 602:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 604:	8bca                	mv	s7,s2
+      state = 0;
+ 606:	4981                	li	s3,0
+        i += 1;
+ 608:	b70d                	j	52a <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 60a:	06400793          	li	a5,100
+ 60e:	02f60763          	beq	a2,a5,63c <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 612:	07500793          	li	a5,117
+ 616:	06f60963          	beq	a2,a5,688 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 61a:	07800793          	li	a5,120
+ 61e:	faf61ee3          	bne	a2,a5,5da <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 622:	008b8913          	addi	s2,s7,8
+ 626:	4681                	li	a3,0
+ 628:	4641                	li	a2,16
+ 62a:	000bb583          	ld	a1,0(s7)
+ 62e:	855a                	mv	a0,s6
+ 630:	e15ff0ef          	jal	444 <printint>
+        i += 2;
+ 634:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 636:	8bca                	mv	s7,s2
+      state = 0;
+ 638:	4981                	li	s3,0
+        i += 2;
+ 63a:	bdc5                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 63c:	008b8913          	addi	s2,s7,8
+ 640:	4685                	li	a3,1
+ 642:	4629                	li	a2,10
+ 644:	000bb583          	ld	a1,0(s7)
+ 648:	855a                	mv	a0,s6
+ 64a:	dfbff0ef          	jal	444 <printint>
+        i += 2;
+ 64e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 650:	8bca                	mv	s7,s2
+      state = 0;
+ 652:	4981                	li	s3,0
+        i += 2;
+ 654:	bdd9                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 656:	008b8913          	addi	s2,s7,8
+ 65a:	4681                	li	a3,0
+ 65c:	4629                	li	a2,10
+ 65e:	000be583          	lwu	a1,0(s7)
+ 662:	855a                	mv	a0,s6
+ 664:	de1ff0ef          	jal	444 <printint>
+ 668:	8bca                	mv	s7,s2
+      state = 0;
+ 66a:	4981                	li	s3,0
+ 66c:	bd7d                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 66e:	008b8913          	addi	s2,s7,8
+ 672:	4681                	li	a3,0
+ 674:	4629                	li	a2,10
+ 676:	000bb583          	ld	a1,0(s7)
+ 67a:	855a                	mv	a0,s6
+ 67c:	dc9ff0ef          	jal	444 <printint>
+        i += 1;
+ 680:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 682:	8bca                	mv	s7,s2
+      state = 0;
+ 684:	4981                	li	s3,0
+        i += 1;
+ 686:	b555                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 688:	008b8913          	addi	s2,s7,8
+ 68c:	4681                	li	a3,0
+ 68e:	4629                	li	a2,10
+ 690:	000bb583          	ld	a1,0(s7)
+ 694:	855a                	mv	a0,s6
+ 696:	dafff0ef          	jal	444 <printint>
+        i += 2;
+ 69a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 69c:	8bca                	mv	s7,s2
+      state = 0;
+ 69e:	4981                	li	s3,0
+        i += 2;
+ 6a0:	b569                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 6a2:	008b8913          	addi	s2,s7,8
+ 6a6:	4681                	li	a3,0
+ 6a8:	4641                	li	a2,16
+ 6aa:	000be583          	lwu	a1,0(s7)
+ 6ae:	855a                	mv	a0,s6
+ 6b0:	d95ff0ef          	jal	444 <printint>
+ 6b4:	8bca                	mv	s7,s2
+      state = 0;
+ 6b6:	4981                	li	s3,0
+ 6b8:	bd8d                	j	52a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6ba:	008b8913          	addi	s2,s7,8
+ 6be:	4681                	li	a3,0
+ 6c0:	4641                	li	a2,16
+ 6c2:	000bb583          	ld	a1,0(s7)
+ 6c6:	855a                	mv	a0,s6
+ 6c8:	d7dff0ef          	jal	444 <printint>
+        i += 1;
+ 6cc:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6ce:	8bca                	mv	s7,s2
+      state = 0;
+ 6d0:	4981                	li	s3,0
+        i += 1;
+ 6d2:	bda1                	j	52a <vprintf+0x4a>
+ 6d4:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6d6:	008b8d13          	addi	s10,s7,8
+ 6da:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6de:	03000593          	li	a1,48
+ 6e2:	855a                	mv	a0,s6
+ 6e4:	d43ff0ef          	jal	426 <putc>
+  putc(fd, 'x');
+ 6e8:	07800593          	li	a1,120
+ 6ec:	855a                	mv	a0,s6
+ 6ee:	d39ff0ef          	jal	426 <putc>
+ 6f2:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 6f4:	00000b97          	auipc	s7,0x0
+ 6f8:	2bcb8b93          	addi	s7,s7,700 # 9b0 <digits>
+ 6fc:	03c9d793          	srli	a5,s3,0x3c
+ 700:	97de                	add	a5,a5,s7
+ 702:	0007c583          	lbu	a1,0(a5)
+ 706:	855a                	mv	a0,s6
+ 708:	d1fff0ef          	jal	426 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 70c:	0992                	slli	s3,s3,0x4
+ 70e:	397d                	addiw	s2,s2,-1
+ 710:	fe0916e3          	bnez	s2,6fc <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 714:	8bea                	mv	s7,s10
+      state = 0;
+ 716:	4981                	li	s3,0
+ 718:	6d02                	ld	s10,0(sp)
+ 71a:	bd01                	j	52a <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 71c:	008b8913          	addi	s2,s7,8
+ 720:	000bc583          	lbu	a1,0(s7)
+ 724:	855a                	mv	a0,s6
+ 726:	d01ff0ef          	jal	426 <putc>
+ 72a:	8bca                	mv	s7,s2
+      state = 0;
+ 72c:	4981                	li	s3,0
+ 72e:	bbf5                	j	52a <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 730:	008b8993          	addi	s3,s7,8
+ 734:	000bb903          	ld	s2,0(s7)
+ 738:	00090f63          	beqz	s2,756 <vprintf+0x276>
+        for(; *s; s++)
+ 73c:	00094583          	lbu	a1,0(s2)
+ 740:	c195                	beqz	a1,764 <vprintf+0x284>
+          putc(fd, *s);
+ 742:	855a                	mv	a0,s6
+ 744:	ce3ff0ef          	jal	426 <putc>
+        for(; *s; s++)
+ 748:	0905                	addi	s2,s2,1
+ 74a:	00094583          	lbu	a1,0(s2)
+ 74e:	f9f5                	bnez	a1,742 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 750:	8bce                	mv	s7,s3
+      state = 0;
+ 752:	4981                	li	s3,0
+ 754:	bbd9                	j	52a <vprintf+0x4a>
+          s = "(null)";
+ 756:	00000917          	auipc	s2,0x0
+ 75a:	25290913          	addi	s2,s2,594 # 9a8 <malloc+0x146>
+        for(; *s; s++)
+ 75e:	02800593          	li	a1,40
+ 762:	b7c5                	j	742 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 764:	8bce                	mv	s7,s3
+      state = 0;
+ 766:	4981                	li	s3,0
+ 768:	b3c9                	j	52a <vprintf+0x4a>
+ 76a:	64a6                	ld	s1,72(sp)
+ 76c:	79e2                	ld	s3,56(sp)
+ 76e:	7a42                	ld	s4,48(sp)
+ 770:	7aa2                	ld	s5,40(sp)
+ 772:	7b02                	ld	s6,32(sp)
+ 774:	6be2                	ld	s7,24(sp)
+ 776:	6c42                	ld	s8,16(sp)
+ 778:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 77a:	60e6                	ld	ra,88(sp)
+ 77c:	6446                	ld	s0,80(sp)
+ 77e:	6906                	ld	s2,64(sp)
+ 780:	6125                	addi	sp,sp,96
+ 782:	8082                	ret
+
+0000000000000784 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 784:	715d                	addi	sp,sp,-80
+ 786:	ec06                	sd	ra,24(sp)
+ 788:	e822                	sd	s0,16(sp)
+ 78a:	1000                	addi	s0,sp,32
+ 78c:	e010                	sd	a2,0(s0)
+ 78e:	e414                	sd	a3,8(s0)
+ 790:	e818                	sd	a4,16(s0)
+ 792:	ec1c                	sd	a5,24(s0)
+ 794:	03043023          	sd	a6,32(s0)
+ 798:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 79c:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 7a0:	8622                	mv	a2,s0
+ 7a2:	d3fff0ef          	jal	4e0 <vprintf>
+}
+ 7a6:	60e2                	ld	ra,24(sp)
+ 7a8:	6442                	ld	s0,16(sp)
+ 7aa:	6161                	addi	sp,sp,80
+ 7ac:	8082                	ret
+
+00000000000007ae <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 7ae:	711d                	addi	sp,sp,-96
+ 7b0:	ec06                	sd	ra,24(sp)
+ 7b2:	e822                	sd	s0,16(sp)
+ 7b4:	1000                	addi	s0,sp,32
+ 7b6:	e40c                	sd	a1,8(s0)
+ 7b8:	e810                	sd	a2,16(s0)
+ 7ba:	ec14                	sd	a3,24(s0)
+ 7bc:	f018                	sd	a4,32(s0)
+ 7be:	f41c                	sd	a5,40(s0)
+ 7c0:	03043823          	sd	a6,48(s0)
+ 7c4:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7c8:	00840613          	addi	a2,s0,8
+ 7cc:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7d0:	85aa                	mv	a1,a0
+ 7d2:	4505                	li	a0,1
+ 7d4:	d0dff0ef          	jal	4e0 <vprintf>
+}
+ 7d8:	60e2                	ld	ra,24(sp)
+ 7da:	6442                	ld	s0,16(sp)
+ 7dc:	6125                	addi	sp,sp,96
+ 7de:	8082                	ret
+
+00000000000007e0 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7e0:	1141                	addi	sp,sp,-16
+ 7e2:	e422                	sd	s0,8(sp)
+ 7e4:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7e6:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7ea:	00001797          	auipc	a5,0x1
+ 7ee:	8167b783          	ld	a5,-2026(a5) # 1000 <freep>
+ 7f2:	a02d                	j	81c <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 7f4:	4618                	lw	a4,8(a2)
+ 7f6:	9f2d                	addw	a4,a4,a1
+ 7f8:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7fc:	6398                	ld	a4,0(a5)
+ 7fe:	6310                	ld	a2,0(a4)
+ 800:	a83d                	j	83e <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 802:	ff852703          	lw	a4,-8(a0)
+ 806:	9f31                	addw	a4,a4,a2
+ 808:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 80a:	ff053683          	ld	a3,-16(a0)
+ 80e:	a091                	j	852 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 810:	6398                	ld	a4,0(a5)
+ 812:	00e7e463          	bltu	a5,a4,81a <free+0x3a>
+ 816:	00e6ea63          	bltu	a3,a4,82a <free+0x4a>
+{
+ 81a:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 81c:	fed7fae3          	bgeu	a5,a3,810 <free+0x30>
+ 820:	6398                	ld	a4,0(a5)
+ 822:	00e6e463          	bltu	a3,a4,82a <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 826:	fee7eae3          	bltu	a5,a4,81a <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 82a:	ff852583          	lw	a1,-8(a0)
+ 82e:	6390                	ld	a2,0(a5)
+ 830:	02059813          	slli	a6,a1,0x20
+ 834:	01c85713          	srli	a4,a6,0x1c
+ 838:	9736                	add	a4,a4,a3
+ 83a:	fae60de3          	beq	a2,a4,7f4 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 83e:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 842:	4790                	lw	a2,8(a5)
+ 844:	02061593          	slli	a1,a2,0x20
+ 848:	01c5d713          	srli	a4,a1,0x1c
+ 84c:	973e                	add	a4,a4,a5
+ 84e:	fae68ae3          	beq	a3,a4,802 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 852:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 854:	00000717          	auipc	a4,0x0
+ 858:	7af73623          	sd	a5,1964(a4) # 1000 <freep>
+}
+ 85c:	6422                	ld	s0,8(sp)
+ 85e:	0141                	addi	sp,sp,16
+ 860:	8082                	ret
+
+0000000000000862 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 862:	7139                	addi	sp,sp,-64
+ 864:	fc06                	sd	ra,56(sp)
+ 866:	f822                	sd	s0,48(sp)
+ 868:	f426                	sd	s1,40(sp)
+ 86a:	ec4e                	sd	s3,24(sp)
+ 86c:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 86e:	02051493          	slli	s1,a0,0x20
+ 872:	9081                	srli	s1,s1,0x20
+ 874:	04bd                	addi	s1,s1,15
+ 876:	8091                	srli	s1,s1,0x4
+ 878:	0014899b          	addiw	s3,s1,1
+ 87c:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 87e:	00000517          	auipc	a0,0x0
+ 882:	78253503          	ld	a0,1922(a0) # 1000 <freep>
+ 886:	c915                	beqz	a0,8ba <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 888:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 88a:	4798                	lw	a4,8(a5)
+ 88c:	08977a63          	bgeu	a4,s1,920 <malloc+0xbe>
+ 890:	f04a                	sd	s2,32(sp)
+ 892:	e852                	sd	s4,16(sp)
+ 894:	e456                	sd	s5,8(sp)
+ 896:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 898:	8a4e                	mv	s4,s3
+ 89a:	0009871b          	sext.w	a4,s3
+ 89e:	6685                	lui	a3,0x1
+ 8a0:	00d77363          	bgeu	a4,a3,8a6 <malloc+0x44>
+ 8a4:	6a05                	lui	s4,0x1
+ 8a6:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 8aa:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 8ae:	00000917          	auipc	s2,0x0
+ 8b2:	75290913          	addi	s2,s2,1874 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 8b6:	5afd                	li	s5,-1
+ 8b8:	a081                	j	8f8 <malloc+0x96>
+ 8ba:	f04a                	sd	s2,32(sp)
+ 8bc:	e852                	sd	s4,16(sp)
+ 8be:	e456                	sd	s5,8(sp)
+ 8c0:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 8c2:	00001797          	auipc	a5,0x1
+ 8c6:	94e78793          	addi	a5,a5,-1714 # 1210 <base>
+ 8ca:	00000717          	auipc	a4,0x0
+ 8ce:	72f73b23          	sd	a5,1846(a4) # 1000 <freep>
+ 8d2:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8d4:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8d8:	b7c1                	j	898 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8da:	6398                	ld	a4,0(a5)
+ 8dc:	e118                	sd	a4,0(a0)
+ 8de:	a8a9                	j	938 <malloc+0xd6>
+  hp->s.size = nu;
+ 8e0:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8e4:	0541                	addi	a0,a0,16
+ 8e6:	efbff0ef          	jal	7e0 <free>
+  return freep;
+ 8ea:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 8ee:	c12d                	beqz	a0,950 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8f0:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8f2:	4798                	lw	a4,8(a5)
+ 8f4:	02977263          	bgeu	a4,s1,918 <malloc+0xb6>
+    if(p == freep)
+ 8f8:	00093703          	ld	a4,0(s2)
+ 8fc:	853e                	mv	a0,a5
+ 8fe:	fef719e3          	bne	a4,a5,8f0 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 902:	8552                	mv	a0,s4
+ 904:	a47ff0ef          	jal	34a <sbrk>
+  if(p == SBRK_ERROR)
+ 908:	fd551ce3          	bne	a0,s5,8e0 <malloc+0x7e>
+        return 0;
+ 90c:	4501                	li	a0,0
+ 90e:	7902                	ld	s2,32(sp)
+ 910:	6a42                	ld	s4,16(sp)
+ 912:	6aa2                	ld	s5,8(sp)
+ 914:	6b02                	ld	s6,0(sp)
+ 916:	a03d                	j	944 <malloc+0xe2>
+ 918:	7902                	ld	s2,32(sp)
+ 91a:	6a42                	ld	s4,16(sp)
+ 91c:	6aa2                	ld	s5,8(sp)
+ 91e:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 920:	fae48de3          	beq	s1,a4,8da <malloc+0x78>
+        p->s.size -= nunits;
+ 924:	4137073b          	subw	a4,a4,s3
+ 928:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 92a:	02071693          	slli	a3,a4,0x20
+ 92e:	01c6d713          	srli	a4,a3,0x1c
+ 932:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 934:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 938:	00000717          	auipc	a4,0x0
+ 93c:	6ca73423          	sd	a0,1736(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 940:	01078513          	addi	a0,a5,16
+  }
+}
+ 944:	70e2                	ld	ra,56(sp)
+ 946:	7442                	ld	s0,48(sp)
+ 948:	74a2                	ld	s1,40(sp)
+ 94a:	69e2                	ld	s3,24(sp)
+ 94c:	6121                	addi	sp,sp,64
+ 94e:	8082                	ret
+ 950:	7902                	ld	s2,32(sp)
+ 952:	6a42                	ld	s4,16(sp)
+ 954:	6aa2                	ld	s5,8(sp)
+ 956:	6b02                	ld	s6,0(sp)
+ 958:	b7f5                	j	944 <malloc+0xe2>
diff -ruN xv6-riscv/user/cat.d xv62/user/cat.d
--- xv6-riscv/user/cat.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/cat.d	2025-09-14 12:32:50.608883371 +0000
@@ -0,0 +1 @@
+user/cat.o: user/cat.c kernel/types.h kernel/fcntl.h user/user.h
Binary files xv6-riscv/user/cat.o and xv62/user/cat.o differ
diff -ruN xv6-riscv/user/cat.sym xv62/user/cat.sym
--- xv6-riscv/user/cat.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/cat.sym	2025-09-14 12:32:50.632883365 +0000
@@ -0,0 +1,68 @@
+0000000000000000 .text
+0000000000000960 .rodata
+00000000000009c8 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 cat.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000426 putc
+0000000000000444 printint
+00000000000009b0 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001210 base
+00000000000000fa strcpy
+000000000000040e pause
+00000000000007ae printf
+0000000000000406 sys_sbrk
+00000000000002a4 memmove
+00000000000003c6 mknod
+00000000000001b2 gets
+00000000000003fe getpid
+0000000000000336 memcpy
+0000000000000000 cat
+0000000000000862 malloc
+0000000000000360 sbrklazy
+000000000000038e pipe
+000000000000039e write
+00000000000003d6 fstat
+0000000000000784 fprintf
+00000000000003ae kill
+00000000000004e0 vprintf
+00000000000003ee chdir
+00000000000003b6 exec
+0000000000000386 wait
+0000000000000396 read
+00000000000003ce unlink
+00000000000002fc memcmp
+0000000000000376 fork
+000000000000034a sbrk
+0000000000000416 uptime
+000000000000016c memset
+0000000000000072 main
+0000000000000116 strcmp
+00000000000003f6 dup
+0000000000001010 buf
+000000000000041e getreadcount
+0000000000000222 stat
+00000000000003de link
+000000000000037e exit
+00000000000000ea start
+000000000000025c atoi
+0000000000000142 strlen
+00000000000003be open
+000000000000018e strchr
+00000000000003e6 mkdir
+00000000000003a6 close
+00000000000007e0 free
diff -ruN xv6-riscv/user/dorphan.asm xv62/user/dorphan.asm
--- xv6-riscv/user/dorphan.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/dorphan.asm	2025-09-14 12:32:52.312883020 +0000
@@ -0,0 +1,1529 @@
+
+user/_dorphan:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+
+char buf[BUFSZ];
+
+int
+main(int argc, char **argv)
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	e426                	sd	s1,8(sp)
+   8:	1000                	addi	s0,sp,32
+  char *s = argv[0];
+   a:	6184                	ld	s1,0(a1)
+
+  if(mkdir("dd") != 0){
+   c:	00001517          	auipc	a0,0x1
+  10:	8f450513          	addi	a0,a0,-1804 # 900 <malloc+0xfe>
+  14:	372000ef          	jal	386 <mkdir>
+  18:	c919                	beqz	a0,2e <main+0x2e>
+    printf("%s: mkdir dd failed\n", s);
+  1a:	85a6                	mv	a1,s1
+  1c:	00001517          	auipc	a0,0x1
+  20:	8ec50513          	addi	a0,a0,-1812 # 908 <malloc+0x106>
+  24:	72a000ef          	jal	74e <printf>
+    exit(1);
+  28:	4505                	li	a0,1
+  2a:	2f4000ef          	jal	31e <exit>
+  }
+
+  if(chdir("dd") != 0){
+  2e:	00001517          	auipc	a0,0x1
+  32:	8d250513          	addi	a0,a0,-1838 # 900 <malloc+0xfe>
+  36:	358000ef          	jal	38e <chdir>
+  3a:	c919                	beqz	a0,50 <main+0x50>
+    printf("%s: chdir dd failed\n", s);
+  3c:	85a6                	mv	a1,s1
+  3e:	00001517          	auipc	a0,0x1
+  42:	8e250513          	addi	a0,a0,-1822 # 920 <malloc+0x11e>
+  46:	708000ef          	jal	74e <printf>
+    exit(1);
+  4a:	4505                	li	a0,1
+  4c:	2d2000ef          	jal	31e <exit>
+  }
+
+  if (unlink("../dd") < 0) {
+  50:	00001517          	auipc	a0,0x1
+  54:	8e850513          	addi	a0,a0,-1816 # 938 <malloc+0x136>
+  58:	316000ef          	jal	36e <unlink>
+  5c:	00054d63          	bltz	a0,76 <main+0x76>
+    printf("%s: unlink failed\n", s);
+    exit(1);
+  }
+  printf("wait for kill and reclaim\n");
+  60:	00001517          	auipc	a0,0x1
+  64:	8f850513          	addi	a0,a0,-1800 # 958 <malloc+0x156>
+  68:	6e6000ef          	jal	74e <printf>
+  // sit around until killed
+  for(;;) pause(1000);
+  6c:	3e800513          	li	a0,1000
+  70:	33e000ef          	jal	3ae <pause>
+  74:	bfe5                	j	6c <main+0x6c>
+    printf("%s: unlink failed\n", s);
+  76:	85a6                	mv	a1,s1
+  78:	00001517          	auipc	a0,0x1
+  7c:	8c850513          	addi	a0,a0,-1848 # 940 <malloc+0x13e>
+  80:	6ce000ef          	jal	74e <printf>
+    exit(1);
+  84:	4505                	li	a0,1
+  86:	298000ef          	jal	31e <exit>
+
+000000000000008a <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  8a:	1141                	addi	sp,sp,-16
+  8c:	e406                	sd	ra,8(sp)
+  8e:	e022                	sd	s0,0(sp)
+  90:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  92:	f6fff0ef          	jal	0 <main>
+  exit(r);
+  96:	288000ef          	jal	31e <exit>
+
+000000000000009a <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  9a:	1141                	addi	sp,sp,-16
+  9c:	e422                	sd	s0,8(sp)
+  9e:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  a0:	87aa                	mv	a5,a0
+  a2:	0585                	addi	a1,a1,1
+  a4:	0785                	addi	a5,a5,1
+  a6:	fff5c703          	lbu	a4,-1(a1)
+  aa:	fee78fa3          	sb	a4,-1(a5)
+  ae:	fb75                	bnez	a4,a2 <strcpy+0x8>
+    ;
+  return os;
+}
+  b0:	6422                	ld	s0,8(sp)
+  b2:	0141                	addi	sp,sp,16
+  b4:	8082                	ret
+
+00000000000000b6 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  b6:	1141                	addi	sp,sp,-16
+  b8:	e422                	sd	s0,8(sp)
+  ba:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  bc:	00054783          	lbu	a5,0(a0)
+  c0:	cb91                	beqz	a5,d4 <strcmp+0x1e>
+  c2:	0005c703          	lbu	a4,0(a1)
+  c6:	00f71763          	bne	a4,a5,d4 <strcmp+0x1e>
+    p++, q++;
+  ca:	0505                	addi	a0,a0,1
+  cc:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  ce:	00054783          	lbu	a5,0(a0)
+  d2:	fbe5                	bnez	a5,c2 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  d4:	0005c503          	lbu	a0,0(a1)
+}
+  d8:	40a7853b          	subw	a0,a5,a0
+  dc:	6422                	ld	s0,8(sp)
+  de:	0141                	addi	sp,sp,16
+  e0:	8082                	ret
+
+00000000000000e2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  e2:	1141                	addi	sp,sp,-16
+  e4:	e422                	sd	s0,8(sp)
+  e6:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  e8:	00054783          	lbu	a5,0(a0)
+  ec:	cf91                	beqz	a5,108 <strlen+0x26>
+  ee:	0505                	addi	a0,a0,1
+  f0:	87aa                	mv	a5,a0
+  f2:	86be                	mv	a3,a5
+  f4:	0785                	addi	a5,a5,1
+  f6:	fff7c703          	lbu	a4,-1(a5)
+  fa:	ff65                	bnez	a4,f2 <strlen+0x10>
+  fc:	40a6853b          	subw	a0,a3,a0
+ 100:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 102:	6422                	ld	s0,8(sp)
+ 104:	0141                	addi	sp,sp,16
+ 106:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 108:	4501                	li	a0,0
+ 10a:	bfe5                	j	102 <strlen+0x20>
+
+000000000000010c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 10c:	1141                	addi	sp,sp,-16
+ 10e:	e422                	sd	s0,8(sp)
+ 110:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 112:	ca19                	beqz	a2,128 <memset+0x1c>
+ 114:	87aa                	mv	a5,a0
+ 116:	1602                	slli	a2,a2,0x20
+ 118:	9201                	srli	a2,a2,0x20
+ 11a:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 11e:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 122:	0785                	addi	a5,a5,1
+ 124:	fee79de3          	bne	a5,a4,11e <memset+0x12>
+  }
+  return dst;
+}
+ 128:	6422                	ld	s0,8(sp)
+ 12a:	0141                	addi	sp,sp,16
+ 12c:	8082                	ret
+
+000000000000012e <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 12e:	1141                	addi	sp,sp,-16
+ 130:	e422                	sd	s0,8(sp)
+ 132:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 134:	00054783          	lbu	a5,0(a0)
+ 138:	cb99                	beqz	a5,14e <strchr+0x20>
+    if(*s == c)
+ 13a:	00f58763          	beq	a1,a5,148 <strchr+0x1a>
+  for(; *s; s++)
+ 13e:	0505                	addi	a0,a0,1
+ 140:	00054783          	lbu	a5,0(a0)
+ 144:	fbfd                	bnez	a5,13a <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 146:	4501                	li	a0,0
+}
+ 148:	6422                	ld	s0,8(sp)
+ 14a:	0141                	addi	sp,sp,16
+ 14c:	8082                	ret
+  return 0;
+ 14e:	4501                	li	a0,0
+ 150:	bfe5                	j	148 <strchr+0x1a>
+
+0000000000000152 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 152:	711d                	addi	sp,sp,-96
+ 154:	ec86                	sd	ra,88(sp)
+ 156:	e8a2                	sd	s0,80(sp)
+ 158:	e4a6                	sd	s1,72(sp)
+ 15a:	e0ca                	sd	s2,64(sp)
+ 15c:	fc4e                	sd	s3,56(sp)
+ 15e:	f852                	sd	s4,48(sp)
+ 160:	f456                	sd	s5,40(sp)
+ 162:	f05a                	sd	s6,32(sp)
+ 164:	ec5e                	sd	s7,24(sp)
+ 166:	1080                	addi	s0,sp,96
+ 168:	8baa                	mv	s7,a0
+ 16a:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 16c:	892a                	mv	s2,a0
+ 16e:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 170:	4aa9                	li	s5,10
+ 172:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 174:	89a6                	mv	s3,s1
+ 176:	2485                	addiw	s1,s1,1
+ 178:	0344d663          	bge	s1,s4,1a4 <gets+0x52>
+    cc = read(0, &c, 1);
+ 17c:	4605                	li	a2,1
+ 17e:	faf40593          	addi	a1,s0,-81
+ 182:	4501                	li	a0,0
+ 184:	1b2000ef          	jal	336 <read>
+    if(cc < 1)
+ 188:	00a05e63          	blez	a0,1a4 <gets+0x52>
+    buf[i++] = c;
+ 18c:	faf44783          	lbu	a5,-81(s0)
+ 190:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 194:	01578763          	beq	a5,s5,1a2 <gets+0x50>
+ 198:	0905                	addi	s2,s2,1
+ 19a:	fd679de3          	bne	a5,s6,174 <gets+0x22>
+    buf[i++] = c;
+ 19e:	89a6                	mv	s3,s1
+ 1a0:	a011                	j	1a4 <gets+0x52>
+ 1a2:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1a4:	99de                	add	s3,s3,s7
+ 1a6:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1aa:	855e                	mv	a0,s7
+ 1ac:	60e6                	ld	ra,88(sp)
+ 1ae:	6446                	ld	s0,80(sp)
+ 1b0:	64a6                	ld	s1,72(sp)
+ 1b2:	6906                	ld	s2,64(sp)
+ 1b4:	79e2                	ld	s3,56(sp)
+ 1b6:	7a42                	ld	s4,48(sp)
+ 1b8:	7aa2                	ld	s5,40(sp)
+ 1ba:	7b02                	ld	s6,32(sp)
+ 1bc:	6be2                	ld	s7,24(sp)
+ 1be:	6125                	addi	sp,sp,96
+ 1c0:	8082                	ret
+
+00000000000001c2 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1c2:	1101                	addi	sp,sp,-32
+ 1c4:	ec06                	sd	ra,24(sp)
+ 1c6:	e822                	sd	s0,16(sp)
+ 1c8:	e04a                	sd	s2,0(sp)
+ 1ca:	1000                	addi	s0,sp,32
+ 1cc:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1ce:	4581                	li	a1,0
+ 1d0:	18e000ef          	jal	35e <open>
+  if(fd < 0)
+ 1d4:	02054263          	bltz	a0,1f8 <stat+0x36>
+ 1d8:	e426                	sd	s1,8(sp)
+ 1da:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1dc:	85ca                	mv	a1,s2
+ 1de:	198000ef          	jal	376 <fstat>
+ 1e2:	892a                	mv	s2,a0
+  close(fd);
+ 1e4:	8526                	mv	a0,s1
+ 1e6:	160000ef          	jal	346 <close>
+  return r;
+ 1ea:	64a2                	ld	s1,8(sp)
+}
+ 1ec:	854a                	mv	a0,s2
+ 1ee:	60e2                	ld	ra,24(sp)
+ 1f0:	6442                	ld	s0,16(sp)
+ 1f2:	6902                	ld	s2,0(sp)
+ 1f4:	6105                	addi	sp,sp,32
+ 1f6:	8082                	ret
+    return -1;
+ 1f8:	597d                	li	s2,-1
+ 1fa:	bfcd                	j	1ec <stat+0x2a>
+
+00000000000001fc <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1fc:	1141                	addi	sp,sp,-16
+ 1fe:	e422                	sd	s0,8(sp)
+ 200:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 202:	00054683          	lbu	a3,0(a0)
+ 206:	fd06879b          	addiw	a5,a3,-48
+ 20a:	0ff7f793          	zext.b	a5,a5
+ 20e:	4625                	li	a2,9
+ 210:	02f66863          	bltu	a2,a5,240 <atoi+0x44>
+ 214:	872a                	mv	a4,a0
+  n = 0;
+ 216:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 218:	0705                	addi	a4,a4,1
+ 21a:	0025179b          	slliw	a5,a0,0x2
+ 21e:	9fa9                	addw	a5,a5,a0
+ 220:	0017979b          	slliw	a5,a5,0x1
+ 224:	9fb5                	addw	a5,a5,a3
+ 226:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 22a:	00074683          	lbu	a3,0(a4)
+ 22e:	fd06879b          	addiw	a5,a3,-48
+ 232:	0ff7f793          	zext.b	a5,a5
+ 236:	fef671e3          	bgeu	a2,a5,218 <atoi+0x1c>
+  return n;
+}
+ 23a:	6422                	ld	s0,8(sp)
+ 23c:	0141                	addi	sp,sp,16
+ 23e:	8082                	ret
+  n = 0;
+ 240:	4501                	li	a0,0
+ 242:	bfe5                	j	23a <atoi+0x3e>
+
+0000000000000244 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 244:	1141                	addi	sp,sp,-16
+ 246:	e422                	sd	s0,8(sp)
+ 248:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 24a:	02b57463          	bgeu	a0,a1,272 <memmove+0x2e>
+    while(n-- > 0)
+ 24e:	00c05f63          	blez	a2,26c <memmove+0x28>
+ 252:	1602                	slli	a2,a2,0x20
+ 254:	9201                	srli	a2,a2,0x20
+ 256:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 25a:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 25c:	0585                	addi	a1,a1,1
+ 25e:	0705                	addi	a4,a4,1
+ 260:	fff5c683          	lbu	a3,-1(a1)
+ 264:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 268:	fef71ae3          	bne	a4,a5,25c <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 26c:	6422                	ld	s0,8(sp)
+ 26e:	0141                	addi	sp,sp,16
+ 270:	8082                	ret
+    dst += n;
+ 272:	00c50733          	add	a4,a0,a2
+    src += n;
+ 276:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 278:	fec05ae3          	blez	a2,26c <memmove+0x28>
+ 27c:	fff6079b          	addiw	a5,a2,-1
+ 280:	1782                	slli	a5,a5,0x20
+ 282:	9381                	srli	a5,a5,0x20
+ 284:	fff7c793          	not	a5,a5
+ 288:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 28a:	15fd                	addi	a1,a1,-1
+ 28c:	177d                	addi	a4,a4,-1
+ 28e:	0005c683          	lbu	a3,0(a1)
+ 292:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 296:	fee79ae3          	bne	a5,a4,28a <memmove+0x46>
+ 29a:	bfc9                	j	26c <memmove+0x28>
+
+000000000000029c <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 29c:	1141                	addi	sp,sp,-16
+ 29e:	e422                	sd	s0,8(sp)
+ 2a0:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2a2:	ca05                	beqz	a2,2d2 <memcmp+0x36>
+ 2a4:	fff6069b          	addiw	a3,a2,-1
+ 2a8:	1682                	slli	a3,a3,0x20
+ 2aa:	9281                	srli	a3,a3,0x20
+ 2ac:	0685                	addi	a3,a3,1
+ 2ae:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2b0:	00054783          	lbu	a5,0(a0)
+ 2b4:	0005c703          	lbu	a4,0(a1)
+ 2b8:	00e79863          	bne	a5,a4,2c8 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 2bc:	0505                	addi	a0,a0,1
+    p2++;
+ 2be:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 2c0:	fed518e3          	bne	a0,a3,2b0 <memcmp+0x14>
+  }
+  return 0;
+ 2c4:	4501                	li	a0,0
+ 2c6:	a019                	j	2cc <memcmp+0x30>
+      return *p1 - *p2;
+ 2c8:	40e7853b          	subw	a0,a5,a4
+}
+ 2cc:	6422                	ld	s0,8(sp)
+ 2ce:	0141                	addi	sp,sp,16
+ 2d0:	8082                	ret
+  return 0;
+ 2d2:	4501                	li	a0,0
+ 2d4:	bfe5                	j	2cc <memcmp+0x30>
+
+00000000000002d6 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2d6:	1141                	addi	sp,sp,-16
+ 2d8:	e406                	sd	ra,8(sp)
+ 2da:	e022                	sd	s0,0(sp)
+ 2dc:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2de:	f67ff0ef          	jal	244 <memmove>
+}
+ 2e2:	60a2                	ld	ra,8(sp)
+ 2e4:	6402                	ld	s0,0(sp)
+ 2e6:	0141                	addi	sp,sp,16
+ 2e8:	8082                	ret
+
+00000000000002ea <sbrk>:
+
+char *
+sbrk(int n) {
+ 2ea:	1141                	addi	sp,sp,-16
+ 2ec:	e406                	sd	ra,8(sp)
+ 2ee:	e022                	sd	s0,0(sp)
+ 2f0:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2f2:	4585                	li	a1,1
+ 2f4:	0b2000ef          	jal	3a6 <sys_sbrk>
+}
+ 2f8:	60a2                	ld	ra,8(sp)
+ 2fa:	6402                	ld	s0,0(sp)
+ 2fc:	0141                	addi	sp,sp,16
+ 2fe:	8082                	ret
+
+0000000000000300 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 300:	1141                	addi	sp,sp,-16
+ 302:	e406                	sd	ra,8(sp)
+ 304:	e022                	sd	s0,0(sp)
+ 306:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 308:	4589                	li	a1,2
+ 30a:	09c000ef          	jal	3a6 <sys_sbrk>
+}
+ 30e:	60a2                	ld	ra,8(sp)
+ 310:	6402                	ld	s0,0(sp)
+ 312:	0141                	addi	sp,sp,16
+ 314:	8082                	ret
+
+0000000000000316 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 316:	4885                	li	a7,1
+ ecall
+ 318:	00000073          	ecall
+ ret
+ 31c:	8082                	ret
+
+000000000000031e <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 31e:	4889                	li	a7,2
+ ecall
+ 320:	00000073          	ecall
+ ret
+ 324:	8082                	ret
+
+0000000000000326 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 326:	488d                	li	a7,3
+ ecall
+ 328:	00000073          	ecall
+ ret
+ 32c:	8082                	ret
+
+000000000000032e <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 32e:	4891                	li	a7,4
+ ecall
+ 330:	00000073          	ecall
+ ret
+ 334:	8082                	ret
+
+0000000000000336 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 336:	4895                	li	a7,5
+ ecall
+ 338:	00000073          	ecall
+ ret
+ 33c:	8082                	ret
+
+000000000000033e <write>:
+.global write
+write:
+ li a7, SYS_write
+ 33e:	48c1                	li	a7,16
+ ecall
+ 340:	00000073          	ecall
+ ret
+ 344:	8082                	ret
+
+0000000000000346 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 346:	48d5                	li	a7,21
+ ecall
+ 348:	00000073          	ecall
+ ret
+ 34c:	8082                	ret
+
+000000000000034e <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 34e:	4899                	li	a7,6
+ ecall
+ 350:	00000073          	ecall
+ ret
+ 354:	8082                	ret
+
+0000000000000356 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 356:	489d                	li	a7,7
+ ecall
+ 358:	00000073          	ecall
+ ret
+ 35c:	8082                	ret
+
+000000000000035e <open>:
+.global open
+open:
+ li a7, SYS_open
+ 35e:	48bd                	li	a7,15
+ ecall
+ 360:	00000073          	ecall
+ ret
+ 364:	8082                	ret
+
+0000000000000366 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 366:	48c5                	li	a7,17
+ ecall
+ 368:	00000073          	ecall
+ ret
+ 36c:	8082                	ret
+
+000000000000036e <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 36e:	48c9                	li	a7,18
+ ecall
+ 370:	00000073          	ecall
+ ret
+ 374:	8082                	ret
+
+0000000000000376 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 376:	48a1                	li	a7,8
+ ecall
+ 378:	00000073          	ecall
+ ret
+ 37c:	8082                	ret
+
+000000000000037e <link>:
+.global link
+link:
+ li a7, SYS_link
+ 37e:	48cd                	li	a7,19
+ ecall
+ 380:	00000073          	ecall
+ ret
+ 384:	8082                	ret
+
+0000000000000386 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 386:	48d1                	li	a7,20
+ ecall
+ 388:	00000073          	ecall
+ ret
+ 38c:	8082                	ret
+
+000000000000038e <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 38e:	48a5                	li	a7,9
+ ecall
+ 390:	00000073          	ecall
+ ret
+ 394:	8082                	ret
+
+0000000000000396 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 396:	48a9                	li	a7,10
+ ecall
+ 398:	00000073          	ecall
+ ret
+ 39c:	8082                	ret
+
+000000000000039e <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 39e:	48ad                	li	a7,11
+ ecall
+ 3a0:	00000073          	ecall
+ ret
+ 3a4:	8082                	ret
+
+00000000000003a6 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3a6:	48b1                	li	a7,12
+ ecall
+ 3a8:	00000073          	ecall
+ ret
+ 3ac:	8082                	ret
+
+00000000000003ae <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3ae:	48b5                	li	a7,13
+ ecall
+ 3b0:	00000073          	ecall
+ ret
+ 3b4:	8082                	ret
+
+00000000000003b6 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 3b6:	48b9                	li	a7,14
+ ecall
+ 3b8:	00000073          	ecall
+ ret
+ 3bc:	8082                	ret
+
+00000000000003be <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 3be:	48d9                	li	a7,22
+ ecall
+ 3c0:	00000073          	ecall
+ ret
+ 3c4:	8082                	ret
+
+00000000000003c6 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3c6:	1101                	addi	sp,sp,-32
+ 3c8:	ec06                	sd	ra,24(sp)
+ 3ca:	e822                	sd	s0,16(sp)
+ 3cc:	1000                	addi	s0,sp,32
+ 3ce:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 3d2:	4605                	li	a2,1
+ 3d4:	fef40593          	addi	a1,s0,-17
+ 3d8:	f67ff0ef          	jal	33e <write>
+}
+ 3dc:	60e2                	ld	ra,24(sp)
+ 3de:	6442                	ld	s0,16(sp)
+ 3e0:	6105                	addi	sp,sp,32
+ 3e2:	8082                	ret
+
+00000000000003e4 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3e4:	715d                	addi	sp,sp,-80
+ 3e6:	e486                	sd	ra,72(sp)
+ 3e8:	e0a2                	sd	s0,64(sp)
+ 3ea:	f84a                	sd	s2,48(sp)
+ 3ec:	0880                	addi	s0,sp,80
+ 3ee:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3f0:	c299                	beqz	a3,3f6 <printint+0x12>
+ 3f2:	0805c363          	bltz	a1,478 <printint+0x94>
+  neg = 0;
+ 3f6:	4881                	li	a7,0
+ 3f8:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3fc:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3fe:	00000517          	auipc	a0,0x0
+ 402:	58250513          	addi	a0,a0,1410 # 980 <digits>
+ 406:	883e                	mv	a6,a5
+ 408:	2785                	addiw	a5,a5,1
+ 40a:	02c5f733          	remu	a4,a1,a2
+ 40e:	972a                	add	a4,a4,a0
+ 410:	00074703          	lbu	a4,0(a4)
+ 414:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 418:	872e                	mv	a4,a1
+ 41a:	02c5d5b3          	divu	a1,a1,a2
+ 41e:	0685                	addi	a3,a3,1
+ 420:	fec773e3          	bgeu	a4,a2,406 <printint+0x22>
+  if(neg)
+ 424:	00088b63          	beqz	a7,43a <printint+0x56>
+    buf[i++] = '-';
+ 428:	fd078793          	addi	a5,a5,-48
+ 42c:	97a2                	add	a5,a5,s0
+ 42e:	02d00713          	li	a4,45
+ 432:	fee78423          	sb	a4,-24(a5)
+ 436:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 43a:	02f05a63          	blez	a5,46e <printint+0x8a>
+ 43e:	fc26                	sd	s1,56(sp)
+ 440:	f44e                	sd	s3,40(sp)
+ 442:	fb840713          	addi	a4,s0,-72
+ 446:	00f704b3          	add	s1,a4,a5
+ 44a:	fff70993          	addi	s3,a4,-1
+ 44e:	99be                	add	s3,s3,a5
+ 450:	37fd                	addiw	a5,a5,-1
+ 452:	1782                	slli	a5,a5,0x20
+ 454:	9381                	srli	a5,a5,0x20
+ 456:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 45a:	fff4c583          	lbu	a1,-1(s1)
+ 45e:	854a                	mv	a0,s2
+ 460:	f67ff0ef          	jal	3c6 <putc>
+  while(--i >= 0)
+ 464:	14fd                	addi	s1,s1,-1
+ 466:	ff349ae3          	bne	s1,s3,45a <printint+0x76>
+ 46a:	74e2                	ld	s1,56(sp)
+ 46c:	79a2                	ld	s3,40(sp)
+}
+ 46e:	60a6                	ld	ra,72(sp)
+ 470:	6406                	ld	s0,64(sp)
+ 472:	7942                	ld	s2,48(sp)
+ 474:	6161                	addi	sp,sp,80
+ 476:	8082                	ret
+    x = -xx;
+ 478:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 47c:	4885                	li	a7,1
+    x = -xx;
+ 47e:	bfad                	j	3f8 <printint+0x14>
+
+0000000000000480 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 480:	711d                	addi	sp,sp,-96
+ 482:	ec86                	sd	ra,88(sp)
+ 484:	e8a2                	sd	s0,80(sp)
+ 486:	e0ca                	sd	s2,64(sp)
+ 488:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 48a:	0005c903          	lbu	s2,0(a1)
+ 48e:	28090663          	beqz	s2,71a <vprintf+0x29a>
+ 492:	e4a6                	sd	s1,72(sp)
+ 494:	fc4e                	sd	s3,56(sp)
+ 496:	f852                	sd	s4,48(sp)
+ 498:	f456                	sd	s5,40(sp)
+ 49a:	f05a                	sd	s6,32(sp)
+ 49c:	ec5e                	sd	s7,24(sp)
+ 49e:	e862                	sd	s8,16(sp)
+ 4a0:	e466                	sd	s9,8(sp)
+ 4a2:	8b2a                	mv	s6,a0
+ 4a4:	8a2e                	mv	s4,a1
+ 4a6:	8bb2                	mv	s7,a2
+  state = 0;
+ 4a8:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 4aa:	4481                	li	s1,0
+ 4ac:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 4ae:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 4b2:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4b6:	06c00c93          	li	s9,108
+ 4ba:	a005                	j	4da <vprintf+0x5a>
+        putc(fd, c0);
+ 4bc:	85ca                	mv	a1,s2
+ 4be:	855a                	mv	a0,s6
+ 4c0:	f07ff0ef          	jal	3c6 <putc>
+ 4c4:	a019                	j	4ca <vprintf+0x4a>
+    } else if(state == '%'){
+ 4c6:	03598263          	beq	s3,s5,4ea <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4ca:	2485                	addiw	s1,s1,1
+ 4cc:	8726                	mv	a4,s1
+ 4ce:	009a07b3          	add	a5,s4,s1
+ 4d2:	0007c903          	lbu	s2,0(a5)
+ 4d6:	22090a63          	beqz	s2,70a <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4da:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4de:	fe0994e3          	bnez	s3,4c6 <vprintf+0x46>
+      if(c0 == '%'){
+ 4e2:	fd579de3          	bne	a5,s5,4bc <vprintf+0x3c>
+        state = '%';
+ 4e6:	89be                	mv	s3,a5
+ 4e8:	b7cd                	j	4ca <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4ea:	00ea06b3          	add	a3,s4,a4
+ 4ee:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4f2:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4f4:	c681                	beqz	a3,4fc <vprintf+0x7c>
+ 4f6:	9752                	add	a4,a4,s4
+ 4f8:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4fc:	05878363          	beq	a5,s8,542 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 500:	05978d63          	beq	a5,s9,55a <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 504:	07500713          	li	a4,117
+ 508:	0ee78763          	beq	a5,a4,5f6 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 50c:	07800713          	li	a4,120
+ 510:	12e78963          	beq	a5,a4,642 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 514:	07000713          	li	a4,112
+ 518:	14e78e63          	beq	a5,a4,674 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 51c:	06300713          	li	a4,99
+ 520:	18e78e63          	beq	a5,a4,6bc <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 524:	07300713          	li	a4,115
+ 528:	1ae78463          	beq	a5,a4,6d0 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 52c:	02500713          	li	a4,37
+ 530:	04e79563          	bne	a5,a4,57a <vprintf+0xfa>
+        putc(fd, '%');
+ 534:	02500593          	li	a1,37
+ 538:	855a                	mv	a0,s6
+ 53a:	e8dff0ef          	jal	3c6 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 53e:	4981                	li	s3,0
+ 540:	b769                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 542:	008b8913          	addi	s2,s7,8
+ 546:	4685                	li	a3,1
+ 548:	4629                	li	a2,10
+ 54a:	000ba583          	lw	a1,0(s7)
+ 54e:	855a                	mv	a0,s6
+ 550:	e95ff0ef          	jal	3e4 <printint>
+ 554:	8bca                	mv	s7,s2
+      state = 0;
+ 556:	4981                	li	s3,0
+ 558:	bf8d                	j	4ca <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 55a:	06400793          	li	a5,100
+ 55e:	02f68963          	beq	a3,a5,590 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 562:	06c00793          	li	a5,108
+ 566:	04f68263          	beq	a3,a5,5aa <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 56a:	07500793          	li	a5,117
+ 56e:	0af68063          	beq	a3,a5,60e <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 572:	07800793          	li	a5,120
+ 576:	0ef68263          	beq	a3,a5,65a <vprintf+0x1da>
+        putc(fd, '%');
+ 57a:	02500593          	li	a1,37
+ 57e:	855a                	mv	a0,s6
+ 580:	e47ff0ef          	jal	3c6 <putc>
+        putc(fd, c0);
+ 584:	85ca                	mv	a1,s2
+ 586:	855a                	mv	a0,s6
+ 588:	e3fff0ef          	jal	3c6 <putc>
+      state = 0;
+ 58c:	4981                	li	s3,0
+ 58e:	bf35                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 590:	008b8913          	addi	s2,s7,8
+ 594:	4685                	li	a3,1
+ 596:	4629                	li	a2,10
+ 598:	000bb583          	ld	a1,0(s7)
+ 59c:	855a                	mv	a0,s6
+ 59e:	e47ff0ef          	jal	3e4 <printint>
+        i += 1;
+ 5a2:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5a4:	8bca                	mv	s7,s2
+      state = 0;
+ 5a6:	4981                	li	s3,0
+        i += 1;
+ 5a8:	b70d                	j	4ca <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5aa:	06400793          	li	a5,100
+ 5ae:	02f60763          	beq	a2,a5,5dc <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 5b2:	07500793          	li	a5,117
+ 5b6:	06f60963          	beq	a2,a5,628 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 5ba:	07800793          	li	a5,120
+ 5be:	faf61ee3          	bne	a2,a5,57a <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5c2:	008b8913          	addi	s2,s7,8
+ 5c6:	4681                	li	a3,0
+ 5c8:	4641                	li	a2,16
+ 5ca:	000bb583          	ld	a1,0(s7)
+ 5ce:	855a                	mv	a0,s6
+ 5d0:	e15ff0ef          	jal	3e4 <printint>
+        i += 2;
+ 5d4:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5d6:	8bca                	mv	s7,s2
+      state = 0;
+ 5d8:	4981                	li	s3,0
+        i += 2;
+ 5da:	bdc5                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5dc:	008b8913          	addi	s2,s7,8
+ 5e0:	4685                	li	a3,1
+ 5e2:	4629                	li	a2,10
+ 5e4:	000bb583          	ld	a1,0(s7)
+ 5e8:	855a                	mv	a0,s6
+ 5ea:	dfbff0ef          	jal	3e4 <printint>
+        i += 2;
+ 5ee:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5f0:	8bca                	mv	s7,s2
+      state = 0;
+ 5f2:	4981                	li	s3,0
+        i += 2;
+ 5f4:	bdd9                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5f6:	008b8913          	addi	s2,s7,8
+ 5fa:	4681                	li	a3,0
+ 5fc:	4629                	li	a2,10
+ 5fe:	000be583          	lwu	a1,0(s7)
+ 602:	855a                	mv	a0,s6
+ 604:	de1ff0ef          	jal	3e4 <printint>
+ 608:	8bca                	mv	s7,s2
+      state = 0;
+ 60a:	4981                	li	s3,0
+ 60c:	bd7d                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 60e:	008b8913          	addi	s2,s7,8
+ 612:	4681                	li	a3,0
+ 614:	4629                	li	a2,10
+ 616:	000bb583          	ld	a1,0(s7)
+ 61a:	855a                	mv	a0,s6
+ 61c:	dc9ff0ef          	jal	3e4 <printint>
+        i += 1;
+ 620:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 622:	8bca                	mv	s7,s2
+      state = 0;
+ 624:	4981                	li	s3,0
+        i += 1;
+ 626:	b555                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 628:	008b8913          	addi	s2,s7,8
+ 62c:	4681                	li	a3,0
+ 62e:	4629                	li	a2,10
+ 630:	000bb583          	ld	a1,0(s7)
+ 634:	855a                	mv	a0,s6
+ 636:	dafff0ef          	jal	3e4 <printint>
+        i += 2;
+ 63a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 63c:	8bca                	mv	s7,s2
+      state = 0;
+ 63e:	4981                	li	s3,0
+        i += 2;
+ 640:	b569                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 642:	008b8913          	addi	s2,s7,8
+ 646:	4681                	li	a3,0
+ 648:	4641                	li	a2,16
+ 64a:	000be583          	lwu	a1,0(s7)
+ 64e:	855a                	mv	a0,s6
+ 650:	d95ff0ef          	jal	3e4 <printint>
+ 654:	8bca                	mv	s7,s2
+      state = 0;
+ 656:	4981                	li	s3,0
+ 658:	bd8d                	j	4ca <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 65a:	008b8913          	addi	s2,s7,8
+ 65e:	4681                	li	a3,0
+ 660:	4641                	li	a2,16
+ 662:	000bb583          	ld	a1,0(s7)
+ 666:	855a                	mv	a0,s6
+ 668:	d7dff0ef          	jal	3e4 <printint>
+        i += 1;
+ 66c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 66e:	8bca                	mv	s7,s2
+      state = 0;
+ 670:	4981                	li	s3,0
+        i += 1;
+ 672:	bda1                	j	4ca <vprintf+0x4a>
+ 674:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 676:	008b8d13          	addi	s10,s7,8
+ 67a:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 67e:	03000593          	li	a1,48
+ 682:	855a                	mv	a0,s6
+ 684:	d43ff0ef          	jal	3c6 <putc>
+  putc(fd, 'x');
+ 688:	07800593          	li	a1,120
+ 68c:	855a                	mv	a0,s6
+ 68e:	d39ff0ef          	jal	3c6 <putc>
+ 692:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 694:	00000b97          	auipc	s7,0x0
+ 698:	2ecb8b93          	addi	s7,s7,748 # 980 <digits>
+ 69c:	03c9d793          	srli	a5,s3,0x3c
+ 6a0:	97de                	add	a5,a5,s7
+ 6a2:	0007c583          	lbu	a1,0(a5)
+ 6a6:	855a                	mv	a0,s6
+ 6a8:	d1fff0ef          	jal	3c6 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 6ac:	0992                	slli	s3,s3,0x4
+ 6ae:	397d                	addiw	s2,s2,-1
+ 6b0:	fe0916e3          	bnez	s2,69c <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 6b4:	8bea                	mv	s7,s10
+      state = 0;
+ 6b6:	4981                	li	s3,0
+ 6b8:	6d02                	ld	s10,0(sp)
+ 6ba:	bd01                	j	4ca <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 6bc:	008b8913          	addi	s2,s7,8
+ 6c0:	000bc583          	lbu	a1,0(s7)
+ 6c4:	855a                	mv	a0,s6
+ 6c6:	d01ff0ef          	jal	3c6 <putc>
+ 6ca:	8bca                	mv	s7,s2
+      state = 0;
+ 6cc:	4981                	li	s3,0
+ 6ce:	bbf5                	j	4ca <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 6d0:	008b8993          	addi	s3,s7,8
+ 6d4:	000bb903          	ld	s2,0(s7)
+ 6d8:	00090f63          	beqz	s2,6f6 <vprintf+0x276>
+        for(; *s; s++)
+ 6dc:	00094583          	lbu	a1,0(s2)
+ 6e0:	c195                	beqz	a1,704 <vprintf+0x284>
+          putc(fd, *s);
+ 6e2:	855a                	mv	a0,s6
+ 6e4:	ce3ff0ef          	jal	3c6 <putc>
+        for(; *s; s++)
+ 6e8:	0905                	addi	s2,s2,1
+ 6ea:	00094583          	lbu	a1,0(s2)
+ 6ee:	f9f5                	bnez	a1,6e2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6f0:	8bce                	mv	s7,s3
+      state = 0;
+ 6f2:	4981                	li	s3,0
+ 6f4:	bbd9                	j	4ca <vprintf+0x4a>
+          s = "(null)";
+ 6f6:	00000917          	auipc	s2,0x0
+ 6fa:	28290913          	addi	s2,s2,642 # 978 <malloc+0x176>
+        for(; *s; s++)
+ 6fe:	02800593          	li	a1,40
+ 702:	b7c5                	j	6e2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 704:	8bce                	mv	s7,s3
+      state = 0;
+ 706:	4981                	li	s3,0
+ 708:	b3c9                	j	4ca <vprintf+0x4a>
+ 70a:	64a6                	ld	s1,72(sp)
+ 70c:	79e2                	ld	s3,56(sp)
+ 70e:	7a42                	ld	s4,48(sp)
+ 710:	7aa2                	ld	s5,40(sp)
+ 712:	7b02                	ld	s6,32(sp)
+ 714:	6be2                	ld	s7,24(sp)
+ 716:	6c42                	ld	s8,16(sp)
+ 718:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 71a:	60e6                	ld	ra,88(sp)
+ 71c:	6446                	ld	s0,80(sp)
+ 71e:	6906                	ld	s2,64(sp)
+ 720:	6125                	addi	sp,sp,96
+ 722:	8082                	ret
+
+0000000000000724 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 724:	715d                	addi	sp,sp,-80
+ 726:	ec06                	sd	ra,24(sp)
+ 728:	e822                	sd	s0,16(sp)
+ 72a:	1000                	addi	s0,sp,32
+ 72c:	e010                	sd	a2,0(s0)
+ 72e:	e414                	sd	a3,8(s0)
+ 730:	e818                	sd	a4,16(s0)
+ 732:	ec1c                	sd	a5,24(s0)
+ 734:	03043023          	sd	a6,32(s0)
+ 738:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 73c:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 740:	8622                	mv	a2,s0
+ 742:	d3fff0ef          	jal	480 <vprintf>
+}
+ 746:	60e2                	ld	ra,24(sp)
+ 748:	6442                	ld	s0,16(sp)
+ 74a:	6161                	addi	sp,sp,80
+ 74c:	8082                	ret
+
+000000000000074e <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 74e:	711d                	addi	sp,sp,-96
+ 750:	ec06                	sd	ra,24(sp)
+ 752:	e822                	sd	s0,16(sp)
+ 754:	1000                	addi	s0,sp,32
+ 756:	e40c                	sd	a1,8(s0)
+ 758:	e810                	sd	a2,16(s0)
+ 75a:	ec14                	sd	a3,24(s0)
+ 75c:	f018                	sd	a4,32(s0)
+ 75e:	f41c                	sd	a5,40(s0)
+ 760:	03043823          	sd	a6,48(s0)
+ 764:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 768:	00840613          	addi	a2,s0,8
+ 76c:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 770:	85aa                	mv	a1,a0
+ 772:	4505                	li	a0,1
+ 774:	d0dff0ef          	jal	480 <vprintf>
+}
+ 778:	60e2                	ld	ra,24(sp)
+ 77a:	6442                	ld	s0,16(sp)
+ 77c:	6125                	addi	sp,sp,96
+ 77e:	8082                	ret
+
+0000000000000780 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 780:	1141                	addi	sp,sp,-16
+ 782:	e422                	sd	s0,8(sp)
+ 784:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 786:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 78a:	00001797          	auipc	a5,0x1
+ 78e:	8767b783          	ld	a5,-1930(a5) # 1000 <freep>
+ 792:	a02d                	j	7bc <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 794:	4618                	lw	a4,8(a2)
+ 796:	9f2d                	addw	a4,a4,a1
+ 798:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 79c:	6398                	ld	a4,0(a5)
+ 79e:	6310                	ld	a2,0(a4)
+ 7a0:	a83d                	j	7de <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 7a2:	ff852703          	lw	a4,-8(a0)
+ 7a6:	9f31                	addw	a4,a4,a2
+ 7a8:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 7aa:	ff053683          	ld	a3,-16(a0)
+ 7ae:	a091                	j	7f2 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7b0:	6398                	ld	a4,0(a5)
+ 7b2:	00e7e463          	bltu	a5,a4,7ba <free+0x3a>
+ 7b6:	00e6ea63          	bltu	a3,a4,7ca <free+0x4a>
+{
+ 7ba:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7bc:	fed7fae3          	bgeu	a5,a3,7b0 <free+0x30>
+ 7c0:	6398                	ld	a4,0(a5)
+ 7c2:	00e6e463          	bltu	a3,a4,7ca <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7c6:	fee7eae3          	bltu	a5,a4,7ba <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7ca:	ff852583          	lw	a1,-8(a0)
+ 7ce:	6390                	ld	a2,0(a5)
+ 7d0:	02059813          	slli	a6,a1,0x20
+ 7d4:	01c85713          	srli	a4,a6,0x1c
+ 7d8:	9736                	add	a4,a4,a3
+ 7da:	fae60de3          	beq	a2,a4,794 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7de:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7e2:	4790                	lw	a2,8(a5)
+ 7e4:	02061593          	slli	a1,a2,0x20
+ 7e8:	01c5d713          	srli	a4,a1,0x1c
+ 7ec:	973e                	add	a4,a4,a5
+ 7ee:	fae68ae3          	beq	a3,a4,7a2 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7f2:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7f4:	00001717          	auipc	a4,0x1
+ 7f8:	80f73623          	sd	a5,-2036(a4) # 1000 <freep>
+}
+ 7fc:	6422                	ld	s0,8(sp)
+ 7fe:	0141                	addi	sp,sp,16
+ 800:	8082                	ret
+
+0000000000000802 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 802:	7139                	addi	sp,sp,-64
+ 804:	fc06                	sd	ra,56(sp)
+ 806:	f822                	sd	s0,48(sp)
+ 808:	f426                	sd	s1,40(sp)
+ 80a:	ec4e                	sd	s3,24(sp)
+ 80c:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 80e:	02051493          	slli	s1,a0,0x20
+ 812:	9081                	srli	s1,s1,0x20
+ 814:	04bd                	addi	s1,s1,15
+ 816:	8091                	srli	s1,s1,0x4
+ 818:	0014899b          	addiw	s3,s1,1
+ 81c:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 81e:	00000517          	auipc	a0,0x0
+ 822:	7e253503          	ld	a0,2018(a0) # 1000 <freep>
+ 826:	c915                	beqz	a0,85a <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 828:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 82a:	4798                	lw	a4,8(a5)
+ 82c:	08977a63          	bgeu	a4,s1,8c0 <malloc+0xbe>
+ 830:	f04a                	sd	s2,32(sp)
+ 832:	e852                	sd	s4,16(sp)
+ 834:	e456                	sd	s5,8(sp)
+ 836:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 838:	8a4e                	mv	s4,s3
+ 83a:	0009871b          	sext.w	a4,s3
+ 83e:	6685                	lui	a3,0x1
+ 840:	00d77363          	bgeu	a4,a3,846 <malloc+0x44>
+ 844:	6a05                	lui	s4,0x1
+ 846:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 84a:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 84e:	00000917          	auipc	s2,0x0
+ 852:	7b290913          	addi	s2,s2,1970 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 856:	5afd                	li	s5,-1
+ 858:	a081                	j	898 <malloc+0x96>
+ 85a:	f04a                	sd	s2,32(sp)
+ 85c:	e852                	sd	s4,16(sp)
+ 85e:	e456                	sd	s5,8(sp)
+ 860:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 862:	00001797          	auipc	a5,0x1
+ 866:	9a678793          	addi	a5,a5,-1626 # 1208 <base>
+ 86a:	00000717          	auipc	a4,0x0
+ 86e:	78f73b23          	sd	a5,1942(a4) # 1000 <freep>
+ 872:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 874:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 878:	b7c1                	j	838 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 87a:	6398                	ld	a4,0(a5)
+ 87c:	e118                	sd	a4,0(a0)
+ 87e:	a8a9                	j	8d8 <malloc+0xd6>
+  hp->s.size = nu;
+ 880:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 884:	0541                	addi	a0,a0,16
+ 886:	efbff0ef          	jal	780 <free>
+  return freep;
+ 88a:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 88e:	c12d                	beqz	a0,8f0 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 890:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 892:	4798                	lw	a4,8(a5)
+ 894:	02977263          	bgeu	a4,s1,8b8 <malloc+0xb6>
+    if(p == freep)
+ 898:	00093703          	ld	a4,0(s2)
+ 89c:	853e                	mv	a0,a5
+ 89e:	fef719e3          	bne	a4,a5,890 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 8a2:	8552                	mv	a0,s4
+ 8a4:	a47ff0ef          	jal	2ea <sbrk>
+  if(p == SBRK_ERROR)
+ 8a8:	fd551ce3          	bne	a0,s5,880 <malloc+0x7e>
+        return 0;
+ 8ac:	4501                	li	a0,0
+ 8ae:	7902                	ld	s2,32(sp)
+ 8b0:	6a42                	ld	s4,16(sp)
+ 8b2:	6aa2                	ld	s5,8(sp)
+ 8b4:	6b02                	ld	s6,0(sp)
+ 8b6:	a03d                	j	8e4 <malloc+0xe2>
+ 8b8:	7902                	ld	s2,32(sp)
+ 8ba:	6a42                	ld	s4,16(sp)
+ 8bc:	6aa2                	ld	s5,8(sp)
+ 8be:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 8c0:	fae48de3          	beq	s1,a4,87a <malloc+0x78>
+        p->s.size -= nunits;
+ 8c4:	4137073b          	subw	a4,a4,s3
+ 8c8:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8ca:	02071693          	slli	a3,a4,0x20
+ 8ce:	01c6d713          	srli	a4,a3,0x1c
+ 8d2:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 8d4:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8d8:	00000717          	auipc	a4,0x0
+ 8dc:	72a73423          	sd	a0,1832(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8e0:	01078513          	addi	a0,a5,16
+  }
+}
+ 8e4:	70e2                	ld	ra,56(sp)
+ 8e6:	7442                	ld	s0,48(sp)
+ 8e8:	74a2                	ld	s1,40(sp)
+ 8ea:	69e2                	ld	s3,24(sp)
+ 8ec:	6121                	addi	sp,sp,64
+ 8ee:	8082                	ret
+ 8f0:	7902                	ld	s2,32(sp)
+ 8f2:	6a42                	ld	s4,16(sp)
+ 8f4:	6aa2                	ld	s5,8(sp)
+ 8f6:	6b02                	ld	s6,0(sp)
+ 8f8:	b7f5                	j	8e4 <malloc+0xe2>
diff -ruN xv6-riscv/user/dorphan.d xv62/user/dorphan.d
--- xv6-riscv/user/dorphan.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/dorphan.d	2025-09-14 12:32:52.292883025 +0000
@@ -0,0 +1,2 @@
+user/dorphan.o: user/dorphan.c kernel/types.h kernel/stat.h \
+ kernel/fcntl.h user/user.h
Binary files xv6-riscv/user/dorphan.o and xv62/user/dorphan.o differ
diff -ruN xv6-riscv/user/dorphan.sym xv62/user/dorphan.sym
--- xv6-riscv/user/dorphan.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/dorphan.sym	2025-09-14 12:32:52.316883020 +0000
@@ -0,0 +1,67 @@
+0000000000000000 .text
+0000000000000900 .rodata
+0000000000000998 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 dorphan.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003c6 putc
+00000000000003e4 printint
+0000000000000980 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001208 base
+000000000000009a strcpy
+00000000000003ae pause
+000000000000074e printf
+00000000000003a6 sys_sbrk
+0000000000000244 memmove
+0000000000000366 mknod
+0000000000000152 gets
+000000000000039e getpid
+00000000000002d6 memcpy
+0000000000000802 malloc
+0000000000000300 sbrklazy
+000000000000032e pipe
+000000000000033e write
+0000000000000376 fstat
+0000000000000724 fprintf
+000000000000034e kill
+0000000000000480 vprintf
+000000000000038e chdir
+0000000000000356 exec
+0000000000000326 wait
+0000000000000336 read
+000000000000036e unlink
+000000000000029c memcmp
+0000000000000316 fork
+00000000000002ea sbrk
+00000000000003b6 uptime
+000000000000010c memset
+0000000000000000 main
+00000000000000b6 strcmp
+0000000000000396 dup
+0000000000001010 buf
+00000000000003be getreadcount
+00000000000001c2 stat
+000000000000037e link
+000000000000031e exit
+000000000000008a start
+00000000000001fc atoi
+00000000000000e2 strlen
+000000000000035e open
+000000000000012e strchr
+0000000000000386 mkdir
+0000000000000346 close
+0000000000000780 free
diff -ruN xv6-riscv/user/echo.asm xv62/user/echo.asm
--- xv6-riscv/user/echo.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/echo.asm	2025-09-14 12:32:50.680883356 +0000
@@ -0,0 +1,1522 @@
+
+user/_echo:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	7139                	addi	sp,sp,-64
+   2:	fc06                	sd	ra,56(sp)
+   4:	f822                	sd	s0,48(sp)
+   6:	f426                	sd	s1,40(sp)
+   8:	f04a                	sd	s2,32(sp)
+   a:	ec4e                	sd	s3,24(sp)
+   c:	e852                	sd	s4,16(sp)
+   e:	e456                	sd	s5,8(sp)
+  10:	0080                	addi	s0,sp,64
+  int i;
+
+  for(i = 1; i < argc; i++){
+  12:	4785                	li	a5,1
+  14:	06a7d063          	bge	a5,a0,74 <main+0x74>
+  18:	00858493          	addi	s1,a1,8
+  1c:	3579                	addiw	a0,a0,-2
+  1e:	02051793          	slli	a5,a0,0x20
+  22:	01d7d513          	srli	a0,a5,0x1d
+  26:	00a48a33          	add	s4,s1,a0
+  2a:	05c1                	addi	a1,a1,16
+  2c:	00a589b3          	add	s3,a1,a0
+    write(1, argv[i], strlen(argv[i]));
+    if(i + 1 < argc){
+      write(1, " ", 1);
+  30:	00001a97          	auipc	s5,0x1
+  34:	8c0a8a93          	addi	s5,s5,-1856 # 8f0 <malloc+0xfe>
+  38:	a809                	j	4a <main+0x4a>
+  3a:	4605                	li	a2,1
+  3c:	85d6                	mv	a1,s5
+  3e:	4505                	li	a0,1
+  40:	2ee000ef          	jal	32e <write>
+  for(i = 1; i < argc; i++){
+  44:	04a1                	addi	s1,s1,8
+  46:	03348763          	beq	s1,s3,74 <main+0x74>
+    write(1, argv[i], strlen(argv[i]));
+  4a:	0004b903          	ld	s2,0(s1)
+  4e:	854a                	mv	a0,s2
+  50:	082000ef          	jal	d2 <strlen>
+  54:	0005061b          	sext.w	a2,a0
+  58:	85ca                	mv	a1,s2
+  5a:	4505                	li	a0,1
+  5c:	2d2000ef          	jal	32e <write>
+    if(i + 1 < argc){
+  60:	fd449de3          	bne	s1,s4,3a <main+0x3a>
+    } else {
+      write(1, "\n", 1);
+  64:	4605                	li	a2,1
+  66:	00001597          	auipc	a1,0x1
+  6a:	89258593          	addi	a1,a1,-1902 # 8f8 <malloc+0x106>
+  6e:	4505                	li	a0,1
+  70:	2be000ef          	jal	32e <write>
+    }
+  }
+  exit(0);
+  74:	4501                	li	a0,0
+  76:	298000ef          	jal	30e <exit>
+
+000000000000007a <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  7a:	1141                	addi	sp,sp,-16
+  7c:	e406                	sd	ra,8(sp)
+  7e:	e022                	sd	s0,0(sp)
+  80:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  82:	f7fff0ef          	jal	0 <main>
+  exit(r);
+  86:	288000ef          	jal	30e <exit>
+
+000000000000008a <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  8a:	1141                	addi	sp,sp,-16
+  8c:	e422                	sd	s0,8(sp)
+  8e:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  90:	87aa                	mv	a5,a0
+  92:	0585                	addi	a1,a1,1
+  94:	0785                	addi	a5,a5,1
+  96:	fff5c703          	lbu	a4,-1(a1)
+  9a:	fee78fa3          	sb	a4,-1(a5)
+  9e:	fb75                	bnez	a4,92 <strcpy+0x8>
+    ;
+  return os;
+}
+  a0:	6422                	ld	s0,8(sp)
+  a2:	0141                	addi	sp,sp,16
+  a4:	8082                	ret
+
+00000000000000a6 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  a6:	1141                	addi	sp,sp,-16
+  a8:	e422                	sd	s0,8(sp)
+  aa:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  ac:	00054783          	lbu	a5,0(a0)
+  b0:	cb91                	beqz	a5,c4 <strcmp+0x1e>
+  b2:	0005c703          	lbu	a4,0(a1)
+  b6:	00f71763          	bne	a4,a5,c4 <strcmp+0x1e>
+    p++, q++;
+  ba:	0505                	addi	a0,a0,1
+  bc:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  be:	00054783          	lbu	a5,0(a0)
+  c2:	fbe5                	bnez	a5,b2 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  c4:	0005c503          	lbu	a0,0(a1)
+}
+  c8:	40a7853b          	subw	a0,a5,a0
+  cc:	6422                	ld	s0,8(sp)
+  ce:	0141                	addi	sp,sp,16
+  d0:	8082                	ret
+
+00000000000000d2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  d2:	1141                	addi	sp,sp,-16
+  d4:	e422                	sd	s0,8(sp)
+  d6:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  d8:	00054783          	lbu	a5,0(a0)
+  dc:	cf91                	beqz	a5,f8 <strlen+0x26>
+  de:	0505                	addi	a0,a0,1
+  e0:	87aa                	mv	a5,a0
+  e2:	86be                	mv	a3,a5
+  e4:	0785                	addi	a5,a5,1
+  e6:	fff7c703          	lbu	a4,-1(a5)
+  ea:	ff65                	bnez	a4,e2 <strlen+0x10>
+  ec:	40a6853b          	subw	a0,a3,a0
+  f0:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  f2:	6422                	ld	s0,8(sp)
+  f4:	0141                	addi	sp,sp,16
+  f6:	8082                	ret
+  for(n = 0; s[n]; n++)
+  f8:	4501                	li	a0,0
+  fa:	bfe5                	j	f2 <strlen+0x20>
+
+00000000000000fc <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  fc:	1141                	addi	sp,sp,-16
+  fe:	e422                	sd	s0,8(sp)
+ 100:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 102:	ca19                	beqz	a2,118 <memset+0x1c>
+ 104:	87aa                	mv	a5,a0
+ 106:	1602                	slli	a2,a2,0x20
+ 108:	9201                	srli	a2,a2,0x20
+ 10a:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 10e:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 112:	0785                	addi	a5,a5,1
+ 114:	fee79de3          	bne	a5,a4,10e <memset+0x12>
+  }
+  return dst;
+}
+ 118:	6422                	ld	s0,8(sp)
+ 11a:	0141                	addi	sp,sp,16
+ 11c:	8082                	ret
+
+000000000000011e <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 11e:	1141                	addi	sp,sp,-16
+ 120:	e422                	sd	s0,8(sp)
+ 122:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 124:	00054783          	lbu	a5,0(a0)
+ 128:	cb99                	beqz	a5,13e <strchr+0x20>
+    if(*s == c)
+ 12a:	00f58763          	beq	a1,a5,138 <strchr+0x1a>
+  for(; *s; s++)
+ 12e:	0505                	addi	a0,a0,1
+ 130:	00054783          	lbu	a5,0(a0)
+ 134:	fbfd                	bnez	a5,12a <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 136:	4501                	li	a0,0
+}
+ 138:	6422                	ld	s0,8(sp)
+ 13a:	0141                	addi	sp,sp,16
+ 13c:	8082                	ret
+  return 0;
+ 13e:	4501                	li	a0,0
+ 140:	bfe5                	j	138 <strchr+0x1a>
+
+0000000000000142 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 142:	711d                	addi	sp,sp,-96
+ 144:	ec86                	sd	ra,88(sp)
+ 146:	e8a2                	sd	s0,80(sp)
+ 148:	e4a6                	sd	s1,72(sp)
+ 14a:	e0ca                	sd	s2,64(sp)
+ 14c:	fc4e                	sd	s3,56(sp)
+ 14e:	f852                	sd	s4,48(sp)
+ 150:	f456                	sd	s5,40(sp)
+ 152:	f05a                	sd	s6,32(sp)
+ 154:	ec5e                	sd	s7,24(sp)
+ 156:	1080                	addi	s0,sp,96
+ 158:	8baa                	mv	s7,a0
+ 15a:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 15c:	892a                	mv	s2,a0
+ 15e:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 160:	4aa9                	li	s5,10
+ 162:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 164:	89a6                	mv	s3,s1
+ 166:	2485                	addiw	s1,s1,1
+ 168:	0344d663          	bge	s1,s4,194 <gets+0x52>
+    cc = read(0, &c, 1);
+ 16c:	4605                	li	a2,1
+ 16e:	faf40593          	addi	a1,s0,-81
+ 172:	4501                	li	a0,0
+ 174:	1b2000ef          	jal	326 <read>
+    if(cc < 1)
+ 178:	00a05e63          	blez	a0,194 <gets+0x52>
+    buf[i++] = c;
+ 17c:	faf44783          	lbu	a5,-81(s0)
+ 180:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 184:	01578763          	beq	a5,s5,192 <gets+0x50>
+ 188:	0905                	addi	s2,s2,1
+ 18a:	fd679de3          	bne	a5,s6,164 <gets+0x22>
+    buf[i++] = c;
+ 18e:	89a6                	mv	s3,s1
+ 190:	a011                	j	194 <gets+0x52>
+ 192:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 194:	99de                	add	s3,s3,s7
+ 196:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 19a:	855e                	mv	a0,s7
+ 19c:	60e6                	ld	ra,88(sp)
+ 19e:	6446                	ld	s0,80(sp)
+ 1a0:	64a6                	ld	s1,72(sp)
+ 1a2:	6906                	ld	s2,64(sp)
+ 1a4:	79e2                	ld	s3,56(sp)
+ 1a6:	7a42                	ld	s4,48(sp)
+ 1a8:	7aa2                	ld	s5,40(sp)
+ 1aa:	7b02                	ld	s6,32(sp)
+ 1ac:	6be2                	ld	s7,24(sp)
+ 1ae:	6125                	addi	sp,sp,96
+ 1b0:	8082                	ret
+
+00000000000001b2 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1b2:	1101                	addi	sp,sp,-32
+ 1b4:	ec06                	sd	ra,24(sp)
+ 1b6:	e822                	sd	s0,16(sp)
+ 1b8:	e04a                	sd	s2,0(sp)
+ 1ba:	1000                	addi	s0,sp,32
+ 1bc:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1be:	4581                	li	a1,0
+ 1c0:	18e000ef          	jal	34e <open>
+  if(fd < 0)
+ 1c4:	02054263          	bltz	a0,1e8 <stat+0x36>
+ 1c8:	e426                	sd	s1,8(sp)
+ 1ca:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1cc:	85ca                	mv	a1,s2
+ 1ce:	198000ef          	jal	366 <fstat>
+ 1d2:	892a                	mv	s2,a0
+  close(fd);
+ 1d4:	8526                	mv	a0,s1
+ 1d6:	160000ef          	jal	336 <close>
+  return r;
+ 1da:	64a2                	ld	s1,8(sp)
+}
+ 1dc:	854a                	mv	a0,s2
+ 1de:	60e2                	ld	ra,24(sp)
+ 1e0:	6442                	ld	s0,16(sp)
+ 1e2:	6902                	ld	s2,0(sp)
+ 1e4:	6105                	addi	sp,sp,32
+ 1e6:	8082                	ret
+    return -1;
+ 1e8:	597d                	li	s2,-1
+ 1ea:	bfcd                	j	1dc <stat+0x2a>
+
+00000000000001ec <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1ec:	1141                	addi	sp,sp,-16
+ 1ee:	e422                	sd	s0,8(sp)
+ 1f0:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1f2:	00054683          	lbu	a3,0(a0)
+ 1f6:	fd06879b          	addiw	a5,a3,-48
+ 1fa:	0ff7f793          	zext.b	a5,a5
+ 1fe:	4625                	li	a2,9
+ 200:	02f66863          	bltu	a2,a5,230 <atoi+0x44>
+ 204:	872a                	mv	a4,a0
+  n = 0;
+ 206:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 208:	0705                	addi	a4,a4,1
+ 20a:	0025179b          	slliw	a5,a0,0x2
+ 20e:	9fa9                	addw	a5,a5,a0
+ 210:	0017979b          	slliw	a5,a5,0x1
+ 214:	9fb5                	addw	a5,a5,a3
+ 216:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 21a:	00074683          	lbu	a3,0(a4)
+ 21e:	fd06879b          	addiw	a5,a3,-48
+ 222:	0ff7f793          	zext.b	a5,a5
+ 226:	fef671e3          	bgeu	a2,a5,208 <atoi+0x1c>
+  return n;
+}
+ 22a:	6422                	ld	s0,8(sp)
+ 22c:	0141                	addi	sp,sp,16
+ 22e:	8082                	ret
+  n = 0;
+ 230:	4501                	li	a0,0
+ 232:	bfe5                	j	22a <atoi+0x3e>
+
+0000000000000234 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 234:	1141                	addi	sp,sp,-16
+ 236:	e422                	sd	s0,8(sp)
+ 238:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 23a:	02b57463          	bgeu	a0,a1,262 <memmove+0x2e>
+    while(n-- > 0)
+ 23e:	00c05f63          	blez	a2,25c <memmove+0x28>
+ 242:	1602                	slli	a2,a2,0x20
+ 244:	9201                	srli	a2,a2,0x20
+ 246:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 24a:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 24c:	0585                	addi	a1,a1,1
+ 24e:	0705                	addi	a4,a4,1
+ 250:	fff5c683          	lbu	a3,-1(a1)
+ 254:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 258:	fef71ae3          	bne	a4,a5,24c <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 25c:	6422                	ld	s0,8(sp)
+ 25e:	0141                	addi	sp,sp,16
+ 260:	8082                	ret
+    dst += n;
+ 262:	00c50733          	add	a4,a0,a2
+    src += n;
+ 266:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 268:	fec05ae3          	blez	a2,25c <memmove+0x28>
+ 26c:	fff6079b          	addiw	a5,a2,-1
+ 270:	1782                	slli	a5,a5,0x20
+ 272:	9381                	srli	a5,a5,0x20
+ 274:	fff7c793          	not	a5,a5
+ 278:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 27a:	15fd                	addi	a1,a1,-1
+ 27c:	177d                	addi	a4,a4,-1
+ 27e:	0005c683          	lbu	a3,0(a1)
+ 282:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 286:	fee79ae3          	bne	a5,a4,27a <memmove+0x46>
+ 28a:	bfc9                	j	25c <memmove+0x28>
+
+000000000000028c <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 28c:	1141                	addi	sp,sp,-16
+ 28e:	e422                	sd	s0,8(sp)
+ 290:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 292:	ca05                	beqz	a2,2c2 <memcmp+0x36>
+ 294:	fff6069b          	addiw	a3,a2,-1
+ 298:	1682                	slli	a3,a3,0x20
+ 29a:	9281                	srli	a3,a3,0x20
+ 29c:	0685                	addi	a3,a3,1
+ 29e:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2a0:	00054783          	lbu	a5,0(a0)
+ 2a4:	0005c703          	lbu	a4,0(a1)
+ 2a8:	00e79863          	bne	a5,a4,2b8 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 2ac:	0505                	addi	a0,a0,1
+    p2++;
+ 2ae:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 2b0:	fed518e3          	bne	a0,a3,2a0 <memcmp+0x14>
+  }
+  return 0;
+ 2b4:	4501                	li	a0,0
+ 2b6:	a019                	j	2bc <memcmp+0x30>
+      return *p1 - *p2;
+ 2b8:	40e7853b          	subw	a0,a5,a4
+}
+ 2bc:	6422                	ld	s0,8(sp)
+ 2be:	0141                	addi	sp,sp,16
+ 2c0:	8082                	ret
+  return 0;
+ 2c2:	4501                	li	a0,0
+ 2c4:	bfe5                	j	2bc <memcmp+0x30>
+
+00000000000002c6 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2c6:	1141                	addi	sp,sp,-16
+ 2c8:	e406                	sd	ra,8(sp)
+ 2ca:	e022                	sd	s0,0(sp)
+ 2cc:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2ce:	f67ff0ef          	jal	234 <memmove>
+}
+ 2d2:	60a2                	ld	ra,8(sp)
+ 2d4:	6402                	ld	s0,0(sp)
+ 2d6:	0141                	addi	sp,sp,16
+ 2d8:	8082                	ret
+
+00000000000002da <sbrk>:
+
+char *
+sbrk(int n) {
+ 2da:	1141                	addi	sp,sp,-16
+ 2dc:	e406                	sd	ra,8(sp)
+ 2de:	e022                	sd	s0,0(sp)
+ 2e0:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2e2:	4585                	li	a1,1
+ 2e4:	0b2000ef          	jal	396 <sys_sbrk>
+}
+ 2e8:	60a2                	ld	ra,8(sp)
+ 2ea:	6402                	ld	s0,0(sp)
+ 2ec:	0141                	addi	sp,sp,16
+ 2ee:	8082                	ret
+
+00000000000002f0 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2f0:	1141                	addi	sp,sp,-16
+ 2f2:	e406                	sd	ra,8(sp)
+ 2f4:	e022                	sd	s0,0(sp)
+ 2f6:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2f8:	4589                	li	a1,2
+ 2fa:	09c000ef          	jal	396 <sys_sbrk>
+}
+ 2fe:	60a2                	ld	ra,8(sp)
+ 300:	6402                	ld	s0,0(sp)
+ 302:	0141                	addi	sp,sp,16
+ 304:	8082                	ret
+
+0000000000000306 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 306:	4885                	li	a7,1
+ ecall
+ 308:	00000073          	ecall
+ ret
+ 30c:	8082                	ret
+
+000000000000030e <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 30e:	4889                	li	a7,2
+ ecall
+ 310:	00000073          	ecall
+ ret
+ 314:	8082                	ret
+
+0000000000000316 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 316:	488d                	li	a7,3
+ ecall
+ 318:	00000073          	ecall
+ ret
+ 31c:	8082                	ret
+
+000000000000031e <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 31e:	4891                	li	a7,4
+ ecall
+ 320:	00000073          	ecall
+ ret
+ 324:	8082                	ret
+
+0000000000000326 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 326:	4895                	li	a7,5
+ ecall
+ 328:	00000073          	ecall
+ ret
+ 32c:	8082                	ret
+
+000000000000032e <write>:
+.global write
+write:
+ li a7, SYS_write
+ 32e:	48c1                	li	a7,16
+ ecall
+ 330:	00000073          	ecall
+ ret
+ 334:	8082                	ret
+
+0000000000000336 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 336:	48d5                	li	a7,21
+ ecall
+ 338:	00000073          	ecall
+ ret
+ 33c:	8082                	ret
+
+000000000000033e <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 33e:	4899                	li	a7,6
+ ecall
+ 340:	00000073          	ecall
+ ret
+ 344:	8082                	ret
+
+0000000000000346 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 346:	489d                	li	a7,7
+ ecall
+ 348:	00000073          	ecall
+ ret
+ 34c:	8082                	ret
+
+000000000000034e <open>:
+.global open
+open:
+ li a7, SYS_open
+ 34e:	48bd                	li	a7,15
+ ecall
+ 350:	00000073          	ecall
+ ret
+ 354:	8082                	ret
+
+0000000000000356 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 356:	48c5                	li	a7,17
+ ecall
+ 358:	00000073          	ecall
+ ret
+ 35c:	8082                	ret
+
+000000000000035e <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 35e:	48c9                	li	a7,18
+ ecall
+ 360:	00000073          	ecall
+ ret
+ 364:	8082                	ret
+
+0000000000000366 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 366:	48a1                	li	a7,8
+ ecall
+ 368:	00000073          	ecall
+ ret
+ 36c:	8082                	ret
+
+000000000000036e <link>:
+.global link
+link:
+ li a7, SYS_link
+ 36e:	48cd                	li	a7,19
+ ecall
+ 370:	00000073          	ecall
+ ret
+ 374:	8082                	ret
+
+0000000000000376 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 376:	48d1                	li	a7,20
+ ecall
+ 378:	00000073          	ecall
+ ret
+ 37c:	8082                	ret
+
+000000000000037e <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 37e:	48a5                	li	a7,9
+ ecall
+ 380:	00000073          	ecall
+ ret
+ 384:	8082                	ret
+
+0000000000000386 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 386:	48a9                	li	a7,10
+ ecall
+ 388:	00000073          	ecall
+ ret
+ 38c:	8082                	ret
+
+000000000000038e <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 38e:	48ad                	li	a7,11
+ ecall
+ 390:	00000073          	ecall
+ ret
+ 394:	8082                	ret
+
+0000000000000396 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 396:	48b1                	li	a7,12
+ ecall
+ 398:	00000073          	ecall
+ ret
+ 39c:	8082                	ret
+
+000000000000039e <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 39e:	48b5                	li	a7,13
+ ecall
+ 3a0:	00000073          	ecall
+ ret
+ 3a4:	8082                	ret
+
+00000000000003a6 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 3a6:	48b9                	li	a7,14
+ ecall
+ 3a8:	00000073          	ecall
+ ret
+ 3ac:	8082                	ret
+
+00000000000003ae <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 3ae:	48d9                	li	a7,22
+ ecall
+ 3b0:	00000073          	ecall
+ ret
+ 3b4:	8082                	ret
+
+00000000000003b6 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3b6:	1101                	addi	sp,sp,-32
+ 3b8:	ec06                	sd	ra,24(sp)
+ 3ba:	e822                	sd	s0,16(sp)
+ 3bc:	1000                	addi	s0,sp,32
+ 3be:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 3c2:	4605                	li	a2,1
+ 3c4:	fef40593          	addi	a1,s0,-17
+ 3c8:	f67ff0ef          	jal	32e <write>
+}
+ 3cc:	60e2                	ld	ra,24(sp)
+ 3ce:	6442                	ld	s0,16(sp)
+ 3d0:	6105                	addi	sp,sp,32
+ 3d2:	8082                	ret
+
+00000000000003d4 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3d4:	715d                	addi	sp,sp,-80
+ 3d6:	e486                	sd	ra,72(sp)
+ 3d8:	e0a2                	sd	s0,64(sp)
+ 3da:	f84a                	sd	s2,48(sp)
+ 3dc:	0880                	addi	s0,sp,80
+ 3de:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3e0:	c299                	beqz	a3,3e6 <printint+0x12>
+ 3e2:	0805c363          	bltz	a1,468 <printint+0x94>
+  neg = 0;
+ 3e6:	4881                	li	a7,0
+ 3e8:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3ec:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3ee:	00000517          	auipc	a0,0x0
+ 3f2:	51a50513          	addi	a0,a0,1306 # 908 <digits>
+ 3f6:	883e                	mv	a6,a5
+ 3f8:	2785                	addiw	a5,a5,1
+ 3fa:	02c5f733          	remu	a4,a1,a2
+ 3fe:	972a                	add	a4,a4,a0
+ 400:	00074703          	lbu	a4,0(a4)
+ 404:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 408:	872e                	mv	a4,a1
+ 40a:	02c5d5b3          	divu	a1,a1,a2
+ 40e:	0685                	addi	a3,a3,1
+ 410:	fec773e3          	bgeu	a4,a2,3f6 <printint+0x22>
+  if(neg)
+ 414:	00088b63          	beqz	a7,42a <printint+0x56>
+    buf[i++] = '-';
+ 418:	fd078793          	addi	a5,a5,-48
+ 41c:	97a2                	add	a5,a5,s0
+ 41e:	02d00713          	li	a4,45
+ 422:	fee78423          	sb	a4,-24(a5)
+ 426:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 42a:	02f05a63          	blez	a5,45e <printint+0x8a>
+ 42e:	fc26                	sd	s1,56(sp)
+ 430:	f44e                	sd	s3,40(sp)
+ 432:	fb840713          	addi	a4,s0,-72
+ 436:	00f704b3          	add	s1,a4,a5
+ 43a:	fff70993          	addi	s3,a4,-1
+ 43e:	99be                	add	s3,s3,a5
+ 440:	37fd                	addiw	a5,a5,-1
+ 442:	1782                	slli	a5,a5,0x20
+ 444:	9381                	srli	a5,a5,0x20
+ 446:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 44a:	fff4c583          	lbu	a1,-1(s1)
+ 44e:	854a                	mv	a0,s2
+ 450:	f67ff0ef          	jal	3b6 <putc>
+  while(--i >= 0)
+ 454:	14fd                	addi	s1,s1,-1
+ 456:	ff349ae3          	bne	s1,s3,44a <printint+0x76>
+ 45a:	74e2                	ld	s1,56(sp)
+ 45c:	79a2                	ld	s3,40(sp)
+}
+ 45e:	60a6                	ld	ra,72(sp)
+ 460:	6406                	ld	s0,64(sp)
+ 462:	7942                	ld	s2,48(sp)
+ 464:	6161                	addi	sp,sp,80
+ 466:	8082                	ret
+    x = -xx;
+ 468:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 46c:	4885                	li	a7,1
+    x = -xx;
+ 46e:	bfad                	j	3e8 <printint+0x14>
+
+0000000000000470 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 470:	711d                	addi	sp,sp,-96
+ 472:	ec86                	sd	ra,88(sp)
+ 474:	e8a2                	sd	s0,80(sp)
+ 476:	e0ca                	sd	s2,64(sp)
+ 478:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 47a:	0005c903          	lbu	s2,0(a1)
+ 47e:	28090663          	beqz	s2,70a <vprintf+0x29a>
+ 482:	e4a6                	sd	s1,72(sp)
+ 484:	fc4e                	sd	s3,56(sp)
+ 486:	f852                	sd	s4,48(sp)
+ 488:	f456                	sd	s5,40(sp)
+ 48a:	f05a                	sd	s6,32(sp)
+ 48c:	ec5e                	sd	s7,24(sp)
+ 48e:	e862                	sd	s8,16(sp)
+ 490:	e466                	sd	s9,8(sp)
+ 492:	8b2a                	mv	s6,a0
+ 494:	8a2e                	mv	s4,a1
+ 496:	8bb2                	mv	s7,a2
+  state = 0;
+ 498:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 49a:	4481                	li	s1,0
+ 49c:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 49e:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 4a2:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4a6:	06c00c93          	li	s9,108
+ 4aa:	a005                	j	4ca <vprintf+0x5a>
+        putc(fd, c0);
+ 4ac:	85ca                	mv	a1,s2
+ 4ae:	855a                	mv	a0,s6
+ 4b0:	f07ff0ef          	jal	3b6 <putc>
+ 4b4:	a019                	j	4ba <vprintf+0x4a>
+    } else if(state == '%'){
+ 4b6:	03598263          	beq	s3,s5,4da <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4ba:	2485                	addiw	s1,s1,1
+ 4bc:	8726                	mv	a4,s1
+ 4be:	009a07b3          	add	a5,s4,s1
+ 4c2:	0007c903          	lbu	s2,0(a5)
+ 4c6:	22090a63          	beqz	s2,6fa <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4ca:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4ce:	fe0994e3          	bnez	s3,4b6 <vprintf+0x46>
+      if(c0 == '%'){
+ 4d2:	fd579de3          	bne	a5,s5,4ac <vprintf+0x3c>
+        state = '%';
+ 4d6:	89be                	mv	s3,a5
+ 4d8:	b7cd                	j	4ba <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4da:	00ea06b3          	add	a3,s4,a4
+ 4de:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4e2:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4e4:	c681                	beqz	a3,4ec <vprintf+0x7c>
+ 4e6:	9752                	add	a4,a4,s4
+ 4e8:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4ec:	05878363          	beq	a5,s8,532 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4f0:	05978d63          	beq	a5,s9,54a <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4f4:	07500713          	li	a4,117
+ 4f8:	0ee78763          	beq	a5,a4,5e6 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4fc:	07800713          	li	a4,120
+ 500:	12e78963          	beq	a5,a4,632 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 504:	07000713          	li	a4,112
+ 508:	14e78e63          	beq	a5,a4,664 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 50c:	06300713          	li	a4,99
+ 510:	18e78e63          	beq	a5,a4,6ac <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 514:	07300713          	li	a4,115
+ 518:	1ae78463          	beq	a5,a4,6c0 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 51c:	02500713          	li	a4,37
+ 520:	04e79563          	bne	a5,a4,56a <vprintf+0xfa>
+        putc(fd, '%');
+ 524:	02500593          	li	a1,37
+ 528:	855a                	mv	a0,s6
+ 52a:	e8dff0ef          	jal	3b6 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 52e:	4981                	li	s3,0
+ 530:	b769                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 532:	008b8913          	addi	s2,s7,8
+ 536:	4685                	li	a3,1
+ 538:	4629                	li	a2,10
+ 53a:	000ba583          	lw	a1,0(s7)
+ 53e:	855a                	mv	a0,s6
+ 540:	e95ff0ef          	jal	3d4 <printint>
+ 544:	8bca                	mv	s7,s2
+      state = 0;
+ 546:	4981                	li	s3,0
+ 548:	bf8d                	j	4ba <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 54a:	06400793          	li	a5,100
+ 54e:	02f68963          	beq	a3,a5,580 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 552:	06c00793          	li	a5,108
+ 556:	04f68263          	beq	a3,a5,59a <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 55a:	07500793          	li	a5,117
+ 55e:	0af68063          	beq	a3,a5,5fe <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 562:	07800793          	li	a5,120
+ 566:	0ef68263          	beq	a3,a5,64a <vprintf+0x1da>
+        putc(fd, '%');
+ 56a:	02500593          	li	a1,37
+ 56e:	855a                	mv	a0,s6
+ 570:	e47ff0ef          	jal	3b6 <putc>
+        putc(fd, c0);
+ 574:	85ca                	mv	a1,s2
+ 576:	855a                	mv	a0,s6
+ 578:	e3fff0ef          	jal	3b6 <putc>
+      state = 0;
+ 57c:	4981                	li	s3,0
+ 57e:	bf35                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 580:	008b8913          	addi	s2,s7,8
+ 584:	4685                	li	a3,1
+ 586:	4629                	li	a2,10
+ 588:	000bb583          	ld	a1,0(s7)
+ 58c:	855a                	mv	a0,s6
+ 58e:	e47ff0ef          	jal	3d4 <printint>
+        i += 1;
+ 592:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 594:	8bca                	mv	s7,s2
+      state = 0;
+ 596:	4981                	li	s3,0
+        i += 1;
+ 598:	b70d                	j	4ba <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 59a:	06400793          	li	a5,100
+ 59e:	02f60763          	beq	a2,a5,5cc <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 5a2:	07500793          	li	a5,117
+ 5a6:	06f60963          	beq	a2,a5,618 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 5aa:	07800793          	li	a5,120
+ 5ae:	faf61ee3          	bne	a2,a5,56a <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5b2:	008b8913          	addi	s2,s7,8
+ 5b6:	4681                	li	a3,0
+ 5b8:	4641                	li	a2,16
+ 5ba:	000bb583          	ld	a1,0(s7)
+ 5be:	855a                	mv	a0,s6
+ 5c0:	e15ff0ef          	jal	3d4 <printint>
+        i += 2;
+ 5c4:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5c6:	8bca                	mv	s7,s2
+      state = 0;
+ 5c8:	4981                	li	s3,0
+        i += 2;
+ 5ca:	bdc5                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5cc:	008b8913          	addi	s2,s7,8
+ 5d0:	4685                	li	a3,1
+ 5d2:	4629                	li	a2,10
+ 5d4:	000bb583          	ld	a1,0(s7)
+ 5d8:	855a                	mv	a0,s6
+ 5da:	dfbff0ef          	jal	3d4 <printint>
+        i += 2;
+ 5de:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5e0:	8bca                	mv	s7,s2
+      state = 0;
+ 5e2:	4981                	li	s3,0
+        i += 2;
+ 5e4:	bdd9                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5e6:	008b8913          	addi	s2,s7,8
+ 5ea:	4681                	li	a3,0
+ 5ec:	4629                	li	a2,10
+ 5ee:	000be583          	lwu	a1,0(s7)
+ 5f2:	855a                	mv	a0,s6
+ 5f4:	de1ff0ef          	jal	3d4 <printint>
+ 5f8:	8bca                	mv	s7,s2
+      state = 0;
+ 5fa:	4981                	li	s3,0
+ 5fc:	bd7d                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5fe:	008b8913          	addi	s2,s7,8
+ 602:	4681                	li	a3,0
+ 604:	4629                	li	a2,10
+ 606:	000bb583          	ld	a1,0(s7)
+ 60a:	855a                	mv	a0,s6
+ 60c:	dc9ff0ef          	jal	3d4 <printint>
+        i += 1;
+ 610:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 612:	8bca                	mv	s7,s2
+      state = 0;
+ 614:	4981                	li	s3,0
+        i += 1;
+ 616:	b555                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 618:	008b8913          	addi	s2,s7,8
+ 61c:	4681                	li	a3,0
+ 61e:	4629                	li	a2,10
+ 620:	000bb583          	ld	a1,0(s7)
+ 624:	855a                	mv	a0,s6
+ 626:	dafff0ef          	jal	3d4 <printint>
+        i += 2;
+ 62a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 62c:	8bca                	mv	s7,s2
+      state = 0;
+ 62e:	4981                	li	s3,0
+        i += 2;
+ 630:	b569                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 632:	008b8913          	addi	s2,s7,8
+ 636:	4681                	li	a3,0
+ 638:	4641                	li	a2,16
+ 63a:	000be583          	lwu	a1,0(s7)
+ 63e:	855a                	mv	a0,s6
+ 640:	d95ff0ef          	jal	3d4 <printint>
+ 644:	8bca                	mv	s7,s2
+      state = 0;
+ 646:	4981                	li	s3,0
+ 648:	bd8d                	j	4ba <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 64a:	008b8913          	addi	s2,s7,8
+ 64e:	4681                	li	a3,0
+ 650:	4641                	li	a2,16
+ 652:	000bb583          	ld	a1,0(s7)
+ 656:	855a                	mv	a0,s6
+ 658:	d7dff0ef          	jal	3d4 <printint>
+        i += 1;
+ 65c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 65e:	8bca                	mv	s7,s2
+      state = 0;
+ 660:	4981                	li	s3,0
+        i += 1;
+ 662:	bda1                	j	4ba <vprintf+0x4a>
+ 664:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 666:	008b8d13          	addi	s10,s7,8
+ 66a:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 66e:	03000593          	li	a1,48
+ 672:	855a                	mv	a0,s6
+ 674:	d43ff0ef          	jal	3b6 <putc>
+  putc(fd, 'x');
+ 678:	07800593          	li	a1,120
+ 67c:	855a                	mv	a0,s6
+ 67e:	d39ff0ef          	jal	3b6 <putc>
+ 682:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 684:	00000b97          	auipc	s7,0x0
+ 688:	284b8b93          	addi	s7,s7,644 # 908 <digits>
+ 68c:	03c9d793          	srli	a5,s3,0x3c
+ 690:	97de                	add	a5,a5,s7
+ 692:	0007c583          	lbu	a1,0(a5)
+ 696:	855a                	mv	a0,s6
+ 698:	d1fff0ef          	jal	3b6 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 69c:	0992                	slli	s3,s3,0x4
+ 69e:	397d                	addiw	s2,s2,-1
+ 6a0:	fe0916e3          	bnez	s2,68c <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 6a4:	8bea                	mv	s7,s10
+      state = 0;
+ 6a6:	4981                	li	s3,0
+ 6a8:	6d02                	ld	s10,0(sp)
+ 6aa:	bd01                	j	4ba <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 6ac:	008b8913          	addi	s2,s7,8
+ 6b0:	000bc583          	lbu	a1,0(s7)
+ 6b4:	855a                	mv	a0,s6
+ 6b6:	d01ff0ef          	jal	3b6 <putc>
+ 6ba:	8bca                	mv	s7,s2
+      state = 0;
+ 6bc:	4981                	li	s3,0
+ 6be:	bbf5                	j	4ba <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 6c0:	008b8993          	addi	s3,s7,8
+ 6c4:	000bb903          	ld	s2,0(s7)
+ 6c8:	00090f63          	beqz	s2,6e6 <vprintf+0x276>
+        for(; *s; s++)
+ 6cc:	00094583          	lbu	a1,0(s2)
+ 6d0:	c195                	beqz	a1,6f4 <vprintf+0x284>
+          putc(fd, *s);
+ 6d2:	855a                	mv	a0,s6
+ 6d4:	ce3ff0ef          	jal	3b6 <putc>
+        for(; *s; s++)
+ 6d8:	0905                	addi	s2,s2,1
+ 6da:	00094583          	lbu	a1,0(s2)
+ 6de:	f9f5                	bnez	a1,6d2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6e0:	8bce                	mv	s7,s3
+      state = 0;
+ 6e2:	4981                	li	s3,0
+ 6e4:	bbd9                	j	4ba <vprintf+0x4a>
+          s = "(null)";
+ 6e6:	00000917          	auipc	s2,0x0
+ 6ea:	21a90913          	addi	s2,s2,538 # 900 <malloc+0x10e>
+        for(; *s; s++)
+ 6ee:	02800593          	li	a1,40
+ 6f2:	b7c5                	j	6d2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6f4:	8bce                	mv	s7,s3
+      state = 0;
+ 6f6:	4981                	li	s3,0
+ 6f8:	b3c9                	j	4ba <vprintf+0x4a>
+ 6fa:	64a6                	ld	s1,72(sp)
+ 6fc:	79e2                	ld	s3,56(sp)
+ 6fe:	7a42                	ld	s4,48(sp)
+ 700:	7aa2                	ld	s5,40(sp)
+ 702:	7b02                	ld	s6,32(sp)
+ 704:	6be2                	ld	s7,24(sp)
+ 706:	6c42                	ld	s8,16(sp)
+ 708:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 70a:	60e6                	ld	ra,88(sp)
+ 70c:	6446                	ld	s0,80(sp)
+ 70e:	6906                	ld	s2,64(sp)
+ 710:	6125                	addi	sp,sp,96
+ 712:	8082                	ret
+
+0000000000000714 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 714:	715d                	addi	sp,sp,-80
+ 716:	ec06                	sd	ra,24(sp)
+ 718:	e822                	sd	s0,16(sp)
+ 71a:	1000                	addi	s0,sp,32
+ 71c:	e010                	sd	a2,0(s0)
+ 71e:	e414                	sd	a3,8(s0)
+ 720:	e818                	sd	a4,16(s0)
+ 722:	ec1c                	sd	a5,24(s0)
+ 724:	03043023          	sd	a6,32(s0)
+ 728:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 72c:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 730:	8622                	mv	a2,s0
+ 732:	d3fff0ef          	jal	470 <vprintf>
+}
+ 736:	60e2                	ld	ra,24(sp)
+ 738:	6442                	ld	s0,16(sp)
+ 73a:	6161                	addi	sp,sp,80
+ 73c:	8082                	ret
+
+000000000000073e <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 73e:	711d                	addi	sp,sp,-96
+ 740:	ec06                	sd	ra,24(sp)
+ 742:	e822                	sd	s0,16(sp)
+ 744:	1000                	addi	s0,sp,32
+ 746:	e40c                	sd	a1,8(s0)
+ 748:	e810                	sd	a2,16(s0)
+ 74a:	ec14                	sd	a3,24(s0)
+ 74c:	f018                	sd	a4,32(s0)
+ 74e:	f41c                	sd	a5,40(s0)
+ 750:	03043823          	sd	a6,48(s0)
+ 754:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 758:	00840613          	addi	a2,s0,8
+ 75c:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 760:	85aa                	mv	a1,a0
+ 762:	4505                	li	a0,1
+ 764:	d0dff0ef          	jal	470 <vprintf>
+}
+ 768:	60e2                	ld	ra,24(sp)
+ 76a:	6442                	ld	s0,16(sp)
+ 76c:	6125                	addi	sp,sp,96
+ 76e:	8082                	ret
+
+0000000000000770 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 770:	1141                	addi	sp,sp,-16
+ 772:	e422                	sd	s0,8(sp)
+ 774:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 776:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 77a:	00001797          	auipc	a5,0x1
+ 77e:	8867b783          	ld	a5,-1914(a5) # 1000 <freep>
+ 782:	a02d                	j	7ac <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 784:	4618                	lw	a4,8(a2)
+ 786:	9f2d                	addw	a4,a4,a1
+ 788:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 78c:	6398                	ld	a4,0(a5)
+ 78e:	6310                	ld	a2,0(a4)
+ 790:	a83d                	j	7ce <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 792:	ff852703          	lw	a4,-8(a0)
+ 796:	9f31                	addw	a4,a4,a2
+ 798:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 79a:	ff053683          	ld	a3,-16(a0)
+ 79e:	a091                	j	7e2 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7a0:	6398                	ld	a4,0(a5)
+ 7a2:	00e7e463          	bltu	a5,a4,7aa <free+0x3a>
+ 7a6:	00e6ea63          	bltu	a3,a4,7ba <free+0x4a>
+{
+ 7aa:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7ac:	fed7fae3          	bgeu	a5,a3,7a0 <free+0x30>
+ 7b0:	6398                	ld	a4,0(a5)
+ 7b2:	00e6e463          	bltu	a3,a4,7ba <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7b6:	fee7eae3          	bltu	a5,a4,7aa <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7ba:	ff852583          	lw	a1,-8(a0)
+ 7be:	6390                	ld	a2,0(a5)
+ 7c0:	02059813          	slli	a6,a1,0x20
+ 7c4:	01c85713          	srli	a4,a6,0x1c
+ 7c8:	9736                	add	a4,a4,a3
+ 7ca:	fae60de3          	beq	a2,a4,784 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7ce:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7d2:	4790                	lw	a2,8(a5)
+ 7d4:	02061593          	slli	a1,a2,0x20
+ 7d8:	01c5d713          	srli	a4,a1,0x1c
+ 7dc:	973e                	add	a4,a4,a5
+ 7de:	fae68ae3          	beq	a3,a4,792 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7e2:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7e4:	00001717          	auipc	a4,0x1
+ 7e8:	80f73e23          	sd	a5,-2020(a4) # 1000 <freep>
+}
+ 7ec:	6422                	ld	s0,8(sp)
+ 7ee:	0141                	addi	sp,sp,16
+ 7f0:	8082                	ret
+
+00000000000007f2 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7f2:	7139                	addi	sp,sp,-64
+ 7f4:	fc06                	sd	ra,56(sp)
+ 7f6:	f822                	sd	s0,48(sp)
+ 7f8:	f426                	sd	s1,40(sp)
+ 7fa:	ec4e                	sd	s3,24(sp)
+ 7fc:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7fe:	02051493          	slli	s1,a0,0x20
+ 802:	9081                	srli	s1,s1,0x20
+ 804:	04bd                	addi	s1,s1,15
+ 806:	8091                	srli	s1,s1,0x4
+ 808:	0014899b          	addiw	s3,s1,1
+ 80c:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 80e:	00000517          	auipc	a0,0x0
+ 812:	7f253503          	ld	a0,2034(a0) # 1000 <freep>
+ 816:	c915                	beqz	a0,84a <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 818:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 81a:	4798                	lw	a4,8(a5)
+ 81c:	08977a63          	bgeu	a4,s1,8b0 <malloc+0xbe>
+ 820:	f04a                	sd	s2,32(sp)
+ 822:	e852                	sd	s4,16(sp)
+ 824:	e456                	sd	s5,8(sp)
+ 826:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 828:	8a4e                	mv	s4,s3
+ 82a:	0009871b          	sext.w	a4,s3
+ 82e:	6685                	lui	a3,0x1
+ 830:	00d77363          	bgeu	a4,a3,836 <malloc+0x44>
+ 834:	6a05                	lui	s4,0x1
+ 836:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 83a:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 83e:	00000917          	auipc	s2,0x0
+ 842:	7c290913          	addi	s2,s2,1986 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 846:	5afd                	li	s5,-1
+ 848:	a081                	j	888 <malloc+0x96>
+ 84a:	f04a                	sd	s2,32(sp)
+ 84c:	e852                	sd	s4,16(sp)
+ 84e:	e456                	sd	s5,8(sp)
+ 850:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 852:	00000797          	auipc	a5,0x0
+ 856:	7be78793          	addi	a5,a5,1982 # 1010 <base>
+ 85a:	00000717          	auipc	a4,0x0
+ 85e:	7af73323          	sd	a5,1958(a4) # 1000 <freep>
+ 862:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 864:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 868:	b7c1                	j	828 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 86a:	6398                	ld	a4,0(a5)
+ 86c:	e118                	sd	a4,0(a0)
+ 86e:	a8a9                	j	8c8 <malloc+0xd6>
+  hp->s.size = nu;
+ 870:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 874:	0541                	addi	a0,a0,16
+ 876:	efbff0ef          	jal	770 <free>
+  return freep;
+ 87a:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 87e:	c12d                	beqz	a0,8e0 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 880:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 882:	4798                	lw	a4,8(a5)
+ 884:	02977263          	bgeu	a4,s1,8a8 <malloc+0xb6>
+    if(p == freep)
+ 888:	00093703          	ld	a4,0(s2)
+ 88c:	853e                	mv	a0,a5
+ 88e:	fef719e3          	bne	a4,a5,880 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 892:	8552                	mv	a0,s4
+ 894:	a47ff0ef          	jal	2da <sbrk>
+  if(p == SBRK_ERROR)
+ 898:	fd551ce3          	bne	a0,s5,870 <malloc+0x7e>
+        return 0;
+ 89c:	4501                	li	a0,0
+ 89e:	7902                	ld	s2,32(sp)
+ 8a0:	6a42                	ld	s4,16(sp)
+ 8a2:	6aa2                	ld	s5,8(sp)
+ 8a4:	6b02                	ld	s6,0(sp)
+ 8a6:	a03d                	j	8d4 <malloc+0xe2>
+ 8a8:	7902                	ld	s2,32(sp)
+ 8aa:	6a42                	ld	s4,16(sp)
+ 8ac:	6aa2                	ld	s5,8(sp)
+ 8ae:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 8b0:	fae48de3          	beq	s1,a4,86a <malloc+0x78>
+        p->s.size -= nunits;
+ 8b4:	4137073b          	subw	a4,a4,s3
+ 8b8:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8ba:	02071693          	slli	a3,a4,0x20
+ 8be:	01c6d713          	srli	a4,a3,0x1c
+ 8c2:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 8c4:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8c8:	00000717          	auipc	a4,0x0
+ 8cc:	72a73c23          	sd	a0,1848(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8d0:	01078513          	addi	a0,a5,16
+  }
+}
+ 8d4:	70e2                	ld	ra,56(sp)
+ 8d6:	7442                	ld	s0,48(sp)
+ 8d8:	74a2                	ld	s1,40(sp)
+ 8da:	69e2                	ld	s3,24(sp)
+ 8dc:	6121                	addi	sp,sp,64
+ 8de:	8082                	ret
+ 8e0:	7902                	ld	s2,32(sp)
+ 8e2:	6a42                	ld	s4,16(sp)
+ 8e4:	6aa2                	ld	s5,8(sp)
+ 8e6:	6b02                	ld	s6,0(sp)
+ 8e8:	b7f5                	j	8d4 <malloc+0xe2>
diff -ruN xv6-riscv/user/echo.d xv62/user/echo.d
--- xv6-riscv/user/echo.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/echo.d	2025-09-14 12:32:50.664883358 +0000
@@ -0,0 +1 @@
+user/echo.o: user/echo.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/echo.o and xv62/user/echo.o differ
diff -ruN xv6-riscv/user/echo.sym xv62/user/echo.sym
--- xv6-riscv/user/echo.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/echo.sym	2025-09-14 12:32:50.680883356 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008f0 .rodata
+0000000000000920 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 echo.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003b6 putc
+00000000000003d4 printint
+0000000000000908 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+000000000000008a strcpy
+000000000000039e pause
+000000000000073e printf
+0000000000000396 sys_sbrk
+0000000000000234 memmove
+0000000000000356 mknod
+0000000000000142 gets
+000000000000038e getpid
+00000000000002c6 memcpy
+00000000000007f2 malloc
+00000000000002f0 sbrklazy
+000000000000031e pipe
+000000000000032e write
+0000000000000366 fstat
+0000000000000714 fprintf
+000000000000033e kill
+0000000000000470 vprintf
+000000000000037e chdir
+0000000000000346 exec
+0000000000000316 wait
+0000000000000326 read
+000000000000035e unlink
+000000000000028c memcmp
+0000000000000306 fork
+00000000000002da sbrk
+00000000000003a6 uptime
+00000000000000fc memset
+0000000000000000 main
+00000000000000a6 strcmp
+0000000000000386 dup
+00000000000003ae getreadcount
+00000000000001b2 stat
+000000000000036e link
+000000000000030e exit
+000000000000007a start
+00000000000001ec atoi
+00000000000000d2 strlen
+000000000000034e open
+000000000000011e strchr
+0000000000000376 mkdir
+0000000000000336 close
+0000000000000770 free
diff -ruN xv6-riscv/user/forktest.asm xv62/user/forktest.asm
--- xv6-riscv/user/forktest.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/forktest.asm	2025-09-14 12:32:50.732883344 +0000
@@ -0,0 +1,827 @@
+
+user/_forktest:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <print>:
+
+#define N  1000
+
+void
+print(const char *s)
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	e426                	sd	s1,8(sp)
+   8:	1000                	addi	s0,sp,32
+   a:	84aa                	mv	s1,a0
+  write(1, s, strlen(s));
+   c:	122000ef          	jal	12e <strlen>
+  10:	0005061b          	sext.w	a2,a0
+  14:	85a6                	mv	a1,s1
+  16:	4505                	li	a0,1
+  18:	372000ef          	jal	38a <write>
+}
+  1c:	60e2                	ld	ra,24(sp)
+  1e:	6442                	ld	s0,16(sp)
+  20:	64a2                	ld	s1,8(sp)
+  22:	6105                	addi	sp,sp,32
+  24:	8082                	ret
+
+0000000000000026 <forktest>:
+
+void
+forktest(void)
+{
+  26:	1101                	addi	sp,sp,-32
+  28:	ec06                	sd	ra,24(sp)
+  2a:	e822                	sd	s0,16(sp)
+  2c:	e426                	sd	s1,8(sp)
+  2e:	e04a                	sd	s2,0(sp)
+  30:	1000                	addi	s0,sp,32
+  int n, pid;
+
+  print("fork test\n");
+  32:	00000517          	auipc	a0,0x0
+  36:	3e650513          	addi	a0,a0,998 # 418 <getreadcount+0xe>
+  3a:	fc7ff0ef          	jal	0 <print>
+
+  for(n=0; n<N; n++){
+  3e:	4481                	li	s1,0
+  40:	3e800913          	li	s2,1000
+    pid = fork();
+  44:	31e000ef          	jal	362 <fork>
+    if(pid < 0)
+  48:	04054363          	bltz	a0,8e <forktest+0x68>
+      break;
+    if(pid == 0)
+  4c:	cd09                	beqz	a0,66 <forktest+0x40>
+  for(n=0; n<N; n++){
+  4e:	2485                	addiw	s1,s1,1
+  50:	ff249ae3          	bne	s1,s2,44 <forktest+0x1e>
+      exit(0);
+  }
+
+  if(n == N){
+    print("fork claimed to work N times!\n");
+  54:	00000517          	auipc	a0,0x0
+  58:	41450513          	addi	a0,a0,1044 # 468 <getreadcount+0x5e>
+  5c:	fa5ff0ef          	jal	0 <print>
+    exit(1);
+  60:	4505                	li	a0,1
+  62:	308000ef          	jal	36a <exit>
+      exit(0);
+  66:	304000ef          	jal	36a <exit>
+  }
+
+  for(; n > 0; n--){
+    if(wait(0) < 0){
+      print("wait stopped early\n");
+  6a:	00000517          	auipc	a0,0x0
+  6e:	3be50513          	addi	a0,a0,958 # 428 <getreadcount+0x1e>
+  72:	f8fff0ef          	jal	0 <print>
+      exit(1);
+  76:	4505                	li	a0,1
+  78:	2f2000ef          	jal	36a <exit>
+    }
+  }
+
+  if(wait(0) != -1){
+    print("wait got too many\n");
+  7c:	00000517          	auipc	a0,0x0
+  80:	3c450513          	addi	a0,a0,964 # 440 <getreadcount+0x36>
+  84:	f7dff0ef          	jal	0 <print>
+    exit(1);
+  88:	4505                	li	a0,1
+  8a:	2e0000ef          	jal	36a <exit>
+  for(; n > 0; n--){
+  8e:	00905963          	blez	s1,a0 <forktest+0x7a>
+    if(wait(0) < 0){
+  92:	4501                	li	a0,0
+  94:	2de000ef          	jal	372 <wait>
+  98:	fc0549e3          	bltz	a0,6a <forktest+0x44>
+  for(; n > 0; n--){
+  9c:	34fd                	addiw	s1,s1,-1
+  9e:	f8f5                	bnez	s1,92 <forktest+0x6c>
+  if(wait(0) != -1){
+  a0:	4501                	li	a0,0
+  a2:	2d0000ef          	jal	372 <wait>
+  a6:	57fd                	li	a5,-1
+  a8:	fcf51ae3          	bne	a0,a5,7c <forktest+0x56>
+  }
+
+  print("fork test OK\n");
+  ac:	00000517          	auipc	a0,0x0
+  b0:	3ac50513          	addi	a0,a0,940 # 458 <getreadcount+0x4e>
+  b4:	f4dff0ef          	jal	0 <print>
+}
+  b8:	60e2                	ld	ra,24(sp)
+  ba:	6442                	ld	s0,16(sp)
+  bc:	64a2                	ld	s1,8(sp)
+  be:	6902                	ld	s2,0(sp)
+  c0:	6105                	addi	sp,sp,32
+  c2:	8082                	ret
+
+00000000000000c4 <main>:
+
+int
+main(void)
+{
+  c4:	1141                	addi	sp,sp,-16
+  c6:	e406                	sd	ra,8(sp)
+  c8:	e022                	sd	s0,0(sp)
+  ca:	0800                	addi	s0,sp,16
+  forktest();
+  cc:	f5bff0ef          	jal	26 <forktest>
+  exit(0);
+  d0:	4501                	li	a0,0
+  d2:	298000ef          	jal	36a <exit>
+
+00000000000000d6 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  d6:	1141                	addi	sp,sp,-16
+  d8:	e406                	sd	ra,8(sp)
+  da:	e022                	sd	s0,0(sp)
+  dc:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  de:	fe7ff0ef          	jal	c4 <main>
+  exit(r);
+  e2:	288000ef          	jal	36a <exit>
+
+00000000000000e6 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  e6:	1141                	addi	sp,sp,-16
+  e8:	e422                	sd	s0,8(sp)
+  ea:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  ec:	87aa                	mv	a5,a0
+  ee:	0585                	addi	a1,a1,1
+  f0:	0785                	addi	a5,a5,1
+  f2:	fff5c703          	lbu	a4,-1(a1)
+  f6:	fee78fa3          	sb	a4,-1(a5)
+  fa:	fb75                	bnez	a4,ee <strcpy+0x8>
+    ;
+  return os;
+}
+  fc:	6422                	ld	s0,8(sp)
+  fe:	0141                	addi	sp,sp,16
+ 100:	8082                	ret
+
+0000000000000102 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 102:	1141                	addi	sp,sp,-16
+ 104:	e422                	sd	s0,8(sp)
+ 106:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 108:	00054783          	lbu	a5,0(a0)
+ 10c:	cb91                	beqz	a5,120 <strcmp+0x1e>
+ 10e:	0005c703          	lbu	a4,0(a1)
+ 112:	00f71763          	bne	a4,a5,120 <strcmp+0x1e>
+    p++, q++;
+ 116:	0505                	addi	a0,a0,1
+ 118:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 11a:	00054783          	lbu	a5,0(a0)
+ 11e:	fbe5                	bnez	a5,10e <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 120:	0005c503          	lbu	a0,0(a1)
+}
+ 124:	40a7853b          	subw	a0,a5,a0
+ 128:	6422                	ld	s0,8(sp)
+ 12a:	0141                	addi	sp,sp,16
+ 12c:	8082                	ret
+
+000000000000012e <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 12e:	1141                	addi	sp,sp,-16
+ 130:	e422                	sd	s0,8(sp)
+ 132:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 134:	00054783          	lbu	a5,0(a0)
+ 138:	cf91                	beqz	a5,154 <strlen+0x26>
+ 13a:	0505                	addi	a0,a0,1
+ 13c:	87aa                	mv	a5,a0
+ 13e:	86be                	mv	a3,a5
+ 140:	0785                	addi	a5,a5,1
+ 142:	fff7c703          	lbu	a4,-1(a5)
+ 146:	ff65                	bnez	a4,13e <strlen+0x10>
+ 148:	40a6853b          	subw	a0,a3,a0
+ 14c:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 14e:	6422                	ld	s0,8(sp)
+ 150:	0141                	addi	sp,sp,16
+ 152:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 154:	4501                	li	a0,0
+ 156:	bfe5                	j	14e <strlen+0x20>
+
+0000000000000158 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 158:	1141                	addi	sp,sp,-16
+ 15a:	e422                	sd	s0,8(sp)
+ 15c:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 15e:	ca19                	beqz	a2,174 <memset+0x1c>
+ 160:	87aa                	mv	a5,a0
+ 162:	1602                	slli	a2,a2,0x20
+ 164:	9201                	srli	a2,a2,0x20
+ 166:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 16a:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 16e:	0785                	addi	a5,a5,1
+ 170:	fee79de3          	bne	a5,a4,16a <memset+0x12>
+  }
+  return dst;
+}
+ 174:	6422                	ld	s0,8(sp)
+ 176:	0141                	addi	sp,sp,16
+ 178:	8082                	ret
+
+000000000000017a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 17a:	1141                	addi	sp,sp,-16
+ 17c:	e422                	sd	s0,8(sp)
+ 17e:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 180:	00054783          	lbu	a5,0(a0)
+ 184:	cb99                	beqz	a5,19a <strchr+0x20>
+    if(*s == c)
+ 186:	00f58763          	beq	a1,a5,194 <strchr+0x1a>
+  for(; *s; s++)
+ 18a:	0505                	addi	a0,a0,1
+ 18c:	00054783          	lbu	a5,0(a0)
+ 190:	fbfd                	bnez	a5,186 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 192:	4501                	li	a0,0
+}
+ 194:	6422                	ld	s0,8(sp)
+ 196:	0141                	addi	sp,sp,16
+ 198:	8082                	ret
+  return 0;
+ 19a:	4501                	li	a0,0
+ 19c:	bfe5                	j	194 <strchr+0x1a>
+
+000000000000019e <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 19e:	711d                	addi	sp,sp,-96
+ 1a0:	ec86                	sd	ra,88(sp)
+ 1a2:	e8a2                	sd	s0,80(sp)
+ 1a4:	e4a6                	sd	s1,72(sp)
+ 1a6:	e0ca                	sd	s2,64(sp)
+ 1a8:	fc4e                	sd	s3,56(sp)
+ 1aa:	f852                	sd	s4,48(sp)
+ 1ac:	f456                	sd	s5,40(sp)
+ 1ae:	f05a                	sd	s6,32(sp)
+ 1b0:	ec5e                	sd	s7,24(sp)
+ 1b2:	1080                	addi	s0,sp,96
+ 1b4:	8baa                	mv	s7,a0
+ 1b6:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1b8:	892a                	mv	s2,a0
+ 1ba:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1bc:	4aa9                	li	s5,10
+ 1be:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1c0:	89a6                	mv	s3,s1
+ 1c2:	2485                	addiw	s1,s1,1
+ 1c4:	0344d663          	bge	s1,s4,1f0 <gets+0x52>
+    cc = read(0, &c, 1);
+ 1c8:	4605                	li	a2,1
+ 1ca:	faf40593          	addi	a1,s0,-81
+ 1ce:	4501                	li	a0,0
+ 1d0:	1b2000ef          	jal	382 <read>
+    if(cc < 1)
+ 1d4:	00a05e63          	blez	a0,1f0 <gets+0x52>
+    buf[i++] = c;
+ 1d8:	faf44783          	lbu	a5,-81(s0)
+ 1dc:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1e0:	01578763          	beq	a5,s5,1ee <gets+0x50>
+ 1e4:	0905                	addi	s2,s2,1
+ 1e6:	fd679de3          	bne	a5,s6,1c0 <gets+0x22>
+    buf[i++] = c;
+ 1ea:	89a6                	mv	s3,s1
+ 1ec:	a011                	j	1f0 <gets+0x52>
+ 1ee:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1f0:	99de                	add	s3,s3,s7
+ 1f2:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1f6:	855e                	mv	a0,s7
+ 1f8:	60e6                	ld	ra,88(sp)
+ 1fa:	6446                	ld	s0,80(sp)
+ 1fc:	64a6                	ld	s1,72(sp)
+ 1fe:	6906                	ld	s2,64(sp)
+ 200:	79e2                	ld	s3,56(sp)
+ 202:	7a42                	ld	s4,48(sp)
+ 204:	7aa2                	ld	s5,40(sp)
+ 206:	7b02                	ld	s6,32(sp)
+ 208:	6be2                	ld	s7,24(sp)
+ 20a:	6125                	addi	sp,sp,96
+ 20c:	8082                	ret
+
+000000000000020e <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 20e:	1101                	addi	sp,sp,-32
+ 210:	ec06                	sd	ra,24(sp)
+ 212:	e822                	sd	s0,16(sp)
+ 214:	e04a                	sd	s2,0(sp)
+ 216:	1000                	addi	s0,sp,32
+ 218:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 21a:	4581                	li	a1,0
+ 21c:	18e000ef          	jal	3aa <open>
+  if(fd < 0)
+ 220:	02054263          	bltz	a0,244 <stat+0x36>
+ 224:	e426                	sd	s1,8(sp)
+ 226:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 228:	85ca                	mv	a1,s2
+ 22a:	198000ef          	jal	3c2 <fstat>
+ 22e:	892a                	mv	s2,a0
+  close(fd);
+ 230:	8526                	mv	a0,s1
+ 232:	160000ef          	jal	392 <close>
+  return r;
+ 236:	64a2                	ld	s1,8(sp)
+}
+ 238:	854a                	mv	a0,s2
+ 23a:	60e2                	ld	ra,24(sp)
+ 23c:	6442                	ld	s0,16(sp)
+ 23e:	6902                	ld	s2,0(sp)
+ 240:	6105                	addi	sp,sp,32
+ 242:	8082                	ret
+    return -1;
+ 244:	597d                	li	s2,-1
+ 246:	bfcd                	j	238 <stat+0x2a>
+
+0000000000000248 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 248:	1141                	addi	sp,sp,-16
+ 24a:	e422                	sd	s0,8(sp)
+ 24c:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 24e:	00054683          	lbu	a3,0(a0)
+ 252:	fd06879b          	addiw	a5,a3,-48
+ 256:	0ff7f793          	zext.b	a5,a5
+ 25a:	4625                	li	a2,9
+ 25c:	02f66863          	bltu	a2,a5,28c <atoi+0x44>
+ 260:	872a                	mv	a4,a0
+  n = 0;
+ 262:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 264:	0705                	addi	a4,a4,1
+ 266:	0025179b          	slliw	a5,a0,0x2
+ 26a:	9fa9                	addw	a5,a5,a0
+ 26c:	0017979b          	slliw	a5,a5,0x1
+ 270:	9fb5                	addw	a5,a5,a3
+ 272:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 276:	00074683          	lbu	a3,0(a4)
+ 27a:	fd06879b          	addiw	a5,a3,-48
+ 27e:	0ff7f793          	zext.b	a5,a5
+ 282:	fef671e3          	bgeu	a2,a5,264 <atoi+0x1c>
+  return n;
+}
+ 286:	6422                	ld	s0,8(sp)
+ 288:	0141                	addi	sp,sp,16
+ 28a:	8082                	ret
+  n = 0;
+ 28c:	4501                	li	a0,0
+ 28e:	bfe5                	j	286 <atoi+0x3e>
+
+0000000000000290 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 290:	1141                	addi	sp,sp,-16
+ 292:	e422                	sd	s0,8(sp)
+ 294:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 296:	02b57463          	bgeu	a0,a1,2be <memmove+0x2e>
+    while(n-- > 0)
+ 29a:	00c05f63          	blez	a2,2b8 <memmove+0x28>
+ 29e:	1602                	slli	a2,a2,0x20
+ 2a0:	9201                	srli	a2,a2,0x20
+ 2a2:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 2a6:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 2a8:	0585                	addi	a1,a1,1
+ 2aa:	0705                	addi	a4,a4,1
+ 2ac:	fff5c683          	lbu	a3,-1(a1)
+ 2b0:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2b4:	fef71ae3          	bne	a4,a5,2a8 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2b8:	6422                	ld	s0,8(sp)
+ 2ba:	0141                	addi	sp,sp,16
+ 2bc:	8082                	ret
+    dst += n;
+ 2be:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2c2:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2c4:	fec05ae3          	blez	a2,2b8 <memmove+0x28>
+ 2c8:	fff6079b          	addiw	a5,a2,-1
+ 2cc:	1782                	slli	a5,a5,0x20
+ 2ce:	9381                	srli	a5,a5,0x20
+ 2d0:	fff7c793          	not	a5,a5
+ 2d4:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2d6:	15fd                	addi	a1,a1,-1
+ 2d8:	177d                	addi	a4,a4,-1
+ 2da:	0005c683          	lbu	a3,0(a1)
+ 2de:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2e2:	fee79ae3          	bne	a5,a4,2d6 <memmove+0x46>
+ 2e6:	bfc9                	j	2b8 <memmove+0x28>
+
+00000000000002e8 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2e8:	1141                	addi	sp,sp,-16
+ 2ea:	e422                	sd	s0,8(sp)
+ 2ec:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2ee:	ca05                	beqz	a2,31e <memcmp+0x36>
+ 2f0:	fff6069b          	addiw	a3,a2,-1
+ 2f4:	1682                	slli	a3,a3,0x20
+ 2f6:	9281                	srli	a3,a3,0x20
+ 2f8:	0685                	addi	a3,a3,1
+ 2fa:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2fc:	00054783          	lbu	a5,0(a0)
+ 300:	0005c703          	lbu	a4,0(a1)
+ 304:	00e79863          	bne	a5,a4,314 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 308:	0505                	addi	a0,a0,1
+    p2++;
+ 30a:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 30c:	fed518e3          	bne	a0,a3,2fc <memcmp+0x14>
+  }
+  return 0;
+ 310:	4501                	li	a0,0
+ 312:	a019                	j	318 <memcmp+0x30>
+      return *p1 - *p2;
+ 314:	40e7853b          	subw	a0,a5,a4
+}
+ 318:	6422                	ld	s0,8(sp)
+ 31a:	0141                	addi	sp,sp,16
+ 31c:	8082                	ret
+  return 0;
+ 31e:	4501                	li	a0,0
+ 320:	bfe5                	j	318 <memcmp+0x30>
+
+0000000000000322 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 322:	1141                	addi	sp,sp,-16
+ 324:	e406                	sd	ra,8(sp)
+ 326:	e022                	sd	s0,0(sp)
+ 328:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 32a:	f67ff0ef          	jal	290 <memmove>
+}
+ 32e:	60a2                	ld	ra,8(sp)
+ 330:	6402                	ld	s0,0(sp)
+ 332:	0141                	addi	sp,sp,16
+ 334:	8082                	ret
+
+0000000000000336 <sbrk>:
+
+char *
+sbrk(int n) {
+ 336:	1141                	addi	sp,sp,-16
+ 338:	e406                	sd	ra,8(sp)
+ 33a:	e022                	sd	s0,0(sp)
+ 33c:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 33e:	4585                	li	a1,1
+ 340:	0b2000ef          	jal	3f2 <sys_sbrk>
+}
+ 344:	60a2                	ld	ra,8(sp)
+ 346:	6402                	ld	s0,0(sp)
+ 348:	0141                	addi	sp,sp,16
+ 34a:	8082                	ret
+
+000000000000034c <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 34c:	1141                	addi	sp,sp,-16
+ 34e:	e406                	sd	ra,8(sp)
+ 350:	e022                	sd	s0,0(sp)
+ 352:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 354:	4589                	li	a1,2
+ 356:	09c000ef          	jal	3f2 <sys_sbrk>
+}
+ 35a:	60a2                	ld	ra,8(sp)
+ 35c:	6402                	ld	s0,0(sp)
+ 35e:	0141                	addi	sp,sp,16
+ 360:	8082                	ret
+
+0000000000000362 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 362:	4885                	li	a7,1
+ ecall
+ 364:	00000073          	ecall
+ ret
+ 368:	8082                	ret
+
+000000000000036a <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 36a:	4889                	li	a7,2
+ ecall
+ 36c:	00000073          	ecall
+ ret
+ 370:	8082                	ret
+
+0000000000000372 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 372:	488d                	li	a7,3
+ ecall
+ 374:	00000073          	ecall
+ ret
+ 378:	8082                	ret
+
+000000000000037a <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 37a:	4891                	li	a7,4
+ ecall
+ 37c:	00000073          	ecall
+ ret
+ 380:	8082                	ret
+
+0000000000000382 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 382:	4895                	li	a7,5
+ ecall
+ 384:	00000073          	ecall
+ ret
+ 388:	8082                	ret
+
+000000000000038a <write>:
+.global write
+write:
+ li a7, SYS_write
+ 38a:	48c1                	li	a7,16
+ ecall
+ 38c:	00000073          	ecall
+ ret
+ 390:	8082                	ret
+
+0000000000000392 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 392:	48d5                	li	a7,21
+ ecall
+ 394:	00000073          	ecall
+ ret
+ 398:	8082                	ret
+
+000000000000039a <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 39a:	4899                	li	a7,6
+ ecall
+ 39c:	00000073          	ecall
+ ret
+ 3a0:	8082                	ret
+
+00000000000003a2 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 3a2:	489d                	li	a7,7
+ ecall
+ 3a4:	00000073          	ecall
+ ret
+ 3a8:	8082                	ret
+
+00000000000003aa <open>:
+.global open
+open:
+ li a7, SYS_open
+ 3aa:	48bd                	li	a7,15
+ ecall
+ 3ac:	00000073          	ecall
+ ret
+ 3b0:	8082                	ret
+
+00000000000003b2 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3b2:	48c5                	li	a7,17
+ ecall
+ 3b4:	00000073          	ecall
+ ret
+ 3b8:	8082                	ret
+
+00000000000003ba <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3ba:	48c9                	li	a7,18
+ ecall
+ 3bc:	00000073          	ecall
+ ret
+ 3c0:	8082                	ret
+
+00000000000003c2 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3c2:	48a1                	li	a7,8
+ ecall
+ 3c4:	00000073          	ecall
+ ret
+ 3c8:	8082                	ret
+
+00000000000003ca <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3ca:	48cd                	li	a7,19
+ ecall
+ 3cc:	00000073          	ecall
+ ret
+ 3d0:	8082                	ret
+
+00000000000003d2 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3d2:	48d1                	li	a7,20
+ ecall
+ 3d4:	00000073          	ecall
+ ret
+ 3d8:	8082                	ret
+
+00000000000003da <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3da:	48a5                	li	a7,9
+ ecall
+ 3dc:	00000073          	ecall
+ ret
+ 3e0:	8082                	ret
+
+00000000000003e2 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3e2:	48a9                	li	a7,10
+ ecall
+ 3e4:	00000073          	ecall
+ ret
+ 3e8:	8082                	ret
+
+00000000000003ea <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3ea:	48ad                	li	a7,11
+ ecall
+ 3ec:	00000073          	ecall
+ ret
+ 3f0:	8082                	ret
+
+00000000000003f2 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3f2:	48b1                	li	a7,12
+ ecall
+ 3f4:	00000073          	ecall
+ ret
+ 3f8:	8082                	ret
+
+00000000000003fa <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3fa:	48b5                	li	a7,13
+ ecall
+ 3fc:	00000073          	ecall
+ ret
+ 400:	8082                	ret
+
+0000000000000402 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 402:	48b9                	li	a7,14
+ ecall
+ 404:	00000073          	ecall
+ ret
+ 408:	8082                	ret
+
+000000000000040a <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 40a:	48d9                	li	a7,22
+ ecall
+ 40c:	00000073          	ecall
+ ret
+ 410:	8082                	ret
diff -ruN xv6-riscv/user/forktest.d xv62/user/forktest.d
--- xv6-riscv/user/forktest.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/forktest.d	2025-09-14 12:32:50.720883347 +0000
@@ -0,0 +1 @@
+user/forktest.o: user/forktest.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/forktest.o and xv62/user/forktest.o differ
diff -ruN xv6-riscv/user/forphan.asm xv62/user/forphan.asm
--- xv6-riscv/user/forphan.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/forphan.asm	2025-09-14 12:32:52.256883032 +0000
@@ -0,0 +1,1554 @@
+
+user/_forphan:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+
+char buf[BUFSZ];
+
+int
+main(int argc, char **argv)
+{
+   0:	7139                	addi	sp,sp,-64
+   2:	fc06                	sd	ra,56(sp)
+   4:	f822                	sd	s0,48(sp)
+   6:	f426                	sd	s1,40(sp)
+   8:	0080                	addi	s0,sp,64
+  int fd = 0;
+  char *s = argv[0];
+   a:	6184                	ld	s1,0(a1)
+  struct stat st;
+  char *ff = "file0";
+  
+  if ((fd = open(ff, O_CREATE|O_WRONLY)) < 0) {
+   c:	20100593          	li	a1,513
+  10:	00001517          	auipc	a0,0x1
+  14:	93050513          	addi	a0,a0,-1744 # 940 <malloc+0x104>
+  18:	380000ef          	jal	398 <open>
+  1c:	04054463          	bltz	a0,64 <main+0x64>
+    printf("%s: open failed\n", s);
+    exit(1);
+  }
+  if(fstat(fd, &st) < 0){
+  20:	fc840593          	addi	a1,s0,-56
+  24:	38c000ef          	jal	3b0 <fstat>
+  28:	04054863          	bltz	a0,78 <main+0x78>
+    fprintf(2, "%s: cannot stat %s\n", s, "ff");
+    exit(1);
+  }
+  if (unlink(ff) < 0) {
+  2c:	00001517          	auipc	a0,0x1
+  30:	91450513          	addi	a0,a0,-1772 # 940 <malloc+0x104>
+  34:	374000ef          	jal	3a8 <unlink>
+  38:	04054f63          	bltz	a0,96 <main+0x96>
+    printf("%s: unlink failed\n", s);
+    exit(1);
+  }
+  if (open(ff, O_RDONLY) != -1) {
+  3c:	4581                	li	a1,0
+  3e:	00001517          	auipc	a0,0x1
+  42:	90250513          	addi	a0,a0,-1790 # 940 <malloc+0x104>
+  46:	352000ef          	jal	398 <open>
+  4a:	57fd                	li	a5,-1
+  4c:	04f50f63          	beq	a0,a5,aa <main+0xaa>
+    printf("%s: open successed\n", s);
+  50:	85a6                	mv	a1,s1
+  52:	00001517          	auipc	a0,0x1
+  56:	94e50513          	addi	a0,a0,-1714 # 9a0 <malloc+0x164>
+  5a:	72e000ef          	jal	788 <printf>
+    exit(1);
+  5e:	4505                	li	a0,1
+  60:	2f8000ef          	jal	358 <exit>
+    printf("%s: open failed\n", s);
+  64:	85a6                	mv	a1,s1
+  66:	00001517          	auipc	a0,0x1
+  6a:	8ea50513          	addi	a0,a0,-1814 # 950 <malloc+0x114>
+  6e:	71a000ef          	jal	788 <printf>
+    exit(1);
+  72:	4505                	li	a0,1
+  74:	2e4000ef          	jal	358 <exit>
+    fprintf(2, "%s: cannot stat %s\n", s, "ff");
+  78:	00001697          	auipc	a3,0x1
+  7c:	8f068693          	addi	a3,a3,-1808 # 968 <malloc+0x12c>
+  80:	8626                	mv	a2,s1
+  82:	00001597          	auipc	a1,0x1
+  86:	8ee58593          	addi	a1,a1,-1810 # 970 <malloc+0x134>
+  8a:	4509                	li	a0,2
+  8c:	6d2000ef          	jal	75e <fprintf>
+    exit(1);
+  90:	4505                	li	a0,1
+  92:	2c6000ef          	jal	358 <exit>
+    printf("%s: unlink failed\n", s);
+  96:	85a6                	mv	a1,s1
+  98:	00001517          	auipc	a0,0x1
+  9c:	8f050513          	addi	a0,a0,-1808 # 988 <malloc+0x14c>
+  a0:	6e8000ef          	jal	788 <printf>
+    exit(1);
+  a4:	4505                	li	a0,1
+  a6:	2b2000ef          	jal	358 <exit>
+  }
+  printf("wait for kill and reclaim %d\n", st.ino);
+  aa:	fcc42583          	lw	a1,-52(s0)
+  ae:	00001517          	auipc	a0,0x1
+  b2:	90a50513          	addi	a0,a0,-1782 # 9b8 <malloc+0x17c>
+  b6:	6d2000ef          	jal	788 <printf>
+  // sit around until killed
+  for(;;) pause(1000);
+  ba:	3e800513          	li	a0,1000
+  be:	32a000ef          	jal	3e8 <pause>
+  c2:	bfe5                	j	ba <main+0xba>
+
+00000000000000c4 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  c4:	1141                	addi	sp,sp,-16
+  c6:	e406                	sd	ra,8(sp)
+  c8:	e022                	sd	s0,0(sp)
+  ca:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  cc:	f35ff0ef          	jal	0 <main>
+  exit(r);
+  d0:	288000ef          	jal	358 <exit>
+
+00000000000000d4 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  d4:	1141                	addi	sp,sp,-16
+  d6:	e422                	sd	s0,8(sp)
+  d8:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  da:	87aa                	mv	a5,a0
+  dc:	0585                	addi	a1,a1,1
+  de:	0785                	addi	a5,a5,1
+  e0:	fff5c703          	lbu	a4,-1(a1)
+  e4:	fee78fa3          	sb	a4,-1(a5)
+  e8:	fb75                	bnez	a4,dc <strcpy+0x8>
+    ;
+  return os;
+}
+  ea:	6422                	ld	s0,8(sp)
+  ec:	0141                	addi	sp,sp,16
+  ee:	8082                	ret
+
+00000000000000f0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  f0:	1141                	addi	sp,sp,-16
+  f2:	e422                	sd	s0,8(sp)
+  f4:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  f6:	00054783          	lbu	a5,0(a0)
+  fa:	cb91                	beqz	a5,10e <strcmp+0x1e>
+  fc:	0005c703          	lbu	a4,0(a1)
+ 100:	00f71763          	bne	a4,a5,10e <strcmp+0x1e>
+    p++, q++;
+ 104:	0505                	addi	a0,a0,1
+ 106:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 108:	00054783          	lbu	a5,0(a0)
+ 10c:	fbe5                	bnez	a5,fc <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 10e:	0005c503          	lbu	a0,0(a1)
+}
+ 112:	40a7853b          	subw	a0,a5,a0
+ 116:	6422                	ld	s0,8(sp)
+ 118:	0141                	addi	sp,sp,16
+ 11a:	8082                	ret
+
+000000000000011c <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 11c:	1141                	addi	sp,sp,-16
+ 11e:	e422                	sd	s0,8(sp)
+ 120:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 122:	00054783          	lbu	a5,0(a0)
+ 126:	cf91                	beqz	a5,142 <strlen+0x26>
+ 128:	0505                	addi	a0,a0,1
+ 12a:	87aa                	mv	a5,a0
+ 12c:	86be                	mv	a3,a5
+ 12e:	0785                	addi	a5,a5,1
+ 130:	fff7c703          	lbu	a4,-1(a5)
+ 134:	ff65                	bnez	a4,12c <strlen+0x10>
+ 136:	40a6853b          	subw	a0,a3,a0
+ 13a:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 13c:	6422                	ld	s0,8(sp)
+ 13e:	0141                	addi	sp,sp,16
+ 140:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 142:	4501                	li	a0,0
+ 144:	bfe5                	j	13c <strlen+0x20>
+
+0000000000000146 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 146:	1141                	addi	sp,sp,-16
+ 148:	e422                	sd	s0,8(sp)
+ 14a:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 14c:	ca19                	beqz	a2,162 <memset+0x1c>
+ 14e:	87aa                	mv	a5,a0
+ 150:	1602                	slli	a2,a2,0x20
+ 152:	9201                	srli	a2,a2,0x20
+ 154:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 158:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 15c:	0785                	addi	a5,a5,1
+ 15e:	fee79de3          	bne	a5,a4,158 <memset+0x12>
+  }
+  return dst;
+}
+ 162:	6422                	ld	s0,8(sp)
+ 164:	0141                	addi	sp,sp,16
+ 166:	8082                	ret
+
+0000000000000168 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 168:	1141                	addi	sp,sp,-16
+ 16a:	e422                	sd	s0,8(sp)
+ 16c:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 16e:	00054783          	lbu	a5,0(a0)
+ 172:	cb99                	beqz	a5,188 <strchr+0x20>
+    if(*s == c)
+ 174:	00f58763          	beq	a1,a5,182 <strchr+0x1a>
+  for(; *s; s++)
+ 178:	0505                	addi	a0,a0,1
+ 17a:	00054783          	lbu	a5,0(a0)
+ 17e:	fbfd                	bnez	a5,174 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 180:	4501                	li	a0,0
+}
+ 182:	6422                	ld	s0,8(sp)
+ 184:	0141                	addi	sp,sp,16
+ 186:	8082                	ret
+  return 0;
+ 188:	4501                	li	a0,0
+ 18a:	bfe5                	j	182 <strchr+0x1a>
+
+000000000000018c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 18c:	711d                	addi	sp,sp,-96
+ 18e:	ec86                	sd	ra,88(sp)
+ 190:	e8a2                	sd	s0,80(sp)
+ 192:	e4a6                	sd	s1,72(sp)
+ 194:	e0ca                	sd	s2,64(sp)
+ 196:	fc4e                	sd	s3,56(sp)
+ 198:	f852                	sd	s4,48(sp)
+ 19a:	f456                	sd	s5,40(sp)
+ 19c:	f05a                	sd	s6,32(sp)
+ 19e:	ec5e                	sd	s7,24(sp)
+ 1a0:	1080                	addi	s0,sp,96
+ 1a2:	8baa                	mv	s7,a0
+ 1a4:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1a6:	892a                	mv	s2,a0
+ 1a8:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1aa:	4aa9                	li	s5,10
+ 1ac:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1ae:	89a6                	mv	s3,s1
+ 1b0:	2485                	addiw	s1,s1,1
+ 1b2:	0344d663          	bge	s1,s4,1de <gets+0x52>
+    cc = read(0, &c, 1);
+ 1b6:	4605                	li	a2,1
+ 1b8:	faf40593          	addi	a1,s0,-81
+ 1bc:	4501                	li	a0,0
+ 1be:	1b2000ef          	jal	370 <read>
+    if(cc < 1)
+ 1c2:	00a05e63          	blez	a0,1de <gets+0x52>
+    buf[i++] = c;
+ 1c6:	faf44783          	lbu	a5,-81(s0)
+ 1ca:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1ce:	01578763          	beq	a5,s5,1dc <gets+0x50>
+ 1d2:	0905                	addi	s2,s2,1
+ 1d4:	fd679de3          	bne	a5,s6,1ae <gets+0x22>
+    buf[i++] = c;
+ 1d8:	89a6                	mv	s3,s1
+ 1da:	a011                	j	1de <gets+0x52>
+ 1dc:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1de:	99de                	add	s3,s3,s7
+ 1e0:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1e4:	855e                	mv	a0,s7
+ 1e6:	60e6                	ld	ra,88(sp)
+ 1e8:	6446                	ld	s0,80(sp)
+ 1ea:	64a6                	ld	s1,72(sp)
+ 1ec:	6906                	ld	s2,64(sp)
+ 1ee:	79e2                	ld	s3,56(sp)
+ 1f0:	7a42                	ld	s4,48(sp)
+ 1f2:	7aa2                	ld	s5,40(sp)
+ 1f4:	7b02                	ld	s6,32(sp)
+ 1f6:	6be2                	ld	s7,24(sp)
+ 1f8:	6125                	addi	sp,sp,96
+ 1fa:	8082                	ret
+
+00000000000001fc <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1fc:	1101                	addi	sp,sp,-32
+ 1fe:	ec06                	sd	ra,24(sp)
+ 200:	e822                	sd	s0,16(sp)
+ 202:	e04a                	sd	s2,0(sp)
+ 204:	1000                	addi	s0,sp,32
+ 206:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 208:	4581                	li	a1,0
+ 20a:	18e000ef          	jal	398 <open>
+  if(fd < 0)
+ 20e:	02054263          	bltz	a0,232 <stat+0x36>
+ 212:	e426                	sd	s1,8(sp)
+ 214:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 216:	85ca                	mv	a1,s2
+ 218:	198000ef          	jal	3b0 <fstat>
+ 21c:	892a                	mv	s2,a0
+  close(fd);
+ 21e:	8526                	mv	a0,s1
+ 220:	160000ef          	jal	380 <close>
+  return r;
+ 224:	64a2                	ld	s1,8(sp)
+}
+ 226:	854a                	mv	a0,s2
+ 228:	60e2                	ld	ra,24(sp)
+ 22a:	6442                	ld	s0,16(sp)
+ 22c:	6902                	ld	s2,0(sp)
+ 22e:	6105                	addi	sp,sp,32
+ 230:	8082                	ret
+    return -1;
+ 232:	597d                	li	s2,-1
+ 234:	bfcd                	j	226 <stat+0x2a>
+
+0000000000000236 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 236:	1141                	addi	sp,sp,-16
+ 238:	e422                	sd	s0,8(sp)
+ 23a:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 23c:	00054683          	lbu	a3,0(a0)
+ 240:	fd06879b          	addiw	a5,a3,-48
+ 244:	0ff7f793          	zext.b	a5,a5
+ 248:	4625                	li	a2,9
+ 24a:	02f66863          	bltu	a2,a5,27a <atoi+0x44>
+ 24e:	872a                	mv	a4,a0
+  n = 0;
+ 250:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 252:	0705                	addi	a4,a4,1
+ 254:	0025179b          	slliw	a5,a0,0x2
+ 258:	9fa9                	addw	a5,a5,a0
+ 25a:	0017979b          	slliw	a5,a5,0x1
+ 25e:	9fb5                	addw	a5,a5,a3
+ 260:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 264:	00074683          	lbu	a3,0(a4)
+ 268:	fd06879b          	addiw	a5,a3,-48
+ 26c:	0ff7f793          	zext.b	a5,a5
+ 270:	fef671e3          	bgeu	a2,a5,252 <atoi+0x1c>
+  return n;
+}
+ 274:	6422                	ld	s0,8(sp)
+ 276:	0141                	addi	sp,sp,16
+ 278:	8082                	ret
+  n = 0;
+ 27a:	4501                	li	a0,0
+ 27c:	bfe5                	j	274 <atoi+0x3e>
+
+000000000000027e <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 27e:	1141                	addi	sp,sp,-16
+ 280:	e422                	sd	s0,8(sp)
+ 282:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 284:	02b57463          	bgeu	a0,a1,2ac <memmove+0x2e>
+    while(n-- > 0)
+ 288:	00c05f63          	blez	a2,2a6 <memmove+0x28>
+ 28c:	1602                	slli	a2,a2,0x20
+ 28e:	9201                	srli	a2,a2,0x20
+ 290:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 294:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 296:	0585                	addi	a1,a1,1
+ 298:	0705                	addi	a4,a4,1
+ 29a:	fff5c683          	lbu	a3,-1(a1)
+ 29e:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2a2:	fef71ae3          	bne	a4,a5,296 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2a6:	6422                	ld	s0,8(sp)
+ 2a8:	0141                	addi	sp,sp,16
+ 2aa:	8082                	ret
+    dst += n;
+ 2ac:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2b0:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2b2:	fec05ae3          	blez	a2,2a6 <memmove+0x28>
+ 2b6:	fff6079b          	addiw	a5,a2,-1
+ 2ba:	1782                	slli	a5,a5,0x20
+ 2bc:	9381                	srli	a5,a5,0x20
+ 2be:	fff7c793          	not	a5,a5
+ 2c2:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2c4:	15fd                	addi	a1,a1,-1
+ 2c6:	177d                	addi	a4,a4,-1
+ 2c8:	0005c683          	lbu	a3,0(a1)
+ 2cc:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2d0:	fee79ae3          	bne	a5,a4,2c4 <memmove+0x46>
+ 2d4:	bfc9                	j	2a6 <memmove+0x28>
+
+00000000000002d6 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2d6:	1141                	addi	sp,sp,-16
+ 2d8:	e422                	sd	s0,8(sp)
+ 2da:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2dc:	ca05                	beqz	a2,30c <memcmp+0x36>
+ 2de:	fff6069b          	addiw	a3,a2,-1
+ 2e2:	1682                	slli	a3,a3,0x20
+ 2e4:	9281                	srli	a3,a3,0x20
+ 2e6:	0685                	addi	a3,a3,1
+ 2e8:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2ea:	00054783          	lbu	a5,0(a0)
+ 2ee:	0005c703          	lbu	a4,0(a1)
+ 2f2:	00e79863          	bne	a5,a4,302 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 2f6:	0505                	addi	a0,a0,1
+    p2++;
+ 2f8:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 2fa:	fed518e3          	bne	a0,a3,2ea <memcmp+0x14>
+  }
+  return 0;
+ 2fe:	4501                	li	a0,0
+ 300:	a019                	j	306 <memcmp+0x30>
+      return *p1 - *p2;
+ 302:	40e7853b          	subw	a0,a5,a4
+}
+ 306:	6422                	ld	s0,8(sp)
+ 308:	0141                	addi	sp,sp,16
+ 30a:	8082                	ret
+  return 0;
+ 30c:	4501                	li	a0,0
+ 30e:	bfe5                	j	306 <memcmp+0x30>
+
+0000000000000310 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 310:	1141                	addi	sp,sp,-16
+ 312:	e406                	sd	ra,8(sp)
+ 314:	e022                	sd	s0,0(sp)
+ 316:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 318:	f67ff0ef          	jal	27e <memmove>
+}
+ 31c:	60a2                	ld	ra,8(sp)
+ 31e:	6402                	ld	s0,0(sp)
+ 320:	0141                	addi	sp,sp,16
+ 322:	8082                	ret
+
+0000000000000324 <sbrk>:
+
+char *
+sbrk(int n) {
+ 324:	1141                	addi	sp,sp,-16
+ 326:	e406                	sd	ra,8(sp)
+ 328:	e022                	sd	s0,0(sp)
+ 32a:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 32c:	4585                	li	a1,1
+ 32e:	0b2000ef          	jal	3e0 <sys_sbrk>
+}
+ 332:	60a2                	ld	ra,8(sp)
+ 334:	6402                	ld	s0,0(sp)
+ 336:	0141                	addi	sp,sp,16
+ 338:	8082                	ret
+
+000000000000033a <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 33a:	1141                	addi	sp,sp,-16
+ 33c:	e406                	sd	ra,8(sp)
+ 33e:	e022                	sd	s0,0(sp)
+ 340:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 342:	4589                	li	a1,2
+ 344:	09c000ef          	jal	3e0 <sys_sbrk>
+}
+ 348:	60a2                	ld	ra,8(sp)
+ 34a:	6402                	ld	s0,0(sp)
+ 34c:	0141                	addi	sp,sp,16
+ 34e:	8082                	ret
+
+0000000000000350 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 350:	4885                	li	a7,1
+ ecall
+ 352:	00000073          	ecall
+ ret
+ 356:	8082                	ret
+
+0000000000000358 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 358:	4889                	li	a7,2
+ ecall
+ 35a:	00000073          	ecall
+ ret
+ 35e:	8082                	ret
+
+0000000000000360 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 360:	488d                	li	a7,3
+ ecall
+ 362:	00000073          	ecall
+ ret
+ 366:	8082                	ret
+
+0000000000000368 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 368:	4891                	li	a7,4
+ ecall
+ 36a:	00000073          	ecall
+ ret
+ 36e:	8082                	ret
+
+0000000000000370 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 370:	4895                	li	a7,5
+ ecall
+ 372:	00000073          	ecall
+ ret
+ 376:	8082                	ret
+
+0000000000000378 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 378:	48c1                	li	a7,16
+ ecall
+ 37a:	00000073          	ecall
+ ret
+ 37e:	8082                	ret
+
+0000000000000380 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 380:	48d5                	li	a7,21
+ ecall
+ 382:	00000073          	ecall
+ ret
+ 386:	8082                	ret
+
+0000000000000388 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 388:	4899                	li	a7,6
+ ecall
+ 38a:	00000073          	ecall
+ ret
+ 38e:	8082                	ret
+
+0000000000000390 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 390:	489d                	li	a7,7
+ ecall
+ 392:	00000073          	ecall
+ ret
+ 396:	8082                	ret
+
+0000000000000398 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 398:	48bd                	li	a7,15
+ ecall
+ 39a:	00000073          	ecall
+ ret
+ 39e:	8082                	ret
+
+00000000000003a0 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3a0:	48c5                	li	a7,17
+ ecall
+ 3a2:	00000073          	ecall
+ ret
+ 3a6:	8082                	ret
+
+00000000000003a8 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3a8:	48c9                	li	a7,18
+ ecall
+ 3aa:	00000073          	ecall
+ ret
+ 3ae:	8082                	ret
+
+00000000000003b0 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3b0:	48a1                	li	a7,8
+ ecall
+ 3b2:	00000073          	ecall
+ ret
+ 3b6:	8082                	ret
+
+00000000000003b8 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3b8:	48cd                	li	a7,19
+ ecall
+ 3ba:	00000073          	ecall
+ ret
+ 3be:	8082                	ret
+
+00000000000003c0 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3c0:	48d1                	li	a7,20
+ ecall
+ 3c2:	00000073          	ecall
+ ret
+ 3c6:	8082                	ret
+
+00000000000003c8 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3c8:	48a5                	li	a7,9
+ ecall
+ 3ca:	00000073          	ecall
+ ret
+ 3ce:	8082                	ret
+
+00000000000003d0 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3d0:	48a9                	li	a7,10
+ ecall
+ 3d2:	00000073          	ecall
+ ret
+ 3d6:	8082                	ret
+
+00000000000003d8 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3d8:	48ad                	li	a7,11
+ ecall
+ 3da:	00000073          	ecall
+ ret
+ 3de:	8082                	ret
+
+00000000000003e0 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3e0:	48b1                	li	a7,12
+ ecall
+ 3e2:	00000073          	ecall
+ ret
+ 3e6:	8082                	ret
+
+00000000000003e8 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3e8:	48b5                	li	a7,13
+ ecall
+ 3ea:	00000073          	ecall
+ ret
+ 3ee:	8082                	ret
+
+00000000000003f0 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 3f0:	48b9                	li	a7,14
+ ecall
+ 3f2:	00000073          	ecall
+ ret
+ 3f6:	8082                	ret
+
+00000000000003f8 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 3f8:	48d9                	li	a7,22
+ ecall
+ 3fa:	00000073          	ecall
+ ret
+ 3fe:	8082                	ret
+
+0000000000000400 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 400:	1101                	addi	sp,sp,-32
+ 402:	ec06                	sd	ra,24(sp)
+ 404:	e822                	sd	s0,16(sp)
+ 406:	1000                	addi	s0,sp,32
+ 408:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 40c:	4605                	li	a2,1
+ 40e:	fef40593          	addi	a1,s0,-17
+ 412:	f67ff0ef          	jal	378 <write>
+}
+ 416:	60e2                	ld	ra,24(sp)
+ 418:	6442                	ld	s0,16(sp)
+ 41a:	6105                	addi	sp,sp,32
+ 41c:	8082                	ret
+
+000000000000041e <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 41e:	715d                	addi	sp,sp,-80
+ 420:	e486                	sd	ra,72(sp)
+ 422:	e0a2                	sd	s0,64(sp)
+ 424:	f84a                	sd	s2,48(sp)
+ 426:	0880                	addi	s0,sp,80
+ 428:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 42a:	c299                	beqz	a3,430 <printint+0x12>
+ 42c:	0805c363          	bltz	a1,4b2 <printint+0x94>
+  neg = 0;
+ 430:	4881                	li	a7,0
+ 432:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 436:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 438:	00000517          	auipc	a0,0x0
+ 43c:	5a850513          	addi	a0,a0,1448 # 9e0 <digits>
+ 440:	883e                	mv	a6,a5
+ 442:	2785                	addiw	a5,a5,1
+ 444:	02c5f733          	remu	a4,a1,a2
+ 448:	972a                	add	a4,a4,a0
+ 44a:	00074703          	lbu	a4,0(a4)
+ 44e:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 452:	872e                	mv	a4,a1
+ 454:	02c5d5b3          	divu	a1,a1,a2
+ 458:	0685                	addi	a3,a3,1
+ 45a:	fec773e3          	bgeu	a4,a2,440 <printint+0x22>
+  if(neg)
+ 45e:	00088b63          	beqz	a7,474 <printint+0x56>
+    buf[i++] = '-';
+ 462:	fd078793          	addi	a5,a5,-48
+ 466:	97a2                	add	a5,a5,s0
+ 468:	02d00713          	li	a4,45
+ 46c:	fee78423          	sb	a4,-24(a5)
+ 470:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 474:	02f05a63          	blez	a5,4a8 <printint+0x8a>
+ 478:	fc26                	sd	s1,56(sp)
+ 47a:	f44e                	sd	s3,40(sp)
+ 47c:	fb840713          	addi	a4,s0,-72
+ 480:	00f704b3          	add	s1,a4,a5
+ 484:	fff70993          	addi	s3,a4,-1
+ 488:	99be                	add	s3,s3,a5
+ 48a:	37fd                	addiw	a5,a5,-1
+ 48c:	1782                	slli	a5,a5,0x20
+ 48e:	9381                	srli	a5,a5,0x20
+ 490:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 494:	fff4c583          	lbu	a1,-1(s1)
+ 498:	854a                	mv	a0,s2
+ 49a:	f67ff0ef          	jal	400 <putc>
+  while(--i >= 0)
+ 49e:	14fd                	addi	s1,s1,-1
+ 4a0:	ff349ae3          	bne	s1,s3,494 <printint+0x76>
+ 4a4:	74e2                	ld	s1,56(sp)
+ 4a6:	79a2                	ld	s3,40(sp)
+}
+ 4a8:	60a6                	ld	ra,72(sp)
+ 4aa:	6406                	ld	s0,64(sp)
+ 4ac:	7942                	ld	s2,48(sp)
+ 4ae:	6161                	addi	sp,sp,80
+ 4b0:	8082                	ret
+    x = -xx;
+ 4b2:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4b6:	4885                	li	a7,1
+    x = -xx;
+ 4b8:	bfad                	j	432 <printint+0x14>
+
+00000000000004ba <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4ba:	711d                	addi	sp,sp,-96
+ 4bc:	ec86                	sd	ra,88(sp)
+ 4be:	e8a2                	sd	s0,80(sp)
+ 4c0:	e0ca                	sd	s2,64(sp)
+ 4c2:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 4c4:	0005c903          	lbu	s2,0(a1)
+ 4c8:	28090663          	beqz	s2,754 <vprintf+0x29a>
+ 4cc:	e4a6                	sd	s1,72(sp)
+ 4ce:	fc4e                	sd	s3,56(sp)
+ 4d0:	f852                	sd	s4,48(sp)
+ 4d2:	f456                	sd	s5,40(sp)
+ 4d4:	f05a                	sd	s6,32(sp)
+ 4d6:	ec5e                	sd	s7,24(sp)
+ 4d8:	e862                	sd	s8,16(sp)
+ 4da:	e466                	sd	s9,8(sp)
+ 4dc:	8b2a                	mv	s6,a0
+ 4de:	8a2e                	mv	s4,a1
+ 4e0:	8bb2                	mv	s7,a2
+  state = 0;
+ 4e2:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 4e4:	4481                	li	s1,0
+ 4e6:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 4e8:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 4ec:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4f0:	06c00c93          	li	s9,108
+ 4f4:	a005                	j	514 <vprintf+0x5a>
+        putc(fd, c0);
+ 4f6:	85ca                	mv	a1,s2
+ 4f8:	855a                	mv	a0,s6
+ 4fa:	f07ff0ef          	jal	400 <putc>
+ 4fe:	a019                	j	504 <vprintf+0x4a>
+    } else if(state == '%'){
+ 500:	03598263          	beq	s3,s5,524 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 504:	2485                	addiw	s1,s1,1
+ 506:	8726                	mv	a4,s1
+ 508:	009a07b3          	add	a5,s4,s1
+ 50c:	0007c903          	lbu	s2,0(a5)
+ 510:	22090a63          	beqz	s2,744 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 514:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 518:	fe0994e3          	bnez	s3,500 <vprintf+0x46>
+      if(c0 == '%'){
+ 51c:	fd579de3          	bne	a5,s5,4f6 <vprintf+0x3c>
+        state = '%';
+ 520:	89be                	mv	s3,a5
+ 522:	b7cd                	j	504 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 524:	00ea06b3          	add	a3,s4,a4
+ 528:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 52c:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 52e:	c681                	beqz	a3,536 <vprintf+0x7c>
+ 530:	9752                	add	a4,a4,s4
+ 532:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 536:	05878363          	beq	a5,s8,57c <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 53a:	05978d63          	beq	a5,s9,594 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 53e:	07500713          	li	a4,117
+ 542:	0ee78763          	beq	a5,a4,630 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 546:	07800713          	li	a4,120
+ 54a:	12e78963          	beq	a5,a4,67c <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 54e:	07000713          	li	a4,112
+ 552:	14e78e63          	beq	a5,a4,6ae <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 556:	06300713          	li	a4,99
+ 55a:	18e78e63          	beq	a5,a4,6f6 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 55e:	07300713          	li	a4,115
+ 562:	1ae78463          	beq	a5,a4,70a <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 566:	02500713          	li	a4,37
+ 56a:	04e79563          	bne	a5,a4,5b4 <vprintf+0xfa>
+        putc(fd, '%');
+ 56e:	02500593          	li	a1,37
+ 572:	855a                	mv	a0,s6
+ 574:	e8dff0ef          	jal	400 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 578:	4981                	li	s3,0
+ 57a:	b769                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 57c:	008b8913          	addi	s2,s7,8
+ 580:	4685                	li	a3,1
+ 582:	4629                	li	a2,10
+ 584:	000ba583          	lw	a1,0(s7)
+ 588:	855a                	mv	a0,s6
+ 58a:	e95ff0ef          	jal	41e <printint>
+ 58e:	8bca                	mv	s7,s2
+      state = 0;
+ 590:	4981                	li	s3,0
+ 592:	bf8d                	j	504 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 594:	06400793          	li	a5,100
+ 598:	02f68963          	beq	a3,a5,5ca <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 59c:	06c00793          	li	a5,108
+ 5a0:	04f68263          	beq	a3,a5,5e4 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 5a4:	07500793          	li	a5,117
+ 5a8:	0af68063          	beq	a3,a5,648 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5ac:	07800793          	li	a5,120
+ 5b0:	0ef68263          	beq	a3,a5,694 <vprintf+0x1da>
+        putc(fd, '%');
+ 5b4:	02500593          	li	a1,37
+ 5b8:	855a                	mv	a0,s6
+ 5ba:	e47ff0ef          	jal	400 <putc>
+        putc(fd, c0);
+ 5be:	85ca                	mv	a1,s2
+ 5c0:	855a                	mv	a0,s6
+ 5c2:	e3fff0ef          	jal	400 <putc>
+      state = 0;
+ 5c6:	4981                	li	s3,0
+ 5c8:	bf35                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5ca:	008b8913          	addi	s2,s7,8
+ 5ce:	4685                	li	a3,1
+ 5d0:	4629                	li	a2,10
+ 5d2:	000bb583          	ld	a1,0(s7)
+ 5d6:	855a                	mv	a0,s6
+ 5d8:	e47ff0ef          	jal	41e <printint>
+        i += 1;
+ 5dc:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5de:	8bca                	mv	s7,s2
+      state = 0;
+ 5e0:	4981                	li	s3,0
+        i += 1;
+ 5e2:	b70d                	j	504 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5e4:	06400793          	li	a5,100
+ 5e8:	02f60763          	beq	a2,a5,616 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 5ec:	07500793          	li	a5,117
+ 5f0:	06f60963          	beq	a2,a5,662 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 5f4:	07800793          	li	a5,120
+ 5f8:	faf61ee3          	bne	a2,a5,5b4 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5fc:	008b8913          	addi	s2,s7,8
+ 600:	4681                	li	a3,0
+ 602:	4641                	li	a2,16
+ 604:	000bb583          	ld	a1,0(s7)
+ 608:	855a                	mv	a0,s6
+ 60a:	e15ff0ef          	jal	41e <printint>
+        i += 2;
+ 60e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 610:	8bca                	mv	s7,s2
+      state = 0;
+ 612:	4981                	li	s3,0
+        i += 2;
+ 614:	bdc5                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 616:	008b8913          	addi	s2,s7,8
+ 61a:	4685                	li	a3,1
+ 61c:	4629                	li	a2,10
+ 61e:	000bb583          	ld	a1,0(s7)
+ 622:	855a                	mv	a0,s6
+ 624:	dfbff0ef          	jal	41e <printint>
+        i += 2;
+ 628:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 62a:	8bca                	mv	s7,s2
+      state = 0;
+ 62c:	4981                	li	s3,0
+        i += 2;
+ 62e:	bdd9                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 630:	008b8913          	addi	s2,s7,8
+ 634:	4681                	li	a3,0
+ 636:	4629                	li	a2,10
+ 638:	000be583          	lwu	a1,0(s7)
+ 63c:	855a                	mv	a0,s6
+ 63e:	de1ff0ef          	jal	41e <printint>
+ 642:	8bca                	mv	s7,s2
+      state = 0;
+ 644:	4981                	li	s3,0
+ 646:	bd7d                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 648:	008b8913          	addi	s2,s7,8
+ 64c:	4681                	li	a3,0
+ 64e:	4629                	li	a2,10
+ 650:	000bb583          	ld	a1,0(s7)
+ 654:	855a                	mv	a0,s6
+ 656:	dc9ff0ef          	jal	41e <printint>
+        i += 1;
+ 65a:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 65c:	8bca                	mv	s7,s2
+      state = 0;
+ 65e:	4981                	li	s3,0
+        i += 1;
+ 660:	b555                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 662:	008b8913          	addi	s2,s7,8
+ 666:	4681                	li	a3,0
+ 668:	4629                	li	a2,10
+ 66a:	000bb583          	ld	a1,0(s7)
+ 66e:	855a                	mv	a0,s6
+ 670:	dafff0ef          	jal	41e <printint>
+        i += 2;
+ 674:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 676:	8bca                	mv	s7,s2
+      state = 0;
+ 678:	4981                	li	s3,0
+        i += 2;
+ 67a:	b569                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 67c:	008b8913          	addi	s2,s7,8
+ 680:	4681                	li	a3,0
+ 682:	4641                	li	a2,16
+ 684:	000be583          	lwu	a1,0(s7)
+ 688:	855a                	mv	a0,s6
+ 68a:	d95ff0ef          	jal	41e <printint>
+ 68e:	8bca                	mv	s7,s2
+      state = 0;
+ 690:	4981                	li	s3,0
+ 692:	bd8d                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 694:	008b8913          	addi	s2,s7,8
+ 698:	4681                	li	a3,0
+ 69a:	4641                	li	a2,16
+ 69c:	000bb583          	ld	a1,0(s7)
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	d7dff0ef          	jal	41e <printint>
+        i += 1;
+ 6a6:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6a8:	8bca                	mv	s7,s2
+      state = 0;
+ 6aa:	4981                	li	s3,0
+        i += 1;
+ 6ac:	bda1                	j	504 <vprintf+0x4a>
+ 6ae:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6b0:	008b8d13          	addi	s10,s7,8
+ 6b4:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6b8:	03000593          	li	a1,48
+ 6bc:	855a                	mv	a0,s6
+ 6be:	d43ff0ef          	jal	400 <putc>
+  putc(fd, 'x');
+ 6c2:	07800593          	li	a1,120
+ 6c6:	855a                	mv	a0,s6
+ 6c8:	d39ff0ef          	jal	400 <putc>
+ 6cc:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 6ce:	00000b97          	auipc	s7,0x0
+ 6d2:	312b8b93          	addi	s7,s7,786 # 9e0 <digits>
+ 6d6:	03c9d793          	srli	a5,s3,0x3c
+ 6da:	97de                	add	a5,a5,s7
+ 6dc:	0007c583          	lbu	a1,0(a5)
+ 6e0:	855a                	mv	a0,s6
+ 6e2:	d1fff0ef          	jal	400 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 6e6:	0992                	slli	s3,s3,0x4
+ 6e8:	397d                	addiw	s2,s2,-1
+ 6ea:	fe0916e3          	bnez	s2,6d6 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 6ee:	8bea                	mv	s7,s10
+      state = 0;
+ 6f0:	4981                	li	s3,0
+ 6f2:	6d02                	ld	s10,0(sp)
+ 6f4:	bd01                	j	504 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 6f6:	008b8913          	addi	s2,s7,8
+ 6fa:	000bc583          	lbu	a1,0(s7)
+ 6fe:	855a                	mv	a0,s6
+ 700:	d01ff0ef          	jal	400 <putc>
+ 704:	8bca                	mv	s7,s2
+      state = 0;
+ 706:	4981                	li	s3,0
+ 708:	bbf5                	j	504 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 70a:	008b8993          	addi	s3,s7,8
+ 70e:	000bb903          	ld	s2,0(s7)
+ 712:	00090f63          	beqz	s2,730 <vprintf+0x276>
+        for(; *s; s++)
+ 716:	00094583          	lbu	a1,0(s2)
+ 71a:	c195                	beqz	a1,73e <vprintf+0x284>
+          putc(fd, *s);
+ 71c:	855a                	mv	a0,s6
+ 71e:	ce3ff0ef          	jal	400 <putc>
+        for(; *s; s++)
+ 722:	0905                	addi	s2,s2,1
+ 724:	00094583          	lbu	a1,0(s2)
+ 728:	f9f5                	bnez	a1,71c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 72a:	8bce                	mv	s7,s3
+      state = 0;
+ 72c:	4981                	li	s3,0
+ 72e:	bbd9                	j	504 <vprintf+0x4a>
+          s = "(null)";
+ 730:	00000917          	auipc	s2,0x0
+ 734:	2a890913          	addi	s2,s2,680 # 9d8 <malloc+0x19c>
+        for(; *s; s++)
+ 738:	02800593          	li	a1,40
+ 73c:	b7c5                	j	71c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 73e:	8bce                	mv	s7,s3
+      state = 0;
+ 740:	4981                	li	s3,0
+ 742:	b3c9                	j	504 <vprintf+0x4a>
+ 744:	64a6                	ld	s1,72(sp)
+ 746:	79e2                	ld	s3,56(sp)
+ 748:	7a42                	ld	s4,48(sp)
+ 74a:	7aa2                	ld	s5,40(sp)
+ 74c:	7b02                	ld	s6,32(sp)
+ 74e:	6be2                	ld	s7,24(sp)
+ 750:	6c42                	ld	s8,16(sp)
+ 752:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 754:	60e6                	ld	ra,88(sp)
+ 756:	6446                	ld	s0,80(sp)
+ 758:	6906                	ld	s2,64(sp)
+ 75a:	6125                	addi	sp,sp,96
+ 75c:	8082                	ret
+
+000000000000075e <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 75e:	715d                	addi	sp,sp,-80
+ 760:	ec06                	sd	ra,24(sp)
+ 762:	e822                	sd	s0,16(sp)
+ 764:	1000                	addi	s0,sp,32
+ 766:	e010                	sd	a2,0(s0)
+ 768:	e414                	sd	a3,8(s0)
+ 76a:	e818                	sd	a4,16(s0)
+ 76c:	ec1c                	sd	a5,24(s0)
+ 76e:	03043023          	sd	a6,32(s0)
+ 772:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 776:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 77a:	8622                	mv	a2,s0
+ 77c:	d3fff0ef          	jal	4ba <vprintf>
+}
+ 780:	60e2                	ld	ra,24(sp)
+ 782:	6442                	ld	s0,16(sp)
+ 784:	6161                	addi	sp,sp,80
+ 786:	8082                	ret
+
+0000000000000788 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 788:	711d                	addi	sp,sp,-96
+ 78a:	ec06                	sd	ra,24(sp)
+ 78c:	e822                	sd	s0,16(sp)
+ 78e:	1000                	addi	s0,sp,32
+ 790:	e40c                	sd	a1,8(s0)
+ 792:	e810                	sd	a2,16(s0)
+ 794:	ec14                	sd	a3,24(s0)
+ 796:	f018                	sd	a4,32(s0)
+ 798:	f41c                	sd	a5,40(s0)
+ 79a:	03043823          	sd	a6,48(s0)
+ 79e:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7a2:	00840613          	addi	a2,s0,8
+ 7a6:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7aa:	85aa                	mv	a1,a0
+ 7ac:	4505                	li	a0,1
+ 7ae:	d0dff0ef          	jal	4ba <vprintf>
+}
+ 7b2:	60e2                	ld	ra,24(sp)
+ 7b4:	6442                	ld	s0,16(sp)
+ 7b6:	6125                	addi	sp,sp,96
+ 7b8:	8082                	ret
+
+00000000000007ba <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7ba:	1141                	addi	sp,sp,-16
+ 7bc:	e422                	sd	s0,8(sp)
+ 7be:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7c0:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7c4:	00001797          	auipc	a5,0x1
+ 7c8:	83c7b783          	ld	a5,-1988(a5) # 1000 <freep>
+ 7cc:	a02d                	j	7f6 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 7ce:	4618                	lw	a4,8(a2)
+ 7d0:	9f2d                	addw	a4,a4,a1
+ 7d2:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7d6:	6398                	ld	a4,0(a5)
+ 7d8:	6310                	ld	a2,0(a4)
+ 7da:	a83d                	j	818 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 7dc:	ff852703          	lw	a4,-8(a0)
+ 7e0:	9f31                	addw	a4,a4,a2
+ 7e2:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 7e4:	ff053683          	ld	a3,-16(a0)
+ 7e8:	a091                	j	82c <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7ea:	6398                	ld	a4,0(a5)
+ 7ec:	00e7e463          	bltu	a5,a4,7f4 <free+0x3a>
+ 7f0:	00e6ea63          	bltu	a3,a4,804 <free+0x4a>
+{
+ 7f4:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7f6:	fed7fae3          	bgeu	a5,a3,7ea <free+0x30>
+ 7fa:	6398                	ld	a4,0(a5)
+ 7fc:	00e6e463          	bltu	a3,a4,804 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 800:	fee7eae3          	bltu	a5,a4,7f4 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 804:	ff852583          	lw	a1,-8(a0)
+ 808:	6390                	ld	a2,0(a5)
+ 80a:	02059813          	slli	a6,a1,0x20
+ 80e:	01c85713          	srli	a4,a6,0x1c
+ 812:	9736                	add	a4,a4,a3
+ 814:	fae60de3          	beq	a2,a4,7ce <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 818:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 81c:	4790                	lw	a2,8(a5)
+ 81e:	02061593          	slli	a1,a2,0x20
+ 822:	01c5d713          	srli	a4,a1,0x1c
+ 826:	973e                	add	a4,a4,a5
+ 828:	fae68ae3          	beq	a3,a4,7dc <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 82c:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 82e:	00000717          	auipc	a4,0x0
+ 832:	7cf73923          	sd	a5,2002(a4) # 1000 <freep>
+}
+ 836:	6422                	ld	s0,8(sp)
+ 838:	0141                	addi	sp,sp,16
+ 83a:	8082                	ret
+
+000000000000083c <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 83c:	7139                	addi	sp,sp,-64
+ 83e:	fc06                	sd	ra,56(sp)
+ 840:	f822                	sd	s0,48(sp)
+ 842:	f426                	sd	s1,40(sp)
+ 844:	ec4e                	sd	s3,24(sp)
+ 846:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 848:	02051493          	slli	s1,a0,0x20
+ 84c:	9081                	srli	s1,s1,0x20
+ 84e:	04bd                	addi	s1,s1,15
+ 850:	8091                	srli	s1,s1,0x4
+ 852:	0014899b          	addiw	s3,s1,1
+ 856:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 858:	00000517          	auipc	a0,0x0
+ 85c:	7a853503          	ld	a0,1960(a0) # 1000 <freep>
+ 860:	c915                	beqz	a0,894 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 862:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 864:	4798                	lw	a4,8(a5)
+ 866:	08977a63          	bgeu	a4,s1,8fa <malloc+0xbe>
+ 86a:	f04a                	sd	s2,32(sp)
+ 86c:	e852                	sd	s4,16(sp)
+ 86e:	e456                	sd	s5,8(sp)
+ 870:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 872:	8a4e                	mv	s4,s3
+ 874:	0009871b          	sext.w	a4,s3
+ 878:	6685                	lui	a3,0x1
+ 87a:	00d77363          	bgeu	a4,a3,880 <malloc+0x44>
+ 87e:	6a05                	lui	s4,0x1
+ 880:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 884:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 888:	00000917          	auipc	s2,0x0
+ 88c:	77890913          	addi	s2,s2,1912 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 890:	5afd                	li	s5,-1
+ 892:	a081                	j	8d2 <malloc+0x96>
+ 894:	f04a                	sd	s2,32(sp)
+ 896:	e852                	sd	s4,16(sp)
+ 898:	e456                	sd	s5,8(sp)
+ 89a:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 89c:	00001797          	auipc	a5,0x1
+ 8a0:	96c78793          	addi	a5,a5,-1684 # 1208 <base>
+ 8a4:	00000717          	auipc	a4,0x0
+ 8a8:	74f73e23          	sd	a5,1884(a4) # 1000 <freep>
+ 8ac:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8ae:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8b2:	b7c1                	j	872 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8b4:	6398                	ld	a4,0(a5)
+ 8b6:	e118                	sd	a4,0(a0)
+ 8b8:	a8a9                	j	912 <malloc+0xd6>
+  hp->s.size = nu;
+ 8ba:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8be:	0541                	addi	a0,a0,16
+ 8c0:	efbff0ef          	jal	7ba <free>
+  return freep;
+ 8c4:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 8c8:	c12d                	beqz	a0,92a <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8ca:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8cc:	4798                	lw	a4,8(a5)
+ 8ce:	02977263          	bgeu	a4,s1,8f2 <malloc+0xb6>
+    if(p == freep)
+ 8d2:	00093703          	ld	a4,0(s2)
+ 8d6:	853e                	mv	a0,a5
+ 8d8:	fef719e3          	bne	a4,a5,8ca <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 8dc:	8552                	mv	a0,s4
+ 8de:	a47ff0ef          	jal	324 <sbrk>
+  if(p == SBRK_ERROR)
+ 8e2:	fd551ce3          	bne	a0,s5,8ba <malloc+0x7e>
+        return 0;
+ 8e6:	4501                	li	a0,0
+ 8e8:	7902                	ld	s2,32(sp)
+ 8ea:	6a42                	ld	s4,16(sp)
+ 8ec:	6aa2                	ld	s5,8(sp)
+ 8ee:	6b02                	ld	s6,0(sp)
+ 8f0:	a03d                	j	91e <malloc+0xe2>
+ 8f2:	7902                	ld	s2,32(sp)
+ 8f4:	6a42                	ld	s4,16(sp)
+ 8f6:	6aa2                	ld	s5,8(sp)
+ 8f8:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 8fa:	fae48de3          	beq	s1,a4,8b4 <malloc+0x78>
+        p->s.size -= nunits;
+ 8fe:	4137073b          	subw	a4,a4,s3
+ 902:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 904:	02071693          	slli	a3,a4,0x20
+ 908:	01c6d713          	srli	a4,a3,0x1c
+ 90c:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 90e:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 912:	00000717          	auipc	a4,0x0
+ 916:	6ea73723          	sd	a0,1774(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 91a:	01078513          	addi	a0,a5,16
+  }
+}
+ 91e:	70e2                	ld	ra,56(sp)
+ 920:	7442                	ld	s0,48(sp)
+ 922:	74a2                	ld	s1,40(sp)
+ 924:	69e2                	ld	s3,24(sp)
+ 926:	6121                	addi	sp,sp,64
+ 928:	8082                	ret
+ 92a:	7902                	ld	s2,32(sp)
+ 92c:	6a42                	ld	s4,16(sp)
+ 92e:	6aa2                	ld	s5,8(sp)
+ 930:	6b02                	ld	s6,0(sp)
+ 932:	b7f5                	j	91e <malloc+0xe2>
diff -ruN xv6-riscv/user/forphan.d xv62/user/forphan.d
--- xv6-riscv/user/forphan.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/forphan.d	2025-09-14 12:32:52.240883035 +0000
@@ -0,0 +1,2 @@
+user/forphan.o: user/forphan.c kernel/types.h kernel/stat.h \
+ kernel/fcntl.h user/user.h
Binary files xv6-riscv/user/forphan.o and xv62/user/forphan.o differ
diff -ruN xv6-riscv/user/forphan.sym xv62/user/forphan.sym
--- xv6-riscv/user/forphan.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/forphan.sym	2025-09-14 12:32:52.260883031 +0000
@@ -0,0 +1,67 @@
+0000000000000000 .text
+0000000000000938 .rodata
+00000000000009f8 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 forphan.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000400 putc
+000000000000041e printint
+00000000000009e0 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001208 base
+00000000000000d4 strcpy
+00000000000003e8 pause
+0000000000000788 printf
+00000000000003e0 sys_sbrk
+000000000000027e memmove
+00000000000003a0 mknod
+000000000000018c gets
+00000000000003d8 getpid
+0000000000000310 memcpy
+000000000000083c malloc
+000000000000033a sbrklazy
+0000000000000368 pipe
+0000000000000378 write
+00000000000003b0 fstat
+000000000000075e fprintf
+0000000000000388 kill
+00000000000004ba vprintf
+00000000000003c8 chdir
+0000000000000390 exec
+0000000000000360 wait
+0000000000000370 read
+00000000000003a8 unlink
+00000000000002d6 memcmp
+0000000000000350 fork
+0000000000000324 sbrk
+00000000000003f0 uptime
+0000000000000146 memset
+0000000000000000 main
+00000000000000f0 strcmp
+00000000000003d0 dup
+0000000000001010 buf
+00000000000003f8 getreadcount
+00000000000001fc stat
+00000000000003b8 link
+0000000000000358 exit
+00000000000000c4 start
+0000000000000236 atoi
+000000000000011c strlen
+0000000000000398 open
+0000000000000168 strchr
+00000000000003c0 mkdir
+0000000000000380 close
+00000000000007ba free
diff -ruN xv6-riscv/user/grep.asm xv62/user/grep.asm
--- xv6-riscv/user/grep.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grep.asm	2025-09-14 12:32:50.800883331 +0000
@@ -0,0 +1,1764 @@
+
+user/_grep:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <matchstar>:
+  return 0;
+}
+
+// matchstar: search for c*re at beginning of text
+int matchstar(int c, char *re, char *text)
+{
+   0:	7179                	addi	sp,sp,-48
+   2:	f406                	sd	ra,40(sp)
+   4:	f022                	sd	s0,32(sp)
+   6:	ec26                	sd	s1,24(sp)
+   8:	e84a                	sd	s2,16(sp)
+   a:	e44e                	sd	s3,8(sp)
+   c:	e052                	sd	s4,0(sp)
+   e:	1800                	addi	s0,sp,48
+  10:	892a                	mv	s2,a0
+  12:	89ae                	mv	s3,a1
+  14:	84b2                	mv	s1,a2
+  do{  // a * matches zero or more instances
+    if(matchhere(re, text))
+      return 1;
+  }while(*text!='\0' && (*text++==c || c=='.'));
+  16:	02e00a13          	li	s4,46
+    if(matchhere(re, text))
+  1a:	85a6                	mv	a1,s1
+  1c:	854e                	mv	a0,s3
+  1e:	02c000ef          	jal	4a <matchhere>
+  22:	e919                	bnez	a0,38 <matchstar+0x38>
+  }while(*text!='\0' && (*text++==c || c=='.'));
+  24:	0004c783          	lbu	a5,0(s1)
+  28:	cb89                	beqz	a5,3a <matchstar+0x3a>
+  2a:	0485                	addi	s1,s1,1
+  2c:	2781                	sext.w	a5,a5
+  2e:	ff2786e3          	beq	a5,s2,1a <matchstar+0x1a>
+  32:	ff4904e3          	beq	s2,s4,1a <matchstar+0x1a>
+  36:	a011                	j	3a <matchstar+0x3a>
+      return 1;
+  38:	4505                	li	a0,1
+  return 0;
+}
+  3a:	70a2                	ld	ra,40(sp)
+  3c:	7402                	ld	s0,32(sp)
+  3e:	64e2                	ld	s1,24(sp)
+  40:	6942                	ld	s2,16(sp)
+  42:	69a2                	ld	s3,8(sp)
+  44:	6a02                	ld	s4,0(sp)
+  46:	6145                	addi	sp,sp,48
+  48:	8082                	ret
+
+000000000000004a <matchhere>:
+  if(re[0] == '\0')
+  4a:	00054703          	lbu	a4,0(a0)
+  4e:	c73d                	beqz	a4,bc <matchhere+0x72>
+{
+  50:	1141                	addi	sp,sp,-16
+  52:	e406                	sd	ra,8(sp)
+  54:	e022                	sd	s0,0(sp)
+  56:	0800                	addi	s0,sp,16
+  58:	87aa                	mv	a5,a0
+  if(re[1] == '*')
+  5a:	00154683          	lbu	a3,1(a0)
+  5e:	02a00613          	li	a2,42
+  62:	02c68563          	beq	a3,a2,8c <matchhere+0x42>
+  if(re[0] == '$' && re[1] == '\0')
+  66:	02400613          	li	a2,36
+  6a:	02c70863          	beq	a4,a2,9a <matchhere+0x50>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+  6e:	0005c683          	lbu	a3,0(a1)
+  return 0;
+  72:	4501                	li	a0,0
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+  74:	ca81                	beqz	a3,84 <matchhere+0x3a>
+  76:	02e00613          	li	a2,46
+  7a:	02c70b63          	beq	a4,a2,b0 <matchhere+0x66>
+  return 0;
+  7e:	4501                	li	a0,0
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+  80:	02d70863          	beq	a4,a3,b0 <matchhere+0x66>
+}
+  84:	60a2                	ld	ra,8(sp)
+  86:	6402                	ld	s0,0(sp)
+  88:	0141                	addi	sp,sp,16
+  8a:	8082                	ret
+    return matchstar(re[0], re+2, text);
+  8c:	862e                	mv	a2,a1
+  8e:	00250593          	addi	a1,a0,2
+  92:	853a                	mv	a0,a4
+  94:	f6dff0ef          	jal	0 <matchstar>
+  98:	b7f5                	j	84 <matchhere+0x3a>
+  if(re[0] == '$' && re[1] == '\0')
+  9a:	c691                	beqz	a3,a6 <matchhere+0x5c>
+  if(*text!='\0' && (re[0]=='.' || re[0]==*text))
+  9c:	0005c683          	lbu	a3,0(a1)
+  a0:	fef9                	bnez	a3,7e <matchhere+0x34>
+  return 0;
+  a2:	4501                	li	a0,0
+  a4:	b7c5                	j	84 <matchhere+0x3a>
+    return *text == '\0';
+  a6:	0005c503          	lbu	a0,0(a1)
+  aa:	00153513          	seqz	a0,a0
+  ae:	bfd9                	j	84 <matchhere+0x3a>
+    return matchhere(re+1, text+1);
+  b0:	0585                	addi	a1,a1,1
+  b2:	00178513          	addi	a0,a5,1
+  b6:	f95ff0ef          	jal	4a <matchhere>
+  ba:	b7e9                	j	84 <matchhere+0x3a>
+    return 1;
+  bc:	4505                	li	a0,1
+}
+  be:	8082                	ret
+
+00000000000000c0 <match>:
+{
+  c0:	1101                	addi	sp,sp,-32
+  c2:	ec06                	sd	ra,24(sp)
+  c4:	e822                	sd	s0,16(sp)
+  c6:	e426                	sd	s1,8(sp)
+  c8:	e04a                	sd	s2,0(sp)
+  ca:	1000                	addi	s0,sp,32
+  cc:	892a                	mv	s2,a0
+  ce:	84ae                	mv	s1,a1
+  if(re[0] == '^')
+  d0:	00054703          	lbu	a4,0(a0)
+  d4:	05e00793          	li	a5,94
+  d8:	00f70c63          	beq	a4,a5,f0 <match+0x30>
+    if(matchhere(re, text))
+  dc:	85a6                	mv	a1,s1
+  de:	854a                	mv	a0,s2
+  e0:	f6bff0ef          	jal	4a <matchhere>
+  e4:	e911                	bnez	a0,f8 <match+0x38>
+  }while(*text++ != '\0');
+  e6:	0485                	addi	s1,s1,1
+  e8:	fff4c783          	lbu	a5,-1(s1)
+  ec:	fbe5                	bnez	a5,dc <match+0x1c>
+  ee:	a031                	j	fa <match+0x3a>
+    return matchhere(re+1, text);
+  f0:	0505                	addi	a0,a0,1
+  f2:	f59ff0ef          	jal	4a <matchhere>
+  f6:	a011                	j	fa <match+0x3a>
+      return 1;
+  f8:	4505                	li	a0,1
+}
+  fa:	60e2                	ld	ra,24(sp)
+  fc:	6442                	ld	s0,16(sp)
+  fe:	64a2                	ld	s1,8(sp)
+ 100:	6902                	ld	s2,0(sp)
+ 102:	6105                	addi	sp,sp,32
+ 104:	8082                	ret
+
+0000000000000106 <grep>:
+{
+ 106:	715d                	addi	sp,sp,-80
+ 108:	e486                	sd	ra,72(sp)
+ 10a:	e0a2                	sd	s0,64(sp)
+ 10c:	fc26                	sd	s1,56(sp)
+ 10e:	f84a                	sd	s2,48(sp)
+ 110:	f44e                	sd	s3,40(sp)
+ 112:	f052                	sd	s4,32(sp)
+ 114:	ec56                	sd	s5,24(sp)
+ 116:	e85a                	sd	s6,16(sp)
+ 118:	e45e                	sd	s7,8(sp)
+ 11a:	e062                	sd	s8,0(sp)
+ 11c:	0880                	addi	s0,sp,80
+ 11e:	89aa                	mv	s3,a0
+ 120:	8b2e                	mv	s6,a1
+  m = 0;
+ 122:	4a01                	li	s4,0
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+ 124:	3ff00b93          	li	s7,1023
+ 128:	00002a97          	auipc	s5,0x2
+ 12c:	ee8a8a93          	addi	s5,s5,-280 # 2010 <buf>
+ 130:	a835                	j	16c <grep+0x66>
+      p = q+1;
+ 132:	00148913          	addi	s2,s1,1
+    while((q = strchr(p, '\n')) != 0){
+ 136:	45a9                	li	a1,10
+ 138:	854a                	mv	a0,s2
+ 13a:	1c4000ef          	jal	2fe <strchr>
+ 13e:	84aa                	mv	s1,a0
+ 140:	c505                	beqz	a0,168 <grep+0x62>
+      *q = 0;
+ 142:	00048023          	sb	zero,0(s1)
+      if(match(pattern, p)){
+ 146:	85ca                	mv	a1,s2
+ 148:	854e                	mv	a0,s3
+ 14a:	f77ff0ef          	jal	c0 <match>
+ 14e:	d175                	beqz	a0,132 <grep+0x2c>
+        *q = '\n';
+ 150:	47a9                	li	a5,10
+ 152:	00f48023          	sb	a5,0(s1)
+        write(1, p, q+1 - p);
+ 156:	00148613          	addi	a2,s1,1
+ 15a:	4126063b          	subw	a2,a2,s2
+ 15e:	85ca                	mv	a1,s2
+ 160:	4505                	li	a0,1
+ 162:	3ac000ef          	jal	50e <write>
+ 166:	b7f1                	j	132 <grep+0x2c>
+    if(m > 0){
+ 168:	03404563          	bgtz	s4,192 <grep+0x8c>
+  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
+ 16c:	414b863b          	subw	a2,s7,s4
+ 170:	014a85b3          	add	a1,s5,s4
+ 174:	855a                	mv	a0,s6
+ 176:	390000ef          	jal	506 <read>
+ 17a:	02a05963          	blez	a0,1ac <grep+0xa6>
+    m += n;
+ 17e:	00aa0c3b          	addw	s8,s4,a0
+ 182:	000c0a1b          	sext.w	s4,s8
+    buf[m] = '\0';
+ 186:	014a87b3          	add	a5,s5,s4
+ 18a:	00078023          	sb	zero,0(a5)
+    p = buf;
+ 18e:	8956                	mv	s2,s5
+    while((q = strchr(p, '\n')) != 0){
+ 190:	b75d                	j	136 <grep+0x30>
+      m -= p - buf;
+ 192:	00002517          	auipc	a0,0x2
+ 196:	e7e50513          	addi	a0,a0,-386 # 2010 <buf>
+ 19a:	40a90a33          	sub	s4,s2,a0
+ 19e:	414c0a3b          	subw	s4,s8,s4
+      memmove(buf, p, m);
+ 1a2:	8652                	mv	a2,s4
+ 1a4:	85ca                	mv	a1,s2
+ 1a6:	26e000ef          	jal	414 <memmove>
+ 1aa:	b7c9                	j	16c <grep+0x66>
+}
+ 1ac:	60a6                	ld	ra,72(sp)
+ 1ae:	6406                	ld	s0,64(sp)
+ 1b0:	74e2                	ld	s1,56(sp)
+ 1b2:	7942                	ld	s2,48(sp)
+ 1b4:	79a2                	ld	s3,40(sp)
+ 1b6:	7a02                	ld	s4,32(sp)
+ 1b8:	6ae2                	ld	s5,24(sp)
+ 1ba:	6b42                	ld	s6,16(sp)
+ 1bc:	6ba2                	ld	s7,8(sp)
+ 1be:	6c02                	ld	s8,0(sp)
+ 1c0:	6161                	addi	sp,sp,80
+ 1c2:	8082                	ret
+
+00000000000001c4 <main>:
+{
+ 1c4:	7179                	addi	sp,sp,-48
+ 1c6:	f406                	sd	ra,40(sp)
+ 1c8:	f022                	sd	s0,32(sp)
+ 1ca:	ec26                	sd	s1,24(sp)
+ 1cc:	e84a                	sd	s2,16(sp)
+ 1ce:	e44e                	sd	s3,8(sp)
+ 1d0:	e052                	sd	s4,0(sp)
+ 1d2:	1800                	addi	s0,sp,48
+  if(argc <= 1){
+ 1d4:	4785                	li	a5,1
+ 1d6:	04a7d663          	bge	a5,a0,222 <main+0x5e>
+  pattern = argv[1];
+ 1da:	0085ba03          	ld	s4,8(a1)
+  if(argc <= 2){
+ 1de:	4789                	li	a5,2
+ 1e0:	04a7db63          	bge	a5,a0,236 <main+0x72>
+ 1e4:	01058913          	addi	s2,a1,16
+ 1e8:	ffd5099b          	addiw	s3,a0,-3
+ 1ec:	02099793          	slli	a5,s3,0x20
+ 1f0:	01d7d993          	srli	s3,a5,0x1d
+ 1f4:	05e1                	addi	a1,a1,24
+ 1f6:	99ae                	add	s3,s3,a1
+    if((fd = open(argv[i], O_RDONLY)) < 0){
+ 1f8:	4581                	li	a1,0
+ 1fa:	00093503          	ld	a0,0(s2)
+ 1fe:	330000ef          	jal	52e <open>
+ 202:	84aa                	mv	s1,a0
+ 204:	04054063          	bltz	a0,244 <main+0x80>
+    grep(pattern, fd);
+ 208:	85aa                	mv	a1,a0
+ 20a:	8552                	mv	a0,s4
+ 20c:	efbff0ef          	jal	106 <grep>
+    close(fd);
+ 210:	8526                	mv	a0,s1
+ 212:	304000ef          	jal	516 <close>
+  for(i = 2; i < argc; i++){
+ 216:	0921                	addi	s2,s2,8
+ 218:	ff3910e3          	bne	s2,s3,1f8 <main+0x34>
+  exit(0);
+ 21c:	4501                	li	a0,0
+ 21e:	2d0000ef          	jal	4ee <exit>
+    fprintf(2, "usage: grep pattern [file ...]\n");
+ 222:	00001597          	auipc	a1,0x1
+ 226:	8ae58593          	addi	a1,a1,-1874 # ad0 <malloc+0xfe>
+ 22a:	4509                	li	a0,2
+ 22c:	6c8000ef          	jal	8f4 <fprintf>
+    exit(1);
+ 230:	4505                	li	a0,1
+ 232:	2bc000ef          	jal	4ee <exit>
+    grep(pattern, 0);
+ 236:	4581                	li	a1,0
+ 238:	8552                	mv	a0,s4
+ 23a:	ecdff0ef          	jal	106 <grep>
+    exit(0);
+ 23e:	4501                	li	a0,0
+ 240:	2ae000ef          	jal	4ee <exit>
+      printf("grep: cannot open %s\n", argv[i]);
+ 244:	00093583          	ld	a1,0(s2)
+ 248:	00001517          	auipc	a0,0x1
+ 24c:	8a850513          	addi	a0,a0,-1880 # af0 <malloc+0x11e>
+ 250:	6ce000ef          	jal	91e <printf>
+      exit(1);
+ 254:	4505                	li	a0,1
+ 256:	298000ef          	jal	4ee <exit>
+
+000000000000025a <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+ 25a:	1141                	addi	sp,sp,-16
+ 25c:	e406                	sd	ra,8(sp)
+ 25e:	e022                	sd	s0,0(sp)
+ 260:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+ 262:	f63ff0ef          	jal	1c4 <main>
+  exit(r);
+ 266:	288000ef          	jal	4ee <exit>
+
+000000000000026a <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+ 26a:	1141                	addi	sp,sp,-16
+ 26c:	e422                	sd	s0,8(sp)
+ 26e:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 270:	87aa                	mv	a5,a0
+ 272:	0585                	addi	a1,a1,1
+ 274:	0785                	addi	a5,a5,1
+ 276:	fff5c703          	lbu	a4,-1(a1)
+ 27a:	fee78fa3          	sb	a4,-1(a5)
+ 27e:	fb75                	bnez	a4,272 <strcpy+0x8>
+    ;
+  return os;
+}
+ 280:	6422                	ld	s0,8(sp)
+ 282:	0141                	addi	sp,sp,16
+ 284:	8082                	ret
+
+0000000000000286 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 286:	1141                	addi	sp,sp,-16
+ 288:	e422                	sd	s0,8(sp)
+ 28a:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 28c:	00054783          	lbu	a5,0(a0)
+ 290:	cb91                	beqz	a5,2a4 <strcmp+0x1e>
+ 292:	0005c703          	lbu	a4,0(a1)
+ 296:	00f71763          	bne	a4,a5,2a4 <strcmp+0x1e>
+    p++, q++;
+ 29a:	0505                	addi	a0,a0,1
+ 29c:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 29e:	00054783          	lbu	a5,0(a0)
+ 2a2:	fbe5                	bnez	a5,292 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 2a4:	0005c503          	lbu	a0,0(a1)
+}
+ 2a8:	40a7853b          	subw	a0,a5,a0
+ 2ac:	6422                	ld	s0,8(sp)
+ 2ae:	0141                	addi	sp,sp,16
+ 2b0:	8082                	ret
+
+00000000000002b2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 2b2:	1141                	addi	sp,sp,-16
+ 2b4:	e422                	sd	s0,8(sp)
+ 2b6:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 2b8:	00054783          	lbu	a5,0(a0)
+ 2bc:	cf91                	beqz	a5,2d8 <strlen+0x26>
+ 2be:	0505                	addi	a0,a0,1
+ 2c0:	87aa                	mv	a5,a0
+ 2c2:	86be                	mv	a3,a5
+ 2c4:	0785                	addi	a5,a5,1
+ 2c6:	fff7c703          	lbu	a4,-1(a5)
+ 2ca:	ff65                	bnez	a4,2c2 <strlen+0x10>
+ 2cc:	40a6853b          	subw	a0,a3,a0
+ 2d0:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 2d2:	6422                	ld	s0,8(sp)
+ 2d4:	0141                	addi	sp,sp,16
+ 2d6:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 2d8:	4501                	li	a0,0
+ 2da:	bfe5                	j	2d2 <strlen+0x20>
+
+00000000000002dc <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 2dc:	1141                	addi	sp,sp,-16
+ 2de:	e422                	sd	s0,8(sp)
+ 2e0:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 2e2:	ca19                	beqz	a2,2f8 <memset+0x1c>
+ 2e4:	87aa                	mv	a5,a0
+ 2e6:	1602                	slli	a2,a2,0x20
+ 2e8:	9201                	srli	a2,a2,0x20
+ 2ea:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 2ee:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 2f2:	0785                	addi	a5,a5,1
+ 2f4:	fee79de3          	bne	a5,a4,2ee <memset+0x12>
+  }
+  return dst;
+}
+ 2f8:	6422                	ld	s0,8(sp)
+ 2fa:	0141                	addi	sp,sp,16
+ 2fc:	8082                	ret
+
+00000000000002fe <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 2fe:	1141                	addi	sp,sp,-16
+ 300:	e422                	sd	s0,8(sp)
+ 302:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 304:	00054783          	lbu	a5,0(a0)
+ 308:	cb99                	beqz	a5,31e <strchr+0x20>
+    if(*s == c)
+ 30a:	00f58763          	beq	a1,a5,318 <strchr+0x1a>
+  for(; *s; s++)
+ 30e:	0505                	addi	a0,a0,1
+ 310:	00054783          	lbu	a5,0(a0)
+ 314:	fbfd                	bnez	a5,30a <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 316:	4501                	li	a0,0
+}
+ 318:	6422                	ld	s0,8(sp)
+ 31a:	0141                	addi	sp,sp,16
+ 31c:	8082                	ret
+  return 0;
+ 31e:	4501                	li	a0,0
+ 320:	bfe5                	j	318 <strchr+0x1a>
+
+0000000000000322 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 322:	711d                	addi	sp,sp,-96
+ 324:	ec86                	sd	ra,88(sp)
+ 326:	e8a2                	sd	s0,80(sp)
+ 328:	e4a6                	sd	s1,72(sp)
+ 32a:	e0ca                	sd	s2,64(sp)
+ 32c:	fc4e                	sd	s3,56(sp)
+ 32e:	f852                	sd	s4,48(sp)
+ 330:	f456                	sd	s5,40(sp)
+ 332:	f05a                	sd	s6,32(sp)
+ 334:	ec5e                	sd	s7,24(sp)
+ 336:	1080                	addi	s0,sp,96
+ 338:	8baa                	mv	s7,a0
+ 33a:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 33c:	892a                	mv	s2,a0
+ 33e:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 340:	4aa9                	li	s5,10
+ 342:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 344:	89a6                	mv	s3,s1
+ 346:	2485                	addiw	s1,s1,1
+ 348:	0344d663          	bge	s1,s4,374 <gets+0x52>
+    cc = read(0, &c, 1);
+ 34c:	4605                	li	a2,1
+ 34e:	faf40593          	addi	a1,s0,-81
+ 352:	4501                	li	a0,0
+ 354:	1b2000ef          	jal	506 <read>
+    if(cc < 1)
+ 358:	00a05e63          	blez	a0,374 <gets+0x52>
+    buf[i++] = c;
+ 35c:	faf44783          	lbu	a5,-81(s0)
+ 360:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 364:	01578763          	beq	a5,s5,372 <gets+0x50>
+ 368:	0905                	addi	s2,s2,1
+ 36a:	fd679de3          	bne	a5,s6,344 <gets+0x22>
+    buf[i++] = c;
+ 36e:	89a6                	mv	s3,s1
+ 370:	a011                	j	374 <gets+0x52>
+ 372:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 374:	99de                	add	s3,s3,s7
+ 376:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 37a:	855e                	mv	a0,s7
+ 37c:	60e6                	ld	ra,88(sp)
+ 37e:	6446                	ld	s0,80(sp)
+ 380:	64a6                	ld	s1,72(sp)
+ 382:	6906                	ld	s2,64(sp)
+ 384:	79e2                	ld	s3,56(sp)
+ 386:	7a42                	ld	s4,48(sp)
+ 388:	7aa2                	ld	s5,40(sp)
+ 38a:	7b02                	ld	s6,32(sp)
+ 38c:	6be2                	ld	s7,24(sp)
+ 38e:	6125                	addi	sp,sp,96
+ 390:	8082                	ret
+
+0000000000000392 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 392:	1101                	addi	sp,sp,-32
+ 394:	ec06                	sd	ra,24(sp)
+ 396:	e822                	sd	s0,16(sp)
+ 398:	e04a                	sd	s2,0(sp)
+ 39a:	1000                	addi	s0,sp,32
+ 39c:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 39e:	4581                	li	a1,0
+ 3a0:	18e000ef          	jal	52e <open>
+  if(fd < 0)
+ 3a4:	02054263          	bltz	a0,3c8 <stat+0x36>
+ 3a8:	e426                	sd	s1,8(sp)
+ 3aa:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 3ac:	85ca                	mv	a1,s2
+ 3ae:	198000ef          	jal	546 <fstat>
+ 3b2:	892a                	mv	s2,a0
+  close(fd);
+ 3b4:	8526                	mv	a0,s1
+ 3b6:	160000ef          	jal	516 <close>
+  return r;
+ 3ba:	64a2                	ld	s1,8(sp)
+}
+ 3bc:	854a                	mv	a0,s2
+ 3be:	60e2                	ld	ra,24(sp)
+ 3c0:	6442                	ld	s0,16(sp)
+ 3c2:	6902                	ld	s2,0(sp)
+ 3c4:	6105                	addi	sp,sp,32
+ 3c6:	8082                	ret
+    return -1;
+ 3c8:	597d                	li	s2,-1
+ 3ca:	bfcd                	j	3bc <stat+0x2a>
+
+00000000000003cc <atoi>:
+
+int
+atoi(const char *s)
+{
+ 3cc:	1141                	addi	sp,sp,-16
+ 3ce:	e422                	sd	s0,8(sp)
+ 3d0:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 3d2:	00054683          	lbu	a3,0(a0)
+ 3d6:	fd06879b          	addiw	a5,a3,-48
+ 3da:	0ff7f793          	zext.b	a5,a5
+ 3de:	4625                	li	a2,9
+ 3e0:	02f66863          	bltu	a2,a5,410 <atoi+0x44>
+ 3e4:	872a                	mv	a4,a0
+  n = 0;
+ 3e6:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 3e8:	0705                	addi	a4,a4,1
+ 3ea:	0025179b          	slliw	a5,a0,0x2
+ 3ee:	9fa9                	addw	a5,a5,a0
+ 3f0:	0017979b          	slliw	a5,a5,0x1
+ 3f4:	9fb5                	addw	a5,a5,a3
+ 3f6:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 3fa:	00074683          	lbu	a3,0(a4)
+ 3fe:	fd06879b          	addiw	a5,a3,-48
+ 402:	0ff7f793          	zext.b	a5,a5
+ 406:	fef671e3          	bgeu	a2,a5,3e8 <atoi+0x1c>
+  return n;
+}
+ 40a:	6422                	ld	s0,8(sp)
+ 40c:	0141                	addi	sp,sp,16
+ 40e:	8082                	ret
+  n = 0;
+ 410:	4501                	li	a0,0
+ 412:	bfe5                	j	40a <atoi+0x3e>
+
+0000000000000414 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 414:	1141                	addi	sp,sp,-16
+ 416:	e422                	sd	s0,8(sp)
+ 418:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 41a:	02b57463          	bgeu	a0,a1,442 <memmove+0x2e>
+    while(n-- > 0)
+ 41e:	00c05f63          	blez	a2,43c <memmove+0x28>
+ 422:	1602                	slli	a2,a2,0x20
+ 424:	9201                	srli	a2,a2,0x20
+ 426:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 42a:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 42c:	0585                	addi	a1,a1,1
+ 42e:	0705                	addi	a4,a4,1
+ 430:	fff5c683          	lbu	a3,-1(a1)
+ 434:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 438:	fef71ae3          	bne	a4,a5,42c <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 43c:	6422                	ld	s0,8(sp)
+ 43e:	0141                	addi	sp,sp,16
+ 440:	8082                	ret
+    dst += n;
+ 442:	00c50733          	add	a4,a0,a2
+    src += n;
+ 446:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 448:	fec05ae3          	blez	a2,43c <memmove+0x28>
+ 44c:	fff6079b          	addiw	a5,a2,-1
+ 450:	1782                	slli	a5,a5,0x20
+ 452:	9381                	srli	a5,a5,0x20
+ 454:	fff7c793          	not	a5,a5
+ 458:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 45a:	15fd                	addi	a1,a1,-1
+ 45c:	177d                	addi	a4,a4,-1
+ 45e:	0005c683          	lbu	a3,0(a1)
+ 462:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 466:	fee79ae3          	bne	a5,a4,45a <memmove+0x46>
+ 46a:	bfc9                	j	43c <memmove+0x28>
+
+000000000000046c <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 46c:	1141                	addi	sp,sp,-16
+ 46e:	e422                	sd	s0,8(sp)
+ 470:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 472:	ca05                	beqz	a2,4a2 <memcmp+0x36>
+ 474:	fff6069b          	addiw	a3,a2,-1
+ 478:	1682                	slli	a3,a3,0x20
+ 47a:	9281                	srli	a3,a3,0x20
+ 47c:	0685                	addi	a3,a3,1
+ 47e:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 480:	00054783          	lbu	a5,0(a0)
+ 484:	0005c703          	lbu	a4,0(a1)
+ 488:	00e79863          	bne	a5,a4,498 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 48c:	0505                	addi	a0,a0,1
+    p2++;
+ 48e:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 490:	fed518e3          	bne	a0,a3,480 <memcmp+0x14>
+  }
+  return 0;
+ 494:	4501                	li	a0,0
+ 496:	a019                	j	49c <memcmp+0x30>
+      return *p1 - *p2;
+ 498:	40e7853b          	subw	a0,a5,a4
+}
+ 49c:	6422                	ld	s0,8(sp)
+ 49e:	0141                	addi	sp,sp,16
+ 4a0:	8082                	ret
+  return 0;
+ 4a2:	4501                	li	a0,0
+ 4a4:	bfe5                	j	49c <memcmp+0x30>
+
+00000000000004a6 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 4a6:	1141                	addi	sp,sp,-16
+ 4a8:	e406                	sd	ra,8(sp)
+ 4aa:	e022                	sd	s0,0(sp)
+ 4ac:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 4ae:	f67ff0ef          	jal	414 <memmove>
+}
+ 4b2:	60a2                	ld	ra,8(sp)
+ 4b4:	6402                	ld	s0,0(sp)
+ 4b6:	0141                	addi	sp,sp,16
+ 4b8:	8082                	ret
+
+00000000000004ba <sbrk>:
+
+char *
+sbrk(int n) {
+ 4ba:	1141                	addi	sp,sp,-16
+ 4bc:	e406                	sd	ra,8(sp)
+ 4be:	e022                	sd	s0,0(sp)
+ 4c0:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 4c2:	4585                	li	a1,1
+ 4c4:	0b2000ef          	jal	576 <sys_sbrk>
+}
+ 4c8:	60a2                	ld	ra,8(sp)
+ 4ca:	6402                	ld	s0,0(sp)
+ 4cc:	0141                	addi	sp,sp,16
+ 4ce:	8082                	ret
+
+00000000000004d0 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 4d0:	1141                	addi	sp,sp,-16
+ 4d2:	e406                	sd	ra,8(sp)
+ 4d4:	e022                	sd	s0,0(sp)
+ 4d6:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 4d8:	4589                	li	a1,2
+ 4da:	09c000ef          	jal	576 <sys_sbrk>
+}
+ 4de:	60a2                	ld	ra,8(sp)
+ 4e0:	6402                	ld	s0,0(sp)
+ 4e2:	0141                	addi	sp,sp,16
+ 4e4:	8082                	ret
+
+00000000000004e6 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 4e6:	4885                	li	a7,1
+ ecall
+ 4e8:	00000073          	ecall
+ ret
+ 4ec:	8082                	ret
+
+00000000000004ee <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 4ee:	4889                	li	a7,2
+ ecall
+ 4f0:	00000073          	ecall
+ ret
+ 4f4:	8082                	ret
+
+00000000000004f6 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 4f6:	488d                	li	a7,3
+ ecall
+ 4f8:	00000073          	ecall
+ ret
+ 4fc:	8082                	ret
+
+00000000000004fe <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 4fe:	4891                	li	a7,4
+ ecall
+ 500:	00000073          	ecall
+ ret
+ 504:	8082                	ret
+
+0000000000000506 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 506:	4895                	li	a7,5
+ ecall
+ 508:	00000073          	ecall
+ ret
+ 50c:	8082                	ret
+
+000000000000050e <write>:
+.global write
+write:
+ li a7, SYS_write
+ 50e:	48c1                	li	a7,16
+ ecall
+ 510:	00000073          	ecall
+ ret
+ 514:	8082                	ret
+
+0000000000000516 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 516:	48d5                	li	a7,21
+ ecall
+ 518:	00000073          	ecall
+ ret
+ 51c:	8082                	ret
+
+000000000000051e <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 51e:	4899                	li	a7,6
+ ecall
+ 520:	00000073          	ecall
+ ret
+ 524:	8082                	ret
+
+0000000000000526 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 526:	489d                	li	a7,7
+ ecall
+ 528:	00000073          	ecall
+ ret
+ 52c:	8082                	ret
+
+000000000000052e <open>:
+.global open
+open:
+ li a7, SYS_open
+ 52e:	48bd                	li	a7,15
+ ecall
+ 530:	00000073          	ecall
+ ret
+ 534:	8082                	ret
+
+0000000000000536 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 536:	48c5                	li	a7,17
+ ecall
+ 538:	00000073          	ecall
+ ret
+ 53c:	8082                	ret
+
+000000000000053e <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 53e:	48c9                	li	a7,18
+ ecall
+ 540:	00000073          	ecall
+ ret
+ 544:	8082                	ret
+
+0000000000000546 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 546:	48a1                	li	a7,8
+ ecall
+ 548:	00000073          	ecall
+ ret
+ 54c:	8082                	ret
+
+000000000000054e <link>:
+.global link
+link:
+ li a7, SYS_link
+ 54e:	48cd                	li	a7,19
+ ecall
+ 550:	00000073          	ecall
+ ret
+ 554:	8082                	ret
+
+0000000000000556 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 556:	48d1                	li	a7,20
+ ecall
+ 558:	00000073          	ecall
+ ret
+ 55c:	8082                	ret
+
+000000000000055e <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 55e:	48a5                	li	a7,9
+ ecall
+ 560:	00000073          	ecall
+ ret
+ 564:	8082                	ret
+
+0000000000000566 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 566:	48a9                	li	a7,10
+ ecall
+ 568:	00000073          	ecall
+ ret
+ 56c:	8082                	ret
+
+000000000000056e <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 56e:	48ad                	li	a7,11
+ ecall
+ 570:	00000073          	ecall
+ ret
+ 574:	8082                	ret
+
+0000000000000576 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 576:	48b1                	li	a7,12
+ ecall
+ 578:	00000073          	ecall
+ ret
+ 57c:	8082                	ret
+
+000000000000057e <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 57e:	48b5                	li	a7,13
+ ecall
+ 580:	00000073          	ecall
+ ret
+ 584:	8082                	ret
+
+0000000000000586 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 586:	48b9                	li	a7,14
+ ecall
+ 588:	00000073          	ecall
+ ret
+ 58c:	8082                	ret
+
+000000000000058e <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 58e:	48d9                	li	a7,22
+ ecall
+ 590:	00000073          	ecall
+ ret
+ 594:	8082                	ret
+
+0000000000000596 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 596:	1101                	addi	sp,sp,-32
+ 598:	ec06                	sd	ra,24(sp)
+ 59a:	e822                	sd	s0,16(sp)
+ 59c:	1000                	addi	s0,sp,32
+ 59e:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 5a2:	4605                	li	a2,1
+ 5a4:	fef40593          	addi	a1,s0,-17
+ 5a8:	f67ff0ef          	jal	50e <write>
+}
+ 5ac:	60e2                	ld	ra,24(sp)
+ 5ae:	6442                	ld	s0,16(sp)
+ 5b0:	6105                	addi	sp,sp,32
+ 5b2:	8082                	ret
+
+00000000000005b4 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 5b4:	715d                	addi	sp,sp,-80
+ 5b6:	e486                	sd	ra,72(sp)
+ 5b8:	e0a2                	sd	s0,64(sp)
+ 5ba:	f84a                	sd	s2,48(sp)
+ 5bc:	0880                	addi	s0,sp,80
+ 5be:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 5c0:	c299                	beqz	a3,5c6 <printint+0x12>
+ 5c2:	0805c363          	bltz	a1,648 <printint+0x94>
+  neg = 0;
+ 5c6:	4881                	li	a7,0
+ 5c8:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 5cc:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 5ce:	00000517          	auipc	a0,0x0
+ 5d2:	54250513          	addi	a0,a0,1346 # b10 <digits>
+ 5d6:	883e                	mv	a6,a5
+ 5d8:	2785                	addiw	a5,a5,1
+ 5da:	02c5f733          	remu	a4,a1,a2
+ 5de:	972a                	add	a4,a4,a0
+ 5e0:	00074703          	lbu	a4,0(a4)
+ 5e4:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 5e8:	872e                	mv	a4,a1
+ 5ea:	02c5d5b3          	divu	a1,a1,a2
+ 5ee:	0685                	addi	a3,a3,1
+ 5f0:	fec773e3          	bgeu	a4,a2,5d6 <printint+0x22>
+  if(neg)
+ 5f4:	00088b63          	beqz	a7,60a <printint+0x56>
+    buf[i++] = '-';
+ 5f8:	fd078793          	addi	a5,a5,-48
+ 5fc:	97a2                	add	a5,a5,s0
+ 5fe:	02d00713          	li	a4,45
+ 602:	fee78423          	sb	a4,-24(a5)
+ 606:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 60a:	02f05a63          	blez	a5,63e <printint+0x8a>
+ 60e:	fc26                	sd	s1,56(sp)
+ 610:	f44e                	sd	s3,40(sp)
+ 612:	fb840713          	addi	a4,s0,-72
+ 616:	00f704b3          	add	s1,a4,a5
+ 61a:	fff70993          	addi	s3,a4,-1
+ 61e:	99be                	add	s3,s3,a5
+ 620:	37fd                	addiw	a5,a5,-1
+ 622:	1782                	slli	a5,a5,0x20
+ 624:	9381                	srli	a5,a5,0x20
+ 626:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 62a:	fff4c583          	lbu	a1,-1(s1)
+ 62e:	854a                	mv	a0,s2
+ 630:	f67ff0ef          	jal	596 <putc>
+  while(--i >= 0)
+ 634:	14fd                	addi	s1,s1,-1
+ 636:	ff349ae3          	bne	s1,s3,62a <printint+0x76>
+ 63a:	74e2                	ld	s1,56(sp)
+ 63c:	79a2                	ld	s3,40(sp)
+}
+ 63e:	60a6                	ld	ra,72(sp)
+ 640:	6406                	ld	s0,64(sp)
+ 642:	7942                	ld	s2,48(sp)
+ 644:	6161                	addi	sp,sp,80
+ 646:	8082                	ret
+    x = -xx;
+ 648:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 64c:	4885                	li	a7,1
+    x = -xx;
+ 64e:	bfad                	j	5c8 <printint+0x14>
+
+0000000000000650 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 650:	711d                	addi	sp,sp,-96
+ 652:	ec86                	sd	ra,88(sp)
+ 654:	e8a2                	sd	s0,80(sp)
+ 656:	e0ca                	sd	s2,64(sp)
+ 658:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 65a:	0005c903          	lbu	s2,0(a1)
+ 65e:	28090663          	beqz	s2,8ea <vprintf+0x29a>
+ 662:	e4a6                	sd	s1,72(sp)
+ 664:	fc4e                	sd	s3,56(sp)
+ 666:	f852                	sd	s4,48(sp)
+ 668:	f456                	sd	s5,40(sp)
+ 66a:	f05a                	sd	s6,32(sp)
+ 66c:	ec5e                	sd	s7,24(sp)
+ 66e:	e862                	sd	s8,16(sp)
+ 670:	e466                	sd	s9,8(sp)
+ 672:	8b2a                	mv	s6,a0
+ 674:	8a2e                	mv	s4,a1
+ 676:	8bb2                	mv	s7,a2
+  state = 0;
+ 678:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 67a:	4481                	li	s1,0
+ 67c:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 67e:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 682:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 686:	06c00c93          	li	s9,108
+ 68a:	a005                	j	6aa <vprintf+0x5a>
+        putc(fd, c0);
+ 68c:	85ca                	mv	a1,s2
+ 68e:	855a                	mv	a0,s6
+ 690:	f07ff0ef          	jal	596 <putc>
+ 694:	a019                	j	69a <vprintf+0x4a>
+    } else if(state == '%'){
+ 696:	03598263          	beq	s3,s5,6ba <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 69a:	2485                	addiw	s1,s1,1
+ 69c:	8726                	mv	a4,s1
+ 69e:	009a07b3          	add	a5,s4,s1
+ 6a2:	0007c903          	lbu	s2,0(a5)
+ 6a6:	22090a63          	beqz	s2,8da <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 6aa:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 6ae:	fe0994e3          	bnez	s3,696 <vprintf+0x46>
+      if(c0 == '%'){
+ 6b2:	fd579de3          	bne	a5,s5,68c <vprintf+0x3c>
+        state = '%';
+ 6b6:	89be                	mv	s3,a5
+ 6b8:	b7cd                	j	69a <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 6ba:	00ea06b3          	add	a3,s4,a4
+ 6be:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 6c2:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 6c4:	c681                	beqz	a3,6cc <vprintf+0x7c>
+ 6c6:	9752                	add	a4,a4,s4
+ 6c8:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 6cc:	05878363          	beq	a5,s8,712 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 6d0:	05978d63          	beq	a5,s9,72a <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 6d4:	07500713          	li	a4,117
+ 6d8:	0ee78763          	beq	a5,a4,7c6 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 6dc:	07800713          	li	a4,120
+ 6e0:	12e78963          	beq	a5,a4,812 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 6e4:	07000713          	li	a4,112
+ 6e8:	14e78e63          	beq	a5,a4,844 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 6ec:	06300713          	li	a4,99
+ 6f0:	18e78e63          	beq	a5,a4,88c <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 6f4:	07300713          	li	a4,115
+ 6f8:	1ae78463          	beq	a5,a4,8a0 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 6fc:	02500713          	li	a4,37
+ 700:	04e79563          	bne	a5,a4,74a <vprintf+0xfa>
+        putc(fd, '%');
+ 704:	02500593          	li	a1,37
+ 708:	855a                	mv	a0,s6
+ 70a:	e8dff0ef          	jal	596 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 70e:	4981                	li	s3,0
+ 710:	b769                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 712:	008b8913          	addi	s2,s7,8
+ 716:	4685                	li	a3,1
+ 718:	4629                	li	a2,10
+ 71a:	000ba583          	lw	a1,0(s7)
+ 71e:	855a                	mv	a0,s6
+ 720:	e95ff0ef          	jal	5b4 <printint>
+ 724:	8bca                	mv	s7,s2
+      state = 0;
+ 726:	4981                	li	s3,0
+ 728:	bf8d                	j	69a <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 72a:	06400793          	li	a5,100
+ 72e:	02f68963          	beq	a3,a5,760 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 732:	06c00793          	li	a5,108
+ 736:	04f68263          	beq	a3,a5,77a <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 73a:	07500793          	li	a5,117
+ 73e:	0af68063          	beq	a3,a5,7de <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 742:	07800793          	li	a5,120
+ 746:	0ef68263          	beq	a3,a5,82a <vprintf+0x1da>
+        putc(fd, '%');
+ 74a:	02500593          	li	a1,37
+ 74e:	855a                	mv	a0,s6
+ 750:	e47ff0ef          	jal	596 <putc>
+        putc(fd, c0);
+ 754:	85ca                	mv	a1,s2
+ 756:	855a                	mv	a0,s6
+ 758:	e3fff0ef          	jal	596 <putc>
+      state = 0;
+ 75c:	4981                	li	s3,0
+ 75e:	bf35                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 760:	008b8913          	addi	s2,s7,8
+ 764:	4685                	li	a3,1
+ 766:	4629                	li	a2,10
+ 768:	000bb583          	ld	a1,0(s7)
+ 76c:	855a                	mv	a0,s6
+ 76e:	e47ff0ef          	jal	5b4 <printint>
+        i += 1;
+ 772:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 774:	8bca                	mv	s7,s2
+      state = 0;
+ 776:	4981                	li	s3,0
+        i += 1;
+ 778:	b70d                	j	69a <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 77a:	06400793          	li	a5,100
+ 77e:	02f60763          	beq	a2,a5,7ac <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 782:	07500793          	li	a5,117
+ 786:	06f60963          	beq	a2,a5,7f8 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 78a:	07800793          	li	a5,120
+ 78e:	faf61ee3          	bne	a2,a5,74a <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 792:	008b8913          	addi	s2,s7,8
+ 796:	4681                	li	a3,0
+ 798:	4641                	li	a2,16
+ 79a:	000bb583          	ld	a1,0(s7)
+ 79e:	855a                	mv	a0,s6
+ 7a0:	e15ff0ef          	jal	5b4 <printint>
+        i += 2;
+ 7a4:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 7a6:	8bca                	mv	s7,s2
+      state = 0;
+ 7a8:	4981                	li	s3,0
+        i += 2;
+ 7aa:	bdc5                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 7ac:	008b8913          	addi	s2,s7,8
+ 7b0:	4685                	li	a3,1
+ 7b2:	4629                	li	a2,10
+ 7b4:	000bb583          	ld	a1,0(s7)
+ 7b8:	855a                	mv	a0,s6
+ 7ba:	dfbff0ef          	jal	5b4 <printint>
+        i += 2;
+ 7be:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 7c0:	8bca                	mv	s7,s2
+      state = 0;
+ 7c2:	4981                	li	s3,0
+        i += 2;
+ 7c4:	bdd9                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 7c6:	008b8913          	addi	s2,s7,8
+ 7ca:	4681                	li	a3,0
+ 7cc:	4629                	li	a2,10
+ 7ce:	000be583          	lwu	a1,0(s7)
+ 7d2:	855a                	mv	a0,s6
+ 7d4:	de1ff0ef          	jal	5b4 <printint>
+ 7d8:	8bca                	mv	s7,s2
+      state = 0;
+ 7da:	4981                	li	s3,0
+ 7dc:	bd7d                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 7de:	008b8913          	addi	s2,s7,8
+ 7e2:	4681                	li	a3,0
+ 7e4:	4629                	li	a2,10
+ 7e6:	000bb583          	ld	a1,0(s7)
+ 7ea:	855a                	mv	a0,s6
+ 7ec:	dc9ff0ef          	jal	5b4 <printint>
+        i += 1;
+ 7f0:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 7f2:	8bca                	mv	s7,s2
+      state = 0;
+ 7f4:	4981                	li	s3,0
+        i += 1;
+ 7f6:	b555                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 7f8:	008b8913          	addi	s2,s7,8
+ 7fc:	4681                	li	a3,0
+ 7fe:	4629                	li	a2,10
+ 800:	000bb583          	ld	a1,0(s7)
+ 804:	855a                	mv	a0,s6
+ 806:	dafff0ef          	jal	5b4 <printint>
+        i += 2;
+ 80a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 80c:	8bca                	mv	s7,s2
+      state = 0;
+ 80e:	4981                	li	s3,0
+        i += 2;
+ 810:	b569                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 812:	008b8913          	addi	s2,s7,8
+ 816:	4681                	li	a3,0
+ 818:	4641                	li	a2,16
+ 81a:	000be583          	lwu	a1,0(s7)
+ 81e:	855a                	mv	a0,s6
+ 820:	d95ff0ef          	jal	5b4 <printint>
+ 824:	8bca                	mv	s7,s2
+      state = 0;
+ 826:	4981                	li	s3,0
+ 828:	bd8d                	j	69a <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 82a:	008b8913          	addi	s2,s7,8
+ 82e:	4681                	li	a3,0
+ 830:	4641                	li	a2,16
+ 832:	000bb583          	ld	a1,0(s7)
+ 836:	855a                	mv	a0,s6
+ 838:	d7dff0ef          	jal	5b4 <printint>
+        i += 1;
+ 83c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 83e:	8bca                	mv	s7,s2
+      state = 0;
+ 840:	4981                	li	s3,0
+        i += 1;
+ 842:	bda1                	j	69a <vprintf+0x4a>
+ 844:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 846:	008b8d13          	addi	s10,s7,8
+ 84a:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 84e:	03000593          	li	a1,48
+ 852:	855a                	mv	a0,s6
+ 854:	d43ff0ef          	jal	596 <putc>
+  putc(fd, 'x');
+ 858:	07800593          	li	a1,120
+ 85c:	855a                	mv	a0,s6
+ 85e:	d39ff0ef          	jal	596 <putc>
+ 862:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 864:	00000b97          	auipc	s7,0x0
+ 868:	2acb8b93          	addi	s7,s7,684 # b10 <digits>
+ 86c:	03c9d793          	srli	a5,s3,0x3c
+ 870:	97de                	add	a5,a5,s7
+ 872:	0007c583          	lbu	a1,0(a5)
+ 876:	855a                	mv	a0,s6
+ 878:	d1fff0ef          	jal	596 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 87c:	0992                	slli	s3,s3,0x4
+ 87e:	397d                	addiw	s2,s2,-1
+ 880:	fe0916e3          	bnez	s2,86c <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 884:	8bea                	mv	s7,s10
+      state = 0;
+ 886:	4981                	li	s3,0
+ 888:	6d02                	ld	s10,0(sp)
+ 88a:	bd01                	j	69a <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 88c:	008b8913          	addi	s2,s7,8
+ 890:	000bc583          	lbu	a1,0(s7)
+ 894:	855a                	mv	a0,s6
+ 896:	d01ff0ef          	jal	596 <putc>
+ 89a:	8bca                	mv	s7,s2
+      state = 0;
+ 89c:	4981                	li	s3,0
+ 89e:	bbf5                	j	69a <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 8a0:	008b8993          	addi	s3,s7,8
+ 8a4:	000bb903          	ld	s2,0(s7)
+ 8a8:	00090f63          	beqz	s2,8c6 <vprintf+0x276>
+        for(; *s; s++)
+ 8ac:	00094583          	lbu	a1,0(s2)
+ 8b0:	c195                	beqz	a1,8d4 <vprintf+0x284>
+          putc(fd, *s);
+ 8b2:	855a                	mv	a0,s6
+ 8b4:	ce3ff0ef          	jal	596 <putc>
+        for(; *s; s++)
+ 8b8:	0905                	addi	s2,s2,1
+ 8ba:	00094583          	lbu	a1,0(s2)
+ 8be:	f9f5                	bnez	a1,8b2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 8c0:	8bce                	mv	s7,s3
+      state = 0;
+ 8c2:	4981                	li	s3,0
+ 8c4:	bbd9                	j	69a <vprintf+0x4a>
+          s = "(null)";
+ 8c6:	00000917          	auipc	s2,0x0
+ 8ca:	24290913          	addi	s2,s2,578 # b08 <malloc+0x136>
+        for(; *s; s++)
+ 8ce:	02800593          	li	a1,40
+ 8d2:	b7c5                	j	8b2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 8d4:	8bce                	mv	s7,s3
+      state = 0;
+ 8d6:	4981                	li	s3,0
+ 8d8:	b3c9                	j	69a <vprintf+0x4a>
+ 8da:	64a6                	ld	s1,72(sp)
+ 8dc:	79e2                	ld	s3,56(sp)
+ 8de:	7a42                	ld	s4,48(sp)
+ 8e0:	7aa2                	ld	s5,40(sp)
+ 8e2:	7b02                	ld	s6,32(sp)
+ 8e4:	6be2                	ld	s7,24(sp)
+ 8e6:	6c42                	ld	s8,16(sp)
+ 8e8:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 8ea:	60e6                	ld	ra,88(sp)
+ 8ec:	6446                	ld	s0,80(sp)
+ 8ee:	6906                	ld	s2,64(sp)
+ 8f0:	6125                	addi	sp,sp,96
+ 8f2:	8082                	ret
+
+00000000000008f4 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 8f4:	715d                	addi	sp,sp,-80
+ 8f6:	ec06                	sd	ra,24(sp)
+ 8f8:	e822                	sd	s0,16(sp)
+ 8fa:	1000                	addi	s0,sp,32
+ 8fc:	e010                	sd	a2,0(s0)
+ 8fe:	e414                	sd	a3,8(s0)
+ 900:	e818                	sd	a4,16(s0)
+ 902:	ec1c                	sd	a5,24(s0)
+ 904:	03043023          	sd	a6,32(s0)
+ 908:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 90c:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 910:	8622                	mv	a2,s0
+ 912:	d3fff0ef          	jal	650 <vprintf>
+}
+ 916:	60e2                	ld	ra,24(sp)
+ 918:	6442                	ld	s0,16(sp)
+ 91a:	6161                	addi	sp,sp,80
+ 91c:	8082                	ret
+
+000000000000091e <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 91e:	711d                	addi	sp,sp,-96
+ 920:	ec06                	sd	ra,24(sp)
+ 922:	e822                	sd	s0,16(sp)
+ 924:	1000                	addi	s0,sp,32
+ 926:	e40c                	sd	a1,8(s0)
+ 928:	e810                	sd	a2,16(s0)
+ 92a:	ec14                	sd	a3,24(s0)
+ 92c:	f018                	sd	a4,32(s0)
+ 92e:	f41c                	sd	a5,40(s0)
+ 930:	03043823          	sd	a6,48(s0)
+ 934:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 938:	00840613          	addi	a2,s0,8
+ 93c:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 940:	85aa                	mv	a1,a0
+ 942:	4505                	li	a0,1
+ 944:	d0dff0ef          	jal	650 <vprintf>
+}
+ 948:	60e2                	ld	ra,24(sp)
+ 94a:	6442                	ld	s0,16(sp)
+ 94c:	6125                	addi	sp,sp,96
+ 94e:	8082                	ret
+
+0000000000000950 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 950:	1141                	addi	sp,sp,-16
+ 952:	e422                	sd	s0,8(sp)
+ 954:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 956:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 95a:	00001797          	auipc	a5,0x1
+ 95e:	6a67b783          	ld	a5,1702(a5) # 2000 <freep>
+ 962:	a02d                	j	98c <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 964:	4618                	lw	a4,8(a2)
+ 966:	9f2d                	addw	a4,a4,a1
+ 968:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 96c:	6398                	ld	a4,0(a5)
+ 96e:	6310                	ld	a2,0(a4)
+ 970:	a83d                	j	9ae <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 972:	ff852703          	lw	a4,-8(a0)
+ 976:	9f31                	addw	a4,a4,a2
+ 978:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 97a:	ff053683          	ld	a3,-16(a0)
+ 97e:	a091                	j	9c2 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 980:	6398                	ld	a4,0(a5)
+ 982:	00e7e463          	bltu	a5,a4,98a <free+0x3a>
+ 986:	00e6ea63          	bltu	a3,a4,99a <free+0x4a>
+{
+ 98a:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 98c:	fed7fae3          	bgeu	a5,a3,980 <free+0x30>
+ 990:	6398                	ld	a4,0(a5)
+ 992:	00e6e463          	bltu	a3,a4,99a <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 996:	fee7eae3          	bltu	a5,a4,98a <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 99a:	ff852583          	lw	a1,-8(a0)
+ 99e:	6390                	ld	a2,0(a5)
+ 9a0:	02059813          	slli	a6,a1,0x20
+ 9a4:	01c85713          	srli	a4,a6,0x1c
+ 9a8:	9736                	add	a4,a4,a3
+ 9aa:	fae60de3          	beq	a2,a4,964 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 9ae:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 9b2:	4790                	lw	a2,8(a5)
+ 9b4:	02061593          	slli	a1,a2,0x20
+ 9b8:	01c5d713          	srli	a4,a1,0x1c
+ 9bc:	973e                	add	a4,a4,a5
+ 9be:	fae68ae3          	beq	a3,a4,972 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 9c2:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 9c4:	00001717          	auipc	a4,0x1
+ 9c8:	62f73e23          	sd	a5,1596(a4) # 2000 <freep>
+}
+ 9cc:	6422                	ld	s0,8(sp)
+ 9ce:	0141                	addi	sp,sp,16
+ 9d0:	8082                	ret
+
+00000000000009d2 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 9d2:	7139                	addi	sp,sp,-64
+ 9d4:	fc06                	sd	ra,56(sp)
+ 9d6:	f822                	sd	s0,48(sp)
+ 9d8:	f426                	sd	s1,40(sp)
+ 9da:	ec4e                	sd	s3,24(sp)
+ 9dc:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 9de:	02051493          	slli	s1,a0,0x20
+ 9e2:	9081                	srli	s1,s1,0x20
+ 9e4:	04bd                	addi	s1,s1,15
+ 9e6:	8091                	srli	s1,s1,0x4
+ 9e8:	0014899b          	addiw	s3,s1,1
+ 9ec:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 9ee:	00001517          	auipc	a0,0x1
+ 9f2:	61253503          	ld	a0,1554(a0) # 2000 <freep>
+ 9f6:	c915                	beqz	a0,a2a <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 9f8:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 9fa:	4798                	lw	a4,8(a5)
+ 9fc:	08977a63          	bgeu	a4,s1,a90 <malloc+0xbe>
+ a00:	f04a                	sd	s2,32(sp)
+ a02:	e852                	sd	s4,16(sp)
+ a04:	e456                	sd	s5,8(sp)
+ a06:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ a08:	8a4e                	mv	s4,s3
+ a0a:	0009871b          	sext.w	a4,s3
+ a0e:	6685                	lui	a3,0x1
+ a10:	00d77363          	bgeu	a4,a3,a16 <malloc+0x44>
+ a14:	6a05                	lui	s4,0x1
+ a16:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ a1a:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ a1e:	00001917          	auipc	s2,0x1
+ a22:	5e290913          	addi	s2,s2,1506 # 2000 <freep>
+  if(p == SBRK_ERROR)
+ a26:	5afd                	li	s5,-1
+ a28:	a081                	j	a68 <malloc+0x96>
+ a2a:	f04a                	sd	s2,32(sp)
+ a2c:	e852                	sd	s4,16(sp)
+ a2e:	e456                	sd	s5,8(sp)
+ a30:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ a32:	00002797          	auipc	a5,0x2
+ a36:	9de78793          	addi	a5,a5,-1570 # 2410 <base>
+ a3a:	00001717          	auipc	a4,0x1
+ a3e:	5cf73323          	sd	a5,1478(a4) # 2000 <freep>
+ a42:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ a44:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ a48:	b7c1                	j	a08 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ a4a:	6398                	ld	a4,0(a5)
+ a4c:	e118                	sd	a4,0(a0)
+ a4e:	a8a9                	j	aa8 <malloc+0xd6>
+  hp->s.size = nu;
+ a50:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ a54:	0541                	addi	a0,a0,16
+ a56:	efbff0ef          	jal	950 <free>
+  return freep;
+ a5a:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ a5e:	c12d                	beqz	a0,ac0 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a60:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ a62:	4798                	lw	a4,8(a5)
+ a64:	02977263          	bgeu	a4,s1,a88 <malloc+0xb6>
+    if(p == freep)
+ a68:	00093703          	ld	a4,0(s2)
+ a6c:	853e                	mv	a0,a5
+ a6e:	fef719e3          	bne	a4,a5,a60 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ a72:	8552                	mv	a0,s4
+ a74:	a47ff0ef          	jal	4ba <sbrk>
+  if(p == SBRK_ERROR)
+ a78:	fd551ce3          	bne	a0,s5,a50 <malloc+0x7e>
+        return 0;
+ a7c:	4501                	li	a0,0
+ a7e:	7902                	ld	s2,32(sp)
+ a80:	6a42                	ld	s4,16(sp)
+ a82:	6aa2                	ld	s5,8(sp)
+ a84:	6b02                	ld	s6,0(sp)
+ a86:	a03d                	j	ab4 <malloc+0xe2>
+ a88:	7902                	ld	s2,32(sp)
+ a8a:	6a42                	ld	s4,16(sp)
+ a8c:	6aa2                	ld	s5,8(sp)
+ a8e:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ a90:	fae48de3          	beq	s1,a4,a4a <malloc+0x78>
+        p->s.size -= nunits;
+ a94:	4137073b          	subw	a4,a4,s3
+ a98:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ a9a:	02071693          	slli	a3,a4,0x20
+ a9e:	01c6d713          	srli	a4,a3,0x1c
+ aa2:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ aa4:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ aa8:	00001717          	auipc	a4,0x1
+ aac:	54a73c23          	sd	a0,1368(a4) # 2000 <freep>
+      return (void*)(p + 1);
+ ab0:	01078513          	addi	a0,a5,16
+  }
+}
+ ab4:	70e2                	ld	ra,56(sp)
+ ab6:	7442                	ld	s0,48(sp)
+ ab8:	74a2                	ld	s1,40(sp)
+ aba:	69e2                	ld	s3,24(sp)
+ abc:	6121                	addi	sp,sp,64
+ abe:	8082                	ret
+ ac0:	7902                	ld	s2,32(sp)
+ ac2:	6a42                	ld	s4,16(sp)
+ ac4:	6aa2                	ld	s5,8(sp)
+ ac6:	6b02                	ld	s6,0(sp)
+ ac8:	b7f5                	j	ab4 <malloc+0xe2>
diff -ruN xv6-riscv/user/grep.d xv62/user/grep.d
--- xv6-riscv/user/grep.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grep.d	2025-09-14 12:32:50.780883335 +0000
@@ -0,0 +1,2 @@
+user/grep.o: user/grep.c kernel/types.h kernel/stat.h kernel/fcntl.h \
+ user/user.h
Binary files xv6-riscv/user/grep.o and xv62/user/grep.o differ
diff -ruN xv6-riscv/user/grep.sym xv62/user/grep.sym
--- xv6-riscv/user/grep.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grep.sym	2025-09-14 12:32:50.808883328 +0000
@@ -0,0 +1,71 @@
+0000000000000000 .text
+0000000000000ad0 .rodata
+0000000000000b28 .eh_frame
+0000000000002000 .data
+0000000000002000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 grep.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000596 putc
+00000000000005b4 printint
+0000000000000b10 digits
+0000000000000000 umalloc.c
+0000000000002000 freep
+0000000000002410 base
+000000000000026a strcpy
+000000000000057e pause
+000000000000091e printf
+0000000000000576 sys_sbrk
+0000000000000414 memmove
+000000000000004a matchhere
+0000000000000536 mknod
+0000000000000322 gets
+000000000000056e getpid
+00000000000004a6 memcpy
+0000000000000106 grep
+00000000000009d2 malloc
+00000000000004d0 sbrklazy
+00000000000004fe pipe
+000000000000050e write
+0000000000000546 fstat
+00000000000008f4 fprintf
+000000000000051e kill
+0000000000000650 vprintf
+000000000000055e chdir
+0000000000000526 exec
+00000000000004f6 wait
+0000000000000506 read
+000000000000053e unlink
+000000000000046c memcmp
+00000000000004e6 fork
+00000000000004ba sbrk
+0000000000000586 uptime
+00000000000002dc memset
+00000000000001c4 main
+0000000000000000 matchstar
+0000000000000286 strcmp
+0000000000000566 dup
+0000000000002010 buf
+000000000000058e getreadcount
+0000000000000392 stat
+00000000000000c0 match
+000000000000054e link
+00000000000004ee exit
+000000000000025a start
+00000000000003cc atoi
+00000000000002b2 strlen
+000000000000052e open
+00000000000002fe strchr
+0000000000000556 mkdir
+0000000000000516 close
+0000000000000950 free
diff -ruN xv6-riscv/user/grind.asm xv62/user/grind.asm
--- xv6-riscv/user/grind.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grind.asm	2025-09-14 12:32:52.008883083 +0000
@@ -0,0 +1,2544 @@
+
+user/_grind:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <do_rand>:
+#include "kernel/riscv.h"
+
+// from FreeBSD.
+int
+do_rand(unsigned long *ctx)
+{
+       0:	1141                	addi	sp,sp,-16
+       2:	e422                	sd	s0,8(sp)
+       4:	0800                	addi	s0,sp,16
+ * October 1988, p. 1195.
+ */
+    long hi, lo, x;
+
+    /* Transform to [1, 0x7ffffffe] range. */
+    x = (*ctx % 0x7ffffffe) + 1;
+       6:	611c                	ld	a5,0(a0)
+       8:	80000737          	lui	a4,0x80000
+       c:	ffe74713          	xori	a4,a4,-2
+      10:	02e7f7b3          	remu	a5,a5,a4
+      14:	0785                	addi	a5,a5,1
+    hi = x / 127773;
+    lo = x % 127773;
+      16:	66fd                	lui	a3,0x1f
+      18:	31d68693          	addi	a3,a3,797 # 1f31d <base+0x1cf15>
+      1c:	02d7e733          	rem	a4,a5,a3
+    x = 16807 * lo - 2836 * hi;
+      20:	6611                	lui	a2,0x4
+      22:	1a760613          	addi	a2,a2,423 # 41a7 <base+0x1d9f>
+      26:	02c70733          	mul	a4,a4,a2
+    hi = x / 127773;
+      2a:	02d7c7b3          	div	a5,a5,a3
+    x = 16807 * lo - 2836 * hi;
+      2e:	76fd                	lui	a3,0xfffff
+      30:	4ec68693          	addi	a3,a3,1260 # fffffffffffff4ec <base+0xffffffffffffd0e4>
+      34:	02d787b3          	mul	a5,a5,a3
+      38:	97ba                	add	a5,a5,a4
+    if (x < 0)
+      3a:	0007c963          	bltz	a5,4c <do_rand+0x4c>
+        x += 0x7fffffff;
+    /* Transform to [0, 0x7ffffffd] range. */
+    x--;
+      3e:	17fd                	addi	a5,a5,-1
+    *ctx = x;
+      40:	e11c                	sd	a5,0(a0)
+    return (x);
+}
+      42:	0007851b          	sext.w	a0,a5
+      46:	6422                	ld	s0,8(sp)
+      48:	0141                	addi	sp,sp,16
+      4a:	8082                	ret
+        x += 0x7fffffff;
+      4c:	80000737          	lui	a4,0x80000
+      50:	fff74713          	not	a4,a4
+      54:	97ba                	add	a5,a5,a4
+      56:	b7e5                	j	3e <do_rand+0x3e>
+
+0000000000000058 <rand>:
+
+unsigned long rand_next = 1;
+
+int
+rand(void)
+{
+      58:	1141                	addi	sp,sp,-16
+      5a:	e406                	sd	ra,8(sp)
+      5c:	e022                	sd	s0,0(sp)
+      5e:	0800                	addi	s0,sp,16
+    return (do_rand(&rand_next));
+      60:	00002517          	auipc	a0,0x2
+      64:	fa050513          	addi	a0,a0,-96 # 2000 <rand_next>
+      68:	f99ff0ef          	jal	0 <do_rand>
+}
+      6c:	60a2                	ld	ra,8(sp)
+      6e:	6402                	ld	s0,0(sp)
+      70:	0141                	addi	sp,sp,16
+      72:	8082                	ret
+
+0000000000000074 <go>:
+
+void
+go(int which_child)
+{
+      74:	7159                	addi	sp,sp,-112
+      76:	f486                	sd	ra,104(sp)
+      78:	f0a2                	sd	s0,96(sp)
+      7a:	eca6                	sd	s1,88(sp)
+      7c:	fc56                	sd	s5,56(sp)
+      7e:	1880                	addi	s0,sp,112
+      80:	84aa                	mv	s1,a0
+  int fd = -1;
+  static char buf[999];
+  char *break0 = sbrk(0);
+      82:	4501                	li	a0,0
+      84:	2bb000ef          	jal	b3e <sbrk>
+      88:	8aaa                	mv	s5,a0
+  uint64 iters = 0;
+
+  mkdir("grindir");
+      8a:	00001517          	auipc	a0,0x1
+      8e:	0c650513          	addi	a0,a0,198 # 1150 <malloc+0xfa>
+      92:	349000ef          	jal	bda <mkdir>
+  if(chdir("grindir") != 0){
+      96:	00001517          	auipc	a0,0x1
+      9a:	0ba50513          	addi	a0,a0,186 # 1150 <malloc+0xfa>
+      9e:	345000ef          	jal	be2 <chdir>
+      a2:	cd11                	beqz	a0,be <go+0x4a>
+      a4:	e8ca                	sd	s2,80(sp)
+      a6:	e4ce                	sd	s3,72(sp)
+      a8:	e0d2                	sd	s4,64(sp)
+      aa:	f85a                	sd	s6,48(sp)
+    printf("grind: chdir grindir failed\n");
+      ac:	00001517          	auipc	a0,0x1
+      b0:	0ac50513          	addi	a0,a0,172 # 1158 <malloc+0x102>
+      b4:	6ef000ef          	jal	fa2 <printf>
+    exit(1);
+      b8:	4505                	li	a0,1
+      ba:	2b9000ef          	jal	b72 <exit>
+      be:	e8ca                	sd	s2,80(sp)
+      c0:	e4ce                	sd	s3,72(sp)
+      c2:	e0d2                	sd	s4,64(sp)
+      c4:	f85a                	sd	s6,48(sp)
+  }
+  chdir("/");
+      c6:	00001517          	auipc	a0,0x1
+      ca:	0ba50513          	addi	a0,a0,186 # 1180 <malloc+0x12a>
+      ce:	315000ef          	jal	be2 <chdir>
+      d2:	00001997          	auipc	s3,0x1
+      d6:	0be98993          	addi	s3,s3,190 # 1190 <malloc+0x13a>
+      da:	c489                	beqz	s1,e4 <go+0x70>
+      dc:	00001997          	auipc	s3,0x1
+      e0:	0ac98993          	addi	s3,s3,172 # 1188 <malloc+0x132>
+  uint64 iters = 0;
+      e4:	4481                	li	s1,0
+  int fd = -1;
+      e6:	5a7d                	li	s4,-1
+      e8:	00001917          	auipc	s2,0x1
+      ec:	37890913          	addi	s2,s2,888 # 1460 <malloc+0x40a>
+      f0:	a819                	j	106 <go+0x92>
+    iters++;
+    if((iters % 500) == 0)
+      write(1, which_child?"B":"A", 1);
+    int what = rand() % 23;
+    if(what == 1){
+      close(open("grindir/../a", O_CREATE|O_RDWR));
+      f2:	20200593          	li	a1,514
+      f6:	00001517          	auipc	a0,0x1
+      fa:	0a250513          	addi	a0,a0,162 # 1198 <malloc+0x142>
+      fe:	2b5000ef          	jal	bb2 <open>
+     102:	299000ef          	jal	b9a <close>
+    iters++;
+     106:	0485                	addi	s1,s1,1
+    if((iters % 500) == 0)
+     108:	1f400793          	li	a5,500
+     10c:	02f4f7b3          	remu	a5,s1,a5
+     110:	e791                	bnez	a5,11c <go+0xa8>
+      write(1, which_child?"B":"A", 1);
+     112:	4605                	li	a2,1
+     114:	85ce                	mv	a1,s3
+     116:	4505                	li	a0,1
+     118:	27b000ef          	jal	b92 <write>
+    int what = rand() % 23;
+     11c:	f3dff0ef          	jal	58 <rand>
+     120:	47dd                	li	a5,23
+     122:	02f5653b          	remw	a0,a0,a5
+     126:	0005071b          	sext.w	a4,a0
+     12a:	47d9                	li	a5,22
+     12c:	fce7ede3          	bltu	a5,a4,106 <go+0x92>
+     130:	02051793          	slli	a5,a0,0x20
+     134:	01e7d513          	srli	a0,a5,0x1e
+     138:	954a                	add	a0,a0,s2
+     13a:	411c                	lw	a5,0(a0)
+     13c:	97ca                	add	a5,a5,s2
+     13e:	8782                	jr	a5
+    } else if(what == 2){
+      close(open("grindir/../grindir/../b", O_CREATE|O_RDWR));
+     140:	20200593          	li	a1,514
+     144:	00001517          	auipc	a0,0x1
+     148:	06450513          	addi	a0,a0,100 # 11a8 <malloc+0x152>
+     14c:	267000ef          	jal	bb2 <open>
+     150:	24b000ef          	jal	b9a <close>
+     154:	bf4d                	j	106 <go+0x92>
+    } else if(what == 3){
+      unlink("grindir/../a");
+     156:	00001517          	auipc	a0,0x1
+     15a:	04250513          	addi	a0,a0,66 # 1198 <malloc+0x142>
+     15e:	265000ef          	jal	bc2 <unlink>
+     162:	b755                	j	106 <go+0x92>
+    } else if(what == 4){
+      if(chdir("grindir") != 0){
+     164:	00001517          	auipc	a0,0x1
+     168:	fec50513          	addi	a0,a0,-20 # 1150 <malloc+0xfa>
+     16c:	277000ef          	jal	be2 <chdir>
+     170:	ed11                	bnez	a0,18c <go+0x118>
+        printf("grind: chdir grindir failed\n");
+        exit(1);
+      }
+      unlink("../b");
+     172:	00001517          	auipc	a0,0x1
+     176:	04e50513          	addi	a0,a0,78 # 11c0 <malloc+0x16a>
+     17a:	249000ef          	jal	bc2 <unlink>
+      chdir("/");
+     17e:	00001517          	auipc	a0,0x1
+     182:	00250513          	addi	a0,a0,2 # 1180 <malloc+0x12a>
+     186:	25d000ef          	jal	be2 <chdir>
+     18a:	bfb5                	j	106 <go+0x92>
+        printf("grind: chdir grindir failed\n");
+     18c:	00001517          	auipc	a0,0x1
+     190:	fcc50513          	addi	a0,a0,-52 # 1158 <malloc+0x102>
+     194:	60f000ef          	jal	fa2 <printf>
+        exit(1);
+     198:	4505                	li	a0,1
+     19a:	1d9000ef          	jal	b72 <exit>
+    } else if(what == 5){
+      close(fd);
+     19e:	8552                	mv	a0,s4
+     1a0:	1fb000ef          	jal	b9a <close>
+      fd = open("/grindir/../a", O_CREATE|O_RDWR);
+     1a4:	20200593          	li	a1,514
+     1a8:	00001517          	auipc	a0,0x1
+     1ac:	02050513          	addi	a0,a0,32 # 11c8 <malloc+0x172>
+     1b0:	203000ef          	jal	bb2 <open>
+     1b4:	8a2a                	mv	s4,a0
+     1b6:	bf81                	j	106 <go+0x92>
+    } else if(what == 6){
+      close(fd);
+     1b8:	8552                	mv	a0,s4
+     1ba:	1e1000ef          	jal	b9a <close>
+      fd = open("/./grindir/./../b", O_CREATE|O_RDWR);
+     1be:	20200593          	li	a1,514
+     1c2:	00001517          	auipc	a0,0x1
+     1c6:	01650513          	addi	a0,a0,22 # 11d8 <malloc+0x182>
+     1ca:	1e9000ef          	jal	bb2 <open>
+     1ce:	8a2a                	mv	s4,a0
+     1d0:	bf1d                	j	106 <go+0x92>
+    } else if(what == 7){
+      write(fd, buf, sizeof(buf));
+     1d2:	3e700613          	li	a2,999
+     1d6:	00002597          	auipc	a1,0x2
+     1da:	e4a58593          	addi	a1,a1,-438 # 2020 <buf.0>
+     1de:	8552                	mv	a0,s4
+     1e0:	1b3000ef          	jal	b92 <write>
+     1e4:	b70d                	j	106 <go+0x92>
+    } else if(what == 8){
+      read(fd, buf, sizeof(buf));
+     1e6:	3e700613          	li	a2,999
+     1ea:	00002597          	auipc	a1,0x2
+     1ee:	e3658593          	addi	a1,a1,-458 # 2020 <buf.0>
+     1f2:	8552                	mv	a0,s4
+     1f4:	197000ef          	jal	b8a <read>
+     1f8:	b739                	j	106 <go+0x92>
+    } else if(what == 9){
+      mkdir("grindir/../a");
+     1fa:	00001517          	auipc	a0,0x1
+     1fe:	f9e50513          	addi	a0,a0,-98 # 1198 <malloc+0x142>
+     202:	1d9000ef          	jal	bda <mkdir>
+      close(open("a/../a/./a", O_CREATE|O_RDWR));
+     206:	20200593          	li	a1,514
+     20a:	00001517          	auipc	a0,0x1
+     20e:	fe650513          	addi	a0,a0,-26 # 11f0 <malloc+0x19a>
+     212:	1a1000ef          	jal	bb2 <open>
+     216:	185000ef          	jal	b9a <close>
+      unlink("a/a");
+     21a:	00001517          	auipc	a0,0x1
+     21e:	fe650513          	addi	a0,a0,-26 # 1200 <malloc+0x1aa>
+     222:	1a1000ef          	jal	bc2 <unlink>
+     226:	b5c5                	j	106 <go+0x92>
+    } else if(what == 10){
+      mkdir("/../b");
+     228:	00001517          	auipc	a0,0x1
+     22c:	fe050513          	addi	a0,a0,-32 # 1208 <malloc+0x1b2>
+     230:	1ab000ef          	jal	bda <mkdir>
+      close(open("grindir/../b/b", O_CREATE|O_RDWR));
+     234:	20200593          	li	a1,514
+     238:	00001517          	auipc	a0,0x1
+     23c:	fd850513          	addi	a0,a0,-40 # 1210 <malloc+0x1ba>
+     240:	173000ef          	jal	bb2 <open>
+     244:	157000ef          	jal	b9a <close>
+      unlink("b/b");
+     248:	00001517          	auipc	a0,0x1
+     24c:	fd850513          	addi	a0,a0,-40 # 1220 <malloc+0x1ca>
+     250:	173000ef          	jal	bc2 <unlink>
+     254:	bd4d                	j	106 <go+0x92>
+    } else if(what == 11){
+      unlink("b");
+     256:	00001517          	auipc	a0,0x1
+     25a:	fd250513          	addi	a0,a0,-46 # 1228 <malloc+0x1d2>
+     25e:	165000ef          	jal	bc2 <unlink>
+      link("../grindir/./../a", "../b");
+     262:	00001597          	auipc	a1,0x1
+     266:	f5e58593          	addi	a1,a1,-162 # 11c0 <malloc+0x16a>
+     26a:	00001517          	auipc	a0,0x1
+     26e:	fc650513          	addi	a0,a0,-58 # 1230 <malloc+0x1da>
+     272:	161000ef          	jal	bd2 <link>
+     276:	bd41                	j	106 <go+0x92>
+    } else if(what == 12){
+      unlink("../grindir/../a");
+     278:	00001517          	auipc	a0,0x1
+     27c:	fd050513          	addi	a0,a0,-48 # 1248 <malloc+0x1f2>
+     280:	143000ef          	jal	bc2 <unlink>
+      link(".././b", "/grindir/../a");
+     284:	00001597          	auipc	a1,0x1
+     288:	f4458593          	addi	a1,a1,-188 # 11c8 <malloc+0x172>
+     28c:	00001517          	auipc	a0,0x1
+     290:	fcc50513          	addi	a0,a0,-52 # 1258 <malloc+0x202>
+     294:	13f000ef          	jal	bd2 <link>
+     298:	b5bd                	j	106 <go+0x92>
+    } else if(what == 13){
+      int pid = fork();
+     29a:	0d1000ef          	jal	b6a <fork>
+      if(pid == 0){
+     29e:	c519                	beqz	a0,2ac <go+0x238>
+        exit(0);
+      } else if(pid < 0){
+     2a0:	00054863          	bltz	a0,2b0 <go+0x23c>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      wait(0);
+     2a4:	4501                	li	a0,0
+     2a6:	0d5000ef          	jal	b7a <wait>
+     2aa:	bdb1                	j	106 <go+0x92>
+        exit(0);
+     2ac:	0c7000ef          	jal	b72 <exit>
+        printf("grind: fork failed\n");
+     2b0:	00001517          	auipc	a0,0x1
+     2b4:	fb050513          	addi	a0,a0,-80 # 1260 <malloc+0x20a>
+     2b8:	4eb000ef          	jal	fa2 <printf>
+        exit(1);
+     2bc:	4505                	li	a0,1
+     2be:	0b5000ef          	jal	b72 <exit>
+    } else if(what == 14){
+      int pid = fork();
+     2c2:	0a9000ef          	jal	b6a <fork>
+      if(pid == 0){
+     2c6:	c519                	beqz	a0,2d4 <go+0x260>
+        fork();
+        fork();
+        exit(0);
+      } else if(pid < 0){
+     2c8:	00054d63          	bltz	a0,2e2 <go+0x26e>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      wait(0);
+     2cc:	4501                	li	a0,0
+     2ce:	0ad000ef          	jal	b7a <wait>
+     2d2:	bd15                	j	106 <go+0x92>
+        fork();
+     2d4:	097000ef          	jal	b6a <fork>
+        fork();
+     2d8:	093000ef          	jal	b6a <fork>
+        exit(0);
+     2dc:	4501                	li	a0,0
+     2de:	095000ef          	jal	b72 <exit>
+        printf("grind: fork failed\n");
+     2e2:	00001517          	auipc	a0,0x1
+     2e6:	f7e50513          	addi	a0,a0,-130 # 1260 <malloc+0x20a>
+     2ea:	4b9000ef          	jal	fa2 <printf>
+        exit(1);
+     2ee:	4505                	li	a0,1
+     2f0:	083000ef          	jal	b72 <exit>
+    } else if(what == 15){
+      sbrk(6011);
+     2f4:	6505                	lui	a0,0x1
+     2f6:	77b50513          	addi	a0,a0,1915 # 177b <digits+0x2bb>
+     2fa:	045000ef          	jal	b3e <sbrk>
+     2fe:	b521                	j	106 <go+0x92>
+    } else if(what == 16){
+      if(sbrk(0) > break0)
+     300:	4501                	li	a0,0
+     302:	03d000ef          	jal	b3e <sbrk>
+     306:	e0aaf0e3          	bgeu	s5,a0,106 <go+0x92>
+        sbrk(-(sbrk(0) - break0));
+     30a:	4501                	li	a0,0
+     30c:	033000ef          	jal	b3e <sbrk>
+     310:	40aa853b          	subw	a0,s5,a0
+     314:	02b000ef          	jal	b3e <sbrk>
+     318:	b3fd                	j	106 <go+0x92>
+    } else if(what == 17){
+      int pid = fork();
+     31a:	051000ef          	jal	b6a <fork>
+     31e:	8b2a                	mv	s6,a0
+      if(pid == 0){
+     320:	c10d                	beqz	a0,342 <go+0x2ce>
+        close(open("a", O_CREATE|O_RDWR));
+        exit(0);
+      } else if(pid < 0){
+     322:	02054d63          	bltz	a0,35c <go+0x2e8>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      if(chdir("../grindir/..") != 0){
+     326:	00001517          	auipc	a0,0x1
+     32a:	f5a50513          	addi	a0,a0,-166 # 1280 <malloc+0x22a>
+     32e:	0b5000ef          	jal	be2 <chdir>
+     332:	ed15                	bnez	a0,36e <go+0x2fa>
+        printf("grind: chdir failed\n");
+        exit(1);
+      }
+      kill(pid);
+     334:	855a                	mv	a0,s6
+     336:	06d000ef          	jal	ba2 <kill>
+      wait(0);
+     33a:	4501                	li	a0,0
+     33c:	03f000ef          	jal	b7a <wait>
+     340:	b3d9                	j	106 <go+0x92>
+        close(open("a", O_CREATE|O_RDWR));
+     342:	20200593          	li	a1,514
+     346:	00001517          	auipc	a0,0x1
+     34a:	f3250513          	addi	a0,a0,-206 # 1278 <malloc+0x222>
+     34e:	065000ef          	jal	bb2 <open>
+     352:	049000ef          	jal	b9a <close>
+        exit(0);
+     356:	4501                	li	a0,0
+     358:	01b000ef          	jal	b72 <exit>
+        printf("grind: fork failed\n");
+     35c:	00001517          	auipc	a0,0x1
+     360:	f0450513          	addi	a0,a0,-252 # 1260 <malloc+0x20a>
+     364:	43f000ef          	jal	fa2 <printf>
+        exit(1);
+     368:	4505                	li	a0,1
+     36a:	009000ef          	jal	b72 <exit>
+        printf("grind: chdir failed\n");
+     36e:	00001517          	auipc	a0,0x1
+     372:	f2250513          	addi	a0,a0,-222 # 1290 <malloc+0x23a>
+     376:	42d000ef          	jal	fa2 <printf>
+        exit(1);
+     37a:	4505                	li	a0,1
+     37c:	7f6000ef          	jal	b72 <exit>
+    } else if(what == 18){
+      int pid = fork();
+     380:	7ea000ef          	jal	b6a <fork>
+      if(pid == 0){
+     384:	c519                	beqz	a0,392 <go+0x31e>
+        kill(getpid());
+        exit(0);
+      } else if(pid < 0){
+     386:	00054d63          	bltz	a0,3a0 <go+0x32c>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      wait(0);
+     38a:	4501                	li	a0,0
+     38c:	7ee000ef          	jal	b7a <wait>
+     390:	bb9d                	j	106 <go+0x92>
+        kill(getpid());
+     392:	061000ef          	jal	bf2 <getpid>
+     396:	00d000ef          	jal	ba2 <kill>
+        exit(0);
+     39a:	4501                	li	a0,0
+     39c:	7d6000ef          	jal	b72 <exit>
+        printf("grind: fork failed\n");
+     3a0:	00001517          	auipc	a0,0x1
+     3a4:	ec050513          	addi	a0,a0,-320 # 1260 <malloc+0x20a>
+     3a8:	3fb000ef          	jal	fa2 <printf>
+        exit(1);
+     3ac:	4505                	li	a0,1
+     3ae:	7c4000ef          	jal	b72 <exit>
+    } else if(what == 19){
+      int fds[2];
+      if(pipe(fds) < 0){
+     3b2:	fa840513          	addi	a0,s0,-88
+     3b6:	7cc000ef          	jal	b82 <pipe>
+     3ba:	02054363          	bltz	a0,3e0 <go+0x36c>
+        printf("grind: pipe failed\n");
+        exit(1);
+      }
+      int pid = fork();
+     3be:	7ac000ef          	jal	b6a <fork>
+      if(pid == 0){
+     3c2:	c905                	beqz	a0,3f2 <go+0x37e>
+          printf("grind: pipe write failed\n");
+        char c;
+        if(read(fds[0], &c, 1) != 1)
+          printf("grind: pipe read failed\n");
+        exit(0);
+      } else if(pid < 0){
+     3c4:	08054263          	bltz	a0,448 <go+0x3d4>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      close(fds[0]);
+     3c8:	fa842503          	lw	a0,-88(s0)
+     3cc:	7ce000ef          	jal	b9a <close>
+      close(fds[1]);
+     3d0:	fac42503          	lw	a0,-84(s0)
+     3d4:	7c6000ef          	jal	b9a <close>
+      wait(0);
+     3d8:	4501                	li	a0,0
+     3da:	7a0000ef          	jal	b7a <wait>
+     3de:	b325                	j	106 <go+0x92>
+        printf("grind: pipe failed\n");
+     3e0:	00001517          	auipc	a0,0x1
+     3e4:	ec850513          	addi	a0,a0,-312 # 12a8 <malloc+0x252>
+     3e8:	3bb000ef          	jal	fa2 <printf>
+        exit(1);
+     3ec:	4505                	li	a0,1
+     3ee:	784000ef          	jal	b72 <exit>
+        fork();
+     3f2:	778000ef          	jal	b6a <fork>
+        fork();
+     3f6:	774000ef          	jal	b6a <fork>
+        if(write(fds[1], "x", 1) != 1)
+     3fa:	4605                	li	a2,1
+     3fc:	00001597          	auipc	a1,0x1
+     400:	ec458593          	addi	a1,a1,-316 # 12c0 <malloc+0x26a>
+     404:	fac42503          	lw	a0,-84(s0)
+     408:	78a000ef          	jal	b92 <write>
+     40c:	4785                	li	a5,1
+     40e:	00f51f63          	bne	a0,a5,42c <go+0x3b8>
+        if(read(fds[0], &c, 1) != 1)
+     412:	4605                	li	a2,1
+     414:	fa040593          	addi	a1,s0,-96
+     418:	fa842503          	lw	a0,-88(s0)
+     41c:	76e000ef          	jal	b8a <read>
+     420:	4785                	li	a5,1
+     422:	00f51c63          	bne	a0,a5,43a <go+0x3c6>
+        exit(0);
+     426:	4501                	li	a0,0
+     428:	74a000ef          	jal	b72 <exit>
+          printf("grind: pipe write failed\n");
+     42c:	00001517          	auipc	a0,0x1
+     430:	e9c50513          	addi	a0,a0,-356 # 12c8 <malloc+0x272>
+     434:	36f000ef          	jal	fa2 <printf>
+     438:	bfe9                	j	412 <go+0x39e>
+          printf("grind: pipe read failed\n");
+     43a:	00001517          	auipc	a0,0x1
+     43e:	eae50513          	addi	a0,a0,-338 # 12e8 <malloc+0x292>
+     442:	361000ef          	jal	fa2 <printf>
+     446:	b7c5                	j	426 <go+0x3b2>
+        printf("grind: fork failed\n");
+     448:	00001517          	auipc	a0,0x1
+     44c:	e1850513          	addi	a0,a0,-488 # 1260 <malloc+0x20a>
+     450:	353000ef          	jal	fa2 <printf>
+        exit(1);
+     454:	4505                	li	a0,1
+     456:	71c000ef          	jal	b72 <exit>
+    } else if(what == 20){
+      int pid = fork();
+     45a:	710000ef          	jal	b6a <fork>
+      if(pid == 0){
+     45e:	c519                	beqz	a0,46c <go+0x3f8>
+        chdir("a");
+        unlink("../a");
+        fd = open("x", O_CREATE|O_RDWR);
+        unlink("x");
+        exit(0);
+      } else if(pid < 0){
+     460:	04054f63          	bltz	a0,4be <go+0x44a>
+        printf("grind: fork failed\n");
+        exit(1);
+      }
+      wait(0);
+     464:	4501                	li	a0,0
+     466:	714000ef          	jal	b7a <wait>
+     46a:	b971                	j	106 <go+0x92>
+        unlink("a");
+     46c:	00001517          	auipc	a0,0x1
+     470:	e0c50513          	addi	a0,a0,-500 # 1278 <malloc+0x222>
+     474:	74e000ef          	jal	bc2 <unlink>
+        mkdir("a");
+     478:	00001517          	auipc	a0,0x1
+     47c:	e0050513          	addi	a0,a0,-512 # 1278 <malloc+0x222>
+     480:	75a000ef          	jal	bda <mkdir>
+        chdir("a");
+     484:	00001517          	auipc	a0,0x1
+     488:	df450513          	addi	a0,a0,-524 # 1278 <malloc+0x222>
+     48c:	756000ef          	jal	be2 <chdir>
+        unlink("../a");
+     490:	00001517          	auipc	a0,0x1
+     494:	e7850513          	addi	a0,a0,-392 # 1308 <malloc+0x2b2>
+     498:	72a000ef          	jal	bc2 <unlink>
+        fd = open("x", O_CREATE|O_RDWR);
+     49c:	20200593          	li	a1,514
+     4a0:	00001517          	auipc	a0,0x1
+     4a4:	e2050513          	addi	a0,a0,-480 # 12c0 <malloc+0x26a>
+     4a8:	70a000ef          	jal	bb2 <open>
+        unlink("x");
+     4ac:	00001517          	auipc	a0,0x1
+     4b0:	e1450513          	addi	a0,a0,-492 # 12c0 <malloc+0x26a>
+     4b4:	70e000ef          	jal	bc2 <unlink>
+        exit(0);
+     4b8:	4501                	li	a0,0
+     4ba:	6b8000ef          	jal	b72 <exit>
+        printf("grind: fork failed\n");
+     4be:	00001517          	auipc	a0,0x1
+     4c2:	da250513          	addi	a0,a0,-606 # 1260 <malloc+0x20a>
+     4c6:	2dd000ef          	jal	fa2 <printf>
+        exit(1);
+     4ca:	4505                	li	a0,1
+     4cc:	6a6000ef          	jal	b72 <exit>
+    } else if(what == 21){
+      unlink("c");
+     4d0:	00001517          	auipc	a0,0x1
+     4d4:	e4050513          	addi	a0,a0,-448 # 1310 <malloc+0x2ba>
+     4d8:	6ea000ef          	jal	bc2 <unlink>
+      // should always succeed. check that there are free i-nodes,
+      // file descriptors, blocks.
+      int fd1 = open("c", O_CREATE|O_RDWR);
+     4dc:	20200593          	li	a1,514
+     4e0:	00001517          	auipc	a0,0x1
+     4e4:	e3050513          	addi	a0,a0,-464 # 1310 <malloc+0x2ba>
+     4e8:	6ca000ef          	jal	bb2 <open>
+     4ec:	8b2a                	mv	s6,a0
+      if(fd1 < 0){
+     4ee:	04054763          	bltz	a0,53c <go+0x4c8>
+        printf("grind: create c failed\n");
+        exit(1);
+      }
+      if(write(fd1, "x", 1) != 1){
+     4f2:	4605                	li	a2,1
+     4f4:	00001597          	auipc	a1,0x1
+     4f8:	dcc58593          	addi	a1,a1,-564 # 12c0 <malloc+0x26a>
+     4fc:	696000ef          	jal	b92 <write>
+     500:	4785                	li	a5,1
+     502:	04f51663          	bne	a0,a5,54e <go+0x4da>
+        printf("grind: write c failed\n");
+        exit(1);
+      }
+      struct stat st;
+      if(fstat(fd1, &st) != 0){
+     506:	fa840593          	addi	a1,s0,-88
+     50a:	855a                	mv	a0,s6
+     50c:	6be000ef          	jal	bca <fstat>
+     510:	e921                	bnez	a0,560 <go+0x4ec>
+        printf("grind: fstat failed\n");
+        exit(1);
+      }
+      if(st.size != 1){
+     512:	fb843583          	ld	a1,-72(s0)
+     516:	4785                	li	a5,1
+     518:	04f59d63          	bne	a1,a5,572 <go+0x4fe>
+        printf("grind: fstat reports wrong size %d\n", (int)st.size);
+        exit(1);
+      }
+      if(st.ino > 200){
+     51c:	fac42583          	lw	a1,-84(s0)
+     520:	0c800793          	li	a5,200
+     524:	06b7e163          	bltu	a5,a1,586 <go+0x512>
+        printf("grind: fstat reports crazy i-number %d\n", st.ino);
+        exit(1);
+      }
+      close(fd1);
+     528:	855a                	mv	a0,s6
+     52a:	670000ef          	jal	b9a <close>
+      unlink("c");
+     52e:	00001517          	auipc	a0,0x1
+     532:	de250513          	addi	a0,a0,-542 # 1310 <malloc+0x2ba>
+     536:	68c000ef          	jal	bc2 <unlink>
+     53a:	b6f1                	j	106 <go+0x92>
+        printf("grind: create c failed\n");
+     53c:	00001517          	auipc	a0,0x1
+     540:	ddc50513          	addi	a0,a0,-548 # 1318 <malloc+0x2c2>
+     544:	25f000ef          	jal	fa2 <printf>
+        exit(1);
+     548:	4505                	li	a0,1
+     54a:	628000ef          	jal	b72 <exit>
+        printf("grind: write c failed\n");
+     54e:	00001517          	auipc	a0,0x1
+     552:	de250513          	addi	a0,a0,-542 # 1330 <malloc+0x2da>
+     556:	24d000ef          	jal	fa2 <printf>
+        exit(1);
+     55a:	4505                	li	a0,1
+     55c:	616000ef          	jal	b72 <exit>
+        printf("grind: fstat failed\n");
+     560:	00001517          	auipc	a0,0x1
+     564:	de850513          	addi	a0,a0,-536 # 1348 <malloc+0x2f2>
+     568:	23b000ef          	jal	fa2 <printf>
+        exit(1);
+     56c:	4505                	li	a0,1
+     56e:	604000ef          	jal	b72 <exit>
+        printf("grind: fstat reports wrong size %d\n", (int)st.size);
+     572:	2581                	sext.w	a1,a1
+     574:	00001517          	auipc	a0,0x1
+     578:	dec50513          	addi	a0,a0,-532 # 1360 <malloc+0x30a>
+     57c:	227000ef          	jal	fa2 <printf>
+        exit(1);
+     580:	4505                	li	a0,1
+     582:	5f0000ef          	jal	b72 <exit>
+        printf("grind: fstat reports crazy i-number %d\n", st.ino);
+     586:	00001517          	auipc	a0,0x1
+     58a:	e0250513          	addi	a0,a0,-510 # 1388 <malloc+0x332>
+     58e:	215000ef          	jal	fa2 <printf>
+        exit(1);
+     592:	4505                	li	a0,1
+     594:	5de000ef          	jal	b72 <exit>
+    } else if(what == 22){
+      // echo hi | cat
+      int aa[2], bb[2];
+      if(pipe(aa) < 0){
+     598:	f9840513          	addi	a0,s0,-104
+     59c:	5e6000ef          	jal	b82 <pipe>
+     5a0:	0c054263          	bltz	a0,664 <go+0x5f0>
+        fprintf(2, "grind: pipe failed\n");
+        exit(1);
+      }
+      if(pipe(bb) < 0){
+     5a4:	fa040513          	addi	a0,s0,-96
+     5a8:	5da000ef          	jal	b82 <pipe>
+     5ac:	0c054663          	bltz	a0,678 <go+0x604>
+        fprintf(2, "grind: pipe failed\n");
+        exit(1);
+      }
+      int pid1 = fork();
+     5b0:	5ba000ef          	jal	b6a <fork>
+      if(pid1 == 0){
+     5b4:	0c050c63          	beqz	a0,68c <go+0x618>
+        close(aa[1]);
+        char *args[3] = { "echo", "hi", 0 };
+        exec("grindir/../echo", args);
+        fprintf(2, "grind: echo: not found\n");
+        exit(2);
+      } else if(pid1 < 0){
+     5b8:	14054e63          	bltz	a0,714 <go+0x6a0>
+        fprintf(2, "grind: fork failed\n");
+        exit(3);
+      }
+      int pid2 = fork();
+     5bc:	5ae000ef          	jal	b6a <fork>
+      if(pid2 == 0){
+     5c0:	16050463          	beqz	a0,728 <go+0x6b4>
+        close(bb[1]);
+        char *args[2] = { "cat", 0 };
+        exec("/cat", args);
+        fprintf(2, "grind: cat: not found\n");
+        exit(6);
+      } else if(pid2 < 0){
+     5c4:	20054263          	bltz	a0,7c8 <go+0x754>
+        fprintf(2, "grind: fork failed\n");
+        exit(7);
+      }
+      close(aa[0]);
+     5c8:	f9842503          	lw	a0,-104(s0)
+     5cc:	5ce000ef          	jal	b9a <close>
+      close(aa[1]);
+     5d0:	f9c42503          	lw	a0,-100(s0)
+     5d4:	5c6000ef          	jal	b9a <close>
+      close(bb[1]);
+     5d8:	fa442503          	lw	a0,-92(s0)
+     5dc:	5be000ef          	jal	b9a <close>
+      char buf[4] = { 0, 0, 0, 0 };
+     5e0:	f8042823          	sw	zero,-112(s0)
+      read(bb[0], buf+0, 1);
+     5e4:	4605                	li	a2,1
+     5e6:	f9040593          	addi	a1,s0,-112
+     5ea:	fa042503          	lw	a0,-96(s0)
+     5ee:	59c000ef          	jal	b8a <read>
+      read(bb[0], buf+1, 1);
+     5f2:	4605                	li	a2,1
+     5f4:	f9140593          	addi	a1,s0,-111
+     5f8:	fa042503          	lw	a0,-96(s0)
+     5fc:	58e000ef          	jal	b8a <read>
+      read(bb[0], buf+2, 1);
+     600:	4605                	li	a2,1
+     602:	f9240593          	addi	a1,s0,-110
+     606:	fa042503          	lw	a0,-96(s0)
+     60a:	580000ef          	jal	b8a <read>
+      close(bb[0]);
+     60e:	fa042503          	lw	a0,-96(s0)
+     612:	588000ef          	jal	b9a <close>
+      int st1, st2;
+      wait(&st1);
+     616:	f9440513          	addi	a0,s0,-108
+     61a:	560000ef          	jal	b7a <wait>
+      wait(&st2);
+     61e:	fa840513          	addi	a0,s0,-88
+     622:	558000ef          	jal	b7a <wait>
+      if(st1 != 0 || st2 != 0 || strcmp(buf, "hi\n") != 0){
+     626:	f9442783          	lw	a5,-108(s0)
+     62a:	fa842703          	lw	a4,-88(s0)
+     62e:	8fd9                	or	a5,a5,a4
+     630:	eb99                	bnez	a5,646 <go+0x5d2>
+     632:	00001597          	auipc	a1,0x1
+     636:	df658593          	addi	a1,a1,-522 # 1428 <malloc+0x3d2>
+     63a:	f9040513          	addi	a0,s0,-112
+     63e:	2cc000ef          	jal	90a <strcmp>
+     642:	ac0502e3          	beqz	a0,106 <go+0x92>
+        printf("grind: exec pipeline failed %d %d \"%s\"\n", st1, st2, buf);
+     646:	f9040693          	addi	a3,s0,-112
+     64a:	fa842603          	lw	a2,-88(s0)
+     64e:	f9442583          	lw	a1,-108(s0)
+     652:	00001517          	auipc	a0,0x1
+     656:	dde50513          	addi	a0,a0,-546 # 1430 <malloc+0x3da>
+     65a:	149000ef          	jal	fa2 <printf>
+        exit(1);
+     65e:	4505                	li	a0,1
+     660:	512000ef          	jal	b72 <exit>
+        fprintf(2, "grind: pipe failed\n");
+     664:	00001597          	auipc	a1,0x1
+     668:	c4458593          	addi	a1,a1,-956 # 12a8 <malloc+0x252>
+     66c:	4509                	li	a0,2
+     66e:	10b000ef          	jal	f78 <fprintf>
+        exit(1);
+     672:	4505                	li	a0,1
+     674:	4fe000ef          	jal	b72 <exit>
+        fprintf(2, "grind: pipe failed\n");
+     678:	00001597          	auipc	a1,0x1
+     67c:	c3058593          	addi	a1,a1,-976 # 12a8 <malloc+0x252>
+     680:	4509                	li	a0,2
+     682:	0f7000ef          	jal	f78 <fprintf>
+        exit(1);
+     686:	4505                	li	a0,1
+     688:	4ea000ef          	jal	b72 <exit>
+        close(bb[0]);
+     68c:	fa042503          	lw	a0,-96(s0)
+     690:	50a000ef          	jal	b9a <close>
+        close(bb[1]);
+     694:	fa442503          	lw	a0,-92(s0)
+     698:	502000ef          	jal	b9a <close>
+        close(aa[0]);
+     69c:	f9842503          	lw	a0,-104(s0)
+     6a0:	4fa000ef          	jal	b9a <close>
+        close(1);
+     6a4:	4505                	li	a0,1
+     6a6:	4f4000ef          	jal	b9a <close>
+        if(dup(aa[1]) != 1){
+     6aa:	f9c42503          	lw	a0,-100(s0)
+     6ae:	53c000ef          	jal	bea <dup>
+     6b2:	4785                	li	a5,1
+     6b4:	00f50c63          	beq	a0,a5,6cc <go+0x658>
+          fprintf(2, "grind: dup failed\n");
+     6b8:	00001597          	auipc	a1,0x1
+     6bc:	cf858593          	addi	a1,a1,-776 # 13b0 <malloc+0x35a>
+     6c0:	4509                	li	a0,2
+     6c2:	0b7000ef          	jal	f78 <fprintf>
+          exit(1);
+     6c6:	4505                	li	a0,1
+     6c8:	4aa000ef          	jal	b72 <exit>
+        close(aa[1]);
+     6cc:	f9c42503          	lw	a0,-100(s0)
+     6d0:	4ca000ef          	jal	b9a <close>
+        char *args[3] = { "echo", "hi", 0 };
+     6d4:	00001797          	auipc	a5,0x1
+     6d8:	cf478793          	addi	a5,a5,-780 # 13c8 <malloc+0x372>
+     6dc:	faf43423          	sd	a5,-88(s0)
+     6e0:	00001797          	auipc	a5,0x1
+     6e4:	cf078793          	addi	a5,a5,-784 # 13d0 <malloc+0x37a>
+     6e8:	faf43823          	sd	a5,-80(s0)
+     6ec:	fa043c23          	sd	zero,-72(s0)
+        exec("grindir/../echo", args);
+     6f0:	fa840593          	addi	a1,s0,-88
+     6f4:	00001517          	auipc	a0,0x1
+     6f8:	ce450513          	addi	a0,a0,-796 # 13d8 <malloc+0x382>
+     6fc:	4ae000ef          	jal	baa <exec>
+        fprintf(2, "grind: echo: not found\n");
+     700:	00001597          	auipc	a1,0x1
+     704:	ce858593          	addi	a1,a1,-792 # 13e8 <malloc+0x392>
+     708:	4509                	li	a0,2
+     70a:	06f000ef          	jal	f78 <fprintf>
+        exit(2);
+     70e:	4509                	li	a0,2
+     710:	462000ef          	jal	b72 <exit>
+        fprintf(2, "grind: fork failed\n");
+     714:	00001597          	auipc	a1,0x1
+     718:	b4c58593          	addi	a1,a1,-1204 # 1260 <malloc+0x20a>
+     71c:	4509                	li	a0,2
+     71e:	05b000ef          	jal	f78 <fprintf>
+        exit(3);
+     722:	450d                	li	a0,3
+     724:	44e000ef          	jal	b72 <exit>
+        close(aa[1]);
+     728:	f9c42503          	lw	a0,-100(s0)
+     72c:	46e000ef          	jal	b9a <close>
+        close(bb[0]);
+     730:	fa042503          	lw	a0,-96(s0)
+     734:	466000ef          	jal	b9a <close>
+        close(0);
+     738:	4501                	li	a0,0
+     73a:	460000ef          	jal	b9a <close>
+        if(dup(aa[0]) != 0){
+     73e:	f9842503          	lw	a0,-104(s0)
+     742:	4a8000ef          	jal	bea <dup>
+     746:	c919                	beqz	a0,75c <go+0x6e8>
+          fprintf(2, "grind: dup failed\n");
+     748:	00001597          	auipc	a1,0x1
+     74c:	c6858593          	addi	a1,a1,-920 # 13b0 <malloc+0x35a>
+     750:	4509                	li	a0,2
+     752:	027000ef          	jal	f78 <fprintf>
+          exit(4);
+     756:	4511                	li	a0,4
+     758:	41a000ef          	jal	b72 <exit>
+        close(aa[0]);
+     75c:	f9842503          	lw	a0,-104(s0)
+     760:	43a000ef          	jal	b9a <close>
+        close(1);
+     764:	4505                	li	a0,1
+     766:	434000ef          	jal	b9a <close>
+        if(dup(bb[1]) != 1){
+     76a:	fa442503          	lw	a0,-92(s0)
+     76e:	47c000ef          	jal	bea <dup>
+     772:	4785                	li	a5,1
+     774:	00f50c63          	beq	a0,a5,78c <go+0x718>
+          fprintf(2, "grind: dup failed\n");
+     778:	00001597          	auipc	a1,0x1
+     77c:	c3858593          	addi	a1,a1,-968 # 13b0 <malloc+0x35a>
+     780:	4509                	li	a0,2
+     782:	7f6000ef          	jal	f78 <fprintf>
+          exit(5);
+     786:	4515                	li	a0,5
+     788:	3ea000ef          	jal	b72 <exit>
+        close(bb[1]);
+     78c:	fa442503          	lw	a0,-92(s0)
+     790:	40a000ef          	jal	b9a <close>
+        char *args[2] = { "cat", 0 };
+     794:	00001797          	auipc	a5,0x1
+     798:	c6c78793          	addi	a5,a5,-916 # 1400 <malloc+0x3aa>
+     79c:	faf43423          	sd	a5,-88(s0)
+     7a0:	fa043823          	sd	zero,-80(s0)
+        exec("/cat", args);
+     7a4:	fa840593          	addi	a1,s0,-88
+     7a8:	00001517          	auipc	a0,0x1
+     7ac:	c6050513          	addi	a0,a0,-928 # 1408 <malloc+0x3b2>
+     7b0:	3fa000ef          	jal	baa <exec>
+        fprintf(2, "grind: cat: not found\n");
+     7b4:	00001597          	auipc	a1,0x1
+     7b8:	c5c58593          	addi	a1,a1,-932 # 1410 <malloc+0x3ba>
+     7bc:	4509                	li	a0,2
+     7be:	7ba000ef          	jal	f78 <fprintf>
+        exit(6);
+     7c2:	4519                	li	a0,6
+     7c4:	3ae000ef          	jal	b72 <exit>
+        fprintf(2, "grind: fork failed\n");
+     7c8:	00001597          	auipc	a1,0x1
+     7cc:	a9858593          	addi	a1,a1,-1384 # 1260 <malloc+0x20a>
+     7d0:	4509                	li	a0,2
+     7d2:	7a6000ef          	jal	f78 <fprintf>
+        exit(7);
+     7d6:	451d                	li	a0,7
+     7d8:	39a000ef          	jal	b72 <exit>
+
+00000000000007dc <iter>:
+  }
+}
+
+void
+iter()
+{
+     7dc:	7179                	addi	sp,sp,-48
+     7de:	f406                	sd	ra,40(sp)
+     7e0:	f022                	sd	s0,32(sp)
+     7e2:	1800                	addi	s0,sp,48
+  unlink("a");
+     7e4:	00001517          	auipc	a0,0x1
+     7e8:	a9450513          	addi	a0,a0,-1388 # 1278 <malloc+0x222>
+     7ec:	3d6000ef          	jal	bc2 <unlink>
+  unlink("b");
+     7f0:	00001517          	auipc	a0,0x1
+     7f4:	a3850513          	addi	a0,a0,-1480 # 1228 <malloc+0x1d2>
+     7f8:	3ca000ef          	jal	bc2 <unlink>
+  
+  int pid1 = fork();
+     7fc:	36e000ef          	jal	b6a <fork>
+  if(pid1 < 0){
+     800:	02054163          	bltz	a0,822 <iter+0x46>
+     804:	ec26                	sd	s1,24(sp)
+     806:	84aa                	mv	s1,a0
+    printf("grind: fork failed\n");
+    exit(1);
+  }
+  if(pid1 == 0){
+     808:	e905                	bnez	a0,838 <iter+0x5c>
+     80a:	e84a                	sd	s2,16(sp)
+    rand_next ^= 31;
+     80c:	00001717          	auipc	a4,0x1
+     810:	7f470713          	addi	a4,a4,2036 # 2000 <rand_next>
+     814:	631c                	ld	a5,0(a4)
+     816:	01f7c793          	xori	a5,a5,31
+     81a:	e31c                	sd	a5,0(a4)
+    go(0);
+     81c:	4501                	li	a0,0
+     81e:	857ff0ef          	jal	74 <go>
+     822:	ec26                	sd	s1,24(sp)
+     824:	e84a                	sd	s2,16(sp)
+    printf("grind: fork failed\n");
+     826:	00001517          	auipc	a0,0x1
+     82a:	a3a50513          	addi	a0,a0,-1478 # 1260 <malloc+0x20a>
+     82e:	774000ef          	jal	fa2 <printf>
+    exit(1);
+     832:	4505                	li	a0,1
+     834:	33e000ef          	jal	b72 <exit>
+     838:	e84a                	sd	s2,16(sp)
+    exit(0);
+  }
+
+  int pid2 = fork();
+     83a:	330000ef          	jal	b6a <fork>
+     83e:	892a                	mv	s2,a0
+  if(pid2 < 0){
+     840:	02054063          	bltz	a0,860 <iter+0x84>
+    printf("grind: fork failed\n");
+    exit(1);
+  }
+  if(pid2 == 0){
+     844:	e51d                	bnez	a0,872 <iter+0x96>
+    rand_next ^= 7177;
+     846:	00001697          	auipc	a3,0x1
+     84a:	7ba68693          	addi	a3,a3,1978 # 2000 <rand_next>
+     84e:	629c                	ld	a5,0(a3)
+     850:	6709                	lui	a4,0x2
+     852:	c0970713          	addi	a4,a4,-1015 # 1c09 <digits+0x749>
+     856:	8fb9                	xor	a5,a5,a4
+     858:	e29c                	sd	a5,0(a3)
+    go(1);
+     85a:	4505                	li	a0,1
+     85c:	819ff0ef          	jal	74 <go>
+    printf("grind: fork failed\n");
+     860:	00001517          	auipc	a0,0x1
+     864:	a0050513          	addi	a0,a0,-1536 # 1260 <malloc+0x20a>
+     868:	73a000ef          	jal	fa2 <printf>
+    exit(1);
+     86c:	4505                	li	a0,1
+     86e:	304000ef          	jal	b72 <exit>
+    exit(0);
+  }
+
+  int st1 = -1;
+     872:	57fd                	li	a5,-1
+     874:	fcf42e23          	sw	a5,-36(s0)
+  wait(&st1);
+     878:	fdc40513          	addi	a0,s0,-36
+     87c:	2fe000ef          	jal	b7a <wait>
+  if(st1 != 0){
+     880:	fdc42783          	lw	a5,-36(s0)
+     884:	eb99                	bnez	a5,89a <iter+0xbe>
+    kill(pid1);
+    kill(pid2);
+  }
+  int st2 = -1;
+     886:	57fd                	li	a5,-1
+     888:	fcf42c23          	sw	a5,-40(s0)
+  wait(&st2);
+     88c:	fd840513          	addi	a0,s0,-40
+     890:	2ea000ef          	jal	b7a <wait>
+
+  exit(0);
+     894:	4501                	li	a0,0
+     896:	2dc000ef          	jal	b72 <exit>
+    kill(pid1);
+     89a:	8526                	mv	a0,s1
+     89c:	306000ef          	jal	ba2 <kill>
+    kill(pid2);
+     8a0:	854a                	mv	a0,s2
+     8a2:	300000ef          	jal	ba2 <kill>
+     8a6:	b7c5                	j	886 <iter+0xaa>
+
+00000000000008a8 <main>:
+}
+
+int
+main()
+{
+     8a8:	1101                	addi	sp,sp,-32
+     8aa:	ec06                	sd	ra,24(sp)
+     8ac:	e822                	sd	s0,16(sp)
+     8ae:	e426                	sd	s1,8(sp)
+     8b0:	1000                	addi	s0,sp,32
+    }
+    if(pid > 0){
+      wait(0);
+    }
+    pause(20);
+    rand_next += 1;
+     8b2:	00001497          	auipc	s1,0x1
+     8b6:	74e48493          	addi	s1,s1,1870 # 2000 <rand_next>
+     8ba:	a809                	j	8cc <main+0x24>
+      iter();
+     8bc:	f21ff0ef          	jal	7dc <iter>
+    pause(20);
+     8c0:	4551                	li	a0,20
+     8c2:	340000ef          	jal	c02 <pause>
+    rand_next += 1;
+     8c6:	609c                	ld	a5,0(s1)
+     8c8:	0785                	addi	a5,a5,1
+     8ca:	e09c                	sd	a5,0(s1)
+    int pid = fork();
+     8cc:	29e000ef          	jal	b6a <fork>
+    if(pid == 0){
+     8d0:	d575                	beqz	a0,8bc <main+0x14>
+    if(pid > 0){
+     8d2:	fea057e3          	blez	a0,8c0 <main+0x18>
+      wait(0);
+     8d6:	4501                	li	a0,0
+     8d8:	2a2000ef          	jal	b7a <wait>
+     8dc:	b7d5                	j	8c0 <main+0x18>
+
+00000000000008de <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+     8de:	1141                	addi	sp,sp,-16
+     8e0:	e406                	sd	ra,8(sp)
+     8e2:	e022                	sd	s0,0(sp)
+     8e4:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+     8e6:	fc3ff0ef          	jal	8a8 <main>
+  exit(r);
+     8ea:	288000ef          	jal	b72 <exit>
+
+00000000000008ee <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+     8ee:	1141                	addi	sp,sp,-16
+     8f0:	e422                	sd	s0,8(sp)
+     8f2:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+     8f4:	87aa                	mv	a5,a0
+     8f6:	0585                	addi	a1,a1,1
+     8f8:	0785                	addi	a5,a5,1
+     8fa:	fff5c703          	lbu	a4,-1(a1)
+     8fe:	fee78fa3          	sb	a4,-1(a5)
+     902:	fb75                	bnez	a4,8f6 <strcpy+0x8>
+    ;
+  return os;
+}
+     904:	6422                	ld	s0,8(sp)
+     906:	0141                	addi	sp,sp,16
+     908:	8082                	ret
+
+000000000000090a <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+     90a:	1141                	addi	sp,sp,-16
+     90c:	e422                	sd	s0,8(sp)
+     90e:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+     910:	00054783          	lbu	a5,0(a0)
+     914:	cb91                	beqz	a5,928 <strcmp+0x1e>
+     916:	0005c703          	lbu	a4,0(a1)
+     91a:	00f71763          	bne	a4,a5,928 <strcmp+0x1e>
+    p++, q++;
+     91e:	0505                	addi	a0,a0,1
+     920:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+     922:	00054783          	lbu	a5,0(a0)
+     926:	fbe5                	bnez	a5,916 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+     928:	0005c503          	lbu	a0,0(a1)
+}
+     92c:	40a7853b          	subw	a0,a5,a0
+     930:	6422                	ld	s0,8(sp)
+     932:	0141                	addi	sp,sp,16
+     934:	8082                	ret
+
+0000000000000936 <strlen>:
+
+uint
+strlen(const char *s)
+{
+     936:	1141                	addi	sp,sp,-16
+     938:	e422                	sd	s0,8(sp)
+     93a:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+     93c:	00054783          	lbu	a5,0(a0)
+     940:	cf91                	beqz	a5,95c <strlen+0x26>
+     942:	0505                	addi	a0,a0,1
+     944:	87aa                	mv	a5,a0
+     946:	86be                	mv	a3,a5
+     948:	0785                	addi	a5,a5,1
+     94a:	fff7c703          	lbu	a4,-1(a5)
+     94e:	ff65                	bnez	a4,946 <strlen+0x10>
+     950:	40a6853b          	subw	a0,a3,a0
+     954:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+     956:	6422                	ld	s0,8(sp)
+     958:	0141                	addi	sp,sp,16
+     95a:	8082                	ret
+  for(n = 0; s[n]; n++)
+     95c:	4501                	li	a0,0
+     95e:	bfe5                	j	956 <strlen+0x20>
+
+0000000000000960 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+     960:	1141                	addi	sp,sp,-16
+     962:	e422                	sd	s0,8(sp)
+     964:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+     966:	ca19                	beqz	a2,97c <memset+0x1c>
+     968:	87aa                	mv	a5,a0
+     96a:	1602                	slli	a2,a2,0x20
+     96c:	9201                	srli	a2,a2,0x20
+     96e:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+     972:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+     976:	0785                	addi	a5,a5,1
+     978:	fee79de3          	bne	a5,a4,972 <memset+0x12>
+  }
+  return dst;
+}
+     97c:	6422                	ld	s0,8(sp)
+     97e:	0141                	addi	sp,sp,16
+     980:	8082                	ret
+
+0000000000000982 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+     982:	1141                	addi	sp,sp,-16
+     984:	e422                	sd	s0,8(sp)
+     986:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+     988:	00054783          	lbu	a5,0(a0)
+     98c:	cb99                	beqz	a5,9a2 <strchr+0x20>
+    if(*s == c)
+     98e:	00f58763          	beq	a1,a5,99c <strchr+0x1a>
+  for(; *s; s++)
+     992:	0505                	addi	a0,a0,1
+     994:	00054783          	lbu	a5,0(a0)
+     998:	fbfd                	bnez	a5,98e <strchr+0xc>
+      return (char*)s;
+  return 0;
+     99a:	4501                	li	a0,0
+}
+     99c:	6422                	ld	s0,8(sp)
+     99e:	0141                	addi	sp,sp,16
+     9a0:	8082                	ret
+  return 0;
+     9a2:	4501                	li	a0,0
+     9a4:	bfe5                	j	99c <strchr+0x1a>
+
+00000000000009a6 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+     9a6:	711d                	addi	sp,sp,-96
+     9a8:	ec86                	sd	ra,88(sp)
+     9aa:	e8a2                	sd	s0,80(sp)
+     9ac:	e4a6                	sd	s1,72(sp)
+     9ae:	e0ca                	sd	s2,64(sp)
+     9b0:	fc4e                	sd	s3,56(sp)
+     9b2:	f852                	sd	s4,48(sp)
+     9b4:	f456                	sd	s5,40(sp)
+     9b6:	f05a                	sd	s6,32(sp)
+     9b8:	ec5e                	sd	s7,24(sp)
+     9ba:	1080                	addi	s0,sp,96
+     9bc:	8baa                	mv	s7,a0
+     9be:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     9c0:	892a                	mv	s2,a0
+     9c2:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+     9c4:	4aa9                	li	s5,10
+     9c6:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+     9c8:	89a6                	mv	s3,s1
+     9ca:	2485                	addiw	s1,s1,1
+     9cc:	0344d663          	bge	s1,s4,9f8 <gets+0x52>
+    cc = read(0, &c, 1);
+     9d0:	4605                	li	a2,1
+     9d2:	faf40593          	addi	a1,s0,-81
+     9d6:	4501                	li	a0,0
+     9d8:	1b2000ef          	jal	b8a <read>
+    if(cc < 1)
+     9dc:	00a05e63          	blez	a0,9f8 <gets+0x52>
+    buf[i++] = c;
+     9e0:	faf44783          	lbu	a5,-81(s0)
+     9e4:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+     9e8:	01578763          	beq	a5,s5,9f6 <gets+0x50>
+     9ec:	0905                	addi	s2,s2,1
+     9ee:	fd679de3          	bne	a5,s6,9c8 <gets+0x22>
+    buf[i++] = c;
+     9f2:	89a6                	mv	s3,s1
+     9f4:	a011                	j	9f8 <gets+0x52>
+     9f6:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+     9f8:	99de                	add	s3,s3,s7
+     9fa:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+     9fe:	855e                	mv	a0,s7
+     a00:	60e6                	ld	ra,88(sp)
+     a02:	6446                	ld	s0,80(sp)
+     a04:	64a6                	ld	s1,72(sp)
+     a06:	6906                	ld	s2,64(sp)
+     a08:	79e2                	ld	s3,56(sp)
+     a0a:	7a42                	ld	s4,48(sp)
+     a0c:	7aa2                	ld	s5,40(sp)
+     a0e:	7b02                	ld	s6,32(sp)
+     a10:	6be2                	ld	s7,24(sp)
+     a12:	6125                	addi	sp,sp,96
+     a14:	8082                	ret
+
+0000000000000a16 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+     a16:	1101                	addi	sp,sp,-32
+     a18:	ec06                	sd	ra,24(sp)
+     a1a:	e822                	sd	s0,16(sp)
+     a1c:	e04a                	sd	s2,0(sp)
+     a1e:	1000                	addi	s0,sp,32
+     a20:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+     a22:	4581                	li	a1,0
+     a24:	18e000ef          	jal	bb2 <open>
+  if(fd < 0)
+     a28:	02054263          	bltz	a0,a4c <stat+0x36>
+     a2c:	e426                	sd	s1,8(sp)
+     a2e:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+     a30:	85ca                	mv	a1,s2
+     a32:	198000ef          	jal	bca <fstat>
+     a36:	892a                	mv	s2,a0
+  close(fd);
+     a38:	8526                	mv	a0,s1
+     a3a:	160000ef          	jal	b9a <close>
+  return r;
+     a3e:	64a2                	ld	s1,8(sp)
+}
+     a40:	854a                	mv	a0,s2
+     a42:	60e2                	ld	ra,24(sp)
+     a44:	6442                	ld	s0,16(sp)
+     a46:	6902                	ld	s2,0(sp)
+     a48:	6105                	addi	sp,sp,32
+     a4a:	8082                	ret
+    return -1;
+     a4c:	597d                	li	s2,-1
+     a4e:	bfcd                	j	a40 <stat+0x2a>
+
+0000000000000a50 <atoi>:
+
+int
+atoi(const char *s)
+{
+     a50:	1141                	addi	sp,sp,-16
+     a52:	e422                	sd	s0,8(sp)
+     a54:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+     a56:	00054683          	lbu	a3,0(a0)
+     a5a:	fd06879b          	addiw	a5,a3,-48
+     a5e:	0ff7f793          	zext.b	a5,a5
+     a62:	4625                	li	a2,9
+     a64:	02f66863          	bltu	a2,a5,a94 <atoi+0x44>
+     a68:	872a                	mv	a4,a0
+  n = 0;
+     a6a:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+     a6c:	0705                	addi	a4,a4,1
+     a6e:	0025179b          	slliw	a5,a0,0x2
+     a72:	9fa9                	addw	a5,a5,a0
+     a74:	0017979b          	slliw	a5,a5,0x1
+     a78:	9fb5                	addw	a5,a5,a3
+     a7a:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+     a7e:	00074683          	lbu	a3,0(a4)
+     a82:	fd06879b          	addiw	a5,a3,-48
+     a86:	0ff7f793          	zext.b	a5,a5
+     a8a:	fef671e3          	bgeu	a2,a5,a6c <atoi+0x1c>
+  return n;
+}
+     a8e:	6422                	ld	s0,8(sp)
+     a90:	0141                	addi	sp,sp,16
+     a92:	8082                	ret
+  n = 0;
+     a94:	4501                	li	a0,0
+     a96:	bfe5                	j	a8e <atoi+0x3e>
+
+0000000000000a98 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+     a98:	1141                	addi	sp,sp,-16
+     a9a:	e422                	sd	s0,8(sp)
+     a9c:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+     a9e:	02b57463          	bgeu	a0,a1,ac6 <memmove+0x2e>
+    while(n-- > 0)
+     aa2:	00c05f63          	blez	a2,ac0 <memmove+0x28>
+     aa6:	1602                	slli	a2,a2,0x20
+     aa8:	9201                	srli	a2,a2,0x20
+     aaa:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+     aae:	872a                	mv	a4,a0
+      *dst++ = *src++;
+     ab0:	0585                	addi	a1,a1,1
+     ab2:	0705                	addi	a4,a4,1
+     ab4:	fff5c683          	lbu	a3,-1(a1)
+     ab8:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+     abc:	fef71ae3          	bne	a4,a5,ab0 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+     ac0:	6422                	ld	s0,8(sp)
+     ac2:	0141                	addi	sp,sp,16
+     ac4:	8082                	ret
+    dst += n;
+     ac6:	00c50733          	add	a4,a0,a2
+    src += n;
+     aca:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+     acc:	fec05ae3          	blez	a2,ac0 <memmove+0x28>
+     ad0:	fff6079b          	addiw	a5,a2,-1
+     ad4:	1782                	slli	a5,a5,0x20
+     ad6:	9381                	srli	a5,a5,0x20
+     ad8:	fff7c793          	not	a5,a5
+     adc:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+     ade:	15fd                	addi	a1,a1,-1
+     ae0:	177d                	addi	a4,a4,-1
+     ae2:	0005c683          	lbu	a3,0(a1)
+     ae6:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+     aea:	fee79ae3          	bne	a5,a4,ade <memmove+0x46>
+     aee:	bfc9                	j	ac0 <memmove+0x28>
+
+0000000000000af0 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+     af0:	1141                	addi	sp,sp,-16
+     af2:	e422                	sd	s0,8(sp)
+     af4:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+     af6:	ca05                	beqz	a2,b26 <memcmp+0x36>
+     af8:	fff6069b          	addiw	a3,a2,-1
+     afc:	1682                	slli	a3,a3,0x20
+     afe:	9281                	srli	a3,a3,0x20
+     b00:	0685                	addi	a3,a3,1
+     b02:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+     b04:	00054783          	lbu	a5,0(a0)
+     b08:	0005c703          	lbu	a4,0(a1)
+     b0c:	00e79863          	bne	a5,a4,b1c <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+     b10:	0505                	addi	a0,a0,1
+    p2++;
+     b12:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+     b14:	fed518e3          	bne	a0,a3,b04 <memcmp+0x14>
+  }
+  return 0;
+     b18:	4501                	li	a0,0
+     b1a:	a019                	j	b20 <memcmp+0x30>
+      return *p1 - *p2;
+     b1c:	40e7853b          	subw	a0,a5,a4
+}
+     b20:	6422                	ld	s0,8(sp)
+     b22:	0141                	addi	sp,sp,16
+     b24:	8082                	ret
+  return 0;
+     b26:	4501                	li	a0,0
+     b28:	bfe5                	j	b20 <memcmp+0x30>
+
+0000000000000b2a <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+     b2a:	1141                	addi	sp,sp,-16
+     b2c:	e406                	sd	ra,8(sp)
+     b2e:	e022                	sd	s0,0(sp)
+     b30:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+     b32:	f67ff0ef          	jal	a98 <memmove>
+}
+     b36:	60a2                	ld	ra,8(sp)
+     b38:	6402                	ld	s0,0(sp)
+     b3a:	0141                	addi	sp,sp,16
+     b3c:	8082                	ret
+
+0000000000000b3e <sbrk>:
+
+char *
+sbrk(int n) {
+     b3e:	1141                	addi	sp,sp,-16
+     b40:	e406                	sd	ra,8(sp)
+     b42:	e022                	sd	s0,0(sp)
+     b44:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+     b46:	4585                	li	a1,1
+     b48:	0b2000ef          	jal	bfa <sys_sbrk>
+}
+     b4c:	60a2                	ld	ra,8(sp)
+     b4e:	6402                	ld	s0,0(sp)
+     b50:	0141                	addi	sp,sp,16
+     b52:	8082                	ret
+
+0000000000000b54 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+     b54:	1141                	addi	sp,sp,-16
+     b56:	e406                	sd	ra,8(sp)
+     b58:	e022                	sd	s0,0(sp)
+     b5a:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+     b5c:	4589                	li	a1,2
+     b5e:	09c000ef          	jal	bfa <sys_sbrk>
+}
+     b62:	60a2                	ld	ra,8(sp)
+     b64:	6402                	ld	s0,0(sp)
+     b66:	0141                	addi	sp,sp,16
+     b68:	8082                	ret
+
+0000000000000b6a <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+     b6a:	4885                	li	a7,1
+ ecall
+     b6c:	00000073          	ecall
+ ret
+     b70:	8082                	ret
+
+0000000000000b72 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+     b72:	4889                	li	a7,2
+ ecall
+     b74:	00000073          	ecall
+ ret
+     b78:	8082                	ret
+
+0000000000000b7a <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+     b7a:	488d                	li	a7,3
+ ecall
+     b7c:	00000073          	ecall
+ ret
+     b80:	8082                	ret
+
+0000000000000b82 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+     b82:	4891                	li	a7,4
+ ecall
+     b84:	00000073          	ecall
+ ret
+     b88:	8082                	ret
+
+0000000000000b8a <read>:
+.global read
+read:
+ li a7, SYS_read
+     b8a:	4895                	li	a7,5
+ ecall
+     b8c:	00000073          	ecall
+ ret
+     b90:	8082                	ret
+
+0000000000000b92 <write>:
+.global write
+write:
+ li a7, SYS_write
+     b92:	48c1                	li	a7,16
+ ecall
+     b94:	00000073          	ecall
+ ret
+     b98:	8082                	ret
+
+0000000000000b9a <close>:
+.global close
+close:
+ li a7, SYS_close
+     b9a:	48d5                	li	a7,21
+ ecall
+     b9c:	00000073          	ecall
+ ret
+     ba0:	8082                	ret
+
+0000000000000ba2 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+     ba2:	4899                	li	a7,6
+ ecall
+     ba4:	00000073          	ecall
+ ret
+     ba8:	8082                	ret
+
+0000000000000baa <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+     baa:	489d                	li	a7,7
+ ecall
+     bac:	00000073          	ecall
+ ret
+     bb0:	8082                	ret
+
+0000000000000bb2 <open>:
+.global open
+open:
+ li a7, SYS_open
+     bb2:	48bd                	li	a7,15
+ ecall
+     bb4:	00000073          	ecall
+ ret
+     bb8:	8082                	ret
+
+0000000000000bba <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+     bba:	48c5                	li	a7,17
+ ecall
+     bbc:	00000073          	ecall
+ ret
+     bc0:	8082                	ret
+
+0000000000000bc2 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+     bc2:	48c9                	li	a7,18
+ ecall
+     bc4:	00000073          	ecall
+ ret
+     bc8:	8082                	ret
+
+0000000000000bca <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+     bca:	48a1                	li	a7,8
+ ecall
+     bcc:	00000073          	ecall
+ ret
+     bd0:	8082                	ret
+
+0000000000000bd2 <link>:
+.global link
+link:
+ li a7, SYS_link
+     bd2:	48cd                	li	a7,19
+ ecall
+     bd4:	00000073          	ecall
+ ret
+     bd8:	8082                	ret
+
+0000000000000bda <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+     bda:	48d1                	li	a7,20
+ ecall
+     bdc:	00000073          	ecall
+ ret
+     be0:	8082                	ret
+
+0000000000000be2 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+     be2:	48a5                	li	a7,9
+ ecall
+     be4:	00000073          	ecall
+ ret
+     be8:	8082                	ret
+
+0000000000000bea <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+     bea:	48a9                	li	a7,10
+ ecall
+     bec:	00000073          	ecall
+ ret
+     bf0:	8082                	ret
+
+0000000000000bf2 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+     bf2:	48ad                	li	a7,11
+ ecall
+     bf4:	00000073          	ecall
+ ret
+     bf8:	8082                	ret
+
+0000000000000bfa <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+     bfa:	48b1                	li	a7,12
+ ecall
+     bfc:	00000073          	ecall
+ ret
+     c00:	8082                	ret
+
+0000000000000c02 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+     c02:	48b5                	li	a7,13
+ ecall
+     c04:	00000073          	ecall
+ ret
+     c08:	8082                	ret
+
+0000000000000c0a <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+     c0a:	48b9                	li	a7,14
+ ecall
+     c0c:	00000073          	ecall
+ ret
+     c10:	8082                	ret
+
+0000000000000c12 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+     c12:	48d9                	li	a7,22
+ ecall
+     c14:	00000073          	ecall
+ ret
+     c18:	8082                	ret
+
+0000000000000c1a <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+     c1a:	1101                	addi	sp,sp,-32
+     c1c:	ec06                	sd	ra,24(sp)
+     c1e:	e822                	sd	s0,16(sp)
+     c20:	1000                	addi	s0,sp,32
+     c22:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+     c26:	4605                	li	a2,1
+     c28:	fef40593          	addi	a1,s0,-17
+     c2c:	f67ff0ef          	jal	b92 <write>
+}
+     c30:	60e2                	ld	ra,24(sp)
+     c32:	6442                	ld	s0,16(sp)
+     c34:	6105                	addi	sp,sp,32
+     c36:	8082                	ret
+
+0000000000000c38 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+     c38:	715d                	addi	sp,sp,-80
+     c3a:	e486                	sd	ra,72(sp)
+     c3c:	e0a2                	sd	s0,64(sp)
+     c3e:	f84a                	sd	s2,48(sp)
+     c40:	0880                	addi	s0,sp,80
+     c42:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+     c44:	c299                	beqz	a3,c4a <printint+0x12>
+     c46:	0805c363          	bltz	a1,ccc <printint+0x94>
+  neg = 0;
+     c4a:	4881                	li	a7,0
+     c4c:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+     c50:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+     c52:	00001517          	auipc	a0,0x1
+     c56:	86e50513          	addi	a0,a0,-1938 # 14c0 <digits>
+     c5a:	883e                	mv	a6,a5
+     c5c:	2785                	addiw	a5,a5,1
+     c5e:	02c5f733          	remu	a4,a1,a2
+     c62:	972a                	add	a4,a4,a0
+     c64:	00074703          	lbu	a4,0(a4)
+     c68:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+     c6c:	872e                	mv	a4,a1
+     c6e:	02c5d5b3          	divu	a1,a1,a2
+     c72:	0685                	addi	a3,a3,1
+     c74:	fec773e3          	bgeu	a4,a2,c5a <printint+0x22>
+  if(neg)
+     c78:	00088b63          	beqz	a7,c8e <printint+0x56>
+    buf[i++] = '-';
+     c7c:	fd078793          	addi	a5,a5,-48
+     c80:	97a2                	add	a5,a5,s0
+     c82:	02d00713          	li	a4,45
+     c86:	fee78423          	sb	a4,-24(a5)
+     c8a:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+     c8e:	02f05a63          	blez	a5,cc2 <printint+0x8a>
+     c92:	fc26                	sd	s1,56(sp)
+     c94:	f44e                	sd	s3,40(sp)
+     c96:	fb840713          	addi	a4,s0,-72
+     c9a:	00f704b3          	add	s1,a4,a5
+     c9e:	fff70993          	addi	s3,a4,-1
+     ca2:	99be                	add	s3,s3,a5
+     ca4:	37fd                	addiw	a5,a5,-1
+     ca6:	1782                	slli	a5,a5,0x20
+     ca8:	9381                	srli	a5,a5,0x20
+     caa:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+     cae:	fff4c583          	lbu	a1,-1(s1)
+     cb2:	854a                	mv	a0,s2
+     cb4:	f67ff0ef          	jal	c1a <putc>
+  while(--i >= 0)
+     cb8:	14fd                	addi	s1,s1,-1
+     cba:	ff349ae3          	bne	s1,s3,cae <printint+0x76>
+     cbe:	74e2                	ld	s1,56(sp)
+     cc0:	79a2                	ld	s3,40(sp)
+}
+     cc2:	60a6                	ld	ra,72(sp)
+     cc4:	6406                	ld	s0,64(sp)
+     cc6:	7942                	ld	s2,48(sp)
+     cc8:	6161                	addi	sp,sp,80
+     cca:	8082                	ret
+    x = -xx;
+     ccc:	40b005b3          	neg	a1,a1
+    neg = 1;
+     cd0:	4885                	li	a7,1
+    x = -xx;
+     cd2:	bfad                	j	c4c <printint+0x14>
+
+0000000000000cd4 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+     cd4:	711d                	addi	sp,sp,-96
+     cd6:	ec86                	sd	ra,88(sp)
+     cd8:	e8a2                	sd	s0,80(sp)
+     cda:	e0ca                	sd	s2,64(sp)
+     cdc:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+     cde:	0005c903          	lbu	s2,0(a1)
+     ce2:	28090663          	beqz	s2,f6e <vprintf+0x29a>
+     ce6:	e4a6                	sd	s1,72(sp)
+     ce8:	fc4e                	sd	s3,56(sp)
+     cea:	f852                	sd	s4,48(sp)
+     cec:	f456                	sd	s5,40(sp)
+     cee:	f05a                	sd	s6,32(sp)
+     cf0:	ec5e                	sd	s7,24(sp)
+     cf2:	e862                	sd	s8,16(sp)
+     cf4:	e466                	sd	s9,8(sp)
+     cf6:	8b2a                	mv	s6,a0
+     cf8:	8a2e                	mv	s4,a1
+     cfa:	8bb2                	mv	s7,a2
+  state = 0;
+     cfc:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+     cfe:	4481                	li	s1,0
+     d00:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+     d02:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+     d06:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+     d0a:	06c00c93          	li	s9,108
+     d0e:	a005                	j	d2e <vprintf+0x5a>
+        putc(fd, c0);
+     d10:	85ca                	mv	a1,s2
+     d12:	855a                	mv	a0,s6
+     d14:	f07ff0ef          	jal	c1a <putc>
+     d18:	a019                	j	d1e <vprintf+0x4a>
+    } else if(state == '%'){
+     d1a:	03598263          	beq	s3,s5,d3e <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+     d1e:	2485                	addiw	s1,s1,1
+     d20:	8726                	mv	a4,s1
+     d22:	009a07b3          	add	a5,s4,s1
+     d26:	0007c903          	lbu	s2,0(a5)
+     d2a:	22090a63          	beqz	s2,f5e <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+     d2e:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+     d32:	fe0994e3          	bnez	s3,d1a <vprintf+0x46>
+      if(c0 == '%'){
+     d36:	fd579de3          	bne	a5,s5,d10 <vprintf+0x3c>
+        state = '%';
+     d3a:	89be                	mv	s3,a5
+     d3c:	b7cd                	j	d1e <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+     d3e:	00ea06b3          	add	a3,s4,a4
+     d42:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+     d46:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+     d48:	c681                	beqz	a3,d50 <vprintf+0x7c>
+     d4a:	9752                	add	a4,a4,s4
+     d4c:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+     d50:	05878363          	beq	a5,s8,d96 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+     d54:	05978d63          	beq	a5,s9,dae <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+     d58:	07500713          	li	a4,117
+     d5c:	0ee78763          	beq	a5,a4,e4a <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+     d60:	07800713          	li	a4,120
+     d64:	12e78963          	beq	a5,a4,e96 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+     d68:	07000713          	li	a4,112
+     d6c:	14e78e63          	beq	a5,a4,ec8 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+     d70:	06300713          	li	a4,99
+     d74:	18e78e63          	beq	a5,a4,f10 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+     d78:	07300713          	li	a4,115
+     d7c:	1ae78463          	beq	a5,a4,f24 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+     d80:	02500713          	li	a4,37
+     d84:	04e79563          	bne	a5,a4,dce <vprintf+0xfa>
+        putc(fd, '%');
+     d88:	02500593          	li	a1,37
+     d8c:	855a                	mv	a0,s6
+     d8e:	e8dff0ef          	jal	c1a <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+     d92:	4981                	li	s3,0
+     d94:	b769                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+     d96:	008b8913          	addi	s2,s7,8
+     d9a:	4685                	li	a3,1
+     d9c:	4629                	li	a2,10
+     d9e:	000ba583          	lw	a1,0(s7)
+     da2:	855a                	mv	a0,s6
+     da4:	e95ff0ef          	jal	c38 <printint>
+     da8:	8bca                	mv	s7,s2
+      state = 0;
+     daa:	4981                	li	s3,0
+     dac:	bf8d                	j	d1e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+     dae:	06400793          	li	a5,100
+     db2:	02f68963          	beq	a3,a5,de4 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+     db6:	06c00793          	li	a5,108
+     dba:	04f68263          	beq	a3,a5,dfe <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+     dbe:	07500793          	li	a5,117
+     dc2:	0af68063          	beq	a3,a5,e62 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+     dc6:	07800793          	li	a5,120
+     dca:	0ef68263          	beq	a3,a5,eae <vprintf+0x1da>
+        putc(fd, '%');
+     dce:	02500593          	li	a1,37
+     dd2:	855a                	mv	a0,s6
+     dd4:	e47ff0ef          	jal	c1a <putc>
+        putc(fd, c0);
+     dd8:	85ca                	mv	a1,s2
+     dda:	855a                	mv	a0,s6
+     ddc:	e3fff0ef          	jal	c1a <putc>
+      state = 0;
+     de0:	4981                	li	s3,0
+     de2:	bf35                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     de4:	008b8913          	addi	s2,s7,8
+     de8:	4685                	li	a3,1
+     dea:	4629                	li	a2,10
+     dec:	000bb583          	ld	a1,0(s7)
+     df0:	855a                	mv	a0,s6
+     df2:	e47ff0ef          	jal	c38 <printint>
+        i += 1;
+     df6:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     df8:	8bca                	mv	s7,s2
+      state = 0;
+     dfa:	4981                	li	s3,0
+        i += 1;
+     dfc:	b70d                	j	d1e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+     dfe:	06400793          	li	a5,100
+     e02:	02f60763          	beq	a2,a5,e30 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+     e06:	07500793          	li	a5,117
+     e0a:	06f60963          	beq	a2,a5,e7c <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+     e0e:	07800793          	li	a5,120
+     e12:	faf61ee3          	bne	a2,a5,dce <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     e16:	008b8913          	addi	s2,s7,8
+     e1a:	4681                	li	a3,0
+     e1c:	4641                	li	a2,16
+     e1e:	000bb583          	ld	a1,0(s7)
+     e22:	855a                	mv	a0,s6
+     e24:	e15ff0ef          	jal	c38 <printint>
+        i += 2;
+     e28:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     e2a:	8bca                	mv	s7,s2
+      state = 0;
+     e2c:	4981                	li	s3,0
+        i += 2;
+     e2e:	bdc5                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     e30:	008b8913          	addi	s2,s7,8
+     e34:	4685                	li	a3,1
+     e36:	4629                	li	a2,10
+     e38:	000bb583          	ld	a1,0(s7)
+     e3c:	855a                	mv	a0,s6
+     e3e:	dfbff0ef          	jal	c38 <printint>
+        i += 2;
+     e42:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     e44:	8bca                	mv	s7,s2
+      state = 0;
+     e46:	4981                	li	s3,0
+        i += 2;
+     e48:	bdd9                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+     e4a:	008b8913          	addi	s2,s7,8
+     e4e:	4681                	li	a3,0
+     e50:	4629                	li	a2,10
+     e52:	000be583          	lwu	a1,0(s7)
+     e56:	855a                	mv	a0,s6
+     e58:	de1ff0ef          	jal	c38 <printint>
+     e5c:	8bca                	mv	s7,s2
+      state = 0;
+     e5e:	4981                	li	s3,0
+     e60:	bd7d                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     e62:	008b8913          	addi	s2,s7,8
+     e66:	4681                	li	a3,0
+     e68:	4629                	li	a2,10
+     e6a:	000bb583          	ld	a1,0(s7)
+     e6e:	855a                	mv	a0,s6
+     e70:	dc9ff0ef          	jal	c38 <printint>
+        i += 1;
+     e74:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     e76:	8bca                	mv	s7,s2
+      state = 0;
+     e78:	4981                	li	s3,0
+        i += 1;
+     e7a:	b555                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     e7c:	008b8913          	addi	s2,s7,8
+     e80:	4681                	li	a3,0
+     e82:	4629                	li	a2,10
+     e84:	000bb583          	ld	a1,0(s7)
+     e88:	855a                	mv	a0,s6
+     e8a:	dafff0ef          	jal	c38 <printint>
+        i += 2;
+     e8e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     e90:	8bca                	mv	s7,s2
+      state = 0;
+     e92:	4981                	li	s3,0
+        i += 2;
+     e94:	b569                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+     e96:	008b8913          	addi	s2,s7,8
+     e9a:	4681                	li	a3,0
+     e9c:	4641                	li	a2,16
+     e9e:	000be583          	lwu	a1,0(s7)
+     ea2:	855a                	mv	a0,s6
+     ea4:	d95ff0ef          	jal	c38 <printint>
+     ea8:	8bca                	mv	s7,s2
+      state = 0;
+     eaa:	4981                	li	s3,0
+     eac:	bd8d                	j	d1e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     eae:	008b8913          	addi	s2,s7,8
+     eb2:	4681                	li	a3,0
+     eb4:	4641                	li	a2,16
+     eb6:	000bb583          	ld	a1,0(s7)
+     eba:	855a                	mv	a0,s6
+     ebc:	d7dff0ef          	jal	c38 <printint>
+        i += 1;
+     ec0:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     ec2:	8bca                	mv	s7,s2
+      state = 0;
+     ec4:	4981                	li	s3,0
+        i += 1;
+     ec6:	bda1                	j	d1e <vprintf+0x4a>
+     ec8:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+     eca:	008b8d13          	addi	s10,s7,8
+     ece:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+     ed2:	03000593          	li	a1,48
+     ed6:	855a                	mv	a0,s6
+     ed8:	d43ff0ef          	jal	c1a <putc>
+  putc(fd, 'x');
+     edc:	07800593          	li	a1,120
+     ee0:	855a                	mv	a0,s6
+     ee2:	d39ff0ef          	jal	c1a <putc>
+     ee6:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+     ee8:	00000b97          	auipc	s7,0x0
+     eec:	5d8b8b93          	addi	s7,s7,1496 # 14c0 <digits>
+     ef0:	03c9d793          	srli	a5,s3,0x3c
+     ef4:	97de                	add	a5,a5,s7
+     ef6:	0007c583          	lbu	a1,0(a5)
+     efa:	855a                	mv	a0,s6
+     efc:	d1fff0ef          	jal	c1a <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+     f00:	0992                	slli	s3,s3,0x4
+     f02:	397d                	addiw	s2,s2,-1
+     f04:	fe0916e3          	bnez	s2,ef0 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+     f08:	8bea                	mv	s7,s10
+      state = 0;
+     f0a:	4981                	li	s3,0
+     f0c:	6d02                	ld	s10,0(sp)
+     f0e:	bd01                	j	d1e <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+     f10:	008b8913          	addi	s2,s7,8
+     f14:	000bc583          	lbu	a1,0(s7)
+     f18:	855a                	mv	a0,s6
+     f1a:	d01ff0ef          	jal	c1a <putc>
+     f1e:	8bca                	mv	s7,s2
+      state = 0;
+     f20:	4981                	li	s3,0
+     f22:	bbf5                	j	d1e <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+     f24:	008b8993          	addi	s3,s7,8
+     f28:	000bb903          	ld	s2,0(s7)
+     f2c:	00090f63          	beqz	s2,f4a <vprintf+0x276>
+        for(; *s; s++)
+     f30:	00094583          	lbu	a1,0(s2)
+     f34:	c195                	beqz	a1,f58 <vprintf+0x284>
+          putc(fd, *s);
+     f36:	855a                	mv	a0,s6
+     f38:	ce3ff0ef          	jal	c1a <putc>
+        for(; *s; s++)
+     f3c:	0905                	addi	s2,s2,1
+     f3e:	00094583          	lbu	a1,0(s2)
+     f42:	f9f5                	bnez	a1,f36 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+     f44:	8bce                	mv	s7,s3
+      state = 0;
+     f46:	4981                	li	s3,0
+     f48:	bbd9                	j	d1e <vprintf+0x4a>
+          s = "(null)";
+     f4a:	00000917          	auipc	s2,0x0
+     f4e:	50e90913          	addi	s2,s2,1294 # 1458 <malloc+0x402>
+        for(; *s; s++)
+     f52:	02800593          	li	a1,40
+     f56:	b7c5                	j	f36 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+     f58:	8bce                	mv	s7,s3
+      state = 0;
+     f5a:	4981                	li	s3,0
+     f5c:	b3c9                	j	d1e <vprintf+0x4a>
+     f5e:	64a6                	ld	s1,72(sp)
+     f60:	79e2                	ld	s3,56(sp)
+     f62:	7a42                	ld	s4,48(sp)
+     f64:	7aa2                	ld	s5,40(sp)
+     f66:	7b02                	ld	s6,32(sp)
+     f68:	6be2                	ld	s7,24(sp)
+     f6a:	6c42                	ld	s8,16(sp)
+     f6c:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+     f6e:	60e6                	ld	ra,88(sp)
+     f70:	6446                	ld	s0,80(sp)
+     f72:	6906                	ld	s2,64(sp)
+     f74:	6125                	addi	sp,sp,96
+     f76:	8082                	ret
+
+0000000000000f78 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+     f78:	715d                	addi	sp,sp,-80
+     f7a:	ec06                	sd	ra,24(sp)
+     f7c:	e822                	sd	s0,16(sp)
+     f7e:	1000                	addi	s0,sp,32
+     f80:	e010                	sd	a2,0(s0)
+     f82:	e414                	sd	a3,8(s0)
+     f84:	e818                	sd	a4,16(s0)
+     f86:	ec1c                	sd	a5,24(s0)
+     f88:	03043023          	sd	a6,32(s0)
+     f8c:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+     f90:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+     f94:	8622                	mv	a2,s0
+     f96:	d3fff0ef          	jal	cd4 <vprintf>
+}
+     f9a:	60e2                	ld	ra,24(sp)
+     f9c:	6442                	ld	s0,16(sp)
+     f9e:	6161                	addi	sp,sp,80
+     fa0:	8082                	ret
+
+0000000000000fa2 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+     fa2:	711d                	addi	sp,sp,-96
+     fa4:	ec06                	sd	ra,24(sp)
+     fa6:	e822                	sd	s0,16(sp)
+     fa8:	1000                	addi	s0,sp,32
+     faa:	e40c                	sd	a1,8(s0)
+     fac:	e810                	sd	a2,16(s0)
+     fae:	ec14                	sd	a3,24(s0)
+     fb0:	f018                	sd	a4,32(s0)
+     fb2:	f41c                	sd	a5,40(s0)
+     fb4:	03043823          	sd	a6,48(s0)
+     fb8:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+     fbc:	00840613          	addi	a2,s0,8
+     fc0:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+     fc4:	85aa                	mv	a1,a0
+     fc6:	4505                	li	a0,1
+     fc8:	d0dff0ef          	jal	cd4 <vprintf>
+}
+     fcc:	60e2                	ld	ra,24(sp)
+     fce:	6442                	ld	s0,16(sp)
+     fd0:	6125                	addi	sp,sp,96
+     fd2:	8082                	ret
+
+0000000000000fd4 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+     fd4:	1141                	addi	sp,sp,-16
+     fd6:	e422                	sd	s0,8(sp)
+     fd8:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+     fda:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+     fde:	00001797          	auipc	a5,0x1
+     fe2:	0327b783          	ld	a5,50(a5) # 2010 <freep>
+     fe6:	a02d                	j	1010 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+     fe8:	4618                	lw	a4,8(a2)
+     fea:	9f2d                	addw	a4,a4,a1
+     fec:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+     ff0:	6398                	ld	a4,0(a5)
+     ff2:	6310                	ld	a2,0(a4)
+     ff4:	a83d                	j	1032 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+     ff6:	ff852703          	lw	a4,-8(a0)
+     ffa:	9f31                	addw	a4,a4,a2
+     ffc:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+     ffe:	ff053683          	ld	a3,-16(a0)
+    1002:	a091                	j	1046 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    1004:	6398                	ld	a4,0(a5)
+    1006:	00e7e463          	bltu	a5,a4,100e <free+0x3a>
+    100a:	00e6ea63          	bltu	a3,a4,101e <free+0x4a>
+{
+    100e:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    1010:	fed7fae3          	bgeu	a5,a3,1004 <free+0x30>
+    1014:	6398                	ld	a4,0(a5)
+    1016:	00e6e463          	bltu	a3,a4,101e <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    101a:	fee7eae3          	bltu	a5,a4,100e <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+    101e:	ff852583          	lw	a1,-8(a0)
+    1022:	6390                	ld	a2,0(a5)
+    1024:	02059813          	slli	a6,a1,0x20
+    1028:	01c85713          	srli	a4,a6,0x1c
+    102c:	9736                	add	a4,a4,a3
+    102e:	fae60de3          	beq	a2,a4,fe8 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+    1032:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+    1036:	4790                	lw	a2,8(a5)
+    1038:	02061593          	slli	a1,a2,0x20
+    103c:	01c5d713          	srli	a4,a1,0x1c
+    1040:	973e                	add	a4,a4,a5
+    1042:	fae68ae3          	beq	a3,a4,ff6 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+    1046:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+    1048:	00001717          	auipc	a4,0x1
+    104c:	fcf73423          	sd	a5,-56(a4) # 2010 <freep>
+}
+    1050:	6422                	ld	s0,8(sp)
+    1052:	0141                	addi	sp,sp,16
+    1054:	8082                	ret
+
+0000000000001056 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1056:	7139                	addi	sp,sp,-64
+    1058:	fc06                	sd	ra,56(sp)
+    105a:	f822                	sd	s0,48(sp)
+    105c:	f426                	sd	s1,40(sp)
+    105e:	ec4e                	sd	s3,24(sp)
+    1060:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    1062:	02051493          	slli	s1,a0,0x20
+    1066:	9081                	srli	s1,s1,0x20
+    1068:	04bd                	addi	s1,s1,15
+    106a:	8091                	srli	s1,s1,0x4
+    106c:	0014899b          	addiw	s3,s1,1
+    1070:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+    1072:	00001517          	auipc	a0,0x1
+    1076:	f9e53503          	ld	a0,-98(a0) # 2010 <freep>
+    107a:	c915                	beqz	a0,10ae <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    107c:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    107e:	4798                	lw	a4,8(a5)
+    1080:	08977a63          	bgeu	a4,s1,1114 <malloc+0xbe>
+    1084:	f04a                	sd	s2,32(sp)
+    1086:	e852                	sd	s4,16(sp)
+    1088:	e456                	sd	s5,8(sp)
+    108a:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+    108c:	8a4e                	mv	s4,s3
+    108e:	0009871b          	sext.w	a4,s3
+    1092:	6685                	lui	a3,0x1
+    1094:	00d77363          	bgeu	a4,a3,109a <malloc+0x44>
+    1098:	6a05                	lui	s4,0x1
+    109a:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+    109e:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    10a2:	00001917          	auipc	s2,0x1
+    10a6:	f6e90913          	addi	s2,s2,-146 # 2010 <freep>
+  if(p == SBRK_ERROR)
+    10aa:	5afd                	li	s5,-1
+    10ac:	a081                	j	10ec <malloc+0x96>
+    10ae:	f04a                	sd	s2,32(sp)
+    10b0:	e852                	sd	s4,16(sp)
+    10b2:	e456                	sd	s5,8(sp)
+    10b4:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+    10b6:	00001797          	auipc	a5,0x1
+    10ba:	35278793          	addi	a5,a5,850 # 2408 <base>
+    10be:	00001717          	auipc	a4,0x1
+    10c2:	f4f73923          	sd	a5,-174(a4) # 2010 <freep>
+    10c6:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+    10c8:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+    10cc:	b7c1                	j	108c <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+    10ce:	6398                	ld	a4,0(a5)
+    10d0:	e118                	sd	a4,0(a0)
+    10d2:	a8a9                	j	112c <malloc+0xd6>
+  hp->s.size = nu;
+    10d4:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+    10d8:	0541                	addi	a0,a0,16
+    10da:	efbff0ef          	jal	fd4 <free>
+  return freep;
+    10de:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+    10e2:	c12d                	beqz	a0,1144 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    10e4:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    10e6:	4798                	lw	a4,8(a5)
+    10e8:	02977263          	bgeu	a4,s1,110c <malloc+0xb6>
+    if(p == freep)
+    10ec:	00093703          	ld	a4,0(s2)
+    10f0:	853e                	mv	a0,a5
+    10f2:	fef719e3          	bne	a4,a5,10e4 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+    10f6:	8552                	mv	a0,s4
+    10f8:	a47ff0ef          	jal	b3e <sbrk>
+  if(p == SBRK_ERROR)
+    10fc:	fd551ce3          	bne	a0,s5,10d4 <malloc+0x7e>
+        return 0;
+    1100:	4501                	li	a0,0
+    1102:	7902                	ld	s2,32(sp)
+    1104:	6a42                	ld	s4,16(sp)
+    1106:	6aa2                	ld	s5,8(sp)
+    1108:	6b02                	ld	s6,0(sp)
+    110a:	a03d                	j	1138 <malloc+0xe2>
+    110c:	7902                	ld	s2,32(sp)
+    110e:	6a42                	ld	s4,16(sp)
+    1110:	6aa2                	ld	s5,8(sp)
+    1112:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+    1114:	fae48de3          	beq	s1,a4,10ce <malloc+0x78>
+        p->s.size -= nunits;
+    1118:	4137073b          	subw	a4,a4,s3
+    111c:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+    111e:	02071693          	slli	a3,a4,0x20
+    1122:	01c6d713          	srli	a4,a3,0x1c
+    1126:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+    1128:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+    112c:	00001717          	auipc	a4,0x1
+    1130:	eea73223          	sd	a0,-284(a4) # 2010 <freep>
+      return (void*)(p + 1);
+    1134:	01078513          	addi	a0,a5,16
+  }
+}
+    1138:	70e2                	ld	ra,56(sp)
+    113a:	7442                	ld	s0,48(sp)
+    113c:	74a2                	ld	s1,40(sp)
+    113e:	69e2                	ld	s3,24(sp)
+    1140:	6121                	addi	sp,sp,64
+    1142:	8082                	ret
+    1144:	7902                	ld	s2,32(sp)
+    1146:	6a42                	ld	s4,16(sp)
+    1148:	6aa2                	ld	s5,8(sp)
+    114a:	6b02                	ld	s6,0(sp)
+    114c:	b7f5                	j	1138 <malloc+0xe2>
diff -ruN xv6-riscv/user/grind.d xv62/user/grind.d
--- xv6-riscv/user/grind.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grind.d	2025-09-14 12:32:51.988883087 +0000
@@ -0,0 +1,3 @@
+user/grind.o: user/grind.c kernel/param.h kernel/types.h kernel/stat.h \
+ user/user.h kernel/fs.h kernel/fcntl.h kernel/syscall.h \
+ kernel/memlayout.h kernel/riscv.h
Binary files xv6-riscv/user/grind.o and xv62/user/grind.o differ
diff -ruN xv6-riscv/user/grind.sym xv62/user/grind.sym
--- xv6-riscv/user/grind.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/grind.sym	2025-09-14 12:32:52.012883082 +0000
@@ -0,0 +1,72 @@
+0000000000000000 .text
+0000000000001150 .rodata
+00000000000014d8 .eh_frame
+0000000000002000 .data
+0000000000002010 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_ranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 grind.c
+0000000000002020 buf.0
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000c1a putc
+0000000000000c38 printint
+00000000000014c0 digits
+0000000000000000 umalloc.c
+0000000000002010 freep
+0000000000002408 base
+00000000000008ee strcpy
+0000000000000c02 pause
+0000000000000fa2 printf
+0000000000000bfa sys_sbrk
+0000000000000000 do_rand
+0000000000000a98 memmove
+0000000000000bba mknod
+00000000000009a6 gets
+0000000000000bf2 getpid
+0000000000000b2a memcpy
+0000000000001056 malloc
+0000000000000b54 sbrklazy
+0000000000000b82 pipe
+0000000000000074 go
+00000000000007dc iter
+0000000000000b92 write
+0000000000000bca fstat
+0000000000000f78 fprintf
+0000000000000ba2 kill
+0000000000000cd4 vprintf
+0000000000000be2 chdir
+0000000000000baa exec
+0000000000000b7a wait
+0000000000000058 rand
+0000000000000b8a read
+0000000000000bc2 unlink
+0000000000000af0 memcmp
+0000000000000b6a fork
+0000000000002000 rand_next
+0000000000000b3e sbrk
+0000000000000c0a uptime
+0000000000000960 memset
+00000000000008a8 main
+000000000000090a strcmp
+0000000000000bea dup
+0000000000000c12 getreadcount
+0000000000000a16 stat
+0000000000000bd2 link
+0000000000000b72 exit
+00000000000008de start
+0000000000000a50 atoi
+0000000000000936 strlen
+0000000000000bb2 open
+0000000000000982 strchr
+0000000000000bda mkdir
+0000000000000b9a close
+0000000000000fd4 free
diff -ruN xv6-riscv/user/init.asm xv62/user/init.asm
--- xv6-riscv/user/init.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/init.asm	2025-09-14 12:32:50.868883317 +0000
@@ -0,0 +1,1559 @@
+
+user/_init:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+
+char *argv[] = { "sh", 0 };
+
+int
+main(void)
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	e426                	sd	s1,8(sp)
+   8:	e04a                	sd	s2,0(sp)
+   a:	1000                	addi	s0,sp,32
+  int pid, wpid;
+
+  if(open("console", O_RDWR) < 0){
+   c:	4589                	li	a1,2
+   e:	00001517          	auipc	a0,0x1
+  12:	92250513          	addi	a0,a0,-1758 # 930 <malloc+0xfc>
+  16:	37a000ef          	jal	390 <open>
+  1a:	04054563          	bltz	a0,64 <main+0x64>
+    mknod("console", CONSOLE, 0);
+    open("console", O_RDWR);
+  }
+  dup(0);  // stdout
+  1e:	4501                	li	a0,0
+  20:	3a8000ef          	jal	3c8 <dup>
+  dup(0);  // stderr
+  24:	4501                	li	a0,0
+  26:	3a2000ef          	jal	3c8 <dup>
+
+  for(;;){
+    printf("init: starting sh\n");
+  2a:	00001917          	auipc	s2,0x1
+  2e:	90e90913          	addi	s2,s2,-1778 # 938 <malloc+0x104>
+  32:	854a                	mv	a0,s2
+  34:	74c000ef          	jal	780 <printf>
+    pid = fork();
+  38:	310000ef          	jal	348 <fork>
+  3c:	84aa                	mv	s1,a0
+    if(pid < 0){
+  3e:	04054363          	bltz	a0,84 <main+0x84>
+      printf("init: fork failed\n");
+      exit(1);
+    }
+    if(pid == 0){
+  42:	c931                	beqz	a0,96 <main+0x96>
+    }
+
+    for(;;){
+      // this call to wait() returns if the shell exits,
+      // or if a parentless process exits.
+      wpid = wait((int *) 0);
+  44:	4501                	li	a0,0
+  46:	312000ef          	jal	358 <wait>
+      if(wpid == pid){
+  4a:	fea484e3          	beq	s1,a0,32 <main+0x32>
+        // the shell exited; restart it.
+        break;
+      } else if(wpid < 0){
+  4e:	fe055be3          	bgez	a0,44 <main+0x44>
+        printf("init: wait returned an error\n");
+  52:	00001517          	auipc	a0,0x1
+  56:	93650513          	addi	a0,a0,-1738 # 988 <malloc+0x154>
+  5a:	726000ef          	jal	780 <printf>
+        exit(1);
+  5e:	4505                	li	a0,1
+  60:	2f0000ef          	jal	350 <exit>
+    mknod("console", CONSOLE, 0);
+  64:	4601                	li	a2,0
+  66:	4585                	li	a1,1
+  68:	00001517          	auipc	a0,0x1
+  6c:	8c850513          	addi	a0,a0,-1848 # 930 <malloc+0xfc>
+  70:	328000ef          	jal	398 <mknod>
+    open("console", O_RDWR);
+  74:	4589                	li	a1,2
+  76:	00001517          	auipc	a0,0x1
+  7a:	8ba50513          	addi	a0,a0,-1862 # 930 <malloc+0xfc>
+  7e:	312000ef          	jal	390 <open>
+  82:	bf71                	j	1e <main+0x1e>
+      printf("init: fork failed\n");
+  84:	00001517          	auipc	a0,0x1
+  88:	8cc50513          	addi	a0,a0,-1844 # 950 <malloc+0x11c>
+  8c:	6f4000ef          	jal	780 <printf>
+      exit(1);
+  90:	4505                	li	a0,1
+  92:	2be000ef          	jal	350 <exit>
+      exec("sh", argv);
+  96:	00001597          	auipc	a1,0x1
+  9a:	f6a58593          	addi	a1,a1,-150 # 1000 <argv>
+  9e:	00001517          	auipc	a0,0x1
+  a2:	8ca50513          	addi	a0,a0,-1846 # 968 <malloc+0x134>
+  a6:	2e2000ef          	jal	388 <exec>
+      printf("init: exec sh failed\n");
+  aa:	00001517          	auipc	a0,0x1
+  ae:	8c650513          	addi	a0,a0,-1850 # 970 <malloc+0x13c>
+  b2:	6ce000ef          	jal	780 <printf>
+      exit(1);
+  b6:	4505                	li	a0,1
+  b8:	298000ef          	jal	350 <exit>
+
+00000000000000bc <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  bc:	1141                	addi	sp,sp,-16
+  be:	e406                	sd	ra,8(sp)
+  c0:	e022                	sd	s0,0(sp)
+  c2:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  c4:	f3dff0ef          	jal	0 <main>
+  exit(r);
+  c8:	288000ef          	jal	350 <exit>
+
+00000000000000cc <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  cc:	1141                	addi	sp,sp,-16
+  ce:	e422                	sd	s0,8(sp)
+  d0:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  d2:	87aa                	mv	a5,a0
+  d4:	0585                	addi	a1,a1,1
+  d6:	0785                	addi	a5,a5,1
+  d8:	fff5c703          	lbu	a4,-1(a1)
+  dc:	fee78fa3          	sb	a4,-1(a5)
+  e0:	fb75                	bnez	a4,d4 <strcpy+0x8>
+    ;
+  return os;
+}
+  e2:	6422                	ld	s0,8(sp)
+  e4:	0141                	addi	sp,sp,16
+  e6:	8082                	ret
+
+00000000000000e8 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  e8:	1141                	addi	sp,sp,-16
+  ea:	e422                	sd	s0,8(sp)
+  ec:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  ee:	00054783          	lbu	a5,0(a0)
+  f2:	cb91                	beqz	a5,106 <strcmp+0x1e>
+  f4:	0005c703          	lbu	a4,0(a1)
+  f8:	00f71763          	bne	a4,a5,106 <strcmp+0x1e>
+    p++, q++;
+  fc:	0505                	addi	a0,a0,1
+  fe:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 100:	00054783          	lbu	a5,0(a0)
+ 104:	fbe5                	bnez	a5,f4 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 106:	0005c503          	lbu	a0,0(a1)
+}
+ 10a:	40a7853b          	subw	a0,a5,a0
+ 10e:	6422                	ld	s0,8(sp)
+ 110:	0141                	addi	sp,sp,16
+ 112:	8082                	ret
+
+0000000000000114 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 114:	1141                	addi	sp,sp,-16
+ 116:	e422                	sd	s0,8(sp)
+ 118:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 11a:	00054783          	lbu	a5,0(a0)
+ 11e:	cf91                	beqz	a5,13a <strlen+0x26>
+ 120:	0505                	addi	a0,a0,1
+ 122:	87aa                	mv	a5,a0
+ 124:	86be                	mv	a3,a5
+ 126:	0785                	addi	a5,a5,1
+ 128:	fff7c703          	lbu	a4,-1(a5)
+ 12c:	ff65                	bnez	a4,124 <strlen+0x10>
+ 12e:	40a6853b          	subw	a0,a3,a0
+ 132:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 134:	6422                	ld	s0,8(sp)
+ 136:	0141                	addi	sp,sp,16
+ 138:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 13a:	4501                	li	a0,0
+ 13c:	bfe5                	j	134 <strlen+0x20>
+
+000000000000013e <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 13e:	1141                	addi	sp,sp,-16
+ 140:	e422                	sd	s0,8(sp)
+ 142:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 144:	ca19                	beqz	a2,15a <memset+0x1c>
+ 146:	87aa                	mv	a5,a0
+ 148:	1602                	slli	a2,a2,0x20
+ 14a:	9201                	srli	a2,a2,0x20
+ 14c:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 150:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 154:	0785                	addi	a5,a5,1
+ 156:	fee79de3          	bne	a5,a4,150 <memset+0x12>
+  }
+  return dst;
+}
+ 15a:	6422                	ld	s0,8(sp)
+ 15c:	0141                	addi	sp,sp,16
+ 15e:	8082                	ret
+
+0000000000000160 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 160:	1141                	addi	sp,sp,-16
+ 162:	e422                	sd	s0,8(sp)
+ 164:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 166:	00054783          	lbu	a5,0(a0)
+ 16a:	cb99                	beqz	a5,180 <strchr+0x20>
+    if(*s == c)
+ 16c:	00f58763          	beq	a1,a5,17a <strchr+0x1a>
+  for(; *s; s++)
+ 170:	0505                	addi	a0,a0,1
+ 172:	00054783          	lbu	a5,0(a0)
+ 176:	fbfd                	bnez	a5,16c <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 178:	4501                	li	a0,0
+}
+ 17a:	6422                	ld	s0,8(sp)
+ 17c:	0141                	addi	sp,sp,16
+ 17e:	8082                	ret
+  return 0;
+ 180:	4501                	li	a0,0
+ 182:	bfe5                	j	17a <strchr+0x1a>
+
+0000000000000184 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 184:	711d                	addi	sp,sp,-96
+ 186:	ec86                	sd	ra,88(sp)
+ 188:	e8a2                	sd	s0,80(sp)
+ 18a:	e4a6                	sd	s1,72(sp)
+ 18c:	e0ca                	sd	s2,64(sp)
+ 18e:	fc4e                	sd	s3,56(sp)
+ 190:	f852                	sd	s4,48(sp)
+ 192:	f456                	sd	s5,40(sp)
+ 194:	f05a                	sd	s6,32(sp)
+ 196:	ec5e                	sd	s7,24(sp)
+ 198:	1080                	addi	s0,sp,96
+ 19a:	8baa                	mv	s7,a0
+ 19c:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 19e:	892a                	mv	s2,a0
+ 1a0:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1a2:	4aa9                	li	s5,10
+ 1a4:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1a6:	89a6                	mv	s3,s1
+ 1a8:	2485                	addiw	s1,s1,1
+ 1aa:	0344d663          	bge	s1,s4,1d6 <gets+0x52>
+    cc = read(0, &c, 1);
+ 1ae:	4605                	li	a2,1
+ 1b0:	faf40593          	addi	a1,s0,-81
+ 1b4:	4501                	li	a0,0
+ 1b6:	1b2000ef          	jal	368 <read>
+    if(cc < 1)
+ 1ba:	00a05e63          	blez	a0,1d6 <gets+0x52>
+    buf[i++] = c;
+ 1be:	faf44783          	lbu	a5,-81(s0)
+ 1c2:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1c6:	01578763          	beq	a5,s5,1d4 <gets+0x50>
+ 1ca:	0905                	addi	s2,s2,1
+ 1cc:	fd679de3          	bne	a5,s6,1a6 <gets+0x22>
+    buf[i++] = c;
+ 1d0:	89a6                	mv	s3,s1
+ 1d2:	a011                	j	1d6 <gets+0x52>
+ 1d4:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1d6:	99de                	add	s3,s3,s7
+ 1d8:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1dc:	855e                	mv	a0,s7
+ 1de:	60e6                	ld	ra,88(sp)
+ 1e0:	6446                	ld	s0,80(sp)
+ 1e2:	64a6                	ld	s1,72(sp)
+ 1e4:	6906                	ld	s2,64(sp)
+ 1e6:	79e2                	ld	s3,56(sp)
+ 1e8:	7a42                	ld	s4,48(sp)
+ 1ea:	7aa2                	ld	s5,40(sp)
+ 1ec:	7b02                	ld	s6,32(sp)
+ 1ee:	6be2                	ld	s7,24(sp)
+ 1f0:	6125                	addi	sp,sp,96
+ 1f2:	8082                	ret
+
+00000000000001f4 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1f4:	1101                	addi	sp,sp,-32
+ 1f6:	ec06                	sd	ra,24(sp)
+ 1f8:	e822                	sd	s0,16(sp)
+ 1fa:	e04a                	sd	s2,0(sp)
+ 1fc:	1000                	addi	s0,sp,32
+ 1fe:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 200:	4581                	li	a1,0
+ 202:	18e000ef          	jal	390 <open>
+  if(fd < 0)
+ 206:	02054263          	bltz	a0,22a <stat+0x36>
+ 20a:	e426                	sd	s1,8(sp)
+ 20c:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 20e:	85ca                	mv	a1,s2
+ 210:	198000ef          	jal	3a8 <fstat>
+ 214:	892a                	mv	s2,a0
+  close(fd);
+ 216:	8526                	mv	a0,s1
+ 218:	160000ef          	jal	378 <close>
+  return r;
+ 21c:	64a2                	ld	s1,8(sp)
+}
+ 21e:	854a                	mv	a0,s2
+ 220:	60e2                	ld	ra,24(sp)
+ 222:	6442                	ld	s0,16(sp)
+ 224:	6902                	ld	s2,0(sp)
+ 226:	6105                	addi	sp,sp,32
+ 228:	8082                	ret
+    return -1;
+ 22a:	597d                	li	s2,-1
+ 22c:	bfcd                	j	21e <stat+0x2a>
+
+000000000000022e <atoi>:
+
+int
+atoi(const char *s)
+{
+ 22e:	1141                	addi	sp,sp,-16
+ 230:	e422                	sd	s0,8(sp)
+ 232:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 234:	00054683          	lbu	a3,0(a0)
+ 238:	fd06879b          	addiw	a5,a3,-48
+ 23c:	0ff7f793          	zext.b	a5,a5
+ 240:	4625                	li	a2,9
+ 242:	02f66863          	bltu	a2,a5,272 <atoi+0x44>
+ 246:	872a                	mv	a4,a0
+  n = 0;
+ 248:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 24a:	0705                	addi	a4,a4,1
+ 24c:	0025179b          	slliw	a5,a0,0x2
+ 250:	9fa9                	addw	a5,a5,a0
+ 252:	0017979b          	slliw	a5,a5,0x1
+ 256:	9fb5                	addw	a5,a5,a3
+ 258:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 25c:	00074683          	lbu	a3,0(a4)
+ 260:	fd06879b          	addiw	a5,a3,-48
+ 264:	0ff7f793          	zext.b	a5,a5
+ 268:	fef671e3          	bgeu	a2,a5,24a <atoi+0x1c>
+  return n;
+}
+ 26c:	6422                	ld	s0,8(sp)
+ 26e:	0141                	addi	sp,sp,16
+ 270:	8082                	ret
+  n = 0;
+ 272:	4501                	li	a0,0
+ 274:	bfe5                	j	26c <atoi+0x3e>
+
+0000000000000276 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 276:	1141                	addi	sp,sp,-16
+ 278:	e422                	sd	s0,8(sp)
+ 27a:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 27c:	02b57463          	bgeu	a0,a1,2a4 <memmove+0x2e>
+    while(n-- > 0)
+ 280:	00c05f63          	blez	a2,29e <memmove+0x28>
+ 284:	1602                	slli	a2,a2,0x20
+ 286:	9201                	srli	a2,a2,0x20
+ 288:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 28c:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 28e:	0585                	addi	a1,a1,1
+ 290:	0705                	addi	a4,a4,1
+ 292:	fff5c683          	lbu	a3,-1(a1)
+ 296:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 29a:	fef71ae3          	bne	a4,a5,28e <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 29e:	6422                	ld	s0,8(sp)
+ 2a0:	0141                	addi	sp,sp,16
+ 2a2:	8082                	ret
+    dst += n;
+ 2a4:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2a8:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2aa:	fec05ae3          	blez	a2,29e <memmove+0x28>
+ 2ae:	fff6079b          	addiw	a5,a2,-1
+ 2b2:	1782                	slli	a5,a5,0x20
+ 2b4:	9381                	srli	a5,a5,0x20
+ 2b6:	fff7c793          	not	a5,a5
+ 2ba:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2bc:	15fd                	addi	a1,a1,-1
+ 2be:	177d                	addi	a4,a4,-1
+ 2c0:	0005c683          	lbu	a3,0(a1)
+ 2c4:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2c8:	fee79ae3          	bne	a5,a4,2bc <memmove+0x46>
+ 2cc:	bfc9                	j	29e <memmove+0x28>
+
+00000000000002ce <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2ce:	1141                	addi	sp,sp,-16
+ 2d0:	e422                	sd	s0,8(sp)
+ 2d2:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2d4:	ca05                	beqz	a2,304 <memcmp+0x36>
+ 2d6:	fff6069b          	addiw	a3,a2,-1
+ 2da:	1682                	slli	a3,a3,0x20
+ 2dc:	9281                	srli	a3,a3,0x20
+ 2de:	0685                	addi	a3,a3,1
+ 2e0:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2e2:	00054783          	lbu	a5,0(a0)
+ 2e6:	0005c703          	lbu	a4,0(a1)
+ 2ea:	00e79863          	bne	a5,a4,2fa <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 2ee:	0505                	addi	a0,a0,1
+    p2++;
+ 2f0:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 2f2:	fed518e3          	bne	a0,a3,2e2 <memcmp+0x14>
+  }
+  return 0;
+ 2f6:	4501                	li	a0,0
+ 2f8:	a019                	j	2fe <memcmp+0x30>
+      return *p1 - *p2;
+ 2fa:	40e7853b          	subw	a0,a5,a4
+}
+ 2fe:	6422                	ld	s0,8(sp)
+ 300:	0141                	addi	sp,sp,16
+ 302:	8082                	ret
+  return 0;
+ 304:	4501                	li	a0,0
+ 306:	bfe5                	j	2fe <memcmp+0x30>
+
+0000000000000308 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 308:	1141                	addi	sp,sp,-16
+ 30a:	e406                	sd	ra,8(sp)
+ 30c:	e022                	sd	s0,0(sp)
+ 30e:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 310:	f67ff0ef          	jal	276 <memmove>
+}
+ 314:	60a2                	ld	ra,8(sp)
+ 316:	6402                	ld	s0,0(sp)
+ 318:	0141                	addi	sp,sp,16
+ 31a:	8082                	ret
+
+000000000000031c <sbrk>:
+
+char *
+sbrk(int n) {
+ 31c:	1141                	addi	sp,sp,-16
+ 31e:	e406                	sd	ra,8(sp)
+ 320:	e022                	sd	s0,0(sp)
+ 322:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 324:	4585                	li	a1,1
+ 326:	0b2000ef          	jal	3d8 <sys_sbrk>
+}
+ 32a:	60a2                	ld	ra,8(sp)
+ 32c:	6402                	ld	s0,0(sp)
+ 32e:	0141                	addi	sp,sp,16
+ 330:	8082                	ret
+
+0000000000000332 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 332:	1141                	addi	sp,sp,-16
+ 334:	e406                	sd	ra,8(sp)
+ 336:	e022                	sd	s0,0(sp)
+ 338:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 33a:	4589                	li	a1,2
+ 33c:	09c000ef          	jal	3d8 <sys_sbrk>
+}
+ 340:	60a2                	ld	ra,8(sp)
+ 342:	6402                	ld	s0,0(sp)
+ 344:	0141                	addi	sp,sp,16
+ 346:	8082                	ret
+
+0000000000000348 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 348:	4885                	li	a7,1
+ ecall
+ 34a:	00000073          	ecall
+ ret
+ 34e:	8082                	ret
+
+0000000000000350 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 350:	4889                	li	a7,2
+ ecall
+ 352:	00000073          	ecall
+ ret
+ 356:	8082                	ret
+
+0000000000000358 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 358:	488d                	li	a7,3
+ ecall
+ 35a:	00000073          	ecall
+ ret
+ 35e:	8082                	ret
+
+0000000000000360 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 360:	4891                	li	a7,4
+ ecall
+ 362:	00000073          	ecall
+ ret
+ 366:	8082                	ret
+
+0000000000000368 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 368:	4895                	li	a7,5
+ ecall
+ 36a:	00000073          	ecall
+ ret
+ 36e:	8082                	ret
+
+0000000000000370 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 370:	48c1                	li	a7,16
+ ecall
+ 372:	00000073          	ecall
+ ret
+ 376:	8082                	ret
+
+0000000000000378 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 378:	48d5                	li	a7,21
+ ecall
+ 37a:	00000073          	ecall
+ ret
+ 37e:	8082                	ret
+
+0000000000000380 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 380:	4899                	li	a7,6
+ ecall
+ 382:	00000073          	ecall
+ ret
+ 386:	8082                	ret
+
+0000000000000388 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 388:	489d                	li	a7,7
+ ecall
+ 38a:	00000073          	ecall
+ ret
+ 38e:	8082                	ret
+
+0000000000000390 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 390:	48bd                	li	a7,15
+ ecall
+ 392:	00000073          	ecall
+ ret
+ 396:	8082                	ret
+
+0000000000000398 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 398:	48c5                	li	a7,17
+ ecall
+ 39a:	00000073          	ecall
+ ret
+ 39e:	8082                	ret
+
+00000000000003a0 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3a0:	48c9                	li	a7,18
+ ecall
+ 3a2:	00000073          	ecall
+ ret
+ 3a6:	8082                	ret
+
+00000000000003a8 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3a8:	48a1                	li	a7,8
+ ecall
+ 3aa:	00000073          	ecall
+ ret
+ 3ae:	8082                	ret
+
+00000000000003b0 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3b0:	48cd                	li	a7,19
+ ecall
+ 3b2:	00000073          	ecall
+ ret
+ 3b6:	8082                	ret
+
+00000000000003b8 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3b8:	48d1                	li	a7,20
+ ecall
+ 3ba:	00000073          	ecall
+ ret
+ 3be:	8082                	ret
+
+00000000000003c0 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3c0:	48a5                	li	a7,9
+ ecall
+ 3c2:	00000073          	ecall
+ ret
+ 3c6:	8082                	ret
+
+00000000000003c8 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3c8:	48a9                	li	a7,10
+ ecall
+ 3ca:	00000073          	ecall
+ ret
+ 3ce:	8082                	ret
+
+00000000000003d0 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3d0:	48ad                	li	a7,11
+ ecall
+ 3d2:	00000073          	ecall
+ ret
+ 3d6:	8082                	ret
+
+00000000000003d8 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3d8:	48b1                	li	a7,12
+ ecall
+ 3da:	00000073          	ecall
+ ret
+ 3de:	8082                	ret
+
+00000000000003e0 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3e0:	48b5                	li	a7,13
+ ecall
+ 3e2:	00000073          	ecall
+ ret
+ 3e6:	8082                	ret
+
+00000000000003e8 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 3e8:	48b9                	li	a7,14
+ ecall
+ 3ea:	00000073          	ecall
+ ret
+ 3ee:	8082                	ret
+
+00000000000003f0 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 3f0:	48d9                	li	a7,22
+ ecall
+ 3f2:	00000073          	ecall
+ ret
+ 3f6:	8082                	ret
+
+00000000000003f8 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3f8:	1101                	addi	sp,sp,-32
+ 3fa:	ec06                	sd	ra,24(sp)
+ 3fc:	e822                	sd	s0,16(sp)
+ 3fe:	1000                	addi	s0,sp,32
+ 400:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 404:	4605                	li	a2,1
+ 406:	fef40593          	addi	a1,s0,-17
+ 40a:	f67ff0ef          	jal	370 <write>
+}
+ 40e:	60e2                	ld	ra,24(sp)
+ 410:	6442                	ld	s0,16(sp)
+ 412:	6105                	addi	sp,sp,32
+ 414:	8082                	ret
+
+0000000000000416 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 416:	715d                	addi	sp,sp,-80
+ 418:	e486                	sd	ra,72(sp)
+ 41a:	e0a2                	sd	s0,64(sp)
+ 41c:	f84a                	sd	s2,48(sp)
+ 41e:	0880                	addi	s0,sp,80
+ 420:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 422:	c299                	beqz	a3,428 <printint+0x12>
+ 424:	0805c363          	bltz	a1,4aa <printint+0x94>
+  neg = 0;
+ 428:	4881                	li	a7,0
+ 42a:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 42e:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 430:	00000517          	auipc	a0,0x0
+ 434:	58050513          	addi	a0,a0,1408 # 9b0 <digits>
+ 438:	883e                	mv	a6,a5
+ 43a:	2785                	addiw	a5,a5,1
+ 43c:	02c5f733          	remu	a4,a1,a2
+ 440:	972a                	add	a4,a4,a0
+ 442:	00074703          	lbu	a4,0(a4)
+ 446:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 44a:	872e                	mv	a4,a1
+ 44c:	02c5d5b3          	divu	a1,a1,a2
+ 450:	0685                	addi	a3,a3,1
+ 452:	fec773e3          	bgeu	a4,a2,438 <printint+0x22>
+  if(neg)
+ 456:	00088b63          	beqz	a7,46c <printint+0x56>
+    buf[i++] = '-';
+ 45a:	fd078793          	addi	a5,a5,-48
+ 45e:	97a2                	add	a5,a5,s0
+ 460:	02d00713          	li	a4,45
+ 464:	fee78423          	sb	a4,-24(a5)
+ 468:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 46c:	02f05a63          	blez	a5,4a0 <printint+0x8a>
+ 470:	fc26                	sd	s1,56(sp)
+ 472:	f44e                	sd	s3,40(sp)
+ 474:	fb840713          	addi	a4,s0,-72
+ 478:	00f704b3          	add	s1,a4,a5
+ 47c:	fff70993          	addi	s3,a4,-1
+ 480:	99be                	add	s3,s3,a5
+ 482:	37fd                	addiw	a5,a5,-1
+ 484:	1782                	slli	a5,a5,0x20
+ 486:	9381                	srli	a5,a5,0x20
+ 488:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 48c:	fff4c583          	lbu	a1,-1(s1)
+ 490:	854a                	mv	a0,s2
+ 492:	f67ff0ef          	jal	3f8 <putc>
+  while(--i >= 0)
+ 496:	14fd                	addi	s1,s1,-1
+ 498:	ff349ae3          	bne	s1,s3,48c <printint+0x76>
+ 49c:	74e2                	ld	s1,56(sp)
+ 49e:	79a2                	ld	s3,40(sp)
+}
+ 4a0:	60a6                	ld	ra,72(sp)
+ 4a2:	6406                	ld	s0,64(sp)
+ 4a4:	7942                	ld	s2,48(sp)
+ 4a6:	6161                	addi	sp,sp,80
+ 4a8:	8082                	ret
+    x = -xx;
+ 4aa:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4ae:	4885                	li	a7,1
+    x = -xx;
+ 4b0:	bfad                	j	42a <printint+0x14>
+
+00000000000004b2 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4b2:	711d                	addi	sp,sp,-96
+ 4b4:	ec86                	sd	ra,88(sp)
+ 4b6:	e8a2                	sd	s0,80(sp)
+ 4b8:	e0ca                	sd	s2,64(sp)
+ 4ba:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 4bc:	0005c903          	lbu	s2,0(a1)
+ 4c0:	28090663          	beqz	s2,74c <vprintf+0x29a>
+ 4c4:	e4a6                	sd	s1,72(sp)
+ 4c6:	fc4e                	sd	s3,56(sp)
+ 4c8:	f852                	sd	s4,48(sp)
+ 4ca:	f456                	sd	s5,40(sp)
+ 4cc:	f05a                	sd	s6,32(sp)
+ 4ce:	ec5e                	sd	s7,24(sp)
+ 4d0:	e862                	sd	s8,16(sp)
+ 4d2:	e466                	sd	s9,8(sp)
+ 4d4:	8b2a                	mv	s6,a0
+ 4d6:	8a2e                	mv	s4,a1
+ 4d8:	8bb2                	mv	s7,a2
+  state = 0;
+ 4da:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 4dc:	4481                	li	s1,0
+ 4de:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 4e0:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 4e4:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4e8:	06c00c93          	li	s9,108
+ 4ec:	a005                	j	50c <vprintf+0x5a>
+        putc(fd, c0);
+ 4ee:	85ca                	mv	a1,s2
+ 4f0:	855a                	mv	a0,s6
+ 4f2:	f07ff0ef          	jal	3f8 <putc>
+ 4f6:	a019                	j	4fc <vprintf+0x4a>
+    } else if(state == '%'){
+ 4f8:	03598263          	beq	s3,s5,51c <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4fc:	2485                	addiw	s1,s1,1
+ 4fe:	8726                	mv	a4,s1
+ 500:	009a07b3          	add	a5,s4,s1
+ 504:	0007c903          	lbu	s2,0(a5)
+ 508:	22090a63          	beqz	s2,73c <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 50c:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 510:	fe0994e3          	bnez	s3,4f8 <vprintf+0x46>
+      if(c0 == '%'){
+ 514:	fd579de3          	bne	a5,s5,4ee <vprintf+0x3c>
+        state = '%';
+ 518:	89be                	mv	s3,a5
+ 51a:	b7cd                	j	4fc <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 51c:	00ea06b3          	add	a3,s4,a4
+ 520:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 524:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 526:	c681                	beqz	a3,52e <vprintf+0x7c>
+ 528:	9752                	add	a4,a4,s4
+ 52a:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 52e:	05878363          	beq	a5,s8,574 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 532:	05978d63          	beq	a5,s9,58c <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 536:	07500713          	li	a4,117
+ 53a:	0ee78763          	beq	a5,a4,628 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 53e:	07800713          	li	a4,120
+ 542:	12e78963          	beq	a5,a4,674 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 546:	07000713          	li	a4,112
+ 54a:	14e78e63          	beq	a5,a4,6a6 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 54e:	06300713          	li	a4,99
+ 552:	18e78e63          	beq	a5,a4,6ee <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 556:	07300713          	li	a4,115
+ 55a:	1ae78463          	beq	a5,a4,702 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 55e:	02500713          	li	a4,37
+ 562:	04e79563          	bne	a5,a4,5ac <vprintf+0xfa>
+        putc(fd, '%');
+ 566:	02500593          	li	a1,37
+ 56a:	855a                	mv	a0,s6
+ 56c:	e8dff0ef          	jal	3f8 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 570:	4981                	li	s3,0
+ 572:	b769                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 574:	008b8913          	addi	s2,s7,8
+ 578:	4685                	li	a3,1
+ 57a:	4629                	li	a2,10
+ 57c:	000ba583          	lw	a1,0(s7)
+ 580:	855a                	mv	a0,s6
+ 582:	e95ff0ef          	jal	416 <printint>
+ 586:	8bca                	mv	s7,s2
+      state = 0;
+ 588:	4981                	li	s3,0
+ 58a:	bf8d                	j	4fc <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 58c:	06400793          	li	a5,100
+ 590:	02f68963          	beq	a3,a5,5c2 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 594:	06c00793          	li	a5,108
+ 598:	04f68263          	beq	a3,a5,5dc <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 59c:	07500793          	li	a5,117
+ 5a0:	0af68063          	beq	a3,a5,640 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5a4:	07800793          	li	a5,120
+ 5a8:	0ef68263          	beq	a3,a5,68c <vprintf+0x1da>
+        putc(fd, '%');
+ 5ac:	02500593          	li	a1,37
+ 5b0:	855a                	mv	a0,s6
+ 5b2:	e47ff0ef          	jal	3f8 <putc>
+        putc(fd, c0);
+ 5b6:	85ca                	mv	a1,s2
+ 5b8:	855a                	mv	a0,s6
+ 5ba:	e3fff0ef          	jal	3f8 <putc>
+      state = 0;
+ 5be:	4981                	li	s3,0
+ 5c0:	bf35                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5c2:	008b8913          	addi	s2,s7,8
+ 5c6:	4685                	li	a3,1
+ 5c8:	4629                	li	a2,10
+ 5ca:	000bb583          	ld	a1,0(s7)
+ 5ce:	855a                	mv	a0,s6
+ 5d0:	e47ff0ef          	jal	416 <printint>
+        i += 1;
+ 5d4:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5d6:	8bca                	mv	s7,s2
+      state = 0;
+ 5d8:	4981                	li	s3,0
+        i += 1;
+ 5da:	b70d                	j	4fc <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5dc:	06400793          	li	a5,100
+ 5e0:	02f60763          	beq	a2,a5,60e <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 5e4:	07500793          	li	a5,117
+ 5e8:	06f60963          	beq	a2,a5,65a <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 5ec:	07800793          	li	a5,120
+ 5f0:	faf61ee3          	bne	a2,a5,5ac <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5f4:	008b8913          	addi	s2,s7,8
+ 5f8:	4681                	li	a3,0
+ 5fa:	4641                	li	a2,16
+ 5fc:	000bb583          	ld	a1,0(s7)
+ 600:	855a                	mv	a0,s6
+ 602:	e15ff0ef          	jal	416 <printint>
+        i += 2;
+ 606:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 608:	8bca                	mv	s7,s2
+      state = 0;
+ 60a:	4981                	li	s3,0
+        i += 2;
+ 60c:	bdc5                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 60e:	008b8913          	addi	s2,s7,8
+ 612:	4685                	li	a3,1
+ 614:	4629                	li	a2,10
+ 616:	000bb583          	ld	a1,0(s7)
+ 61a:	855a                	mv	a0,s6
+ 61c:	dfbff0ef          	jal	416 <printint>
+        i += 2;
+ 620:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 622:	8bca                	mv	s7,s2
+      state = 0;
+ 624:	4981                	li	s3,0
+        i += 2;
+ 626:	bdd9                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 628:	008b8913          	addi	s2,s7,8
+ 62c:	4681                	li	a3,0
+ 62e:	4629                	li	a2,10
+ 630:	000be583          	lwu	a1,0(s7)
+ 634:	855a                	mv	a0,s6
+ 636:	de1ff0ef          	jal	416 <printint>
+ 63a:	8bca                	mv	s7,s2
+      state = 0;
+ 63c:	4981                	li	s3,0
+ 63e:	bd7d                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 640:	008b8913          	addi	s2,s7,8
+ 644:	4681                	li	a3,0
+ 646:	4629                	li	a2,10
+ 648:	000bb583          	ld	a1,0(s7)
+ 64c:	855a                	mv	a0,s6
+ 64e:	dc9ff0ef          	jal	416 <printint>
+        i += 1;
+ 652:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 654:	8bca                	mv	s7,s2
+      state = 0;
+ 656:	4981                	li	s3,0
+        i += 1;
+ 658:	b555                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 65a:	008b8913          	addi	s2,s7,8
+ 65e:	4681                	li	a3,0
+ 660:	4629                	li	a2,10
+ 662:	000bb583          	ld	a1,0(s7)
+ 666:	855a                	mv	a0,s6
+ 668:	dafff0ef          	jal	416 <printint>
+        i += 2;
+ 66c:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 66e:	8bca                	mv	s7,s2
+      state = 0;
+ 670:	4981                	li	s3,0
+        i += 2;
+ 672:	b569                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 674:	008b8913          	addi	s2,s7,8
+ 678:	4681                	li	a3,0
+ 67a:	4641                	li	a2,16
+ 67c:	000be583          	lwu	a1,0(s7)
+ 680:	855a                	mv	a0,s6
+ 682:	d95ff0ef          	jal	416 <printint>
+ 686:	8bca                	mv	s7,s2
+      state = 0;
+ 688:	4981                	li	s3,0
+ 68a:	bd8d                	j	4fc <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 68c:	008b8913          	addi	s2,s7,8
+ 690:	4681                	li	a3,0
+ 692:	4641                	li	a2,16
+ 694:	000bb583          	ld	a1,0(s7)
+ 698:	855a                	mv	a0,s6
+ 69a:	d7dff0ef          	jal	416 <printint>
+        i += 1;
+ 69e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6a0:	8bca                	mv	s7,s2
+      state = 0;
+ 6a2:	4981                	li	s3,0
+        i += 1;
+ 6a4:	bda1                	j	4fc <vprintf+0x4a>
+ 6a6:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6a8:	008b8d13          	addi	s10,s7,8
+ 6ac:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6b0:	03000593          	li	a1,48
+ 6b4:	855a                	mv	a0,s6
+ 6b6:	d43ff0ef          	jal	3f8 <putc>
+  putc(fd, 'x');
+ 6ba:	07800593          	li	a1,120
+ 6be:	855a                	mv	a0,s6
+ 6c0:	d39ff0ef          	jal	3f8 <putc>
+ 6c4:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 6c6:	00000b97          	auipc	s7,0x0
+ 6ca:	2eab8b93          	addi	s7,s7,746 # 9b0 <digits>
+ 6ce:	03c9d793          	srli	a5,s3,0x3c
+ 6d2:	97de                	add	a5,a5,s7
+ 6d4:	0007c583          	lbu	a1,0(a5)
+ 6d8:	855a                	mv	a0,s6
+ 6da:	d1fff0ef          	jal	3f8 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 6de:	0992                	slli	s3,s3,0x4
+ 6e0:	397d                	addiw	s2,s2,-1
+ 6e2:	fe0916e3          	bnez	s2,6ce <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 6e6:	8bea                	mv	s7,s10
+      state = 0;
+ 6e8:	4981                	li	s3,0
+ 6ea:	6d02                	ld	s10,0(sp)
+ 6ec:	bd01                	j	4fc <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 6ee:	008b8913          	addi	s2,s7,8
+ 6f2:	000bc583          	lbu	a1,0(s7)
+ 6f6:	855a                	mv	a0,s6
+ 6f8:	d01ff0ef          	jal	3f8 <putc>
+ 6fc:	8bca                	mv	s7,s2
+      state = 0;
+ 6fe:	4981                	li	s3,0
+ 700:	bbf5                	j	4fc <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 702:	008b8993          	addi	s3,s7,8
+ 706:	000bb903          	ld	s2,0(s7)
+ 70a:	00090f63          	beqz	s2,728 <vprintf+0x276>
+        for(; *s; s++)
+ 70e:	00094583          	lbu	a1,0(s2)
+ 712:	c195                	beqz	a1,736 <vprintf+0x284>
+          putc(fd, *s);
+ 714:	855a                	mv	a0,s6
+ 716:	ce3ff0ef          	jal	3f8 <putc>
+        for(; *s; s++)
+ 71a:	0905                	addi	s2,s2,1
+ 71c:	00094583          	lbu	a1,0(s2)
+ 720:	f9f5                	bnez	a1,714 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 722:	8bce                	mv	s7,s3
+      state = 0;
+ 724:	4981                	li	s3,0
+ 726:	bbd9                	j	4fc <vprintf+0x4a>
+          s = "(null)";
+ 728:	00000917          	auipc	s2,0x0
+ 72c:	28090913          	addi	s2,s2,640 # 9a8 <malloc+0x174>
+        for(; *s; s++)
+ 730:	02800593          	li	a1,40
+ 734:	b7c5                	j	714 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 736:	8bce                	mv	s7,s3
+      state = 0;
+ 738:	4981                	li	s3,0
+ 73a:	b3c9                	j	4fc <vprintf+0x4a>
+ 73c:	64a6                	ld	s1,72(sp)
+ 73e:	79e2                	ld	s3,56(sp)
+ 740:	7a42                	ld	s4,48(sp)
+ 742:	7aa2                	ld	s5,40(sp)
+ 744:	7b02                	ld	s6,32(sp)
+ 746:	6be2                	ld	s7,24(sp)
+ 748:	6c42                	ld	s8,16(sp)
+ 74a:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 74c:	60e6                	ld	ra,88(sp)
+ 74e:	6446                	ld	s0,80(sp)
+ 750:	6906                	ld	s2,64(sp)
+ 752:	6125                	addi	sp,sp,96
+ 754:	8082                	ret
+
+0000000000000756 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 756:	715d                	addi	sp,sp,-80
+ 758:	ec06                	sd	ra,24(sp)
+ 75a:	e822                	sd	s0,16(sp)
+ 75c:	1000                	addi	s0,sp,32
+ 75e:	e010                	sd	a2,0(s0)
+ 760:	e414                	sd	a3,8(s0)
+ 762:	e818                	sd	a4,16(s0)
+ 764:	ec1c                	sd	a5,24(s0)
+ 766:	03043023          	sd	a6,32(s0)
+ 76a:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 76e:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 772:	8622                	mv	a2,s0
+ 774:	d3fff0ef          	jal	4b2 <vprintf>
+}
+ 778:	60e2                	ld	ra,24(sp)
+ 77a:	6442                	ld	s0,16(sp)
+ 77c:	6161                	addi	sp,sp,80
+ 77e:	8082                	ret
+
+0000000000000780 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 780:	711d                	addi	sp,sp,-96
+ 782:	ec06                	sd	ra,24(sp)
+ 784:	e822                	sd	s0,16(sp)
+ 786:	1000                	addi	s0,sp,32
+ 788:	e40c                	sd	a1,8(s0)
+ 78a:	e810                	sd	a2,16(s0)
+ 78c:	ec14                	sd	a3,24(s0)
+ 78e:	f018                	sd	a4,32(s0)
+ 790:	f41c                	sd	a5,40(s0)
+ 792:	03043823          	sd	a6,48(s0)
+ 796:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 79a:	00840613          	addi	a2,s0,8
+ 79e:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7a2:	85aa                	mv	a1,a0
+ 7a4:	4505                	li	a0,1
+ 7a6:	d0dff0ef          	jal	4b2 <vprintf>
+}
+ 7aa:	60e2                	ld	ra,24(sp)
+ 7ac:	6442                	ld	s0,16(sp)
+ 7ae:	6125                	addi	sp,sp,96
+ 7b0:	8082                	ret
+
+00000000000007b2 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7b2:	1141                	addi	sp,sp,-16
+ 7b4:	e422                	sd	s0,8(sp)
+ 7b6:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7b8:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7bc:	00001797          	auipc	a5,0x1
+ 7c0:	8547b783          	ld	a5,-1964(a5) # 1010 <freep>
+ 7c4:	a02d                	j	7ee <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 7c6:	4618                	lw	a4,8(a2)
+ 7c8:	9f2d                	addw	a4,a4,a1
+ 7ca:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7ce:	6398                	ld	a4,0(a5)
+ 7d0:	6310                	ld	a2,0(a4)
+ 7d2:	a83d                	j	810 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 7d4:	ff852703          	lw	a4,-8(a0)
+ 7d8:	9f31                	addw	a4,a4,a2
+ 7da:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 7dc:	ff053683          	ld	a3,-16(a0)
+ 7e0:	a091                	j	824 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7e2:	6398                	ld	a4,0(a5)
+ 7e4:	00e7e463          	bltu	a5,a4,7ec <free+0x3a>
+ 7e8:	00e6ea63          	bltu	a3,a4,7fc <free+0x4a>
+{
+ 7ec:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7ee:	fed7fae3          	bgeu	a5,a3,7e2 <free+0x30>
+ 7f2:	6398                	ld	a4,0(a5)
+ 7f4:	00e6e463          	bltu	a3,a4,7fc <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7f8:	fee7eae3          	bltu	a5,a4,7ec <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7fc:	ff852583          	lw	a1,-8(a0)
+ 800:	6390                	ld	a2,0(a5)
+ 802:	02059813          	slli	a6,a1,0x20
+ 806:	01c85713          	srli	a4,a6,0x1c
+ 80a:	9736                	add	a4,a4,a3
+ 80c:	fae60de3          	beq	a2,a4,7c6 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 810:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 814:	4790                	lw	a2,8(a5)
+ 816:	02061593          	slli	a1,a2,0x20
+ 81a:	01c5d713          	srli	a4,a1,0x1c
+ 81e:	973e                	add	a4,a4,a5
+ 820:	fae68ae3          	beq	a3,a4,7d4 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 824:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 826:	00000717          	auipc	a4,0x0
+ 82a:	7ef73523          	sd	a5,2026(a4) # 1010 <freep>
+}
+ 82e:	6422                	ld	s0,8(sp)
+ 830:	0141                	addi	sp,sp,16
+ 832:	8082                	ret
+
+0000000000000834 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 834:	7139                	addi	sp,sp,-64
+ 836:	fc06                	sd	ra,56(sp)
+ 838:	f822                	sd	s0,48(sp)
+ 83a:	f426                	sd	s1,40(sp)
+ 83c:	ec4e                	sd	s3,24(sp)
+ 83e:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 840:	02051493          	slli	s1,a0,0x20
+ 844:	9081                	srli	s1,s1,0x20
+ 846:	04bd                	addi	s1,s1,15
+ 848:	8091                	srli	s1,s1,0x4
+ 84a:	0014899b          	addiw	s3,s1,1
+ 84e:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 850:	00000517          	auipc	a0,0x0
+ 854:	7c053503          	ld	a0,1984(a0) # 1010 <freep>
+ 858:	c915                	beqz	a0,88c <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 85a:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 85c:	4798                	lw	a4,8(a5)
+ 85e:	08977a63          	bgeu	a4,s1,8f2 <malloc+0xbe>
+ 862:	f04a                	sd	s2,32(sp)
+ 864:	e852                	sd	s4,16(sp)
+ 866:	e456                	sd	s5,8(sp)
+ 868:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 86a:	8a4e                	mv	s4,s3
+ 86c:	0009871b          	sext.w	a4,s3
+ 870:	6685                	lui	a3,0x1
+ 872:	00d77363          	bgeu	a4,a3,878 <malloc+0x44>
+ 876:	6a05                	lui	s4,0x1
+ 878:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 87c:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 880:	00000917          	auipc	s2,0x0
+ 884:	79090913          	addi	s2,s2,1936 # 1010 <freep>
+  if(p == SBRK_ERROR)
+ 888:	5afd                	li	s5,-1
+ 88a:	a081                	j	8ca <malloc+0x96>
+ 88c:	f04a                	sd	s2,32(sp)
+ 88e:	e852                	sd	s4,16(sp)
+ 890:	e456                	sd	s5,8(sp)
+ 892:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 894:	00000797          	auipc	a5,0x0
+ 898:	78c78793          	addi	a5,a5,1932 # 1020 <base>
+ 89c:	00000717          	auipc	a4,0x0
+ 8a0:	76f73a23          	sd	a5,1908(a4) # 1010 <freep>
+ 8a4:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8a6:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8aa:	b7c1                	j	86a <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8ac:	6398                	ld	a4,0(a5)
+ 8ae:	e118                	sd	a4,0(a0)
+ 8b0:	a8a9                	j	90a <malloc+0xd6>
+  hp->s.size = nu;
+ 8b2:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8b6:	0541                	addi	a0,a0,16
+ 8b8:	efbff0ef          	jal	7b2 <free>
+  return freep;
+ 8bc:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 8c0:	c12d                	beqz	a0,922 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8c2:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8c4:	4798                	lw	a4,8(a5)
+ 8c6:	02977263          	bgeu	a4,s1,8ea <malloc+0xb6>
+    if(p == freep)
+ 8ca:	00093703          	ld	a4,0(s2)
+ 8ce:	853e                	mv	a0,a5
+ 8d0:	fef719e3          	bne	a4,a5,8c2 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 8d4:	8552                	mv	a0,s4
+ 8d6:	a47ff0ef          	jal	31c <sbrk>
+  if(p == SBRK_ERROR)
+ 8da:	fd551ce3          	bne	a0,s5,8b2 <malloc+0x7e>
+        return 0;
+ 8de:	4501                	li	a0,0
+ 8e0:	7902                	ld	s2,32(sp)
+ 8e2:	6a42                	ld	s4,16(sp)
+ 8e4:	6aa2                	ld	s5,8(sp)
+ 8e6:	6b02                	ld	s6,0(sp)
+ 8e8:	a03d                	j	916 <malloc+0xe2>
+ 8ea:	7902                	ld	s2,32(sp)
+ 8ec:	6a42                	ld	s4,16(sp)
+ 8ee:	6aa2                	ld	s5,8(sp)
+ 8f0:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 8f2:	fae48de3          	beq	s1,a4,8ac <malloc+0x78>
+        p->s.size -= nunits;
+ 8f6:	4137073b          	subw	a4,a4,s3
+ 8fa:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8fc:	02071693          	slli	a3,a4,0x20
+ 900:	01c6d713          	srli	a4,a3,0x1c
+ 904:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 906:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 90a:	00000717          	auipc	a4,0x0
+ 90e:	70a73323          	sd	a0,1798(a4) # 1010 <freep>
+      return (void*)(p + 1);
+ 912:	01078513          	addi	a0,a5,16
+  }
+}
+ 916:	70e2                	ld	ra,56(sp)
+ 918:	7442                	ld	s0,48(sp)
+ 91a:	74a2                	ld	s1,40(sp)
+ 91c:	69e2                	ld	s3,24(sp)
+ 91e:	6121                	addi	sp,sp,64
+ 920:	8082                	ret
+ 922:	7902                	ld	s2,32(sp)
+ 924:	6a42                	ld	s4,16(sp)
+ 926:	6aa2                	ld	s5,8(sp)
+ 928:	6b02                	ld	s6,0(sp)
+ 92a:	b7f5                	j	916 <malloc+0xe2>
diff -ruN xv6-riscv/user/init.d xv62/user/init.d
--- xv6-riscv/user/init.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/init.d	2025-09-14 12:32:50.848883321 +0000
@@ -0,0 +1,2 @@
+user/init.o: user/init.c kernel/types.h kernel/stat.h kernel/spinlock.h \
+ kernel/sleeplock.h kernel/fs.h kernel/file.h user/user.h kernel/fcntl.h
Binary files xv6-riscv/user/init.o and xv62/user/init.o differ
diff -ruN xv6-riscv/user/init.sym xv62/user/init.sym
--- xv6-riscv/user/init.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/init.sym	2025-09-14 12:32:50.872883316 +0000
@@ -0,0 +1,67 @@
+0000000000000000 .text
+0000000000000930 .rodata
+00000000000009c8 .eh_frame
+0000000000001000 .data
+0000000000001010 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 init.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003f8 putc
+0000000000000416 printint
+00000000000009b0 digits
+0000000000000000 umalloc.c
+0000000000001010 freep
+0000000000001020 base
+00000000000000cc strcpy
+00000000000003e0 pause
+0000000000000780 printf
+00000000000003d8 sys_sbrk
+0000000000001000 argv
+0000000000000276 memmove
+0000000000000398 mknod
+0000000000000184 gets
+00000000000003d0 getpid
+0000000000000308 memcpy
+0000000000000834 malloc
+0000000000000332 sbrklazy
+0000000000000360 pipe
+0000000000000370 write
+00000000000003a8 fstat
+0000000000000756 fprintf
+0000000000000380 kill
+00000000000004b2 vprintf
+00000000000003c0 chdir
+0000000000000388 exec
+0000000000000358 wait
+0000000000000368 read
+00000000000003a0 unlink
+00000000000002ce memcmp
+0000000000000348 fork
+000000000000031c sbrk
+00000000000003e8 uptime
+000000000000013e memset
+0000000000000000 main
+00000000000000e8 strcmp
+00000000000003c8 dup
+00000000000003f0 getreadcount
+00000000000001f4 stat
+00000000000003b0 link
+0000000000000350 exit
+00000000000000bc start
+000000000000022e atoi
+0000000000000114 strlen
+0000000000000390 open
+0000000000000160 strchr
+00000000000003b8 mkdir
+0000000000000378 close
+00000000000007b2 free
diff -ruN xv6-riscv/user/kill.asm xv62/user/kill.asm
--- xv6-riscv/user/kill.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/kill.asm	2025-09-14 12:32:50.928883304 +0000
@@ -0,0 +1,1507 @@
+
+user/_kill:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char **argv)
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	1000                	addi	s0,sp,32
+  int i;
+
+  if(argc < 2){
+   8:	4785                	li	a5,1
+   a:	02a7d963          	bge	a5,a0,3c <main+0x3c>
+   e:	e426                	sd	s1,8(sp)
+  10:	e04a                	sd	s2,0(sp)
+  12:	00858493          	addi	s1,a1,8
+  16:	ffe5091b          	addiw	s2,a0,-2
+  1a:	02091793          	slli	a5,s2,0x20
+  1e:	01d7d913          	srli	s2,a5,0x1d
+  22:	05c1                	addi	a1,a1,16
+  24:	992e                	add	s2,s2,a1
+    fprintf(2, "usage: kill pid...\n");
+    exit(1);
+  }
+  for(i=1; i<argc; i++)
+    kill(atoi(argv[i]));
+  26:	6088                	ld	a0,0(s1)
+  28:	19e000ef          	jal	1c6 <atoi>
+  2c:	2ec000ef          	jal	318 <kill>
+  for(i=1; i<argc; i++)
+  30:	04a1                	addi	s1,s1,8
+  32:	ff249ae3          	bne	s1,s2,26 <main+0x26>
+  exit(0);
+  36:	4501                	li	a0,0
+  38:	2b0000ef          	jal	2e8 <exit>
+  3c:	e426                	sd	s1,8(sp)
+  3e:	e04a                	sd	s2,0(sp)
+    fprintf(2, "usage: kill pid...\n");
+  40:	00001597          	auipc	a1,0x1
+  44:	89058593          	addi	a1,a1,-1904 # 8d0 <malloc+0x104>
+  48:	4509                	li	a0,2
+  4a:	6a4000ef          	jal	6ee <fprintf>
+    exit(1);
+  4e:	4505                	li	a0,1
+  50:	298000ef          	jal	2e8 <exit>
+
+0000000000000054 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  54:	1141                	addi	sp,sp,-16
+  56:	e406                	sd	ra,8(sp)
+  58:	e022                	sd	s0,0(sp)
+  5a:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  5c:	fa5ff0ef          	jal	0 <main>
+  exit(r);
+  60:	288000ef          	jal	2e8 <exit>
+
+0000000000000064 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  64:	1141                	addi	sp,sp,-16
+  66:	e422                	sd	s0,8(sp)
+  68:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  6a:	87aa                	mv	a5,a0
+  6c:	0585                	addi	a1,a1,1
+  6e:	0785                	addi	a5,a5,1
+  70:	fff5c703          	lbu	a4,-1(a1)
+  74:	fee78fa3          	sb	a4,-1(a5)
+  78:	fb75                	bnez	a4,6c <strcpy+0x8>
+    ;
+  return os;
+}
+  7a:	6422                	ld	s0,8(sp)
+  7c:	0141                	addi	sp,sp,16
+  7e:	8082                	ret
+
+0000000000000080 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  80:	1141                	addi	sp,sp,-16
+  82:	e422                	sd	s0,8(sp)
+  84:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  86:	00054783          	lbu	a5,0(a0)
+  8a:	cb91                	beqz	a5,9e <strcmp+0x1e>
+  8c:	0005c703          	lbu	a4,0(a1)
+  90:	00f71763          	bne	a4,a5,9e <strcmp+0x1e>
+    p++, q++;
+  94:	0505                	addi	a0,a0,1
+  96:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  98:	00054783          	lbu	a5,0(a0)
+  9c:	fbe5                	bnez	a5,8c <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  9e:	0005c503          	lbu	a0,0(a1)
+}
+  a2:	40a7853b          	subw	a0,a5,a0
+  a6:	6422                	ld	s0,8(sp)
+  a8:	0141                	addi	sp,sp,16
+  aa:	8082                	ret
+
+00000000000000ac <strlen>:
+
+uint
+strlen(const char *s)
+{
+  ac:	1141                	addi	sp,sp,-16
+  ae:	e422                	sd	s0,8(sp)
+  b0:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  b2:	00054783          	lbu	a5,0(a0)
+  b6:	cf91                	beqz	a5,d2 <strlen+0x26>
+  b8:	0505                	addi	a0,a0,1
+  ba:	87aa                	mv	a5,a0
+  bc:	86be                	mv	a3,a5
+  be:	0785                	addi	a5,a5,1
+  c0:	fff7c703          	lbu	a4,-1(a5)
+  c4:	ff65                	bnez	a4,bc <strlen+0x10>
+  c6:	40a6853b          	subw	a0,a3,a0
+  ca:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  cc:	6422                	ld	s0,8(sp)
+  ce:	0141                	addi	sp,sp,16
+  d0:	8082                	ret
+  for(n = 0; s[n]; n++)
+  d2:	4501                	li	a0,0
+  d4:	bfe5                	j	cc <strlen+0x20>
+
+00000000000000d6 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  d6:	1141                	addi	sp,sp,-16
+  d8:	e422                	sd	s0,8(sp)
+  da:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  dc:	ca19                	beqz	a2,f2 <memset+0x1c>
+  de:	87aa                	mv	a5,a0
+  e0:	1602                	slli	a2,a2,0x20
+  e2:	9201                	srli	a2,a2,0x20
+  e4:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  e8:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+  ec:	0785                	addi	a5,a5,1
+  ee:	fee79de3          	bne	a5,a4,e8 <memset+0x12>
+  }
+  return dst;
+}
+  f2:	6422                	ld	s0,8(sp)
+  f4:	0141                	addi	sp,sp,16
+  f6:	8082                	ret
+
+00000000000000f8 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+  f8:	1141                	addi	sp,sp,-16
+  fa:	e422                	sd	s0,8(sp)
+  fc:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+  fe:	00054783          	lbu	a5,0(a0)
+ 102:	cb99                	beqz	a5,118 <strchr+0x20>
+    if(*s == c)
+ 104:	00f58763          	beq	a1,a5,112 <strchr+0x1a>
+  for(; *s; s++)
+ 108:	0505                	addi	a0,a0,1
+ 10a:	00054783          	lbu	a5,0(a0)
+ 10e:	fbfd                	bnez	a5,104 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 110:	4501                	li	a0,0
+}
+ 112:	6422                	ld	s0,8(sp)
+ 114:	0141                	addi	sp,sp,16
+ 116:	8082                	ret
+  return 0;
+ 118:	4501                	li	a0,0
+ 11a:	bfe5                	j	112 <strchr+0x1a>
+
+000000000000011c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 11c:	711d                	addi	sp,sp,-96
+ 11e:	ec86                	sd	ra,88(sp)
+ 120:	e8a2                	sd	s0,80(sp)
+ 122:	e4a6                	sd	s1,72(sp)
+ 124:	e0ca                	sd	s2,64(sp)
+ 126:	fc4e                	sd	s3,56(sp)
+ 128:	f852                	sd	s4,48(sp)
+ 12a:	f456                	sd	s5,40(sp)
+ 12c:	f05a                	sd	s6,32(sp)
+ 12e:	ec5e                	sd	s7,24(sp)
+ 130:	1080                	addi	s0,sp,96
+ 132:	8baa                	mv	s7,a0
+ 134:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 136:	892a                	mv	s2,a0
+ 138:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 13a:	4aa9                	li	s5,10
+ 13c:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 13e:	89a6                	mv	s3,s1
+ 140:	2485                	addiw	s1,s1,1
+ 142:	0344d663          	bge	s1,s4,16e <gets+0x52>
+    cc = read(0, &c, 1);
+ 146:	4605                	li	a2,1
+ 148:	faf40593          	addi	a1,s0,-81
+ 14c:	4501                	li	a0,0
+ 14e:	1b2000ef          	jal	300 <read>
+    if(cc < 1)
+ 152:	00a05e63          	blez	a0,16e <gets+0x52>
+    buf[i++] = c;
+ 156:	faf44783          	lbu	a5,-81(s0)
+ 15a:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 15e:	01578763          	beq	a5,s5,16c <gets+0x50>
+ 162:	0905                	addi	s2,s2,1
+ 164:	fd679de3          	bne	a5,s6,13e <gets+0x22>
+    buf[i++] = c;
+ 168:	89a6                	mv	s3,s1
+ 16a:	a011                	j	16e <gets+0x52>
+ 16c:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 16e:	99de                	add	s3,s3,s7
+ 170:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 174:	855e                	mv	a0,s7
+ 176:	60e6                	ld	ra,88(sp)
+ 178:	6446                	ld	s0,80(sp)
+ 17a:	64a6                	ld	s1,72(sp)
+ 17c:	6906                	ld	s2,64(sp)
+ 17e:	79e2                	ld	s3,56(sp)
+ 180:	7a42                	ld	s4,48(sp)
+ 182:	7aa2                	ld	s5,40(sp)
+ 184:	7b02                	ld	s6,32(sp)
+ 186:	6be2                	ld	s7,24(sp)
+ 188:	6125                	addi	sp,sp,96
+ 18a:	8082                	ret
+
+000000000000018c <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 18c:	1101                	addi	sp,sp,-32
+ 18e:	ec06                	sd	ra,24(sp)
+ 190:	e822                	sd	s0,16(sp)
+ 192:	e04a                	sd	s2,0(sp)
+ 194:	1000                	addi	s0,sp,32
+ 196:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 198:	4581                	li	a1,0
+ 19a:	18e000ef          	jal	328 <open>
+  if(fd < 0)
+ 19e:	02054263          	bltz	a0,1c2 <stat+0x36>
+ 1a2:	e426                	sd	s1,8(sp)
+ 1a4:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1a6:	85ca                	mv	a1,s2
+ 1a8:	198000ef          	jal	340 <fstat>
+ 1ac:	892a                	mv	s2,a0
+  close(fd);
+ 1ae:	8526                	mv	a0,s1
+ 1b0:	160000ef          	jal	310 <close>
+  return r;
+ 1b4:	64a2                	ld	s1,8(sp)
+}
+ 1b6:	854a                	mv	a0,s2
+ 1b8:	60e2                	ld	ra,24(sp)
+ 1ba:	6442                	ld	s0,16(sp)
+ 1bc:	6902                	ld	s2,0(sp)
+ 1be:	6105                	addi	sp,sp,32
+ 1c0:	8082                	ret
+    return -1;
+ 1c2:	597d                	li	s2,-1
+ 1c4:	bfcd                	j	1b6 <stat+0x2a>
+
+00000000000001c6 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1c6:	1141                	addi	sp,sp,-16
+ 1c8:	e422                	sd	s0,8(sp)
+ 1ca:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1cc:	00054683          	lbu	a3,0(a0)
+ 1d0:	fd06879b          	addiw	a5,a3,-48
+ 1d4:	0ff7f793          	zext.b	a5,a5
+ 1d8:	4625                	li	a2,9
+ 1da:	02f66863          	bltu	a2,a5,20a <atoi+0x44>
+ 1de:	872a                	mv	a4,a0
+  n = 0;
+ 1e0:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1e2:	0705                	addi	a4,a4,1
+ 1e4:	0025179b          	slliw	a5,a0,0x2
+ 1e8:	9fa9                	addw	a5,a5,a0
+ 1ea:	0017979b          	slliw	a5,a5,0x1
+ 1ee:	9fb5                	addw	a5,a5,a3
+ 1f0:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 1f4:	00074683          	lbu	a3,0(a4)
+ 1f8:	fd06879b          	addiw	a5,a3,-48
+ 1fc:	0ff7f793          	zext.b	a5,a5
+ 200:	fef671e3          	bgeu	a2,a5,1e2 <atoi+0x1c>
+  return n;
+}
+ 204:	6422                	ld	s0,8(sp)
+ 206:	0141                	addi	sp,sp,16
+ 208:	8082                	ret
+  n = 0;
+ 20a:	4501                	li	a0,0
+ 20c:	bfe5                	j	204 <atoi+0x3e>
+
+000000000000020e <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 20e:	1141                	addi	sp,sp,-16
+ 210:	e422                	sd	s0,8(sp)
+ 212:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 214:	02b57463          	bgeu	a0,a1,23c <memmove+0x2e>
+    while(n-- > 0)
+ 218:	00c05f63          	blez	a2,236 <memmove+0x28>
+ 21c:	1602                	slli	a2,a2,0x20
+ 21e:	9201                	srli	a2,a2,0x20
+ 220:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 224:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 226:	0585                	addi	a1,a1,1
+ 228:	0705                	addi	a4,a4,1
+ 22a:	fff5c683          	lbu	a3,-1(a1)
+ 22e:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 232:	fef71ae3          	bne	a4,a5,226 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 236:	6422                	ld	s0,8(sp)
+ 238:	0141                	addi	sp,sp,16
+ 23a:	8082                	ret
+    dst += n;
+ 23c:	00c50733          	add	a4,a0,a2
+    src += n;
+ 240:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 242:	fec05ae3          	blez	a2,236 <memmove+0x28>
+ 246:	fff6079b          	addiw	a5,a2,-1
+ 24a:	1782                	slli	a5,a5,0x20
+ 24c:	9381                	srli	a5,a5,0x20
+ 24e:	fff7c793          	not	a5,a5
+ 252:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 254:	15fd                	addi	a1,a1,-1
+ 256:	177d                	addi	a4,a4,-1
+ 258:	0005c683          	lbu	a3,0(a1)
+ 25c:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 260:	fee79ae3          	bne	a5,a4,254 <memmove+0x46>
+ 264:	bfc9                	j	236 <memmove+0x28>
+
+0000000000000266 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 266:	1141                	addi	sp,sp,-16
+ 268:	e422                	sd	s0,8(sp)
+ 26a:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 26c:	ca05                	beqz	a2,29c <memcmp+0x36>
+ 26e:	fff6069b          	addiw	a3,a2,-1
+ 272:	1682                	slli	a3,a3,0x20
+ 274:	9281                	srli	a3,a3,0x20
+ 276:	0685                	addi	a3,a3,1
+ 278:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 27a:	00054783          	lbu	a5,0(a0)
+ 27e:	0005c703          	lbu	a4,0(a1)
+ 282:	00e79863          	bne	a5,a4,292 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 286:	0505                	addi	a0,a0,1
+    p2++;
+ 288:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 28a:	fed518e3          	bne	a0,a3,27a <memcmp+0x14>
+  }
+  return 0;
+ 28e:	4501                	li	a0,0
+ 290:	a019                	j	296 <memcmp+0x30>
+      return *p1 - *p2;
+ 292:	40e7853b          	subw	a0,a5,a4
+}
+ 296:	6422                	ld	s0,8(sp)
+ 298:	0141                	addi	sp,sp,16
+ 29a:	8082                	ret
+  return 0;
+ 29c:	4501                	li	a0,0
+ 29e:	bfe5                	j	296 <memcmp+0x30>
+
+00000000000002a0 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2a0:	1141                	addi	sp,sp,-16
+ 2a2:	e406                	sd	ra,8(sp)
+ 2a4:	e022                	sd	s0,0(sp)
+ 2a6:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2a8:	f67ff0ef          	jal	20e <memmove>
+}
+ 2ac:	60a2                	ld	ra,8(sp)
+ 2ae:	6402                	ld	s0,0(sp)
+ 2b0:	0141                	addi	sp,sp,16
+ 2b2:	8082                	ret
+
+00000000000002b4 <sbrk>:
+
+char *
+sbrk(int n) {
+ 2b4:	1141                	addi	sp,sp,-16
+ 2b6:	e406                	sd	ra,8(sp)
+ 2b8:	e022                	sd	s0,0(sp)
+ 2ba:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2bc:	4585                	li	a1,1
+ 2be:	0b2000ef          	jal	370 <sys_sbrk>
+}
+ 2c2:	60a2                	ld	ra,8(sp)
+ 2c4:	6402                	ld	s0,0(sp)
+ 2c6:	0141                	addi	sp,sp,16
+ 2c8:	8082                	ret
+
+00000000000002ca <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2ca:	1141                	addi	sp,sp,-16
+ 2cc:	e406                	sd	ra,8(sp)
+ 2ce:	e022                	sd	s0,0(sp)
+ 2d0:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2d2:	4589                	li	a1,2
+ 2d4:	09c000ef          	jal	370 <sys_sbrk>
+}
+ 2d8:	60a2                	ld	ra,8(sp)
+ 2da:	6402                	ld	s0,0(sp)
+ 2dc:	0141                	addi	sp,sp,16
+ 2de:	8082                	ret
+
+00000000000002e0 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2e0:	4885                	li	a7,1
+ ecall
+ 2e2:	00000073          	ecall
+ ret
+ 2e6:	8082                	ret
+
+00000000000002e8 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2e8:	4889                	li	a7,2
+ ecall
+ 2ea:	00000073          	ecall
+ ret
+ 2ee:	8082                	ret
+
+00000000000002f0 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 2f0:	488d                	li	a7,3
+ ecall
+ 2f2:	00000073          	ecall
+ ret
+ 2f6:	8082                	ret
+
+00000000000002f8 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 2f8:	4891                	li	a7,4
+ ecall
+ 2fa:	00000073          	ecall
+ ret
+ 2fe:	8082                	ret
+
+0000000000000300 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 300:	4895                	li	a7,5
+ ecall
+ 302:	00000073          	ecall
+ ret
+ 306:	8082                	ret
+
+0000000000000308 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 308:	48c1                	li	a7,16
+ ecall
+ 30a:	00000073          	ecall
+ ret
+ 30e:	8082                	ret
+
+0000000000000310 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 310:	48d5                	li	a7,21
+ ecall
+ 312:	00000073          	ecall
+ ret
+ 316:	8082                	ret
+
+0000000000000318 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 318:	4899                	li	a7,6
+ ecall
+ 31a:	00000073          	ecall
+ ret
+ 31e:	8082                	ret
+
+0000000000000320 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 320:	489d                	li	a7,7
+ ecall
+ 322:	00000073          	ecall
+ ret
+ 326:	8082                	ret
+
+0000000000000328 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 328:	48bd                	li	a7,15
+ ecall
+ 32a:	00000073          	ecall
+ ret
+ 32e:	8082                	ret
+
+0000000000000330 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 330:	48c5                	li	a7,17
+ ecall
+ 332:	00000073          	ecall
+ ret
+ 336:	8082                	ret
+
+0000000000000338 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 338:	48c9                	li	a7,18
+ ecall
+ 33a:	00000073          	ecall
+ ret
+ 33e:	8082                	ret
+
+0000000000000340 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 340:	48a1                	li	a7,8
+ ecall
+ 342:	00000073          	ecall
+ ret
+ 346:	8082                	ret
+
+0000000000000348 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 348:	48cd                	li	a7,19
+ ecall
+ 34a:	00000073          	ecall
+ ret
+ 34e:	8082                	ret
+
+0000000000000350 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 350:	48d1                	li	a7,20
+ ecall
+ 352:	00000073          	ecall
+ ret
+ 356:	8082                	ret
+
+0000000000000358 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 358:	48a5                	li	a7,9
+ ecall
+ 35a:	00000073          	ecall
+ ret
+ 35e:	8082                	ret
+
+0000000000000360 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 360:	48a9                	li	a7,10
+ ecall
+ 362:	00000073          	ecall
+ ret
+ 366:	8082                	ret
+
+0000000000000368 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 368:	48ad                	li	a7,11
+ ecall
+ 36a:	00000073          	ecall
+ ret
+ 36e:	8082                	ret
+
+0000000000000370 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 370:	48b1                	li	a7,12
+ ecall
+ 372:	00000073          	ecall
+ ret
+ 376:	8082                	ret
+
+0000000000000378 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 378:	48b5                	li	a7,13
+ ecall
+ 37a:	00000073          	ecall
+ ret
+ 37e:	8082                	ret
+
+0000000000000380 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 380:	48b9                	li	a7,14
+ ecall
+ 382:	00000073          	ecall
+ ret
+ 386:	8082                	ret
+
+0000000000000388 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 388:	48d9                	li	a7,22
+ ecall
+ 38a:	00000073          	ecall
+ ret
+ 38e:	8082                	ret
+
+0000000000000390 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 390:	1101                	addi	sp,sp,-32
+ 392:	ec06                	sd	ra,24(sp)
+ 394:	e822                	sd	s0,16(sp)
+ 396:	1000                	addi	s0,sp,32
+ 398:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 39c:	4605                	li	a2,1
+ 39e:	fef40593          	addi	a1,s0,-17
+ 3a2:	f67ff0ef          	jal	308 <write>
+}
+ 3a6:	60e2                	ld	ra,24(sp)
+ 3a8:	6442                	ld	s0,16(sp)
+ 3aa:	6105                	addi	sp,sp,32
+ 3ac:	8082                	ret
+
+00000000000003ae <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3ae:	715d                	addi	sp,sp,-80
+ 3b0:	e486                	sd	ra,72(sp)
+ 3b2:	e0a2                	sd	s0,64(sp)
+ 3b4:	f84a                	sd	s2,48(sp)
+ 3b6:	0880                	addi	s0,sp,80
+ 3b8:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3ba:	c299                	beqz	a3,3c0 <printint+0x12>
+ 3bc:	0805c363          	bltz	a1,442 <printint+0x94>
+  neg = 0;
+ 3c0:	4881                	li	a7,0
+ 3c2:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3c6:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3c8:	00000517          	auipc	a0,0x0
+ 3cc:	52850513          	addi	a0,a0,1320 # 8f0 <digits>
+ 3d0:	883e                	mv	a6,a5
+ 3d2:	2785                	addiw	a5,a5,1
+ 3d4:	02c5f733          	remu	a4,a1,a2
+ 3d8:	972a                	add	a4,a4,a0
+ 3da:	00074703          	lbu	a4,0(a4)
+ 3de:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3e2:	872e                	mv	a4,a1
+ 3e4:	02c5d5b3          	divu	a1,a1,a2
+ 3e8:	0685                	addi	a3,a3,1
+ 3ea:	fec773e3          	bgeu	a4,a2,3d0 <printint+0x22>
+  if(neg)
+ 3ee:	00088b63          	beqz	a7,404 <printint+0x56>
+    buf[i++] = '-';
+ 3f2:	fd078793          	addi	a5,a5,-48
+ 3f6:	97a2                	add	a5,a5,s0
+ 3f8:	02d00713          	li	a4,45
+ 3fc:	fee78423          	sb	a4,-24(a5)
+ 400:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 404:	02f05a63          	blez	a5,438 <printint+0x8a>
+ 408:	fc26                	sd	s1,56(sp)
+ 40a:	f44e                	sd	s3,40(sp)
+ 40c:	fb840713          	addi	a4,s0,-72
+ 410:	00f704b3          	add	s1,a4,a5
+ 414:	fff70993          	addi	s3,a4,-1
+ 418:	99be                	add	s3,s3,a5
+ 41a:	37fd                	addiw	a5,a5,-1
+ 41c:	1782                	slli	a5,a5,0x20
+ 41e:	9381                	srli	a5,a5,0x20
+ 420:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 424:	fff4c583          	lbu	a1,-1(s1)
+ 428:	854a                	mv	a0,s2
+ 42a:	f67ff0ef          	jal	390 <putc>
+  while(--i >= 0)
+ 42e:	14fd                	addi	s1,s1,-1
+ 430:	ff349ae3          	bne	s1,s3,424 <printint+0x76>
+ 434:	74e2                	ld	s1,56(sp)
+ 436:	79a2                	ld	s3,40(sp)
+}
+ 438:	60a6                	ld	ra,72(sp)
+ 43a:	6406                	ld	s0,64(sp)
+ 43c:	7942                	ld	s2,48(sp)
+ 43e:	6161                	addi	sp,sp,80
+ 440:	8082                	ret
+    x = -xx;
+ 442:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 446:	4885                	li	a7,1
+    x = -xx;
+ 448:	bfad                	j	3c2 <printint+0x14>
+
+000000000000044a <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 44a:	711d                	addi	sp,sp,-96
+ 44c:	ec86                	sd	ra,88(sp)
+ 44e:	e8a2                	sd	s0,80(sp)
+ 450:	e0ca                	sd	s2,64(sp)
+ 452:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 454:	0005c903          	lbu	s2,0(a1)
+ 458:	28090663          	beqz	s2,6e4 <vprintf+0x29a>
+ 45c:	e4a6                	sd	s1,72(sp)
+ 45e:	fc4e                	sd	s3,56(sp)
+ 460:	f852                	sd	s4,48(sp)
+ 462:	f456                	sd	s5,40(sp)
+ 464:	f05a                	sd	s6,32(sp)
+ 466:	ec5e                	sd	s7,24(sp)
+ 468:	e862                	sd	s8,16(sp)
+ 46a:	e466                	sd	s9,8(sp)
+ 46c:	8b2a                	mv	s6,a0
+ 46e:	8a2e                	mv	s4,a1
+ 470:	8bb2                	mv	s7,a2
+  state = 0;
+ 472:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 474:	4481                	li	s1,0
+ 476:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 478:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 47c:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 480:	06c00c93          	li	s9,108
+ 484:	a005                	j	4a4 <vprintf+0x5a>
+        putc(fd, c0);
+ 486:	85ca                	mv	a1,s2
+ 488:	855a                	mv	a0,s6
+ 48a:	f07ff0ef          	jal	390 <putc>
+ 48e:	a019                	j	494 <vprintf+0x4a>
+    } else if(state == '%'){
+ 490:	03598263          	beq	s3,s5,4b4 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 494:	2485                	addiw	s1,s1,1
+ 496:	8726                	mv	a4,s1
+ 498:	009a07b3          	add	a5,s4,s1
+ 49c:	0007c903          	lbu	s2,0(a5)
+ 4a0:	22090a63          	beqz	s2,6d4 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4a4:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4a8:	fe0994e3          	bnez	s3,490 <vprintf+0x46>
+      if(c0 == '%'){
+ 4ac:	fd579de3          	bne	a5,s5,486 <vprintf+0x3c>
+        state = '%';
+ 4b0:	89be                	mv	s3,a5
+ 4b2:	b7cd                	j	494 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4b4:	00ea06b3          	add	a3,s4,a4
+ 4b8:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4bc:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4be:	c681                	beqz	a3,4c6 <vprintf+0x7c>
+ 4c0:	9752                	add	a4,a4,s4
+ 4c2:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4c6:	05878363          	beq	a5,s8,50c <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4ca:	05978d63          	beq	a5,s9,524 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4ce:	07500713          	li	a4,117
+ 4d2:	0ee78763          	beq	a5,a4,5c0 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4d6:	07800713          	li	a4,120
+ 4da:	12e78963          	beq	a5,a4,60c <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4de:	07000713          	li	a4,112
+ 4e2:	14e78e63          	beq	a5,a4,63e <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4e6:	06300713          	li	a4,99
+ 4ea:	18e78e63          	beq	a5,a4,686 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 4ee:	07300713          	li	a4,115
+ 4f2:	1ae78463          	beq	a5,a4,69a <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 4f6:	02500713          	li	a4,37
+ 4fa:	04e79563          	bne	a5,a4,544 <vprintf+0xfa>
+        putc(fd, '%');
+ 4fe:	02500593          	li	a1,37
+ 502:	855a                	mv	a0,s6
+ 504:	e8dff0ef          	jal	390 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 508:	4981                	li	s3,0
+ 50a:	b769                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 50c:	008b8913          	addi	s2,s7,8
+ 510:	4685                	li	a3,1
+ 512:	4629                	li	a2,10
+ 514:	000ba583          	lw	a1,0(s7)
+ 518:	855a                	mv	a0,s6
+ 51a:	e95ff0ef          	jal	3ae <printint>
+ 51e:	8bca                	mv	s7,s2
+      state = 0;
+ 520:	4981                	li	s3,0
+ 522:	bf8d                	j	494 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 524:	06400793          	li	a5,100
+ 528:	02f68963          	beq	a3,a5,55a <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 52c:	06c00793          	li	a5,108
+ 530:	04f68263          	beq	a3,a5,574 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 534:	07500793          	li	a5,117
+ 538:	0af68063          	beq	a3,a5,5d8 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 53c:	07800793          	li	a5,120
+ 540:	0ef68263          	beq	a3,a5,624 <vprintf+0x1da>
+        putc(fd, '%');
+ 544:	02500593          	li	a1,37
+ 548:	855a                	mv	a0,s6
+ 54a:	e47ff0ef          	jal	390 <putc>
+        putc(fd, c0);
+ 54e:	85ca                	mv	a1,s2
+ 550:	855a                	mv	a0,s6
+ 552:	e3fff0ef          	jal	390 <putc>
+      state = 0;
+ 556:	4981                	li	s3,0
+ 558:	bf35                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 55a:	008b8913          	addi	s2,s7,8
+ 55e:	4685                	li	a3,1
+ 560:	4629                	li	a2,10
+ 562:	000bb583          	ld	a1,0(s7)
+ 566:	855a                	mv	a0,s6
+ 568:	e47ff0ef          	jal	3ae <printint>
+        i += 1;
+ 56c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 56e:	8bca                	mv	s7,s2
+      state = 0;
+ 570:	4981                	li	s3,0
+        i += 1;
+ 572:	b70d                	j	494 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 574:	06400793          	li	a5,100
+ 578:	02f60763          	beq	a2,a5,5a6 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 57c:	07500793          	li	a5,117
+ 580:	06f60963          	beq	a2,a5,5f2 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 584:	07800793          	li	a5,120
+ 588:	faf61ee3          	bne	a2,a5,544 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 58c:	008b8913          	addi	s2,s7,8
+ 590:	4681                	li	a3,0
+ 592:	4641                	li	a2,16
+ 594:	000bb583          	ld	a1,0(s7)
+ 598:	855a                	mv	a0,s6
+ 59a:	e15ff0ef          	jal	3ae <printint>
+        i += 2;
+ 59e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5a0:	8bca                	mv	s7,s2
+      state = 0;
+ 5a2:	4981                	li	s3,0
+        i += 2;
+ 5a4:	bdc5                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5a6:	008b8913          	addi	s2,s7,8
+ 5aa:	4685                	li	a3,1
+ 5ac:	4629                	li	a2,10
+ 5ae:	000bb583          	ld	a1,0(s7)
+ 5b2:	855a                	mv	a0,s6
+ 5b4:	dfbff0ef          	jal	3ae <printint>
+        i += 2;
+ 5b8:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5ba:	8bca                	mv	s7,s2
+      state = 0;
+ 5bc:	4981                	li	s3,0
+        i += 2;
+ 5be:	bdd9                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5c0:	008b8913          	addi	s2,s7,8
+ 5c4:	4681                	li	a3,0
+ 5c6:	4629                	li	a2,10
+ 5c8:	000be583          	lwu	a1,0(s7)
+ 5cc:	855a                	mv	a0,s6
+ 5ce:	de1ff0ef          	jal	3ae <printint>
+ 5d2:	8bca                	mv	s7,s2
+      state = 0;
+ 5d4:	4981                	li	s3,0
+ 5d6:	bd7d                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5d8:	008b8913          	addi	s2,s7,8
+ 5dc:	4681                	li	a3,0
+ 5de:	4629                	li	a2,10
+ 5e0:	000bb583          	ld	a1,0(s7)
+ 5e4:	855a                	mv	a0,s6
+ 5e6:	dc9ff0ef          	jal	3ae <printint>
+        i += 1;
+ 5ea:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5ec:	8bca                	mv	s7,s2
+      state = 0;
+ 5ee:	4981                	li	s3,0
+        i += 1;
+ 5f0:	b555                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5f2:	008b8913          	addi	s2,s7,8
+ 5f6:	4681                	li	a3,0
+ 5f8:	4629                	li	a2,10
+ 5fa:	000bb583          	ld	a1,0(s7)
+ 5fe:	855a                	mv	a0,s6
+ 600:	dafff0ef          	jal	3ae <printint>
+        i += 2;
+ 604:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 606:	8bca                	mv	s7,s2
+      state = 0;
+ 608:	4981                	li	s3,0
+        i += 2;
+ 60a:	b569                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 60c:	008b8913          	addi	s2,s7,8
+ 610:	4681                	li	a3,0
+ 612:	4641                	li	a2,16
+ 614:	000be583          	lwu	a1,0(s7)
+ 618:	855a                	mv	a0,s6
+ 61a:	d95ff0ef          	jal	3ae <printint>
+ 61e:	8bca                	mv	s7,s2
+      state = 0;
+ 620:	4981                	li	s3,0
+ 622:	bd8d                	j	494 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 624:	008b8913          	addi	s2,s7,8
+ 628:	4681                	li	a3,0
+ 62a:	4641                	li	a2,16
+ 62c:	000bb583          	ld	a1,0(s7)
+ 630:	855a                	mv	a0,s6
+ 632:	d7dff0ef          	jal	3ae <printint>
+        i += 1;
+ 636:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 638:	8bca                	mv	s7,s2
+      state = 0;
+ 63a:	4981                	li	s3,0
+        i += 1;
+ 63c:	bda1                	j	494 <vprintf+0x4a>
+ 63e:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 640:	008b8d13          	addi	s10,s7,8
+ 644:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 648:	03000593          	li	a1,48
+ 64c:	855a                	mv	a0,s6
+ 64e:	d43ff0ef          	jal	390 <putc>
+  putc(fd, 'x');
+ 652:	07800593          	li	a1,120
+ 656:	855a                	mv	a0,s6
+ 658:	d39ff0ef          	jal	390 <putc>
+ 65c:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 65e:	00000b97          	auipc	s7,0x0
+ 662:	292b8b93          	addi	s7,s7,658 # 8f0 <digits>
+ 666:	03c9d793          	srli	a5,s3,0x3c
+ 66a:	97de                	add	a5,a5,s7
+ 66c:	0007c583          	lbu	a1,0(a5)
+ 670:	855a                	mv	a0,s6
+ 672:	d1fff0ef          	jal	390 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 676:	0992                	slli	s3,s3,0x4
+ 678:	397d                	addiw	s2,s2,-1
+ 67a:	fe0916e3          	bnez	s2,666 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 67e:	8bea                	mv	s7,s10
+      state = 0;
+ 680:	4981                	li	s3,0
+ 682:	6d02                	ld	s10,0(sp)
+ 684:	bd01                	j	494 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 686:	008b8913          	addi	s2,s7,8
+ 68a:	000bc583          	lbu	a1,0(s7)
+ 68e:	855a                	mv	a0,s6
+ 690:	d01ff0ef          	jal	390 <putc>
+ 694:	8bca                	mv	s7,s2
+      state = 0;
+ 696:	4981                	li	s3,0
+ 698:	bbf5                	j	494 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 69a:	008b8993          	addi	s3,s7,8
+ 69e:	000bb903          	ld	s2,0(s7)
+ 6a2:	00090f63          	beqz	s2,6c0 <vprintf+0x276>
+        for(; *s; s++)
+ 6a6:	00094583          	lbu	a1,0(s2)
+ 6aa:	c195                	beqz	a1,6ce <vprintf+0x284>
+          putc(fd, *s);
+ 6ac:	855a                	mv	a0,s6
+ 6ae:	ce3ff0ef          	jal	390 <putc>
+        for(; *s; s++)
+ 6b2:	0905                	addi	s2,s2,1
+ 6b4:	00094583          	lbu	a1,0(s2)
+ 6b8:	f9f5                	bnez	a1,6ac <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ba:	8bce                	mv	s7,s3
+      state = 0;
+ 6bc:	4981                	li	s3,0
+ 6be:	bbd9                	j	494 <vprintf+0x4a>
+          s = "(null)";
+ 6c0:	00000917          	auipc	s2,0x0
+ 6c4:	22890913          	addi	s2,s2,552 # 8e8 <malloc+0x11c>
+        for(; *s; s++)
+ 6c8:	02800593          	li	a1,40
+ 6cc:	b7c5                	j	6ac <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ce:	8bce                	mv	s7,s3
+      state = 0;
+ 6d0:	4981                	li	s3,0
+ 6d2:	b3c9                	j	494 <vprintf+0x4a>
+ 6d4:	64a6                	ld	s1,72(sp)
+ 6d6:	79e2                	ld	s3,56(sp)
+ 6d8:	7a42                	ld	s4,48(sp)
+ 6da:	7aa2                	ld	s5,40(sp)
+ 6dc:	7b02                	ld	s6,32(sp)
+ 6de:	6be2                	ld	s7,24(sp)
+ 6e0:	6c42                	ld	s8,16(sp)
+ 6e2:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6e4:	60e6                	ld	ra,88(sp)
+ 6e6:	6446                	ld	s0,80(sp)
+ 6e8:	6906                	ld	s2,64(sp)
+ 6ea:	6125                	addi	sp,sp,96
+ 6ec:	8082                	ret
+
+00000000000006ee <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 6ee:	715d                	addi	sp,sp,-80
+ 6f0:	ec06                	sd	ra,24(sp)
+ 6f2:	e822                	sd	s0,16(sp)
+ 6f4:	1000                	addi	s0,sp,32
+ 6f6:	e010                	sd	a2,0(s0)
+ 6f8:	e414                	sd	a3,8(s0)
+ 6fa:	e818                	sd	a4,16(s0)
+ 6fc:	ec1c                	sd	a5,24(s0)
+ 6fe:	03043023          	sd	a6,32(s0)
+ 702:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 706:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 70a:	8622                	mv	a2,s0
+ 70c:	d3fff0ef          	jal	44a <vprintf>
+}
+ 710:	60e2                	ld	ra,24(sp)
+ 712:	6442                	ld	s0,16(sp)
+ 714:	6161                	addi	sp,sp,80
+ 716:	8082                	ret
+
+0000000000000718 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 718:	711d                	addi	sp,sp,-96
+ 71a:	ec06                	sd	ra,24(sp)
+ 71c:	e822                	sd	s0,16(sp)
+ 71e:	1000                	addi	s0,sp,32
+ 720:	e40c                	sd	a1,8(s0)
+ 722:	e810                	sd	a2,16(s0)
+ 724:	ec14                	sd	a3,24(s0)
+ 726:	f018                	sd	a4,32(s0)
+ 728:	f41c                	sd	a5,40(s0)
+ 72a:	03043823          	sd	a6,48(s0)
+ 72e:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 732:	00840613          	addi	a2,s0,8
+ 736:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 73a:	85aa                	mv	a1,a0
+ 73c:	4505                	li	a0,1
+ 73e:	d0dff0ef          	jal	44a <vprintf>
+}
+ 742:	60e2                	ld	ra,24(sp)
+ 744:	6442                	ld	s0,16(sp)
+ 746:	6125                	addi	sp,sp,96
+ 748:	8082                	ret
+
+000000000000074a <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 74a:	1141                	addi	sp,sp,-16
+ 74c:	e422                	sd	s0,8(sp)
+ 74e:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 750:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 754:	00001797          	auipc	a5,0x1
+ 758:	8ac7b783          	ld	a5,-1876(a5) # 1000 <freep>
+ 75c:	a02d                	j	786 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 75e:	4618                	lw	a4,8(a2)
+ 760:	9f2d                	addw	a4,a4,a1
+ 762:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 766:	6398                	ld	a4,0(a5)
+ 768:	6310                	ld	a2,0(a4)
+ 76a:	a83d                	j	7a8 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 76c:	ff852703          	lw	a4,-8(a0)
+ 770:	9f31                	addw	a4,a4,a2
+ 772:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 774:	ff053683          	ld	a3,-16(a0)
+ 778:	a091                	j	7bc <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 77a:	6398                	ld	a4,0(a5)
+ 77c:	00e7e463          	bltu	a5,a4,784 <free+0x3a>
+ 780:	00e6ea63          	bltu	a3,a4,794 <free+0x4a>
+{
+ 784:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 786:	fed7fae3          	bgeu	a5,a3,77a <free+0x30>
+ 78a:	6398                	ld	a4,0(a5)
+ 78c:	00e6e463          	bltu	a3,a4,794 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 790:	fee7eae3          	bltu	a5,a4,784 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 794:	ff852583          	lw	a1,-8(a0)
+ 798:	6390                	ld	a2,0(a5)
+ 79a:	02059813          	slli	a6,a1,0x20
+ 79e:	01c85713          	srli	a4,a6,0x1c
+ 7a2:	9736                	add	a4,a4,a3
+ 7a4:	fae60de3          	beq	a2,a4,75e <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7a8:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7ac:	4790                	lw	a2,8(a5)
+ 7ae:	02061593          	slli	a1,a2,0x20
+ 7b2:	01c5d713          	srli	a4,a1,0x1c
+ 7b6:	973e                	add	a4,a4,a5
+ 7b8:	fae68ae3          	beq	a3,a4,76c <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7bc:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7be:	00001717          	auipc	a4,0x1
+ 7c2:	84f73123          	sd	a5,-1982(a4) # 1000 <freep>
+}
+ 7c6:	6422                	ld	s0,8(sp)
+ 7c8:	0141                	addi	sp,sp,16
+ 7ca:	8082                	ret
+
+00000000000007cc <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7cc:	7139                	addi	sp,sp,-64
+ 7ce:	fc06                	sd	ra,56(sp)
+ 7d0:	f822                	sd	s0,48(sp)
+ 7d2:	f426                	sd	s1,40(sp)
+ 7d4:	ec4e                	sd	s3,24(sp)
+ 7d6:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7d8:	02051493          	slli	s1,a0,0x20
+ 7dc:	9081                	srli	s1,s1,0x20
+ 7de:	04bd                	addi	s1,s1,15
+ 7e0:	8091                	srli	s1,s1,0x4
+ 7e2:	0014899b          	addiw	s3,s1,1
+ 7e6:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7e8:	00001517          	auipc	a0,0x1
+ 7ec:	81853503          	ld	a0,-2024(a0) # 1000 <freep>
+ 7f0:	c915                	beqz	a0,824 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7f2:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 7f4:	4798                	lw	a4,8(a5)
+ 7f6:	08977a63          	bgeu	a4,s1,88a <malloc+0xbe>
+ 7fa:	f04a                	sd	s2,32(sp)
+ 7fc:	e852                	sd	s4,16(sp)
+ 7fe:	e456                	sd	s5,8(sp)
+ 800:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 802:	8a4e                	mv	s4,s3
+ 804:	0009871b          	sext.w	a4,s3
+ 808:	6685                	lui	a3,0x1
+ 80a:	00d77363          	bgeu	a4,a3,810 <malloc+0x44>
+ 80e:	6a05                	lui	s4,0x1
+ 810:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 814:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 818:	00000917          	auipc	s2,0x0
+ 81c:	7e890913          	addi	s2,s2,2024 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 820:	5afd                	li	s5,-1
+ 822:	a081                	j	862 <malloc+0x96>
+ 824:	f04a                	sd	s2,32(sp)
+ 826:	e852                	sd	s4,16(sp)
+ 828:	e456                	sd	s5,8(sp)
+ 82a:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 82c:	00000797          	auipc	a5,0x0
+ 830:	7e478793          	addi	a5,a5,2020 # 1010 <base>
+ 834:	00000717          	auipc	a4,0x0
+ 838:	7cf73623          	sd	a5,1996(a4) # 1000 <freep>
+ 83c:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 83e:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 842:	b7c1                	j	802 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 844:	6398                	ld	a4,0(a5)
+ 846:	e118                	sd	a4,0(a0)
+ 848:	a8a9                	j	8a2 <malloc+0xd6>
+  hp->s.size = nu;
+ 84a:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 84e:	0541                	addi	a0,a0,16
+ 850:	efbff0ef          	jal	74a <free>
+  return freep;
+ 854:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 858:	c12d                	beqz	a0,8ba <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 85a:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 85c:	4798                	lw	a4,8(a5)
+ 85e:	02977263          	bgeu	a4,s1,882 <malloc+0xb6>
+    if(p == freep)
+ 862:	00093703          	ld	a4,0(s2)
+ 866:	853e                	mv	a0,a5
+ 868:	fef719e3          	bne	a4,a5,85a <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 86c:	8552                	mv	a0,s4
+ 86e:	a47ff0ef          	jal	2b4 <sbrk>
+  if(p == SBRK_ERROR)
+ 872:	fd551ce3          	bne	a0,s5,84a <malloc+0x7e>
+        return 0;
+ 876:	4501                	li	a0,0
+ 878:	7902                	ld	s2,32(sp)
+ 87a:	6a42                	ld	s4,16(sp)
+ 87c:	6aa2                	ld	s5,8(sp)
+ 87e:	6b02                	ld	s6,0(sp)
+ 880:	a03d                	j	8ae <malloc+0xe2>
+ 882:	7902                	ld	s2,32(sp)
+ 884:	6a42                	ld	s4,16(sp)
+ 886:	6aa2                	ld	s5,8(sp)
+ 888:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 88a:	fae48de3          	beq	s1,a4,844 <malloc+0x78>
+        p->s.size -= nunits;
+ 88e:	4137073b          	subw	a4,a4,s3
+ 892:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 894:	02071693          	slli	a3,a4,0x20
+ 898:	01c6d713          	srli	a4,a3,0x1c
+ 89c:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 89e:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8a2:	00000717          	auipc	a4,0x0
+ 8a6:	74a73f23          	sd	a0,1886(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8aa:	01078513          	addi	a0,a5,16
+  }
+}
+ 8ae:	70e2                	ld	ra,56(sp)
+ 8b0:	7442                	ld	s0,48(sp)
+ 8b2:	74a2                	ld	s1,40(sp)
+ 8b4:	69e2                	ld	s3,24(sp)
+ 8b6:	6121                	addi	sp,sp,64
+ 8b8:	8082                	ret
+ 8ba:	7902                	ld	s2,32(sp)
+ 8bc:	6a42                	ld	s4,16(sp)
+ 8be:	6aa2                	ld	s5,8(sp)
+ 8c0:	6b02                	ld	s6,0(sp)
+ 8c2:	b7f5                	j	8ae <malloc+0xe2>
diff -ruN xv6-riscv/user/kill.d xv62/user/kill.d
--- xv6-riscv/user/kill.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/kill.d	2025-09-14 12:32:50.912883308 +0000
@@ -0,0 +1 @@
+user/kill.o: user/kill.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/kill.o and xv62/user/kill.o differ
diff -ruN xv6-riscv/user/kill.sym xv62/user/kill.sym
--- xv6-riscv/user/kill.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/kill.sym	2025-09-14 12:32:50.932883304 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008c8 .rodata
+0000000000000908 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 kill.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000390 putc
+00000000000003ae printint
+00000000000008f0 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+0000000000000064 strcpy
+0000000000000378 pause
+0000000000000718 printf
+0000000000000370 sys_sbrk
+000000000000020e memmove
+0000000000000330 mknod
+000000000000011c gets
+0000000000000368 getpid
+00000000000002a0 memcpy
+00000000000007cc malloc
+00000000000002ca sbrklazy
+00000000000002f8 pipe
+0000000000000308 write
+0000000000000340 fstat
+00000000000006ee fprintf
+0000000000000318 kill
+000000000000044a vprintf
+0000000000000358 chdir
+0000000000000320 exec
+00000000000002f0 wait
+0000000000000300 read
+0000000000000338 unlink
+0000000000000266 memcmp
+00000000000002e0 fork
+00000000000002b4 sbrk
+0000000000000380 uptime
+00000000000000d6 memset
+0000000000000000 main
+0000000000000080 strcmp
+0000000000000360 dup
+0000000000000388 getreadcount
+000000000000018c stat
+0000000000000348 link
+00000000000002e8 exit
+0000000000000054 start
+00000000000001c6 atoi
+00000000000000ac strlen
+0000000000000328 open
+00000000000000f8 strchr
+0000000000000350 mkdir
+0000000000000310 close
+000000000000074a free
diff -ruN xv6-riscv/user/ln.asm xv62/user/ln.asm
--- xv6-riscv/user/ln.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ln.asm	2025-09-14 12:32:50.984883293 +0000
@@ -0,0 +1,1502 @@
+
+user/_ln:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	1000                	addi	s0,sp,32
+  if(argc != 3){
+   8:	478d                	li	a5,3
+   a:	00f50d63          	beq	a0,a5,24 <main+0x24>
+   e:	e426                	sd	s1,8(sp)
+    fprintf(2, "Usage: ln old new\n");
+  10:	00001597          	auipc	a1,0x1
+  14:	8b058593          	addi	a1,a1,-1872 # 8c0 <malloc+0xfa>
+  18:	4509                	li	a0,2
+  1a:	6ce000ef          	jal	6e8 <fprintf>
+    exit(1);
+  1e:	4505                	li	a0,1
+  20:	2c2000ef          	jal	2e2 <exit>
+  24:	e426                	sd	s1,8(sp)
+  26:	84ae                	mv	s1,a1
+  }
+  if(link(argv[1], argv[2]) < 0)
+  28:	698c                	ld	a1,16(a1)
+  2a:	6488                	ld	a0,8(s1)
+  2c:	316000ef          	jal	342 <link>
+  30:	00054563          	bltz	a0,3a <main+0x3a>
+    fprintf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  exit(0);
+  34:	4501                	li	a0,0
+  36:	2ac000ef          	jal	2e2 <exit>
+    fprintf(2, "link %s %s: failed\n", argv[1], argv[2]);
+  3a:	6894                	ld	a3,16(s1)
+  3c:	6490                	ld	a2,8(s1)
+  3e:	00001597          	auipc	a1,0x1
+  42:	89a58593          	addi	a1,a1,-1894 # 8d8 <malloc+0x112>
+  46:	4509                	li	a0,2
+  48:	6a0000ef          	jal	6e8 <fprintf>
+  4c:	b7e5                	j	34 <main+0x34>
+
+000000000000004e <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  4e:	1141                	addi	sp,sp,-16
+  50:	e406                	sd	ra,8(sp)
+  52:	e022                	sd	s0,0(sp)
+  54:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  56:	fabff0ef          	jal	0 <main>
+  exit(r);
+  5a:	288000ef          	jal	2e2 <exit>
+
+000000000000005e <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  5e:	1141                	addi	sp,sp,-16
+  60:	e422                	sd	s0,8(sp)
+  62:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  64:	87aa                	mv	a5,a0
+  66:	0585                	addi	a1,a1,1
+  68:	0785                	addi	a5,a5,1
+  6a:	fff5c703          	lbu	a4,-1(a1)
+  6e:	fee78fa3          	sb	a4,-1(a5)
+  72:	fb75                	bnez	a4,66 <strcpy+0x8>
+    ;
+  return os;
+}
+  74:	6422                	ld	s0,8(sp)
+  76:	0141                	addi	sp,sp,16
+  78:	8082                	ret
+
+000000000000007a <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  7a:	1141                	addi	sp,sp,-16
+  7c:	e422                	sd	s0,8(sp)
+  7e:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  80:	00054783          	lbu	a5,0(a0)
+  84:	cb91                	beqz	a5,98 <strcmp+0x1e>
+  86:	0005c703          	lbu	a4,0(a1)
+  8a:	00f71763          	bne	a4,a5,98 <strcmp+0x1e>
+    p++, q++;
+  8e:	0505                	addi	a0,a0,1
+  90:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  92:	00054783          	lbu	a5,0(a0)
+  96:	fbe5                	bnez	a5,86 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  98:	0005c503          	lbu	a0,0(a1)
+}
+  9c:	40a7853b          	subw	a0,a5,a0
+  a0:	6422                	ld	s0,8(sp)
+  a2:	0141                	addi	sp,sp,16
+  a4:	8082                	ret
+
+00000000000000a6 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  a6:	1141                	addi	sp,sp,-16
+  a8:	e422                	sd	s0,8(sp)
+  aa:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  ac:	00054783          	lbu	a5,0(a0)
+  b0:	cf91                	beqz	a5,cc <strlen+0x26>
+  b2:	0505                	addi	a0,a0,1
+  b4:	87aa                	mv	a5,a0
+  b6:	86be                	mv	a3,a5
+  b8:	0785                	addi	a5,a5,1
+  ba:	fff7c703          	lbu	a4,-1(a5)
+  be:	ff65                	bnez	a4,b6 <strlen+0x10>
+  c0:	40a6853b          	subw	a0,a3,a0
+  c4:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  c6:	6422                	ld	s0,8(sp)
+  c8:	0141                	addi	sp,sp,16
+  ca:	8082                	ret
+  for(n = 0; s[n]; n++)
+  cc:	4501                	li	a0,0
+  ce:	bfe5                	j	c6 <strlen+0x20>
+
+00000000000000d0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  d0:	1141                	addi	sp,sp,-16
+  d2:	e422                	sd	s0,8(sp)
+  d4:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  d6:	ca19                	beqz	a2,ec <memset+0x1c>
+  d8:	87aa                	mv	a5,a0
+  da:	1602                	slli	a2,a2,0x20
+  dc:	9201                	srli	a2,a2,0x20
+  de:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  e2:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+  e6:	0785                	addi	a5,a5,1
+  e8:	fee79de3          	bne	a5,a4,e2 <memset+0x12>
+  }
+  return dst;
+}
+  ec:	6422                	ld	s0,8(sp)
+  ee:	0141                	addi	sp,sp,16
+  f0:	8082                	ret
+
+00000000000000f2 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+  f2:	1141                	addi	sp,sp,-16
+  f4:	e422                	sd	s0,8(sp)
+  f6:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+  f8:	00054783          	lbu	a5,0(a0)
+  fc:	cb99                	beqz	a5,112 <strchr+0x20>
+    if(*s == c)
+  fe:	00f58763          	beq	a1,a5,10c <strchr+0x1a>
+  for(; *s; s++)
+ 102:	0505                	addi	a0,a0,1
+ 104:	00054783          	lbu	a5,0(a0)
+ 108:	fbfd                	bnez	a5,fe <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 10a:	4501                	li	a0,0
+}
+ 10c:	6422                	ld	s0,8(sp)
+ 10e:	0141                	addi	sp,sp,16
+ 110:	8082                	ret
+  return 0;
+ 112:	4501                	li	a0,0
+ 114:	bfe5                	j	10c <strchr+0x1a>
+
+0000000000000116 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 116:	711d                	addi	sp,sp,-96
+ 118:	ec86                	sd	ra,88(sp)
+ 11a:	e8a2                	sd	s0,80(sp)
+ 11c:	e4a6                	sd	s1,72(sp)
+ 11e:	e0ca                	sd	s2,64(sp)
+ 120:	fc4e                	sd	s3,56(sp)
+ 122:	f852                	sd	s4,48(sp)
+ 124:	f456                	sd	s5,40(sp)
+ 126:	f05a                	sd	s6,32(sp)
+ 128:	ec5e                	sd	s7,24(sp)
+ 12a:	1080                	addi	s0,sp,96
+ 12c:	8baa                	mv	s7,a0
+ 12e:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 130:	892a                	mv	s2,a0
+ 132:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 134:	4aa9                	li	s5,10
+ 136:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 138:	89a6                	mv	s3,s1
+ 13a:	2485                	addiw	s1,s1,1
+ 13c:	0344d663          	bge	s1,s4,168 <gets+0x52>
+    cc = read(0, &c, 1);
+ 140:	4605                	li	a2,1
+ 142:	faf40593          	addi	a1,s0,-81
+ 146:	4501                	li	a0,0
+ 148:	1b2000ef          	jal	2fa <read>
+    if(cc < 1)
+ 14c:	00a05e63          	blez	a0,168 <gets+0x52>
+    buf[i++] = c;
+ 150:	faf44783          	lbu	a5,-81(s0)
+ 154:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 158:	01578763          	beq	a5,s5,166 <gets+0x50>
+ 15c:	0905                	addi	s2,s2,1
+ 15e:	fd679de3          	bne	a5,s6,138 <gets+0x22>
+    buf[i++] = c;
+ 162:	89a6                	mv	s3,s1
+ 164:	a011                	j	168 <gets+0x52>
+ 166:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 168:	99de                	add	s3,s3,s7
+ 16a:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 16e:	855e                	mv	a0,s7
+ 170:	60e6                	ld	ra,88(sp)
+ 172:	6446                	ld	s0,80(sp)
+ 174:	64a6                	ld	s1,72(sp)
+ 176:	6906                	ld	s2,64(sp)
+ 178:	79e2                	ld	s3,56(sp)
+ 17a:	7a42                	ld	s4,48(sp)
+ 17c:	7aa2                	ld	s5,40(sp)
+ 17e:	7b02                	ld	s6,32(sp)
+ 180:	6be2                	ld	s7,24(sp)
+ 182:	6125                	addi	sp,sp,96
+ 184:	8082                	ret
+
+0000000000000186 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 186:	1101                	addi	sp,sp,-32
+ 188:	ec06                	sd	ra,24(sp)
+ 18a:	e822                	sd	s0,16(sp)
+ 18c:	e04a                	sd	s2,0(sp)
+ 18e:	1000                	addi	s0,sp,32
+ 190:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 192:	4581                	li	a1,0
+ 194:	18e000ef          	jal	322 <open>
+  if(fd < 0)
+ 198:	02054263          	bltz	a0,1bc <stat+0x36>
+ 19c:	e426                	sd	s1,8(sp)
+ 19e:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1a0:	85ca                	mv	a1,s2
+ 1a2:	198000ef          	jal	33a <fstat>
+ 1a6:	892a                	mv	s2,a0
+  close(fd);
+ 1a8:	8526                	mv	a0,s1
+ 1aa:	160000ef          	jal	30a <close>
+  return r;
+ 1ae:	64a2                	ld	s1,8(sp)
+}
+ 1b0:	854a                	mv	a0,s2
+ 1b2:	60e2                	ld	ra,24(sp)
+ 1b4:	6442                	ld	s0,16(sp)
+ 1b6:	6902                	ld	s2,0(sp)
+ 1b8:	6105                	addi	sp,sp,32
+ 1ba:	8082                	ret
+    return -1;
+ 1bc:	597d                	li	s2,-1
+ 1be:	bfcd                	j	1b0 <stat+0x2a>
+
+00000000000001c0 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1c0:	1141                	addi	sp,sp,-16
+ 1c2:	e422                	sd	s0,8(sp)
+ 1c4:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1c6:	00054683          	lbu	a3,0(a0)
+ 1ca:	fd06879b          	addiw	a5,a3,-48
+ 1ce:	0ff7f793          	zext.b	a5,a5
+ 1d2:	4625                	li	a2,9
+ 1d4:	02f66863          	bltu	a2,a5,204 <atoi+0x44>
+ 1d8:	872a                	mv	a4,a0
+  n = 0;
+ 1da:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1dc:	0705                	addi	a4,a4,1
+ 1de:	0025179b          	slliw	a5,a0,0x2
+ 1e2:	9fa9                	addw	a5,a5,a0
+ 1e4:	0017979b          	slliw	a5,a5,0x1
+ 1e8:	9fb5                	addw	a5,a5,a3
+ 1ea:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 1ee:	00074683          	lbu	a3,0(a4)
+ 1f2:	fd06879b          	addiw	a5,a3,-48
+ 1f6:	0ff7f793          	zext.b	a5,a5
+ 1fa:	fef671e3          	bgeu	a2,a5,1dc <atoi+0x1c>
+  return n;
+}
+ 1fe:	6422                	ld	s0,8(sp)
+ 200:	0141                	addi	sp,sp,16
+ 202:	8082                	ret
+  n = 0;
+ 204:	4501                	li	a0,0
+ 206:	bfe5                	j	1fe <atoi+0x3e>
+
+0000000000000208 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 208:	1141                	addi	sp,sp,-16
+ 20a:	e422                	sd	s0,8(sp)
+ 20c:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 20e:	02b57463          	bgeu	a0,a1,236 <memmove+0x2e>
+    while(n-- > 0)
+ 212:	00c05f63          	blez	a2,230 <memmove+0x28>
+ 216:	1602                	slli	a2,a2,0x20
+ 218:	9201                	srli	a2,a2,0x20
+ 21a:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 21e:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 220:	0585                	addi	a1,a1,1
+ 222:	0705                	addi	a4,a4,1
+ 224:	fff5c683          	lbu	a3,-1(a1)
+ 228:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 22c:	fef71ae3          	bne	a4,a5,220 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 230:	6422                	ld	s0,8(sp)
+ 232:	0141                	addi	sp,sp,16
+ 234:	8082                	ret
+    dst += n;
+ 236:	00c50733          	add	a4,a0,a2
+    src += n;
+ 23a:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 23c:	fec05ae3          	blez	a2,230 <memmove+0x28>
+ 240:	fff6079b          	addiw	a5,a2,-1
+ 244:	1782                	slli	a5,a5,0x20
+ 246:	9381                	srli	a5,a5,0x20
+ 248:	fff7c793          	not	a5,a5
+ 24c:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 24e:	15fd                	addi	a1,a1,-1
+ 250:	177d                	addi	a4,a4,-1
+ 252:	0005c683          	lbu	a3,0(a1)
+ 256:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 25a:	fee79ae3          	bne	a5,a4,24e <memmove+0x46>
+ 25e:	bfc9                	j	230 <memmove+0x28>
+
+0000000000000260 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 260:	1141                	addi	sp,sp,-16
+ 262:	e422                	sd	s0,8(sp)
+ 264:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 266:	ca05                	beqz	a2,296 <memcmp+0x36>
+ 268:	fff6069b          	addiw	a3,a2,-1
+ 26c:	1682                	slli	a3,a3,0x20
+ 26e:	9281                	srli	a3,a3,0x20
+ 270:	0685                	addi	a3,a3,1
+ 272:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 274:	00054783          	lbu	a5,0(a0)
+ 278:	0005c703          	lbu	a4,0(a1)
+ 27c:	00e79863          	bne	a5,a4,28c <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 280:	0505                	addi	a0,a0,1
+    p2++;
+ 282:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 284:	fed518e3          	bne	a0,a3,274 <memcmp+0x14>
+  }
+  return 0;
+ 288:	4501                	li	a0,0
+ 28a:	a019                	j	290 <memcmp+0x30>
+      return *p1 - *p2;
+ 28c:	40e7853b          	subw	a0,a5,a4
+}
+ 290:	6422                	ld	s0,8(sp)
+ 292:	0141                	addi	sp,sp,16
+ 294:	8082                	ret
+  return 0;
+ 296:	4501                	li	a0,0
+ 298:	bfe5                	j	290 <memcmp+0x30>
+
+000000000000029a <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 29a:	1141                	addi	sp,sp,-16
+ 29c:	e406                	sd	ra,8(sp)
+ 29e:	e022                	sd	s0,0(sp)
+ 2a0:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2a2:	f67ff0ef          	jal	208 <memmove>
+}
+ 2a6:	60a2                	ld	ra,8(sp)
+ 2a8:	6402                	ld	s0,0(sp)
+ 2aa:	0141                	addi	sp,sp,16
+ 2ac:	8082                	ret
+
+00000000000002ae <sbrk>:
+
+char *
+sbrk(int n) {
+ 2ae:	1141                	addi	sp,sp,-16
+ 2b0:	e406                	sd	ra,8(sp)
+ 2b2:	e022                	sd	s0,0(sp)
+ 2b4:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2b6:	4585                	li	a1,1
+ 2b8:	0b2000ef          	jal	36a <sys_sbrk>
+}
+ 2bc:	60a2                	ld	ra,8(sp)
+ 2be:	6402                	ld	s0,0(sp)
+ 2c0:	0141                	addi	sp,sp,16
+ 2c2:	8082                	ret
+
+00000000000002c4 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2c4:	1141                	addi	sp,sp,-16
+ 2c6:	e406                	sd	ra,8(sp)
+ 2c8:	e022                	sd	s0,0(sp)
+ 2ca:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2cc:	4589                	li	a1,2
+ 2ce:	09c000ef          	jal	36a <sys_sbrk>
+}
+ 2d2:	60a2                	ld	ra,8(sp)
+ 2d4:	6402                	ld	s0,0(sp)
+ 2d6:	0141                	addi	sp,sp,16
+ 2d8:	8082                	ret
+
+00000000000002da <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2da:	4885                	li	a7,1
+ ecall
+ 2dc:	00000073          	ecall
+ ret
+ 2e0:	8082                	ret
+
+00000000000002e2 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2e2:	4889                	li	a7,2
+ ecall
+ 2e4:	00000073          	ecall
+ ret
+ 2e8:	8082                	ret
+
+00000000000002ea <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 2ea:	488d                	li	a7,3
+ ecall
+ 2ec:	00000073          	ecall
+ ret
+ 2f0:	8082                	ret
+
+00000000000002f2 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 2f2:	4891                	li	a7,4
+ ecall
+ 2f4:	00000073          	ecall
+ ret
+ 2f8:	8082                	ret
+
+00000000000002fa <read>:
+.global read
+read:
+ li a7, SYS_read
+ 2fa:	4895                	li	a7,5
+ ecall
+ 2fc:	00000073          	ecall
+ ret
+ 300:	8082                	ret
+
+0000000000000302 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 302:	48c1                	li	a7,16
+ ecall
+ 304:	00000073          	ecall
+ ret
+ 308:	8082                	ret
+
+000000000000030a <close>:
+.global close
+close:
+ li a7, SYS_close
+ 30a:	48d5                	li	a7,21
+ ecall
+ 30c:	00000073          	ecall
+ ret
+ 310:	8082                	ret
+
+0000000000000312 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 312:	4899                	li	a7,6
+ ecall
+ 314:	00000073          	ecall
+ ret
+ 318:	8082                	ret
+
+000000000000031a <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 31a:	489d                	li	a7,7
+ ecall
+ 31c:	00000073          	ecall
+ ret
+ 320:	8082                	ret
+
+0000000000000322 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 322:	48bd                	li	a7,15
+ ecall
+ 324:	00000073          	ecall
+ ret
+ 328:	8082                	ret
+
+000000000000032a <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 32a:	48c5                	li	a7,17
+ ecall
+ 32c:	00000073          	ecall
+ ret
+ 330:	8082                	ret
+
+0000000000000332 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 332:	48c9                	li	a7,18
+ ecall
+ 334:	00000073          	ecall
+ ret
+ 338:	8082                	ret
+
+000000000000033a <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 33a:	48a1                	li	a7,8
+ ecall
+ 33c:	00000073          	ecall
+ ret
+ 340:	8082                	ret
+
+0000000000000342 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 342:	48cd                	li	a7,19
+ ecall
+ 344:	00000073          	ecall
+ ret
+ 348:	8082                	ret
+
+000000000000034a <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 34a:	48d1                	li	a7,20
+ ecall
+ 34c:	00000073          	ecall
+ ret
+ 350:	8082                	ret
+
+0000000000000352 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 352:	48a5                	li	a7,9
+ ecall
+ 354:	00000073          	ecall
+ ret
+ 358:	8082                	ret
+
+000000000000035a <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 35a:	48a9                	li	a7,10
+ ecall
+ 35c:	00000073          	ecall
+ ret
+ 360:	8082                	ret
+
+0000000000000362 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 362:	48ad                	li	a7,11
+ ecall
+ 364:	00000073          	ecall
+ ret
+ 368:	8082                	ret
+
+000000000000036a <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 36a:	48b1                	li	a7,12
+ ecall
+ 36c:	00000073          	ecall
+ ret
+ 370:	8082                	ret
+
+0000000000000372 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 372:	48b5                	li	a7,13
+ ecall
+ 374:	00000073          	ecall
+ ret
+ 378:	8082                	ret
+
+000000000000037a <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 37a:	48b9                	li	a7,14
+ ecall
+ 37c:	00000073          	ecall
+ ret
+ 380:	8082                	ret
+
+0000000000000382 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 382:	48d9                	li	a7,22
+ ecall
+ 384:	00000073          	ecall
+ ret
+ 388:	8082                	ret
+
+000000000000038a <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 38a:	1101                	addi	sp,sp,-32
+ 38c:	ec06                	sd	ra,24(sp)
+ 38e:	e822                	sd	s0,16(sp)
+ 390:	1000                	addi	s0,sp,32
+ 392:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 396:	4605                	li	a2,1
+ 398:	fef40593          	addi	a1,s0,-17
+ 39c:	f67ff0ef          	jal	302 <write>
+}
+ 3a0:	60e2                	ld	ra,24(sp)
+ 3a2:	6442                	ld	s0,16(sp)
+ 3a4:	6105                	addi	sp,sp,32
+ 3a6:	8082                	ret
+
+00000000000003a8 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3a8:	715d                	addi	sp,sp,-80
+ 3aa:	e486                	sd	ra,72(sp)
+ 3ac:	e0a2                	sd	s0,64(sp)
+ 3ae:	f84a                	sd	s2,48(sp)
+ 3b0:	0880                	addi	s0,sp,80
+ 3b2:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3b4:	c299                	beqz	a3,3ba <printint+0x12>
+ 3b6:	0805c363          	bltz	a1,43c <printint+0x94>
+  neg = 0;
+ 3ba:	4881                	li	a7,0
+ 3bc:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3c0:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3c2:	00000517          	auipc	a0,0x0
+ 3c6:	53650513          	addi	a0,a0,1334 # 8f8 <digits>
+ 3ca:	883e                	mv	a6,a5
+ 3cc:	2785                	addiw	a5,a5,1
+ 3ce:	02c5f733          	remu	a4,a1,a2
+ 3d2:	972a                	add	a4,a4,a0
+ 3d4:	00074703          	lbu	a4,0(a4)
+ 3d8:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3dc:	872e                	mv	a4,a1
+ 3de:	02c5d5b3          	divu	a1,a1,a2
+ 3e2:	0685                	addi	a3,a3,1
+ 3e4:	fec773e3          	bgeu	a4,a2,3ca <printint+0x22>
+  if(neg)
+ 3e8:	00088b63          	beqz	a7,3fe <printint+0x56>
+    buf[i++] = '-';
+ 3ec:	fd078793          	addi	a5,a5,-48
+ 3f0:	97a2                	add	a5,a5,s0
+ 3f2:	02d00713          	li	a4,45
+ 3f6:	fee78423          	sb	a4,-24(a5)
+ 3fa:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 3fe:	02f05a63          	blez	a5,432 <printint+0x8a>
+ 402:	fc26                	sd	s1,56(sp)
+ 404:	f44e                	sd	s3,40(sp)
+ 406:	fb840713          	addi	a4,s0,-72
+ 40a:	00f704b3          	add	s1,a4,a5
+ 40e:	fff70993          	addi	s3,a4,-1
+ 412:	99be                	add	s3,s3,a5
+ 414:	37fd                	addiw	a5,a5,-1
+ 416:	1782                	slli	a5,a5,0x20
+ 418:	9381                	srli	a5,a5,0x20
+ 41a:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 41e:	fff4c583          	lbu	a1,-1(s1)
+ 422:	854a                	mv	a0,s2
+ 424:	f67ff0ef          	jal	38a <putc>
+  while(--i >= 0)
+ 428:	14fd                	addi	s1,s1,-1
+ 42a:	ff349ae3          	bne	s1,s3,41e <printint+0x76>
+ 42e:	74e2                	ld	s1,56(sp)
+ 430:	79a2                	ld	s3,40(sp)
+}
+ 432:	60a6                	ld	ra,72(sp)
+ 434:	6406                	ld	s0,64(sp)
+ 436:	7942                	ld	s2,48(sp)
+ 438:	6161                	addi	sp,sp,80
+ 43a:	8082                	ret
+    x = -xx;
+ 43c:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 440:	4885                	li	a7,1
+    x = -xx;
+ 442:	bfad                	j	3bc <printint+0x14>
+
+0000000000000444 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 444:	711d                	addi	sp,sp,-96
+ 446:	ec86                	sd	ra,88(sp)
+ 448:	e8a2                	sd	s0,80(sp)
+ 44a:	e0ca                	sd	s2,64(sp)
+ 44c:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 44e:	0005c903          	lbu	s2,0(a1)
+ 452:	28090663          	beqz	s2,6de <vprintf+0x29a>
+ 456:	e4a6                	sd	s1,72(sp)
+ 458:	fc4e                	sd	s3,56(sp)
+ 45a:	f852                	sd	s4,48(sp)
+ 45c:	f456                	sd	s5,40(sp)
+ 45e:	f05a                	sd	s6,32(sp)
+ 460:	ec5e                	sd	s7,24(sp)
+ 462:	e862                	sd	s8,16(sp)
+ 464:	e466                	sd	s9,8(sp)
+ 466:	8b2a                	mv	s6,a0
+ 468:	8a2e                	mv	s4,a1
+ 46a:	8bb2                	mv	s7,a2
+  state = 0;
+ 46c:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 46e:	4481                	li	s1,0
+ 470:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 472:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 476:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 47a:	06c00c93          	li	s9,108
+ 47e:	a005                	j	49e <vprintf+0x5a>
+        putc(fd, c0);
+ 480:	85ca                	mv	a1,s2
+ 482:	855a                	mv	a0,s6
+ 484:	f07ff0ef          	jal	38a <putc>
+ 488:	a019                	j	48e <vprintf+0x4a>
+    } else if(state == '%'){
+ 48a:	03598263          	beq	s3,s5,4ae <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 48e:	2485                	addiw	s1,s1,1
+ 490:	8726                	mv	a4,s1
+ 492:	009a07b3          	add	a5,s4,s1
+ 496:	0007c903          	lbu	s2,0(a5)
+ 49a:	22090a63          	beqz	s2,6ce <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 49e:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4a2:	fe0994e3          	bnez	s3,48a <vprintf+0x46>
+      if(c0 == '%'){
+ 4a6:	fd579de3          	bne	a5,s5,480 <vprintf+0x3c>
+        state = '%';
+ 4aa:	89be                	mv	s3,a5
+ 4ac:	b7cd                	j	48e <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4ae:	00ea06b3          	add	a3,s4,a4
+ 4b2:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4b6:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4b8:	c681                	beqz	a3,4c0 <vprintf+0x7c>
+ 4ba:	9752                	add	a4,a4,s4
+ 4bc:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4c0:	05878363          	beq	a5,s8,506 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4c4:	05978d63          	beq	a5,s9,51e <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4c8:	07500713          	li	a4,117
+ 4cc:	0ee78763          	beq	a5,a4,5ba <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4d0:	07800713          	li	a4,120
+ 4d4:	12e78963          	beq	a5,a4,606 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4d8:	07000713          	li	a4,112
+ 4dc:	14e78e63          	beq	a5,a4,638 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4e0:	06300713          	li	a4,99
+ 4e4:	18e78e63          	beq	a5,a4,680 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 4e8:	07300713          	li	a4,115
+ 4ec:	1ae78463          	beq	a5,a4,694 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 4f0:	02500713          	li	a4,37
+ 4f4:	04e79563          	bne	a5,a4,53e <vprintf+0xfa>
+        putc(fd, '%');
+ 4f8:	02500593          	li	a1,37
+ 4fc:	855a                	mv	a0,s6
+ 4fe:	e8dff0ef          	jal	38a <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 502:	4981                	li	s3,0
+ 504:	b769                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 506:	008b8913          	addi	s2,s7,8
+ 50a:	4685                	li	a3,1
+ 50c:	4629                	li	a2,10
+ 50e:	000ba583          	lw	a1,0(s7)
+ 512:	855a                	mv	a0,s6
+ 514:	e95ff0ef          	jal	3a8 <printint>
+ 518:	8bca                	mv	s7,s2
+      state = 0;
+ 51a:	4981                	li	s3,0
+ 51c:	bf8d                	j	48e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 51e:	06400793          	li	a5,100
+ 522:	02f68963          	beq	a3,a5,554 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 526:	06c00793          	li	a5,108
+ 52a:	04f68263          	beq	a3,a5,56e <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 52e:	07500793          	li	a5,117
+ 532:	0af68063          	beq	a3,a5,5d2 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 536:	07800793          	li	a5,120
+ 53a:	0ef68263          	beq	a3,a5,61e <vprintf+0x1da>
+        putc(fd, '%');
+ 53e:	02500593          	li	a1,37
+ 542:	855a                	mv	a0,s6
+ 544:	e47ff0ef          	jal	38a <putc>
+        putc(fd, c0);
+ 548:	85ca                	mv	a1,s2
+ 54a:	855a                	mv	a0,s6
+ 54c:	e3fff0ef          	jal	38a <putc>
+      state = 0;
+ 550:	4981                	li	s3,0
+ 552:	bf35                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 554:	008b8913          	addi	s2,s7,8
+ 558:	4685                	li	a3,1
+ 55a:	4629                	li	a2,10
+ 55c:	000bb583          	ld	a1,0(s7)
+ 560:	855a                	mv	a0,s6
+ 562:	e47ff0ef          	jal	3a8 <printint>
+        i += 1;
+ 566:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 568:	8bca                	mv	s7,s2
+      state = 0;
+ 56a:	4981                	li	s3,0
+        i += 1;
+ 56c:	b70d                	j	48e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 56e:	06400793          	li	a5,100
+ 572:	02f60763          	beq	a2,a5,5a0 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 576:	07500793          	li	a5,117
+ 57a:	06f60963          	beq	a2,a5,5ec <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 57e:	07800793          	li	a5,120
+ 582:	faf61ee3          	bne	a2,a5,53e <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 586:	008b8913          	addi	s2,s7,8
+ 58a:	4681                	li	a3,0
+ 58c:	4641                	li	a2,16
+ 58e:	000bb583          	ld	a1,0(s7)
+ 592:	855a                	mv	a0,s6
+ 594:	e15ff0ef          	jal	3a8 <printint>
+        i += 2;
+ 598:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 59a:	8bca                	mv	s7,s2
+      state = 0;
+ 59c:	4981                	li	s3,0
+        i += 2;
+ 59e:	bdc5                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5a0:	008b8913          	addi	s2,s7,8
+ 5a4:	4685                	li	a3,1
+ 5a6:	4629                	li	a2,10
+ 5a8:	000bb583          	ld	a1,0(s7)
+ 5ac:	855a                	mv	a0,s6
+ 5ae:	dfbff0ef          	jal	3a8 <printint>
+        i += 2;
+ 5b2:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5b4:	8bca                	mv	s7,s2
+      state = 0;
+ 5b6:	4981                	li	s3,0
+        i += 2;
+ 5b8:	bdd9                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5ba:	008b8913          	addi	s2,s7,8
+ 5be:	4681                	li	a3,0
+ 5c0:	4629                	li	a2,10
+ 5c2:	000be583          	lwu	a1,0(s7)
+ 5c6:	855a                	mv	a0,s6
+ 5c8:	de1ff0ef          	jal	3a8 <printint>
+ 5cc:	8bca                	mv	s7,s2
+      state = 0;
+ 5ce:	4981                	li	s3,0
+ 5d0:	bd7d                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5d2:	008b8913          	addi	s2,s7,8
+ 5d6:	4681                	li	a3,0
+ 5d8:	4629                	li	a2,10
+ 5da:	000bb583          	ld	a1,0(s7)
+ 5de:	855a                	mv	a0,s6
+ 5e0:	dc9ff0ef          	jal	3a8 <printint>
+        i += 1;
+ 5e4:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5e6:	8bca                	mv	s7,s2
+      state = 0;
+ 5e8:	4981                	li	s3,0
+        i += 1;
+ 5ea:	b555                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5ec:	008b8913          	addi	s2,s7,8
+ 5f0:	4681                	li	a3,0
+ 5f2:	4629                	li	a2,10
+ 5f4:	000bb583          	ld	a1,0(s7)
+ 5f8:	855a                	mv	a0,s6
+ 5fa:	dafff0ef          	jal	3a8 <printint>
+        i += 2;
+ 5fe:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 600:	8bca                	mv	s7,s2
+      state = 0;
+ 602:	4981                	li	s3,0
+        i += 2;
+ 604:	b569                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 606:	008b8913          	addi	s2,s7,8
+ 60a:	4681                	li	a3,0
+ 60c:	4641                	li	a2,16
+ 60e:	000be583          	lwu	a1,0(s7)
+ 612:	855a                	mv	a0,s6
+ 614:	d95ff0ef          	jal	3a8 <printint>
+ 618:	8bca                	mv	s7,s2
+      state = 0;
+ 61a:	4981                	li	s3,0
+ 61c:	bd8d                	j	48e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 61e:	008b8913          	addi	s2,s7,8
+ 622:	4681                	li	a3,0
+ 624:	4641                	li	a2,16
+ 626:	000bb583          	ld	a1,0(s7)
+ 62a:	855a                	mv	a0,s6
+ 62c:	d7dff0ef          	jal	3a8 <printint>
+        i += 1;
+ 630:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 632:	8bca                	mv	s7,s2
+      state = 0;
+ 634:	4981                	li	s3,0
+        i += 1;
+ 636:	bda1                	j	48e <vprintf+0x4a>
+ 638:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 63a:	008b8d13          	addi	s10,s7,8
+ 63e:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 642:	03000593          	li	a1,48
+ 646:	855a                	mv	a0,s6
+ 648:	d43ff0ef          	jal	38a <putc>
+  putc(fd, 'x');
+ 64c:	07800593          	li	a1,120
+ 650:	855a                	mv	a0,s6
+ 652:	d39ff0ef          	jal	38a <putc>
+ 656:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 658:	00000b97          	auipc	s7,0x0
+ 65c:	2a0b8b93          	addi	s7,s7,672 # 8f8 <digits>
+ 660:	03c9d793          	srli	a5,s3,0x3c
+ 664:	97de                	add	a5,a5,s7
+ 666:	0007c583          	lbu	a1,0(a5)
+ 66a:	855a                	mv	a0,s6
+ 66c:	d1fff0ef          	jal	38a <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 670:	0992                	slli	s3,s3,0x4
+ 672:	397d                	addiw	s2,s2,-1
+ 674:	fe0916e3          	bnez	s2,660 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 678:	8bea                	mv	s7,s10
+      state = 0;
+ 67a:	4981                	li	s3,0
+ 67c:	6d02                	ld	s10,0(sp)
+ 67e:	bd01                	j	48e <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 680:	008b8913          	addi	s2,s7,8
+ 684:	000bc583          	lbu	a1,0(s7)
+ 688:	855a                	mv	a0,s6
+ 68a:	d01ff0ef          	jal	38a <putc>
+ 68e:	8bca                	mv	s7,s2
+      state = 0;
+ 690:	4981                	li	s3,0
+ 692:	bbf5                	j	48e <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 694:	008b8993          	addi	s3,s7,8
+ 698:	000bb903          	ld	s2,0(s7)
+ 69c:	00090f63          	beqz	s2,6ba <vprintf+0x276>
+        for(; *s; s++)
+ 6a0:	00094583          	lbu	a1,0(s2)
+ 6a4:	c195                	beqz	a1,6c8 <vprintf+0x284>
+          putc(fd, *s);
+ 6a6:	855a                	mv	a0,s6
+ 6a8:	ce3ff0ef          	jal	38a <putc>
+        for(; *s; s++)
+ 6ac:	0905                	addi	s2,s2,1
+ 6ae:	00094583          	lbu	a1,0(s2)
+ 6b2:	f9f5                	bnez	a1,6a6 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6b4:	8bce                	mv	s7,s3
+      state = 0;
+ 6b6:	4981                	li	s3,0
+ 6b8:	bbd9                	j	48e <vprintf+0x4a>
+          s = "(null)";
+ 6ba:	00000917          	auipc	s2,0x0
+ 6be:	23690913          	addi	s2,s2,566 # 8f0 <malloc+0x12a>
+        for(; *s; s++)
+ 6c2:	02800593          	li	a1,40
+ 6c6:	b7c5                	j	6a6 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6c8:	8bce                	mv	s7,s3
+      state = 0;
+ 6ca:	4981                	li	s3,0
+ 6cc:	b3c9                	j	48e <vprintf+0x4a>
+ 6ce:	64a6                	ld	s1,72(sp)
+ 6d0:	79e2                	ld	s3,56(sp)
+ 6d2:	7a42                	ld	s4,48(sp)
+ 6d4:	7aa2                	ld	s5,40(sp)
+ 6d6:	7b02                	ld	s6,32(sp)
+ 6d8:	6be2                	ld	s7,24(sp)
+ 6da:	6c42                	ld	s8,16(sp)
+ 6dc:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6de:	60e6                	ld	ra,88(sp)
+ 6e0:	6446                	ld	s0,80(sp)
+ 6e2:	6906                	ld	s2,64(sp)
+ 6e4:	6125                	addi	sp,sp,96
+ 6e6:	8082                	ret
+
+00000000000006e8 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 6e8:	715d                	addi	sp,sp,-80
+ 6ea:	ec06                	sd	ra,24(sp)
+ 6ec:	e822                	sd	s0,16(sp)
+ 6ee:	1000                	addi	s0,sp,32
+ 6f0:	e010                	sd	a2,0(s0)
+ 6f2:	e414                	sd	a3,8(s0)
+ 6f4:	e818                	sd	a4,16(s0)
+ 6f6:	ec1c                	sd	a5,24(s0)
+ 6f8:	03043023          	sd	a6,32(s0)
+ 6fc:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 700:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 704:	8622                	mv	a2,s0
+ 706:	d3fff0ef          	jal	444 <vprintf>
+}
+ 70a:	60e2                	ld	ra,24(sp)
+ 70c:	6442                	ld	s0,16(sp)
+ 70e:	6161                	addi	sp,sp,80
+ 710:	8082                	ret
+
+0000000000000712 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 712:	711d                	addi	sp,sp,-96
+ 714:	ec06                	sd	ra,24(sp)
+ 716:	e822                	sd	s0,16(sp)
+ 718:	1000                	addi	s0,sp,32
+ 71a:	e40c                	sd	a1,8(s0)
+ 71c:	e810                	sd	a2,16(s0)
+ 71e:	ec14                	sd	a3,24(s0)
+ 720:	f018                	sd	a4,32(s0)
+ 722:	f41c                	sd	a5,40(s0)
+ 724:	03043823          	sd	a6,48(s0)
+ 728:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 72c:	00840613          	addi	a2,s0,8
+ 730:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 734:	85aa                	mv	a1,a0
+ 736:	4505                	li	a0,1
+ 738:	d0dff0ef          	jal	444 <vprintf>
+}
+ 73c:	60e2                	ld	ra,24(sp)
+ 73e:	6442                	ld	s0,16(sp)
+ 740:	6125                	addi	sp,sp,96
+ 742:	8082                	ret
+
+0000000000000744 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 744:	1141                	addi	sp,sp,-16
+ 746:	e422                	sd	s0,8(sp)
+ 748:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 74a:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 74e:	00001797          	auipc	a5,0x1
+ 752:	8b27b783          	ld	a5,-1870(a5) # 1000 <freep>
+ 756:	a02d                	j	780 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 758:	4618                	lw	a4,8(a2)
+ 75a:	9f2d                	addw	a4,a4,a1
+ 75c:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 760:	6398                	ld	a4,0(a5)
+ 762:	6310                	ld	a2,0(a4)
+ 764:	a83d                	j	7a2 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 766:	ff852703          	lw	a4,-8(a0)
+ 76a:	9f31                	addw	a4,a4,a2
+ 76c:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 76e:	ff053683          	ld	a3,-16(a0)
+ 772:	a091                	j	7b6 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 774:	6398                	ld	a4,0(a5)
+ 776:	00e7e463          	bltu	a5,a4,77e <free+0x3a>
+ 77a:	00e6ea63          	bltu	a3,a4,78e <free+0x4a>
+{
+ 77e:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 780:	fed7fae3          	bgeu	a5,a3,774 <free+0x30>
+ 784:	6398                	ld	a4,0(a5)
+ 786:	00e6e463          	bltu	a3,a4,78e <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 78a:	fee7eae3          	bltu	a5,a4,77e <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 78e:	ff852583          	lw	a1,-8(a0)
+ 792:	6390                	ld	a2,0(a5)
+ 794:	02059813          	slli	a6,a1,0x20
+ 798:	01c85713          	srli	a4,a6,0x1c
+ 79c:	9736                	add	a4,a4,a3
+ 79e:	fae60de3          	beq	a2,a4,758 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7a2:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7a6:	4790                	lw	a2,8(a5)
+ 7a8:	02061593          	slli	a1,a2,0x20
+ 7ac:	01c5d713          	srli	a4,a1,0x1c
+ 7b0:	973e                	add	a4,a4,a5
+ 7b2:	fae68ae3          	beq	a3,a4,766 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7b6:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7b8:	00001717          	auipc	a4,0x1
+ 7bc:	84f73423          	sd	a5,-1976(a4) # 1000 <freep>
+}
+ 7c0:	6422                	ld	s0,8(sp)
+ 7c2:	0141                	addi	sp,sp,16
+ 7c4:	8082                	ret
+
+00000000000007c6 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7c6:	7139                	addi	sp,sp,-64
+ 7c8:	fc06                	sd	ra,56(sp)
+ 7ca:	f822                	sd	s0,48(sp)
+ 7cc:	f426                	sd	s1,40(sp)
+ 7ce:	ec4e                	sd	s3,24(sp)
+ 7d0:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7d2:	02051493          	slli	s1,a0,0x20
+ 7d6:	9081                	srli	s1,s1,0x20
+ 7d8:	04bd                	addi	s1,s1,15
+ 7da:	8091                	srli	s1,s1,0x4
+ 7dc:	0014899b          	addiw	s3,s1,1
+ 7e0:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7e2:	00001517          	auipc	a0,0x1
+ 7e6:	81e53503          	ld	a0,-2018(a0) # 1000 <freep>
+ 7ea:	c915                	beqz	a0,81e <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7ec:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 7ee:	4798                	lw	a4,8(a5)
+ 7f0:	08977a63          	bgeu	a4,s1,884 <malloc+0xbe>
+ 7f4:	f04a                	sd	s2,32(sp)
+ 7f6:	e852                	sd	s4,16(sp)
+ 7f8:	e456                	sd	s5,8(sp)
+ 7fa:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 7fc:	8a4e                	mv	s4,s3
+ 7fe:	0009871b          	sext.w	a4,s3
+ 802:	6685                	lui	a3,0x1
+ 804:	00d77363          	bgeu	a4,a3,80a <malloc+0x44>
+ 808:	6a05                	lui	s4,0x1
+ 80a:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 80e:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 812:	00000917          	auipc	s2,0x0
+ 816:	7ee90913          	addi	s2,s2,2030 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 81a:	5afd                	li	s5,-1
+ 81c:	a081                	j	85c <malloc+0x96>
+ 81e:	f04a                	sd	s2,32(sp)
+ 820:	e852                	sd	s4,16(sp)
+ 822:	e456                	sd	s5,8(sp)
+ 824:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 826:	00000797          	auipc	a5,0x0
+ 82a:	7ea78793          	addi	a5,a5,2026 # 1010 <base>
+ 82e:	00000717          	auipc	a4,0x0
+ 832:	7cf73923          	sd	a5,2002(a4) # 1000 <freep>
+ 836:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 838:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 83c:	b7c1                	j	7fc <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 83e:	6398                	ld	a4,0(a5)
+ 840:	e118                	sd	a4,0(a0)
+ 842:	a8a9                	j	89c <malloc+0xd6>
+  hp->s.size = nu;
+ 844:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 848:	0541                	addi	a0,a0,16
+ 84a:	efbff0ef          	jal	744 <free>
+  return freep;
+ 84e:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 852:	c12d                	beqz	a0,8b4 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 854:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 856:	4798                	lw	a4,8(a5)
+ 858:	02977263          	bgeu	a4,s1,87c <malloc+0xb6>
+    if(p == freep)
+ 85c:	00093703          	ld	a4,0(s2)
+ 860:	853e                	mv	a0,a5
+ 862:	fef719e3          	bne	a4,a5,854 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 866:	8552                	mv	a0,s4
+ 868:	a47ff0ef          	jal	2ae <sbrk>
+  if(p == SBRK_ERROR)
+ 86c:	fd551ce3          	bne	a0,s5,844 <malloc+0x7e>
+        return 0;
+ 870:	4501                	li	a0,0
+ 872:	7902                	ld	s2,32(sp)
+ 874:	6a42                	ld	s4,16(sp)
+ 876:	6aa2                	ld	s5,8(sp)
+ 878:	6b02                	ld	s6,0(sp)
+ 87a:	a03d                	j	8a8 <malloc+0xe2>
+ 87c:	7902                	ld	s2,32(sp)
+ 87e:	6a42                	ld	s4,16(sp)
+ 880:	6aa2                	ld	s5,8(sp)
+ 882:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 884:	fae48de3          	beq	s1,a4,83e <malloc+0x78>
+        p->s.size -= nunits;
+ 888:	4137073b          	subw	a4,a4,s3
+ 88c:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 88e:	02071693          	slli	a3,a4,0x20
+ 892:	01c6d713          	srli	a4,a3,0x1c
+ 896:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 898:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 89c:	00000717          	auipc	a4,0x0
+ 8a0:	76a73223          	sd	a0,1892(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8a4:	01078513          	addi	a0,a5,16
+  }
+}
+ 8a8:	70e2                	ld	ra,56(sp)
+ 8aa:	7442                	ld	s0,48(sp)
+ 8ac:	74a2                	ld	s1,40(sp)
+ 8ae:	69e2                	ld	s3,24(sp)
+ 8b0:	6121                	addi	sp,sp,64
+ 8b2:	8082                	ret
+ 8b4:	7902                	ld	s2,32(sp)
+ 8b6:	6a42                	ld	s4,16(sp)
+ 8b8:	6aa2                	ld	s5,8(sp)
+ 8ba:	6b02                	ld	s6,0(sp)
+ 8bc:	b7f5                	j	8a8 <malloc+0xe2>
diff -ruN xv6-riscv/user/ln.d xv62/user/ln.d
--- xv6-riscv/user/ln.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ln.d	2025-09-14 12:32:50.968883296 +0000
@@ -0,0 +1 @@
+user/ln.o: user/ln.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/ln.o and xv62/user/ln.o differ
diff -ruN xv6-riscv/user/ln.sym xv62/user/ln.sym
--- xv6-riscv/user/ln.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ln.sym	2025-09-14 12:32:50.988883292 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008c0 .rodata
+0000000000000910 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 ln.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+000000000000038a putc
+00000000000003a8 printint
+00000000000008f8 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+000000000000005e strcpy
+0000000000000372 pause
+0000000000000712 printf
+000000000000036a sys_sbrk
+0000000000000208 memmove
+000000000000032a mknod
+0000000000000116 gets
+0000000000000362 getpid
+000000000000029a memcpy
+00000000000007c6 malloc
+00000000000002c4 sbrklazy
+00000000000002f2 pipe
+0000000000000302 write
+000000000000033a fstat
+00000000000006e8 fprintf
+0000000000000312 kill
+0000000000000444 vprintf
+0000000000000352 chdir
+000000000000031a exec
+00000000000002ea wait
+00000000000002fa read
+0000000000000332 unlink
+0000000000000260 memcmp
+00000000000002da fork
+00000000000002ae sbrk
+000000000000037a uptime
+00000000000000d0 memset
+0000000000000000 main
+000000000000007a strcmp
+000000000000035a dup
+0000000000000382 getreadcount
+0000000000000186 stat
+0000000000000342 link
+00000000000002e2 exit
+000000000000004e start
+00000000000001c0 atoi
+00000000000000a6 strlen
+0000000000000322 open
+00000000000000f2 strchr
+000000000000034a mkdir
+000000000000030a close
+0000000000000744 free
diff -ruN xv6-riscv/user/logstress.asm xv62/user/logstress.asm
--- xv6-riscv/user/logstress.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/logstress.asm	2025-09-14 12:32:52.192883045 +0000
@@ -0,0 +1,1588 @@
+
+user/_logstress:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+main(int argc, char **argv)
+{
+  int fd, n;
+  enum { N = 250, SZ=2000 };
+  
+  for (int i = 1; i < argc; i++){
+   0:	4785                	li	a5,1
+   2:	0ea7df63          	bge	a5,a0,100 <main+0x100>
+{
+   6:	7139                	addi	sp,sp,-64
+   8:	fc06                	sd	ra,56(sp)
+   a:	f822                	sd	s0,48(sp)
+   c:	f426                	sd	s1,40(sp)
+   e:	f04a                	sd	s2,32(sp)
+  10:	ec4e                	sd	s3,24(sp)
+  12:	0080                	addi	s0,sp,64
+  14:	892a                	mv	s2,a0
+  16:	89ae                	mv	s3,a1
+  for (int i = 1; i < argc; i++){
+  18:	4485                	li	s1,1
+  1a:	a011                	j	1e <main+0x1e>
+  1c:	84be                	mv	s1,a5
+    int pid1 = fork();
+  1e:	372000ef          	jal	390 <fork>
+    if(pid1 < 0){
+  22:	00054963          	bltz	a0,34 <main+0x34>
+      printf("%s: fork failed\n", argv[0]);
+      exit(1);
+    }
+    if(pid1 == 0) {
+  26:	c11d                	beqz	a0,4c <main+0x4c>
+  for (int i = 1; i < argc; i++){
+  28:	0014879b          	addiw	a5,s1,1
+  2c:	fef918e3          	bne	s2,a5,1c <main+0x1c>
+      }
+      exit(0);
+    }
+  }
+  int xstatus;
+  for(int i = 1; i < argc; i++){
+  30:	4905                	li	s2,1
+  32:	a04d                	j	d4 <main+0xd4>
+  34:	e852                	sd	s4,16(sp)
+      printf("%s: fork failed\n", argv[0]);
+  36:	0009b583          	ld	a1,0(s3)
+  3a:	00001517          	auipc	a0,0x1
+  3e:	94650513          	addi	a0,a0,-1722 # 980 <malloc+0x104>
+  42:	786000ef          	jal	7c8 <printf>
+      exit(1);
+  46:	4505                	li	a0,1
+  48:	350000ef          	jal	398 <exit>
+  4c:	e852                	sd	s4,16(sp)
+      fd = open(argv[i], O_CREATE | O_RDWR);
+  4e:	00349a13          	slli	s4,s1,0x3
+  52:	9a4e                	add	s4,s4,s3
+  54:	20200593          	li	a1,514
+  58:	000a3503          	ld	a0,0(s4)
+  5c:	37c000ef          	jal	3d8 <open>
+  60:	892a                	mv	s2,a0
+      if(fd < 0){
+  62:	04054163          	bltz	a0,a4 <main+0xa4>
+      memset(buf, '0'+i, SZ);
+  66:	7d000613          	li	a2,2000
+  6a:	0304859b          	addiw	a1,s1,48
+  6e:	00001517          	auipc	a0,0x1
+  72:	fa250513          	addi	a0,a0,-94 # 1010 <buf>
+  76:	110000ef          	jal	186 <memset>
+  7a:	0fa00493          	li	s1,250
+        if((n = write(fd, buf, SZ)) != SZ){
+  7e:	00001997          	auipc	s3,0x1
+  82:	f9298993          	addi	s3,s3,-110 # 1010 <buf>
+  86:	7d000613          	li	a2,2000
+  8a:	85ce                	mv	a1,s3
+  8c:	854a                	mv	a0,s2
+  8e:	32a000ef          	jal	3b8 <write>
+  92:	7d000793          	li	a5,2000
+  96:	02f51463          	bne	a0,a5,be <main+0xbe>
+      for(i = 0; i < N; i++){
+  9a:	34fd                	addiw	s1,s1,-1
+  9c:	f4ed                	bnez	s1,86 <main+0x86>
+      exit(0);
+  9e:	4501                	li	a0,0
+  a0:	2f8000ef          	jal	398 <exit>
+        printf("%s: create %s failed\n", argv[0], argv[i]);
+  a4:	000a3603          	ld	a2,0(s4)
+  a8:	0009b583          	ld	a1,0(s3)
+  ac:	00001517          	auipc	a0,0x1
+  b0:	8ec50513          	addi	a0,a0,-1812 # 998 <malloc+0x11c>
+  b4:	714000ef          	jal	7c8 <printf>
+        exit(1);
+  b8:	4505                	li	a0,1
+  ba:	2de000ef          	jal	398 <exit>
+          printf("write failed %d\n", n);
+  be:	85aa                	mv	a1,a0
+  c0:	00001517          	auipc	a0,0x1
+  c4:	8f050513          	addi	a0,a0,-1808 # 9b0 <malloc+0x134>
+  c8:	700000ef          	jal	7c8 <printf>
+          exit(1);
+  cc:	4505                	li	a0,1
+  ce:	2ca000ef          	jal	398 <exit>
+  d2:	893e                	mv	s2,a5
+    wait(&xstatus);
+  d4:	fcc40513          	addi	a0,s0,-52
+  d8:	2c8000ef          	jal	3a0 <wait>
+    if(xstatus != 0)
+  dc:	fcc42503          	lw	a0,-52(s0)
+  e0:	ed09                	bnez	a0,fa <main+0xfa>
+  for(int i = 1; i < argc; i++){
+  e2:	0019079b          	addiw	a5,s2,1
+  e6:	ff2496e3          	bne	s1,s2,d2 <main+0xd2>
+      exit(xstatus);
+  }
+  return 0;
+}
+  ea:	4501                	li	a0,0
+  ec:	70e2                	ld	ra,56(sp)
+  ee:	7442                	ld	s0,48(sp)
+  f0:	74a2                	ld	s1,40(sp)
+  f2:	7902                	ld	s2,32(sp)
+  f4:	69e2                	ld	s3,24(sp)
+  f6:	6121                	addi	sp,sp,64
+  f8:	8082                	ret
+  fa:	e852                	sd	s4,16(sp)
+      exit(xstatus);
+  fc:	29c000ef          	jal	398 <exit>
+}
+ 100:	4501                	li	a0,0
+ 102:	8082                	ret
+
+0000000000000104 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+ 104:	1141                	addi	sp,sp,-16
+ 106:	e406                	sd	ra,8(sp)
+ 108:	e022                	sd	s0,0(sp)
+ 10a:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+ 10c:	ef5ff0ef          	jal	0 <main>
+  exit(r);
+ 110:	288000ef          	jal	398 <exit>
+
+0000000000000114 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+ 114:	1141                	addi	sp,sp,-16
+ 116:	e422                	sd	s0,8(sp)
+ 118:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 11a:	87aa                	mv	a5,a0
+ 11c:	0585                	addi	a1,a1,1
+ 11e:	0785                	addi	a5,a5,1
+ 120:	fff5c703          	lbu	a4,-1(a1)
+ 124:	fee78fa3          	sb	a4,-1(a5)
+ 128:	fb75                	bnez	a4,11c <strcpy+0x8>
+    ;
+  return os;
+}
+ 12a:	6422                	ld	s0,8(sp)
+ 12c:	0141                	addi	sp,sp,16
+ 12e:	8082                	ret
+
+0000000000000130 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 130:	1141                	addi	sp,sp,-16
+ 132:	e422                	sd	s0,8(sp)
+ 134:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 136:	00054783          	lbu	a5,0(a0)
+ 13a:	cb91                	beqz	a5,14e <strcmp+0x1e>
+ 13c:	0005c703          	lbu	a4,0(a1)
+ 140:	00f71763          	bne	a4,a5,14e <strcmp+0x1e>
+    p++, q++;
+ 144:	0505                	addi	a0,a0,1
+ 146:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 148:	00054783          	lbu	a5,0(a0)
+ 14c:	fbe5                	bnez	a5,13c <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 14e:	0005c503          	lbu	a0,0(a1)
+}
+ 152:	40a7853b          	subw	a0,a5,a0
+ 156:	6422                	ld	s0,8(sp)
+ 158:	0141                	addi	sp,sp,16
+ 15a:	8082                	ret
+
+000000000000015c <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 15c:	1141                	addi	sp,sp,-16
+ 15e:	e422                	sd	s0,8(sp)
+ 160:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 162:	00054783          	lbu	a5,0(a0)
+ 166:	cf91                	beqz	a5,182 <strlen+0x26>
+ 168:	0505                	addi	a0,a0,1
+ 16a:	87aa                	mv	a5,a0
+ 16c:	86be                	mv	a3,a5
+ 16e:	0785                	addi	a5,a5,1
+ 170:	fff7c703          	lbu	a4,-1(a5)
+ 174:	ff65                	bnez	a4,16c <strlen+0x10>
+ 176:	40a6853b          	subw	a0,a3,a0
+ 17a:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 17c:	6422                	ld	s0,8(sp)
+ 17e:	0141                	addi	sp,sp,16
+ 180:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 182:	4501                	li	a0,0
+ 184:	bfe5                	j	17c <strlen+0x20>
+
+0000000000000186 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 186:	1141                	addi	sp,sp,-16
+ 188:	e422                	sd	s0,8(sp)
+ 18a:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 18c:	ca19                	beqz	a2,1a2 <memset+0x1c>
+ 18e:	87aa                	mv	a5,a0
+ 190:	1602                	slli	a2,a2,0x20
+ 192:	9201                	srli	a2,a2,0x20
+ 194:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 198:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 19c:	0785                	addi	a5,a5,1
+ 19e:	fee79de3          	bne	a5,a4,198 <memset+0x12>
+  }
+  return dst;
+}
+ 1a2:	6422                	ld	s0,8(sp)
+ 1a4:	0141                	addi	sp,sp,16
+ 1a6:	8082                	ret
+
+00000000000001a8 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 1a8:	1141                	addi	sp,sp,-16
+ 1aa:	e422                	sd	s0,8(sp)
+ 1ac:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 1ae:	00054783          	lbu	a5,0(a0)
+ 1b2:	cb99                	beqz	a5,1c8 <strchr+0x20>
+    if(*s == c)
+ 1b4:	00f58763          	beq	a1,a5,1c2 <strchr+0x1a>
+  for(; *s; s++)
+ 1b8:	0505                	addi	a0,a0,1
+ 1ba:	00054783          	lbu	a5,0(a0)
+ 1be:	fbfd                	bnez	a5,1b4 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 1c0:	4501                	li	a0,0
+}
+ 1c2:	6422                	ld	s0,8(sp)
+ 1c4:	0141                	addi	sp,sp,16
+ 1c6:	8082                	ret
+  return 0;
+ 1c8:	4501                	li	a0,0
+ 1ca:	bfe5                	j	1c2 <strchr+0x1a>
+
+00000000000001cc <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1cc:	711d                	addi	sp,sp,-96
+ 1ce:	ec86                	sd	ra,88(sp)
+ 1d0:	e8a2                	sd	s0,80(sp)
+ 1d2:	e4a6                	sd	s1,72(sp)
+ 1d4:	e0ca                	sd	s2,64(sp)
+ 1d6:	fc4e                	sd	s3,56(sp)
+ 1d8:	f852                	sd	s4,48(sp)
+ 1da:	f456                	sd	s5,40(sp)
+ 1dc:	f05a                	sd	s6,32(sp)
+ 1de:	ec5e                	sd	s7,24(sp)
+ 1e0:	1080                	addi	s0,sp,96
+ 1e2:	8baa                	mv	s7,a0
+ 1e4:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1e6:	892a                	mv	s2,a0
+ 1e8:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1ea:	4aa9                	li	s5,10
+ 1ec:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1ee:	89a6                	mv	s3,s1
+ 1f0:	2485                	addiw	s1,s1,1
+ 1f2:	0344d663          	bge	s1,s4,21e <gets+0x52>
+    cc = read(0, &c, 1);
+ 1f6:	4605                	li	a2,1
+ 1f8:	faf40593          	addi	a1,s0,-81
+ 1fc:	4501                	li	a0,0
+ 1fe:	1b2000ef          	jal	3b0 <read>
+    if(cc < 1)
+ 202:	00a05e63          	blez	a0,21e <gets+0x52>
+    buf[i++] = c;
+ 206:	faf44783          	lbu	a5,-81(s0)
+ 20a:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 20e:	01578763          	beq	a5,s5,21c <gets+0x50>
+ 212:	0905                	addi	s2,s2,1
+ 214:	fd679de3          	bne	a5,s6,1ee <gets+0x22>
+    buf[i++] = c;
+ 218:	89a6                	mv	s3,s1
+ 21a:	a011                	j	21e <gets+0x52>
+ 21c:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 21e:	99de                	add	s3,s3,s7
+ 220:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 224:	855e                	mv	a0,s7
+ 226:	60e6                	ld	ra,88(sp)
+ 228:	6446                	ld	s0,80(sp)
+ 22a:	64a6                	ld	s1,72(sp)
+ 22c:	6906                	ld	s2,64(sp)
+ 22e:	79e2                	ld	s3,56(sp)
+ 230:	7a42                	ld	s4,48(sp)
+ 232:	7aa2                	ld	s5,40(sp)
+ 234:	7b02                	ld	s6,32(sp)
+ 236:	6be2                	ld	s7,24(sp)
+ 238:	6125                	addi	sp,sp,96
+ 23a:	8082                	ret
+
+000000000000023c <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 23c:	1101                	addi	sp,sp,-32
+ 23e:	ec06                	sd	ra,24(sp)
+ 240:	e822                	sd	s0,16(sp)
+ 242:	e04a                	sd	s2,0(sp)
+ 244:	1000                	addi	s0,sp,32
+ 246:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 248:	4581                	li	a1,0
+ 24a:	18e000ef          	jal	3d8 <open>
+  if(fd < 0)
+ 24e:	02054263          	bltz	a0,272 <stat+0x36>
+ 252:	e426                	sd	s1,8(sp)
+ 254:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 256:	85ca                	mv	a1,s2
+ 258:	198000ef          	jal	3f0 <fstat>
+ 25c:	892a                	mv	s2,a0
+  close(fd);
+ 25e:	8526                	mv	a0,s1
+ 260:	160000ef          	jal	3c0 <close>
+  return r;
+ 264:	64a2                	ld	s1,8(sp)
+}
+ 266:	854a                	mv	a0,s2
+ 268:	60e2                	ld	ra,24(sp)
+ 26a:	6442                	ld	s0,16(sp)
+ 26c:	6902                	ld	s2,0(sp)
+ 26e:	6105                	addi	sp,sp,32
+ 270:	8082                	ret
+    return -1;
+ 272:	597d                	li	s2,-1
+ 274:	bfcd                	j	266 <stat+0x2a>
+
+0000000000000276 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 276:	1141                	addi	sp,sp,-16
+ 278:	e422                	sd	s0,8(sp)
+ 27a:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 27c:	00054683          	lbu	a3,0(a0)
+ 280:	fd06879b          	addiw	a5,a3,-48
+ 284:	0ff7f793          	zext.b	a5,a5
+ 288:	4625                	li	a2,9
+ 28a:	02f66863          	bltu	a2,a5,2ba <atoi+0x44>
+ 28e:	872a                	mv	a4,a0
+  n = 0;
+ 290:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 292:	0705                	addi	a4,a4,1
+ 294:	0025179b          	slliw	a5,a0,0x2
+ 298:	9fa9                	addw	a5,a5,a0
+ 29a:	0017979b          	slliw	a5,a5,0x1
+ 29e:	9fb5                	addw	a5,a5,a3
+ 2a0:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 2a4:	00074683          	lbu	a3,0(a4)
+ 2a8:	fd06879b          	addiw	a5,a3,-48
+ 2ac:	0ff7f793          	zext.b	a5,a5
+ 2b0:	fef671e3          	bgeu	a2,a5,292 <atoi+0x1c>
+  return n;
+}
+ 2b4:	6422                	ld	s0,8(sp)
+ 2b6:	0141                	addi	sp,sp,16
+ 2b8:	8082                	ret
+  n = 0;
+ 2ba:	4501                	li	a0,0
+ 2bc:	bfe5                	j	2b4 <atoi+0x3e>
+
+00000000000002be <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 2be:	1141                	addi	sp,sp,-16
+ 2c0:	e422                	sd	s0,8(sp)
+ 2c2:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 2c4:	02b57463          	bgeu	a0,a1,2ec <memmove+0x2e>
+    while(n-- > 0)
+ 2c8:	00c05f63          	blez	a2,2e6 <memmove+0x28>
+ 2cc:	1602                	slli	a2,a2,0x20
+ 2ce:	9201                	srli	a2,a2,0x20
+ 2d0:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 2d4:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 2d6:	0585                	addi	a1,a1,1
+ 2d8:	0705                	addi	a4,a4,1
+ 2da:	fff5c683          	lbu	a3,-1(a1)
+ 2de:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2e2:	fef71ae3          	bne	a4,a5,2d6 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2e6:	6422                	ld	s0,8(sp)
+ 2e8:	0141                	addi	sp,sp,16
+ 2ea:	8082                	ret
+    dst += n;
+ 2ec:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2f0:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2f2:	fec05ae3          	blez	a2,2e6 <memmove+0x28>
+ 2f6:	fff6079b          	addiw	a5,a2,-1
+ 2fa:	1782                	slli	a5,a5,0x20
+ 2fc:	9381                	srli	a5,a5,0x20
+ 2fe:	fff7c793          	not	a5,a5
+ 302:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 304:	15fd                	addi	a1,a1,-1
+ 306:	177d                	addi	a4,a4,-1
+ 308:	0005c683          	lbu	a3,0(a1)
+ 30c:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 310:	fee79ae3          	bne	a5,a4,304 <memmove+0x46>
+ 314:	bfc9                	j	2e6 <memmove+0x28>
+
+0000000000000316 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 316:	1141                	addi	sp,sp,-16
+ 318:	e422                	sd	s0,8(sp)
+ 31a:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 31c:	ca05                	beqz	a2,34c <memcmp+0x36>
+ 31e:	fff6069b          	addiw	a3,a2,-1
+ 322:	1682                	slli	a3,a3,0x20
+ 324:	9281                	srli	a3,a3,0x20
+ 326:	0685                	addi	a3,a3,1
+ 328:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 32a:	00054783          	lbu	a5,0(a0)
+ 32e:	0005c703          	lbu	a4,0(a1)
+ 332:	00e79863          	bne	a5,a4,342 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 336:	0505                	addi	a0,a0,1
+    p2++;
+ 338:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 33a:	fed518e3          	bne	a0,a3,32a <memcmp+0x14>
+  }
+  return 0;
+ 33e:	4501                	li	a0,0
+ 340:	a019                	j	346 <memcmp+0x30>
+      return *p1 - *p2;
+ 342:	40e7853b          	subw	a0,a5,a4
+}
+ 346:	6422                	ld	s0,8(sp)
+ 348:	0141                	addi	sp,sp,16
+ 34a:	8082                	ret
+  return 0;
+ 34c:	4501                	li	a0,0
+ 34e:	bfe5                	j	346 <memcmp+0x30>
+
+0000000000000350 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 350:	1141                	addi	sp,sp,-16
+ 352:	e406                	sd	ra,8(sp)
+ 354:	e022                	sd	s0,0(sp)
+ 356:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 358:	f67ff0ef          	jal	2be <memmove>
+}
+ 35c:	60a2                	ld	ra,8(sp)
+ 35e:	6402                	ld	s0,0(sp)
+ 360:	0141                	addi	sp,sp,16
+ 362:	8082                	ret
+
+0000000000000364 <sbrk>:
+
+char *
+sbrk(int n) {
+ 364:	1141                	addi	sp,sp,-16
+ 366:	e406                	sd	ra,8(sp)
+ 368:	e022                	sd	s0,0(sp)
+ 36a:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 36c:	4585                	li	a1,1
+ 36e:	0b2000ef          	jal	420 <sys_sbrk>
+}
+ 372:	60a2                	ld	ra,8(sp)
+ 374:	6402                	ld	s0,0(sp)
+ 376:	0141                	addi	sp,sp,16
+ 378:	8082                	ret
+
+000000000000037a <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 37a:	1141                	addi	sp,sp,-16
+ 37c:	e406                	sd	ra,8(sp)
+ 37e:	e022                	sd	s0,0(sp)
+ 380:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 382:	4589                	li	a1,2
+ 384:	09c000ef          	jal	420 <sys_sbrk>
+}
+ 388:	60a2                	ld	ra,8(sp)
+ 38a:	6402                	ld	s0,0(sp)
+ 38c:	0141                	addi	sp,sp,16
+ 38e:	8082                	ret
+
+0000000000000390 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 390:	4885                	li	a7,1
+ ecall
+ 392:	00000073          	ecall
+ ret
+ 396:	8082                	ret
+
+0000000000000398 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 398:	4889                	li	a7,2
+ ecall
+ 39a:	00000073          	ecall
+ ret
+ 39e:	8082                	ret
+
+00000000000003a0 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 3a0:	488d                	li	a7,3
+ ecall
+ 3a2:	00000073          	ecall
+ ret
+ 3a6:	8082                	ret
+
+00000000000003a8 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 3a8:	4891                	li	a7,4
+ ecall
+ 3aa:	00000073          	ecall
+ ret
+ 3ae:	8082                	ret
+
+00000000000003b0 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 3b0:	4895                	li	a7,5
+ ecall
+ 3b2:	00000073          	ecall
+ ret
+ 3b6:	8082                	ret
+
+00000000000003b8 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 3b8:	48c1                	li	a7,16
+ ecall
+ 3ba:	00000073          	ecall
+ ret
+ 3be:	8082                	ret
+
+00000000000003c0 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 3c0:	48d5                	li	a7,21
+ ecall
+ 3c2:	00000073          	ecall
+ ret
+ 3c6:	8082                	ret
+
+00000000000003c8 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 3c8:	4899                	li	a7,6
+ ecall
+ 3ca:	00000073          	ecall
+ ret
+ 3ce:	8082                	ret
+
+00000000000003d0 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 3d0:	489d                	li	a7,7
+ ecall
+ 3d2:	00000073          	ecall
+ ret
+ 3d6:	8082                	ret
+
+00000000000003d8 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 3d8:	48bd                	li	a7,15
+ ecall
+ 3da:	00000073          	ecall
+ ret
+ 3de:	8082                	ret
+
+00000000000003e0 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3e0:	48c5                	li	a7,17
+ ecall
+ 3e2:	00000073          	ecall
+ ret
+ 3e6:	8082                	ret
+
+00000000000003e8 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3e8:	48c9                	li	a7,18
+ ecall
+ 3ea:	00000073          	ecall
+ ret
+ 3ee:	8082                	ret
+
+00000000000003f0 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3f0:	48a1                	li	a7,8
+ ecall
+ 3f2:	00000073          	ecall
+ ret
+ 3f6:	8082                	ret
+
+00000000000003f8 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3f8:	48cd                	li	a7,19
+ ecall
+ 3fa:	00000073          	ecall
+ ret
+ 3fe:	8082                	ret
+
+0000000000000400 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 400:	48d1                	li	a7,20
+ ecall
+ 402:	00000073          	ecall
+ ret
+ 406:	8082                	ret
+
+0000000000000408 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 408:	48a5                	li	a7,9
+ ecall
+ 40a:	00000073          	ecall
+ ret
+ 40e:	8082                	ret
+
+0000000000000410 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 410:	48a9                	li	a7,10
+ ecall
+ 412:	00000073          	ecall
+ ret
+ 416:	8082                	ret
+
+0000000000000418 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 418:	48ad                	li	a7,11
+ ecall
+ 41a:	00000073          	ecall
+ ret
+ 41e:	8082                	ret
+
+0000000000000420 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 420:	48b1                	li	a7,12
+ ecall
+ 422:	00000073          	ecall
+ ret
+ 426:	8082                	ret
+
+0000000000000428 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 428:	48b5                	li	a7,13
+ ecall
+ 42a:	00000073          	ecall
+ ret
+ 42e:	8082                	ret
+
+0000000000000430 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 430:	48b9                	li	a7,14
+ ecall
+ 432:	00000073          	ecall
+ ret
+ 436:	8082                	ret
+
+0000000000000438 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 438:	48d9                	li	a7,22
+ ecall
+ 43a:	00000073          	ecall
+ ret
+ 43e:	8082                	ret
+
+0000000000000440 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 440:	1101                	addi	sp,sp,-32
+ 442:	ec06                	sd	ra,24(sp)
+ 444:	e822                	sd	s0,16(sp)
+ 446:	1000                	addi	s0,sp,32
+ 448:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 44c:	4605                	li	a2,1
+ 44e:	fef40593          	addi	a1,s0,-17
+ 452:	f67ff0ef          	jal	3b8 <write>
+}
+ 456:	60e2                	ld	ra,24(sp)
+ 458:	6442                	ld	s0,16(sp)
+ 45a:	6105                	addi	sp,sp,32
+ 45c:	8082                	ret
+
+000000000000045e <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 45e:	715d                	addi	sp,sp,-80
+ 460:	e486                	sd	ra,72(sp)
+ 462:	e0a2                	sd	s0,64(sp)
+ 464:	f84a                	sd	s2,48(sp)
+ 466:	0880                	addi	s0,sp,80
+ 468:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 46a:	c299                	beqz	a3,470 <printint+0x12>
+ 46c:	0805c363          	bltz	a1,4f2 <printint+0x94>
+  neg = 0;
+ 470:	4881                	li	a7,0
+ 472:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 476:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 478:	00000517          	auipc	a0,0x0
+ 47c:	55850513          	addi	a0,a0,1368 # 9d0 <digits>
+ 480:	883e                	mv	a6,a5
+ 482:	2785                	addiw	a5,a5,1
+ 484:	02c5f733          	remu	a4,a1,a2
+ 488:	972a                	add	a4,a4,a0
+ 48a:	00074703          	lbu	a4,0(a4)
+ 48e:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 492:	872e                	mv	a4,a1
+ 494:	02c5d5b3          	divu	a1,a1,a2
+ 498:	0685                	addi	a3,a3,1
+ 49a:	fec773e3          	bgeu	a4,a2,480 <printint+0x22>
+  if(neg)
+ 49e:	00088b63          	beqz	a7,4b4 <printint+0x56>
+    buf[i++] = '-';
+ 4a2:	fd078793          	addi	a5,a5,-48
+ 4a6:	97a2                	add	a5,a5,s0
+ 4a8:	02d00713          	li	a4,45
+ 4ac:	fee78423          	sb	a4,-24(a5)
+ 4b0:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 4b4:	02f05a63          	blez	a5,4e8 <printint+0x8a>
+ 4b8:	fc26                	sd	s1,56(sp)
+ 4ba:	f44e                	sd	s3,40(sp)
+ 4bc:	fb840713          	addi	a4,s0,-72
+ 4c0:	00f704b3          	add	s1,a4,a5
+ 4c4:	fff70993          	addi	s3,a4,-1
+ 4c8:	99be                	add	s3,s3,a5
+ 4ca:	37fd                	addiw	a5,a5,-1
+ 4cc:	1782                	slli	a5,a5,0x20
+ 4ce:	9381                	srli	a5,a5,0x20
+ 4d0:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 4d4:	fff4c583          	lbu	a1,-1(s1)
+ 4d8:	854a                	mv	a0,s2
+ 4da:	f67ff0ef          	jal	440 <putc>
+  while(--i >= 0)
+ 4de:	14fd                	addi	s1,s1,-1
+ 4e0:	ff349ae3          	bne	s1,s3,4d4 <printint+0x76>
+ 4e4:	74e2                	ld	s1,56(sp)
+ 4e6:	79a2                	ld	s3,40(sp)
+}
+ 4e8:	60a6                	ld	ra,72(sp)
+ 4ea:	6406                	ld	s0,64(sp)
+ 4ec:	7942                	ld	s2,48(sp)
+ 4ee:	6161                	addi	sp,sp,80
+ 4f0:	8082                	ret
+    x = -xx;
+ 4f2:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4f6:	4885                	li	a7,1
+    x = -xx;
+ 4f8:	bfad                	j	472 <printint+0x14>
+
+00000000000004fa <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4fa:	711d                	addi	sp,sp,-96
+ 4fc:	ec86                	sd	ra,88(sp)
+ 4fe:	e8a2                	sd	s0,80(sp)
+ 500:	e0ca                	sd	s2,64(sp)
+ 502:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 504:	0005c903          	lbu	s2,0(a1)
+ 508:	28090663          	beqz	s2,794 <vprintf+0x29a>
+ 50c:	e4a6                	sd	s1,72(sp)
+ 50e:	fc4e                	sd	s3,56(sp)
+ 510:	f852                	sd	s4,48(sp)
+ 512:	f456                	sd	s5,40(sp)
+ 514:	f05a                	sd	s6,32(sp)
+ 516:	ec5e                	sd	s7,24(sp)
+ 518:	e862                	sd	s8,16(sp)
+ 51a:	e466                	sd	s9,8(sp)
+ 51c:	8b2a                	mv	s6,a0
+ 51e:	8a2e                	mv	s4,a1
+ 520:	8bb2                	mv	s7,a2
+  state = 0;
+ 522:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 524:	4481                	li	s1,0
+ 526:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 528:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 52c:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 530:	06c00c93          	li	s9,108
+ 534:	a005                	j	554 <vprintf+0x5a>
+        putc(fd, c0);
+ 536:	85ca                	mv	a1,s2
+ 538:	855a                	mv	a0,s6
+ 53a:	f07ff0ef          	jal	440 <putc>
+ 53e:	a019                	j	544 <vprintf+0x4a>
+    } else if(state == '%'){
+ 540:	03598263          	beq	s3,s5,564 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 544:	2485                	addiw	s1,s1,1
+ 546:	8726                	mv	a4,s1
+ 548:	009a07b3          	add	a5,s4,s1
+ 54c:	0007c903          	lbu	s2,0(a5)
+ 550:	22090a63          	beqz	s2,784 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 554:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 558:	fe0994e3          	bnez	s3,540 <vprintf+0x46>
+      if(c0 == '%'){
+ 55c:	fd579de3          	bne	a5,s5,536 <vprintf+0x3c>
+        state = '%';
+ 560:	89be                	mv	s3,a5
+ 562:	b7cd                	j	544 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 564:	00ea06b3          	add	a3,s4,a4
+ 568:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 56c:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 56e:	c681                	beqz	a3,576 <vprintf+0x7c>
+ 570:	9752                	add	a4,a4,s4
+ 572:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 576:	05878363          	beq	a5,s8,5bc <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 57a:	05978d63          	beq	a5,s9,5d4 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 57e:	07500713          	li	a4,117
+ 582:	0ee78763          	beq	a5,a4,670 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 586:	07800713          	li	a4,120
+ 58a:	12e78963          	beq	a5,a4,6bc <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 58e:	07000713          	li	a4,112
+ 592:	14e78e63          	beq	a5,a4,6ee <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 596:	06300713          	li	a4,99
+ 59a:	18e78e63          	beq	a5,a4,736 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 59e:	07300713          	li	a4,115
+ 5a2:	1ae78463          	beq	a5,a4,74a <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 5a6:	02500713          	li	a4,37
+ 5aa:	04e79563          	bne	a5,a4,5f4 <vprintf+0xfa>
+        putc(fd, '%');
+ 5ae:	02500593          	li	a1,37
+ 5b2:	855a                	mv	a0,s6
+ 5b4:	e8dff0ef          	jal	440 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 5b8:	4981                	li	s3,0
+ 5ba:	b769                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 5bc:	008b8913          	addi	s2,s7,8
+ 5c0:	4685                	li	a3,1
+ 5c2:	4629                	li	a2,10
+ 5c4:	000ba583          	lw	a1,0(s7)
+ 5c8:	855a                	mv	a0,s6
+ 5ca:	e95ff0ef          	jal	45e <printint>
+ 5ce:	8bca                	mv	s7,s2
+      state = 0;
+ 5d0:	4981                	li	s3,0
+ 5d2:	bf8d                	j	544 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 5d4:	06400793          	li	a5,100
+ 5d8:	02f68963          	beq	a3,a5,60a <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5dc:	06c00793          	li	a5,108
+ 5e0:	04f68263          	beq	a3,a5,624 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 5e4:	07500793          	li	a5,117
+ 5e8:	0af68063          	beq	a3,a5,688 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5ec:	07800793          	li	a5,120
+ 5f0:	0ef68263          	beq	a3,a5,6d4 <vprintf+0x1da>
+        putc(fd, '%');
+ 5f4:	02500593          	li	a1,37
+ 5f8:	855a                	mv	a0,s6
+ 5fa:	e47ff0ef          	jal	440 <putc>
+        putc(fd, c0);
+ 5fe:	85ca                	mv	a1,s2
+ 600:	855a                	mv	a0,s6
+ 602:	e3fff0ef          	jal	440 <putc>
+      state = 0;
+ 606:	4981                	li	s3,0
+ 608:	bf35                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 60a:	008b8913          	addi	s2,s7,8
+ 60e:	4685                	li	a3,1
+ 610:	4629                	li	a2,10
+ 612:	000bb583          	ld	a1,0(s7)
+ 616:	855a                	mv	a0,s6
+ 618:	e47ff0ef          	jal	45e <printint>
+        i += 1;
+ 61c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 61e:	8bca                	mv	s7,s2
+      state = 0;
+ 620:	4981                	li	s3,0
+        i += 1;
+ 622:	b70d                	j	544 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 624:	06400793          	li	a5,100
+ 628:	02f60763          	beq	a2,a5,656 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 62c:	07500793          	li	a5,117
+ 630:	06f60963          	beq	a2,a5,6a2 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 634:	07800793          	li	a5,120
+ 638:	faf61ee3          	bne	a2,a5,5f4 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 63c:	008b8913          	addi	s2,s7,8
+ 640:	4681                	li	a3,0
+ 642:	4641                	li	a2,16
+ 644:	000bb583          	ld	a1,0(s7)
+ 648:	855a                	mv	a0,s6
+ 64a:	e15ff0ef          	jal	45e <printint>
+        i += 2;
+ 64e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 650:	8bca                	mv	s7,s2
+      state = 0;
+ 652:	4981                	li	s3,0
+        i += 2;
+ 654:	bdc5                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 656:	008b8913          	addi	s2,s7,8
+ 65a:	4685                	li	a3,1
+ 65c:	4629                	li	a2,10
+ 65e:	000bb583          	ld	a1,0(s7)
+ 662:	855a                	mv	a0,s6
+ 664:	dfbff0ef          	jal	45e <printint>
+        i += 2;
+ 668:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 66a:	8bca                	mv	s7,s2
+      state = 0;
+ 66c:	4981                	li	s3,0
+        i += 2;
+ 66e:	bdd9                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 670:	008b8913          	addi	s2,s7,8
+ 674:	4681                	li	a3,0
+ 676:	4629                	li	a2,10
+ 678:	000be583          	lwu	a1,0(s7)
+ 67c:	855a                	mv	a0,s6
+ 67e:	de1ff0ef          	jal	45e <printint>
+ 682:	8bca                	mv	s7,s2
+      state = 0;
+ 684:	4981                	li	s3,0
+ 686:	bd7d                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 688:	008b8913          	addi	s2,s7,8
+ 68c:	4681                	li	a3,0
+ 68e:	4629                	li	a2,10
+ 690:	000bb583          	ld	a1,0(s7)
+ 694:	855a                	mv	a0,s6
+ 696:	dc9ff0ef          	jal	45e <printint>
+        i += 1;
+ 69a:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 69c:	8bca                	mv	s7,s2
+      state = 0;
+ 69e:	4981                	li	s3,0
+        i += 1;
+ 6a0:	b555                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 6a2:	008b8913          	addi	s2,s7,8
+ 6a6:	4681                	li	a3,0
+ 6a8:	4629                	li	a2,10
+ 6aa:	000bb583          	ld	a1,0(s7)
+ 6ae:	855a                	mv	a0,s6
+ 6b0:	dafff0ef          	jal	45e <printint>
+        i += 2;
+ 6b4:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 6b6:	8bca                	mv	s7,s2
+      state = 0;
+ 6b8:	4981                	li	s3,0
+        i += 2;
+ 6ba:	b569                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 6bc:	008b8913          	addi	s2,s7,8
+ 6c0:	4681                	li	a3,0
+ 6c2:	4641                	li	a2,16
+ 6c4:	000be583          	lwu	a1,0(s7)
+ 6c8:	855a                	mv	a0,s6
+ 6ca:	d95ff0ef          	jal	45e <printint>
+ 6ce:	8bca                	mv	s7,s2
+      state = 0;
+ 6d0:	4981                	li	s3,0
+ 6d2:	bd8d                	j	544 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6d4:	008b8913          	addi	s2,s7,8
+ 6d8:	4681                	li	a3,0
+ 6da:	4641                	li	a2,16
+ 6dc:	000bb583          	ld	a1,0(s7)
+ 6e0:	855a                	mv	a0,s6
+ 6e2:	d7dff0ef          	jal	45e <printint>
+        i += 1;
+ 6e6:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6e8:	8bca                	mv	s7,s2
+      state = 0;
+ 6ea:	4981                	li	s3,0
+        i += 1;
+ 6ec:	bda1                	j	544 <vprintf+0x4a>
+ 6ee:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6f0:	008b8d13          	addi	s10,s7,8
+ 6f4:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6f8:	03000593          	li	a1,48
+ 6fc:	855a                	mv	a0,s6
+ 6fe:	d43ff0ef          	jal	440 <putc>
+  putc(fd, 'x');
+ 702:	07800593          	li	a1,120
+ 706:	855a                	mv	a0,s6
+ 708:	d39ff0ef          	jal	440 <putc>
+ 70c:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 70e:	00000b97          	auipc	s7,0x0
+ 712:	2c2b8b93          	addi	s7,s7,706 # 9d0 <digits>
+ 716:	03c9d793          	srli	a5,s3,0x3c
+ 71a:	97de                	add	a5,a5,s7
+ 71c:	0007c583          	lbu	a1,0(a5)
+ 720:	855a                	mv	a0,s6
+ 722:	d1fff0ef          	jal	440 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 726:	0992                	slli	s3,s3,0x4
+ 728:	397d                	addiw	s2,s2,-1
+ 72a:	fe0916e3          	bnez	s2,716 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 72e:	8bea                	mv	s7,s10
+      state = 0;
+ 730:	4981                	li	s3,0
+ 732:	6d02                	ld	s10,0(sp)
+ 734:	bd01                	j	544 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 736:	008b8913          	addi	s2,s7,8
+ 73a:	000bc583          	lbu	a1,0(s7)
+ 73e:	855a                	mv	a0,s6
+ 740:	d01ff0ef          	jal	440 <putc>
+ 744:	8bca                	mv	s7,s2
+      state = 0;
+ 746:	4981                	li	s3,0
+ 748:	bbf5                	j	544 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 74a:	008b8993          	addi	s3,s7,8
+ 74e:	000bb903          	ld	s2,0(s7)
+ 752:	00090f63          	beqz	s2,770 <vprintf+0x276>
+        for(; *s; s++)
+ 756:	00094583          	lbu	a1,0(s2)
+ 75a:	c195                	beqz	a1,77e <vprintf+0x284>
+          putc(fd, *s);
+ 75c:	855a                	mv	a0,s6
+ 75e:	ce3ff0ef          	jal	440 <putc>
+        for(; *s; s++)
+ 762:	0905                	addi	s2,s2,1
+ 764:	00094583          	lbu	a1,0(s2)
+ 768:	f9f5                	bnez	a1,75c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 76a:	8bce                	mv	s7,s3
+      state = 0;
+ 76c:	4981                	li	s3,0
+ 76e:	bbd9                	j	544 <vprintf+0x4a>
+          s = "(null)";
+ 770:	00000917          	auipc	s2,0x0
+ 774:	25890913          	addi	s2,s2,600 # 9c8 <malloc+0x14c>
+        for(; *s; s++)
+ 778:	02800593          	li	a1,40
+ 77c:	b7c5                	j	75c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 77e:	8bce                	mv	s7,s3
+      state = 0;
+ 780:	4981                	li	s3,0
+ 782:	b3c9                	j	544 <vprintf+0x4a>
+ 784:	64a6                	ld	s1,72(sp)
+ 786:	79e2                	ld	s3,56(sp)
+ 788:	7a42                	ld	s4,48(sp)
+ 78a:	7aa2                	ld	s5,40(sp)
+ 78c:	7b02                	ld	s6,32(sp)
+ 78e:	6be2                	ld	s7,24(sp)
+ 790:	6c42                	ld	s8,16(sp)
+ 792:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 794:	60e6                	ld	ra,88(sp)
+ 796:	6446                	ld	s0,80(sp)
+ 798:	6906                	ld	s2,64(sp)
+ 79a:	6125                	addi	sp,sp,96
+ 79c:	8082                	ret
+
+000000000000079e <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 79e:	715d                	addi	sp,sp,-80
+ 7a0:	ec06                	sd	ra,24(sp)
+ 7a2:	e822                	sd	s0,16(sp)
+ 7a4:	1000                	addi	s0,sp,32
+ 7a6:	e010                	sd	a2,0(s0)
+ 7a8:	e414                	sd	a3,8(s0)
+ 7aa:	e818                	sd	a4,16(s0)
+ 7ac:	ec1c                	sd	a5,24(s0)
+ 7ae:	03043023          	sd	a6,32(s0)
+ 7b2:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7b6:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 7ba:	8622                	mv	a2,s0
+ 7bc:	d3fff0ef          	jal	4fa <vprintf>
+}
+ 7c0:	60e2                	ld	ra,24(sp)
+ 7c2:	6442                	ld	s0,16(sp)
+ 7c4:	6161                	addi	sp,sp,80
+ 7c6:	8082                	ret
+
+00000000000007c8 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 7c8:	711d                	addi	sp,sp,-96
+ 7ca:	ec06                	sd	ra,24(sp)
+ 7cc:	e822                	sd	s0,16(sp)
+ 7ce:	1000                	addi	s0,sp,32
+ 7d0:	e40c                	sd	a1,8(s0)
+ 7d2:	e810                	sd	a2,16(s0)
+ 7d4:	ec14                	sd	a3,24(s0)
+ 7d6:	f018                	sd	a4,32(s0)
+ 7d8:	f41c                	sd	a5,40(s0)
+ 7da:	03043823          	sd	a6,48(s0)
+ 7de:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7e2:	00840613          	addi	a2,s0,8
+ 7e6:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7ea:	85aa                	mv	a1,a0
+ 7ec:	4505                	li	a0,1
+ 7ee:	d0dff0ef          	jal	4fa <vprintf>
+}
+ 7f2:	60e2                	ld	ra,24(sp)
+ 7f4:	6442                	ld	s0,16(sp)
+ 7f6:	6125                	addi	sp,sp,96
+ 7f8:	8082                	ret
+
+00000000000007fa <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7fa:	1141                	addi	sp,sp,-16
+ 7fc:	e422                	sd	s0,8(sp)
+ 7fe:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 800:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 804:	00000797          	auipc	a5,0x0
+ 808:	7fc7b783          	ld	a5,2044(a5) # 1000 <freep>
+ 80c:	a02d                	j	836 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 80e:	4618                	lw	a4,8(a2)
+ 810:	9f2d                	addw	a4,a4,a1
+ 812:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 816:	6398                	ld	a4,0(a5)
+ 818:	6310                	ld	a2,0(a4)
+ 81a:	a83d                	j	858 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 81c:	ff852703          	lw	a4,-8(a0)
+ 820:	9f31                	addw	a4,a4,a2
+ 822:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 824:	ff053683          	ld	a3,-16(a0)
+ 828:	a091                	j	86c <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 82a:	6398                	ld	a4,0(a5)
+ 82c:	00e7e463          	bltu	a5,a4,834 <free+0x3a>
+ 830:	00e6ea63          	bltu	a3,a4,844 <free+0x4a>
+{
+ 834:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 836:	fed7fae3          	bgeu	a5,a3,82a <free+0x30>
+ 83a:	6398                	ld	a4,0(a5)
+ 83c:	00e6e463          	bltu	a3,a4,844 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 840:	fee7eae3          	bltu	a5,a4,834 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 844:	ff852583          	lw	a1,-8(a0)
+ 848:	6390                	ld	a2,0(a5)
+ 84a:	02059813          	slli	a6,a1,0x20
+ 84e:	01c85713          	srli	a4,a6,0x1c
+ 852:	9736                	add	a4,a4,a3
+ 854:	fae60de3          	beq	a2,a4,80e <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 858:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 85c:	4790                	lw	a2,8(a5)
+ 85e:	02061593          	slli	a1,a2,0x20
+ 862:	01c5d713          	srli	a4,a1,0x1c
+ 866:	973e                	add	a4,a4,a5
+ 868:	fae68ae3          	beq	a3,a4,81c <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 86c:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 86e:	00000717          	auipc	a4,0x0
+ 872:	78f73923          	sd	a5,1938(a4) # 1000 <freep>
+}
+ 876:	6422                	ld	s0,8(sp)
+ 878:	0141                	addi	sp,sp,16
+ 87a:	8082                	ret
+
+000000000000087c <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 87c:	7139                	addi	sp,sp,-64
+ 87e:	fc06                	sd	ra,56(sp)
+ 880:	f822                	sd	s0,48(sp)
+ 882:	f426                	sd	s1,40(sp)
+ 884:	ec4e                	sd	s3,24(sp)
+ 886:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 888:	02051493          	slli	s1,a0,0x20
+ 88c:	9081                	srli	s1,s1,0x20
+ 88e:	04bd                	addi	s1,s1,15
+ 890:	8091                	srli	s1,s1,0x4
+ 892:	0014899b          	addiw	s3,s1,1
+ 896:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 898:	00000517          	auipc	a0,0x0
+ 89c:	76853503          	ld	a0,1896(a0) # 1000 <freep>
+ 8a0:	c915                	beqz	a0,8d4 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8a2:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8a4:	4798                	lw	a4,8(a5)
+ 8a6:	08977a63          	bgeu	a4,s1,93a <malloc+0xbe>
+ 8aa:	f04a                	sd	s2,32(sp)
+ 8ac:	e852                	sd	s4,16(sp)
+ 8ae:	e456                	sd	s5,8(sp)
+ 8b0:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 8b2:	8a4e                	mv	s4,s3
+ 8b4:	0009871b          	sext.w	a4,s3
+ 8b8:	6685                	lui	a3,0x1
+ 8ba:	00d77363          	bgeu	a4,a3,8c0 <malloc+0x44>
+ 8be:	6a05                	lui	s4,0x1
+ 8c0:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 8c4:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 8c8:	00000917          	auipc	s2,0x0
+ 8cc:	73890913          	addi	s2,s2,1848 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 8d0:	5afd                	li	s5,-1
+ 8d2:	a081                	j	912 <malloc+0x96>
+ 8d4:	f04a                	sd	s2,32(sp)
+ 8d6:	e852                	sd	s4,16(sp)
+ 8d8:	e456                	sd	s5,8(sp)
+ 8da:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 8dc:	00001797          	auipc	a5,0x1
+ 8e0:	92c78793          	addi	a5,a5,-1748 # 1208 <base>
+ 8e4:	00000717          	auipc	a4,0x0
+ 8e8:	70f73e23          	sd	a5,1820(a4) # 1000 <freep>
+ 8ec:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8ee:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8f2:	b7c1                	j	8b2 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8f4:	6398                	ld	a4,0(a5)
+ 8f6:	e118                	sd	a4,0(a0)
+ 8f8:	a8a9                	j	952 <malloc+0xd6>
+  hp->s.size = nu;
+ 8fa:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8fe:	0541                	addi	a0,a0,16
+ 900:	efbff0ef          	jal	7fa <free>
+  return freep;
+ 904:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 908:	c12d                	beqz	a0,96a <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 90a:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 90c:	4798                	lw	a4,8(a5)
+ 90e:	02977263          	bgeu	a4,s1,932 <malloc+0xb6>
+    if(p == freep)
+ 912:	00093703          	ld	a4,0(s2)
+ 916:	853e                	mv	a0,a5
+ 918:	fef719e3          	bne	a4,a5,90a <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 91c:	8552                	mv	a0,s4
+ 91e:	a47ff0ef          	jal	364 <sbrk>
+  if(p == SBRK_ERROR)
+ 922:	fd551ce3          	bne	a0,s5,8fa <malloc+0x7e>
+        return 0;
+ 926:	4501                	li	a0,0
+ 928:	7902                	ld	s2,32(sp)
+ 92a:	6a42                	ld	s4,16(sp)
+ 92c:	6aa2                	ld	s5,8(sp)
+ 92e:	6b02                	ld	s6,0(sp)
+ 930:	a03d                	j	95e <malloc+0xe2>
+ 932:	7902                	ld	s2,32(sp)
+ 934:	6a42                	ld	s4,16(sp)
+ 936:	6aa2                	ld	s5,8(sp)
+ 938:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 93a:	fae48de3          	beq	s1,a4,8f4 <malloc+0x78>
+        p->s.size -= nunits;
+ 93e:	4137073b          	subw	a4,a4,s3
+ 942:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 944:	02071693          	slli	a3,a4,0x20
+ 948:	01c6d713          	srli	a4,a3,0x1c
+ 94c:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 94e:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 952:	00000717          	auipc	a4,0x0
+ 956:	6aa73723          	sd	a0,1710(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 95a:	01078513          	addi	a0,a5,16
+  }
+}
+ 95e:	70e2                	ld	ra,56(sp)
+ 960:	7442                	ld	s0,48(sp)
+ 962:	74a2                	ld	s1,40(sp)
+ 964:	69e2                	ld	s3,24(sp)
+ 966:	6121                	addi	sp,sp,64
+ 968:	8082                	ret
+ 96a:	7902                	ld	s2,32(sp)
+ 96c:	6a42                	ld	s4,16(sp)
+ 96e:	6aa2                	ld	s5,8(sp)
+ 970:	6b02                	ld	s6,0(sp)
+ 972:	b7f5                	j	95e <malloc+0xe2>
diff -ruN xv6-riscv/user/logstress.d xv62/user/logstress.d
--- xv6-riscv/user/logstress.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/logstress.d	2025-09-14 12:32:52.164883051 +0000
@@ -0,0 +1,2 @@
+user/logstress.o: user/logstress.c kernel/types.h kernel/stat.h \
+ kernel/fcntl.h user/user.h
Binary files xv6-riscv/user/logstress.o and xv62/user/logstress.o differ
diff -ruN xv6-riscv/user/logstress.sym xv62/user/logstress.sym
--- xv6-riscv/user/logstress.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/logstress.sym	2025-09-14 12:32:52.196883044 +0000
@@ -0,0 +1,67 @@
+0000000000000000 .text
+0000000000000978 .rodata
+00000000000009e8 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_ranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 logstress.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000440 putc
+000000000000045e printint
+00000000000009d0 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001208 base
+0000000000000114 strcpy
+0000000000000428 pause
+00000000000007c8 printf
+0000000000000420 sys_sbrk
+00000000000002be memmove
+00000000000003e0 mknod
+00000000000001cc gets
+0000000000000418 getpid
+0000000000000350 memcpy
+000000000000087c malloc
+000000000000037a sbrklazy
+00000000000003a8 pipe
+00000000000003b8 write
+00000000000003f0 fstat
+000000000000079e fprintf
+00000000000003c8 kill
+00000000000004fa vprintf
+0000000000000408 chdir
+00000000000003d0 exec
+00000000000003a0 wait
+00000000000003b0 read
+00000000000003e8 unlink
+0000000000000316 memcmp
+0000000000000390 fork
+0000000000000364 sbrk
+0000000000000430 uptime
+0000000000000186 memset
+0000000000000000 main
+0000000000000130 strcmp
+0000000000000410 dup
+0000000000001010 buf
+0000000000000438 getreadcount
+000000000000023c stat
+00000000000003f8 link
+0000000000000398 exit
+0000000000000104 start
+0000000000000276 atoi
+000000000000015c strlen
+00000000000003d8 open
+00000000000001a8 strchr
+0000000000000400 mkdir
+00000000000003c0 close
+00000000000007fa free
diff -ruN xv6-riscv/user/loop.asm xv62/user/loop.asm
--- xv6-riscv/user/loop.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/loop.asm	2025-09-14 12:32:52.416882999 +0000
@@ -0,0 +1,1519 @@
+
+user/_loop:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/fcntl.h"
+
+#define NFORK 10
+#define IO 5
+
+int main() {
+   0:	7179                	addi	sp,sp,-48
+   2:	f406                	sd	ra,40(sp)
+   4:	f022                	sd	s0,32(sp)
+   6:	ec26                	sd	s1,24(sp)
+   8:	e84a                	sd	s2,16(sp)
+   a:	1800                	addi	s0,sp,48
+  int n, pid;
+  
+  for (n = 0; n < NFORK; n++) {
+   c:	4481                	li	s1,0
+   e:	4929                	li	s2,10
+    pid = fork();
+  10:	2e4000ef          	jal	2f4 <fork>
+    if (pid < 0)
+  14:	00054663          	bltz	a0,20 <main+0x20>
+      break;
+    if (pid == 0) {
+  18:	c519                	beqz	a0,26 <main+0x26>
+  for (n = 0; n < NFORK; n++) {
+  1a:	2485                	addiw	s1,s1,1
+  1c:	ff249ae3          	bne	s1,s2,10 <main+0x10>
+      }
+      // printf("\nProcess %d finished\n", n);
+      exit(0);
+    }
+  }
+  exit(0);
+  20:	4501                	li	a0,0
+  22:	2da000ef          	jal	2fc <exit>
+      if (n < IO) {
+  26:	4791                	li	a5,4
+  28:	0297db63          	bge	a5,s1,5e <main+0x5e>
+        for (volatile int i = 0; i < 1000000000; i++) {} // CPU-bound process
+  2c:	fc042e23          	sw	zero,-36(s0)
+  30:	fdc42703          	lw	a4,-36(s0)
+  34:	2701                	sext.w	a4,a4
+  36:	3b9ad7b7          	lui	a5,0x3b9ad
+  3a:	9ff78793          	addi	a5,a5,-1537 # 3b9ac9ff <base+0x3b9ab9ef>
+  3e:	00e7cd63          	blt	a5,a4,58 <main+0x58>
+  42:	873e                	mv	a4,a5
+  44:	fdc42783          	lw	a5,-36(s0)
+  48:	2785                	addiw	a5,a5,1
+  4a:	fcf42e23          	sw	a5,-36(s0)
+  4e:	fdc42783          	lw	a5,-36(s0)
+  52:	2781                	sext.w	a5,a5
+  54:	fef758e3          	bge	a4,a5,44 <main+0x44>
+      exit(0);
+  58:	4501                	li	a0,0
+  5a:	2a2000ef          	jal	2fc <exit>
+        pause(200); // IO-bound process
+  5e:	0c800513          	li	a0,200
+  62:	32a000ef          	jal	38c <pause>
+  66:	bfcd                	j	58 <main+0x58>
+
+0000000000000068 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  68:	1141                	addi	sp,sp,-16
+  6a:	e406                	sd	ra,8(sp)
+  6c:	e022                	sd	s0,0(sp)
+  6e:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  70:	f91ff0ef          	jal	0 <main>
+  exit(r);
+  74:	288000ef          	jal	2fc <exit>
+
+0000000000000078 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  78:	1141                	addi	sp,sp,-16
+  7a:	e422                	sd	s0,8(sp)
+  7c:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  7e:	87aa                	mv	a5,a0
+  80:	0585                	addi	a1,a1,1
+  82:	0785                	addi	a5,a5,1
+  84:	fff5c703          	lbu	a4,-1(a1)
+  88:	fee78fa3          	sb	a4,-1(a5)
+  8c:	fb75                	bnez	a4,80 <strcpy+0x8>
+    ;
+  return os;
+}
+  8e:	6422                	ld	s0,8(sp)
+  90:	0141                	addi	sp,sp,16
+  92:	8082                	ret
+
+0000000000000094 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  94:	1141                	addi	sp,sp,-16
+  96:	e422                	sd	s0,8(sp)
+  98:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  9a:	00054783          	lbu	a5,0(a0)
+  9e:	cb91                	beqz	a5,b2 <strcmp+0x1e>
+  a0:	0005c703          	lbu	a4,0(a1)
+  a4:	00f71763          	bne	a4,a5,b2 <strcmp+0x1e>
+    p++, q++;
+  a8:	0505                	addi	a0,a0,1
+  aa:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  ac:	00054783          	lbu	a5,0(a0)
+  b0:	fbe5                	bnez	a5,a0 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  b2:	0005c503          	lbu	a0,0(a1)
+}
+  b6:	40a7853b          	subw	a0,a5,a0
+  ba:	6422                	ld	s0,8(sp)
+  bc:	0141                	addi	sp,sp,16
+  be:	8082                	ret
+
+00000000000000c0 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  c0:	1141                	addi	sp,sp,-16
+  c2:	e422                	sd	s0,8(sp)
+  c4:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  c6:	00054783          	lbu	a5,0(a0)
+  ca:	cf91                	beqz	a5,e6 <strlen+0x26>
+  cc:	0505                	addi	a0,a0,1
+  ce:	87aa                	mv	a5,a0
+  d0:	86be                	mv	a3,a5
+  d2:	0785                	addi	a5,a5,1
+  d4:	fff7c703          	lbu	a4,-1(a5)
+  d8:	ff65                	bnez	a4,d0 <strlen+0x10>
+  da:	40a6853b          	subw	a0,a3,a0
+  de:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  e0:	6422                	ld	s0,8(sp)
+  e2:	0141                	addi	sp,sp,16
+  e4:	8082                	ret
+  for(n = 0; s[n]; n++)
+  e6:	4501                	li	a0,0
+  e8:	bfe5                	j	e0 <strlen+0x20>
+
+00000000000000ea <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  ea:	1141                	addi	sp,sp,-16
+  ec:	e422                	sd	s0,8(sp)
+  ee:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  f0:	ca19                	beqz	a2,106 <memset+0x1c>
+  f2:	87aa                	mv	a5,a0
+  f4:	1602                	slli	a2,a2,0x20
+  f6:	9201                	srli	a2,a2,0x20
+  f8:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  fc:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 100:	0785                	addi	a5,a5,1
+ 102:	fee79de3          	bne	a5,a4,fc <memset+0x12>
+  }
+  return dst;
+}
+ 106:	6422                	ld	s0,8(sp)
+ 108:	0141                	addi	sp,sp,16
+ 10a:	8082                	ret
+
+000000000000010c <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 10c:	1141                	addi	sp,sp,-16
+ 10e:	e422                	sd	s0,8(sp)
+ 110:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 112:	00054783          	lbu	a5,0(a0)
+ 116:	cb99                	beqz	a5,12c <strchr+0x20>
+    if(*s == c)
+ 118:	00f58763          	beq	a1,a5,126 <strchr+0x1a>
+  for(; *s; s++)
+ 11c:	0505                	addi	a0,a0,1
+ 11e:	00054783          	lbu	a5,0(a0)
+ 122:	fbfd                	bnez	a5,118 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 124:	4501                	li	a0,0
+}
+ 126:	6422                	ld	s0,8(sp)
+ 128:	0141                	addi	sp,sp,16
+ 12a:	8082                	ret
+  return 0;
+ 12c:	4501                	li	a0,0
+ 12e:	bfe5                	j	126 <strchr+0x1a>
+
+0000000000000130 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 130:	711d                	addi	sp,sp,-96
+ 132:	ec86                	sd	ra,88(sp)
+ 134:	e8a2                	sd	s0,80(sp)
+ 136:	e4a6                	sd	s1,72(sp)
+ 138:	e0ca                	sd	s2,64(sp)
+ 13a:	fc4e                	sd	s3,56(sp)
+ 13c:	f852                	sd	s4,48(sp)
+ 13e:	f456                	sd	s5,40(sp)
+ 140:	f05a                	sd	s6,32(sp)
+ 142:	ec5e                	sd	s7,24(sp)
+ 144:	1080                	addi	s0,sp,96
+ 146:	8baa                	mv	s7,a0
+ 148:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 14a:	892a                	mv	s2,a0
+ 14c:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 14e:	4aa9                	li	s5,10
+ 150:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 152:	89a6                	mv	s3,s1
+ 154:	2485                	addiw	s1,s1,1
+ 156:	0344d663          	bge	s1,s4,182 <gets+0x52>
+    cc = read(0, &c, 1);
+ 15a:	4605                	li	a2,1
+ 15c:	faf40593          	addi	a1,s0,-81
+ 160:	4501                	li	a0,0
+ 162:	1b2000ef          	jal	314 <read>
+    if(cc < 1)
+ 166:	00a05e63          	blez	a0,182 <gets+0x52>
+    buf[i++] = c;
+ 16a:	faf44783          	lbu	a5,-81(s0)
+ 16e:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 172:	01578763          	beq	a5,s5,180 <gets+0x50>
+ 176:	0905                	addi	s2,s2,1
+ 178:	fd679de3          	bne	a5,s6,152 <gets+0x22>
+    buf[i++] = c;
+ 17c:	89a6                	mv	s3,s1
+ 17e:	a011                	j	182 <gets+0x52>
+ 180:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 182:	99de                	add	s3,s3,s7
+ 184:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 188:	855e                	mv	a0,s7
+ 18a:	60e6                	ld	ra,88(sp)
+ 18c:	6446                	ld	s0,80(sp)
+ 18e:	64a6                	ld	s1,72(sp)
+ 190:	6906                	ld	s2,64(sp)
+ 192:	79e2                	ld	s3,56(sp)
+ 194:	7a42                	ld	s4,48(sp)
+ 196:	7aa2                	ld	s5,40(sp)
+ 198:	7b02                	ld	s6,32(sp)
+ 19a:	6be2                	ld	s7,24(sp)
+ 19c:	6125                	addi	sp,sp,96
+ 19e:	8082                	ret
+
+00000000000001a0 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1a0:	1101                	addi	sp,sp,-32
+ 1a2:	ec06                	sd	ra,24(sp)
+ 1a4:	e822                	sd	s0,16(sp)
+ 1a6:	e04a                	sd	s2,0(sp)
+ 1a8:	1000                	addi	s0,sp,32
+ 1aa:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1ac:	4581                	li	a1,0
+ 1ae:	18e000ef          	jal	33c <open>
+  if(fd < 0)
+ 1b2:	02054263          	bltz	a0,1d6 <stat+0x36>
+ 1b6:	e426                	sd	s1,8(sp)
+ 1b8:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1ba:	85ca                	mv	a1,s2
+ 1bc:	198000ef          	jal	354 <fstat>
+ 1c0:	892a                	mv	s2,a0
+  close(fd);
+ 1c2:	8526                	mv	a0,s1
+ 1c4:	160000ef          	jal	324 <close>
+  return r;
+ 1c8:	64a2                	ld	s1,8(sp)
+}
+ 1ca:	854a                	mv	a0,s2
+ 1cc:	60e2                	ld	ra,24(sp)
+ 1ce:	6442                	ld	s0,16(sp)
+ 1d0:	6902                	ld	s2,0(sp)
+ 1d2:	6105                	addi	sp,sp,32
+ 1d4:	8082                	ret
+    return -1;
+ 1d6:	597d                	li	s2,-1
+ 1d8:	bfcd                	j	1ca <stat+0x2a>
+
+00000000000001da <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1da:	1141                	addi	sp,sp,-16
+ 1dc:	e422                	sd	s0,8(sp)
+ 1de:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1e0:	00054683          	lbu	a3,0(a0)
+ 1e4:	fd06879b          	addiw	a5,a3,-48
+ 1e8:	0ff7f793          	zext.b	a5,a5
+ 1ec:	4625                	li	a2,9
+ 1ee:	02f66863          	bltu	a2,a5,21e <atoi+0x44>
+ 1f2:	872a                	mv	a4,a0
+  n = 0;
+ 1f4:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1f6:	0705                	addi	a4,a4,1
+ 1f8:	0025179b          	slliw	a5,a0,0x2
+ 1fc:	9fa9                	addw	a5,a5,a0
+ 1fe:	0017979b          	slliw	a5,a5,0x1
+ 202:	9fb5                	addw	a5,a5,a3
+ 204:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 208:	00074683          	lbu	a3,0(a4)
+ 20c:	fd06879b          	addiw	a5,a3,-48
+ 210:	0ff7f793          	zext.b	a5,a5
+ 214:	fef671e3          	bgeu	a2,a5,1f6 <atoi+0x1c>
+  return n;
+}
+ 218:	6422                	ld	s0,8(sp)
+ 21a:	0141                	addi	sp,sp,16
+ 21c:	8082                	ret
+  n = 0;
+ 21e:	4501                	li	a0,0
+ 220:	bfe5                	j	218 <atoi+0x3e>
+
+0000000000000222 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 222:	1141                	addi	sp,sp,-16
+ 224:	e422                	sd	s0,8(sp)
+ 226:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 228:	02b57463          	bgeu	a0,a1,250 <memmove+0x2e>
+    while(n-- > 0)
+ 22c:	00c05f63          	blez	a2,24a <memmove+0x28>
+ 230:	1602                	slli	a2,a2,0x20
+ 232:	9201                	srli	a2,a2,0x20
+ 234:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 238:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 23a:	0585                	addi	a1,a1,1
+ 23c:	0705                	addi	a4,a4,1
+ 23e:	fff5c683          	lbu	a3,-1(a1)
+ 242:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 246:	fef71ae3          	bne	a4,a5,23a <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 24a:	6422                	ld	s0,8(sp)
+ 24c:	0141                	addi	sp,sp,16
+ 24e:	8082                	ret
+    dst += n;
+ 250:	00c50733          	add	a4,a0,a2
+    src += n;
+ 254:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 256:	fec05ae3          	blez	a2,24a <memmove+0x28>
+ 25a:	fff6079b          	addiw	a5,a2,-1
+ 25e:	1782                	slli	a5,a5,0x20
+ 260:	9381                	srli	a5,a5,0x20
+ 262:	fff7c793          	not	a5,a5
+ 266:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 268:	15fd                	addi	a1,a1,-1
+ 26a:	177d                	addi	a4,a4,-1
+ 26c:	0005c683          	lbu	a3,0(a1)
+ 270:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 274:	fee79ae3          	bne	a5,a4,268 <memmove+0x46>
+ 278:	bfc9                	j	24a <memmove+0x28>
+
+000000000000027a <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 27a:	1141                	addi	sp,sp,-16
+ 27c:	e422                	sd	s0,8(sp)
+ 27e:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 280:	ca05                	beqz	a2,2b0 <memcmp+0x36>
+ 282:	fff6069b          	addiw	a3,a2,-1
+ 286:	1682                	slli	a3,a3,0x20
+ 288:	9281                	srli	a3,a3,0x20
+ 28a:	0685                	addi	a3,a3,1
+ 28c:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 28e:	00054783          	lbu	a5,0(a0)
+ 292:	0005c703          	lbu	a4,0(a1)
+ 296:	00e79863          	bne	a5,a4,2a6 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 29a:	0505                	addi	a0,a0,1
+    p2++;
+ 29c:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 29e:	fed518e3          	bne	a0,a3,28e <memcmp+0x14>
+  }
+  return 0;
+ 2a2:	4501                	li	a0,0
+ 2a4:	a019                	j	2aa <memcmp+0x30>
+      return *p1 - *p2;
+ 2a6:	40e7853b          	subw	a0,a5,a4
+}
+ 2aa:	6422                	ld	s0,8(sp)
+ 2ac:	0141                	addi	sp,sp,16
+ 2ae:	8082                	ret
+  return 0;
+ 2b0:	4501                	li	a0,0
+ 2b2:	bfe5                	j	2aa <memcmp+0x30>
+
+00000000000002b4 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2b4:	1141                	addi	sp,sp,-16
+ 2b6:	e406                	sd	ra,8(sp)
+ 2b8:	e022                	sd	s0,0(sp)
+ 2ba:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2bc:	f67ff0ef          	jal	222 <memmove>
+}
+ 2c0:	60a2                	ld	ra,8(sp)
+ 2c2:	6402                	ld	s0,0(sp)
+ 2c4:	0141                	addi	sp,sp,16
+ 2c6:	8082                	ret
+
+00000000000002c8 <sbrk>:
+
+char *
+sbrk(int n) {
+ 2c8:	1141                	addi	sp,sp,-16
+ 2ca:	e406                	sd	ra,8(sp)
+ 2cc:	e022                	sd	s0,0(sp)
+ 2ce:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2d0:	4585                	li	a1,1
+ 2d2:	0b2000ef          	jal	384 <sys_sbrk>
+}
+ 2d6:	60a2                	ld	ra,8(sp)
+ 2d8:	6402                	ld	s0,0(sp)
+ 2da:	0141                	addi	sp,sp,16
+ 2dc:	8082                	ret
+
+00000000000002de <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2de:	1141                	addi	sp,sp,-16
+ 2e0:	e406                	sd	ra,8(sp)
+ 2e2:	e022                	sd	s0,0(sp)
+ 2e4:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2e6:	4589                	li	a1,2
+ 2e8:	09c000ef          	jal	384 <sys_sbrk>
+}
+ 2ec:	60a2                	ld	ra,8(sp)
+ 2ee:	6402                	ld	s0,0(sp)
+ 2f0:	0141                	addi	sp,sp,16
+ 2f2:	8082                	ret
+
+00000000000002f4 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2f4:	4885                	li	a7,1
+ ecall
+ 2f6:	00000073          	ecall
+ ret
+ 2fa:	8082                	ret
+
+00000000000002fc <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2fc:	4889                	li	a7,2
+ ecall
+ 2fe:	00000073          	ecall
+ ret
+ 302:	8082                	ret
+
+0000000000000304 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 304:	488d                	li	a7,3
+ ecall
+ 306:	00000073          	ecall
+ ret
+ 30a:	8082                	ret
+
+000000000000030c <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 30c:	4891                	li	a7,4
+ ecall
+ 30e:	00000073          	ecall
+ ret
+ 312:	8082                	ret
+
+0000000000000314 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 314:	4895                	li	a7,5
+ ecall
+ 316:	00000073          	ecall
+ ret
+ 31a:	8082                	ret
+
+000000000000031c <write>:
+.global write
+write:
+ li a7, SYS_write
+ 31c:	48c1                	li	a7,16
+ ecall
+ 31e:	00000073          	ecall
+ ret
+ 322:	8082                	ret
+
+0000000000000324 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 324:	48d5                	li	a7,21
+ ecall
+ 326:	00000073          	ecall
+ ret
+ 32a:	8082                	ret
+
+000000000000032c <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 32c:	4899                	li	a7,6
+ ecall
+ 32e:	00000073          	ecall
+ ret
+ 332:	8082                	ret
+
+0000000000000334 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 334:	489d                	li	a7,7
+ ecall
+ 336:	00000073          	ecall
+ ret
+ 33a:	8082                	ret
+
+000000000000033c <open>:
+.global open
+open:
+ li a7, SYS_open
+ 33c:	48bd                	li	a7,15
+ ecall
+ 33e:	00000073          	ecall
+ ret
+ 342:	8082                	ret
+
+0000000000000344 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 344:	48c5                	li	a7,17
+ ecall
+ 346:	00000073          	ecall
+ ret
+ 34a:	8082                	ret
+
+000000000000034c <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 34c:	48c9                	li	a7,18
+ ecall
+ 34e:	00000073          	ecall
+ ret
+ 352:	8082                	ret
+
+0000000000000354 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 354:	48a1                	li	a7,8
+ ecall
+ 356:	00000073          	ecall
+ ret
+ 35a:	8082                	ret
+
+000000000000035c <link>:
+.global link
+link:
+ li a7, SYS_link
+ 35c:	48cd                	li	a7,19
+ ecall
+ 35e:	00000073          	ecall
+ ret
+ 362:	8082                	ret
+
+0000000000000364 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 364:	48d1                	li	a7,20
+ ecall
+ 366:	00000073          	ecall
+ ret
+ 36a:	8082                	ret
+
+000000000000036c <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 36c:	48a5                	li	a7,9
+ ecall
+ 36e:	00000073          	ecall
+ ret
+ 372:	8082                	ret
+
+0000000000000374 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 374:	48a9                	li	a7,10
+ ecall
+ 376:	00000073          	ecall
+ ret
+ 37a:	8082                	ret
+
+000000000000037c <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 37c:	48ad                	li	a7,11
+ ecall
+ 37e:	00000073          	ecall
+ ret
+ 382:	8082                	ret
+
+0000000000000384 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 384:	48b1                	li	a7,12
+ ecall
+ 386:	00000073          	ecall
+ ret
+ 38a:	8082                	ret
+
+000000000000038c <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 38c:	48b5                	li	a7,13
+ ecall
+ 38e:	00000073          	ecall
+ ret
+ 392:	8082                	ret
+
+0000000000000394 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 394:	48b9                	li	a7,14
+ ecall
+ 396:	00000073          	ecall
+ ret
+ 39a:	8082                	ret
+
+000000000000039c <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 39c:	48d9                	li	a7,22
+ ecall
+ 39e:	00000073          	ecall
+ ret
+ 3a2:	8082                	ret
+
+00000000000003a4 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3a4:	1101                	addi	sp,sp,-32
+ 3a6:	ec06                	sd	ra,24(sp)
+ 3a8:	e822                	sd	s0,16(sp)
+ 3aa:	1000                	addi	s0,sp,32
+ 3ac:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 3b0:	4605                	li	a2,1
+ 3b2:	fef40593          	addi	a1,s0,-17
+ 3b6:	f67ff0ef          	jal	31c <write>
+}
+ 3ba:	60e2                	ld	ra,24(sp)
+ 3bc:	6442                	ld	s0,16(sp)
+ 3be:	6105                	addi	sp,sp,32
+ 3c0:	8082                	ret
+
+00000000000003c2 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3c2:	715d                	addi	sp,sp,-80
+ 3c4:	e486                	sd	ra,72(sp)
+ 3c6:	e0a2                	sd	s0,64(sp)
+ 3c8:	f84a                	sd	s2,48(sp)
+ 3ca:	0880                	addi	s0,sp,80
+ 3cc:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3ce:	c299                	beqz	a3,3d4 <printint+0x12>
+ 3d0:	0805c363          	bltz	a1,456 <printint+0x94>
+  neg = 0;
+ 3d4:	4881                	li	a7,0
+ 3d6:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3da:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3dc:	00000517          	auipc	a0,0x0
+ 3e0:	50c50513          	addi	a0,a0,1292 # 8e8 <digits>
+ 3e4:	883e                	mv	a6,a5
+ 3e6:	2785                	addiw	a5,a5,1
+ 3e8:	02c5f733          	remu	a4,a1,a2
+ 3ec:	972a                	add	a4,a4,a0
+ 3ee:	00074703          	lbu	a4,0(a4)
+ 3f2:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3f6:	872e                	mv	a4,a1
+ 3f8:	02c5d5b3          	divu	a1,a1,a2
+ 3fc:	0685                	addi	a3,a3,1
+ 3fe:	fec773e3          	bgeu	a4,a2,3e4 <printint+0x22>
+  if(neg)
+ 402:	00088b63          	beqz	a7,418 <printint+0x56>
+    buf[i++] = '-';
+ 406:	fd078793          	addi	a5,a5,-48
+ 40a:	97a2                	add	a5,a5,s0
+ 40c:	02d00713          	li	a4,45
+ 410:	fee78423          	sb	a4,-24(a5)
+ 414:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 418:	02f05a63          	blez	a5,44c <printint+0x8a>
+ 41c:	fc26                	sd	s1,56(sp)
+ 41e:	f44e                	sd	s3,40(sp)
+ 420:	fb840713          	addi	a4,s0,-72
+ 424:	00f704b3          	add	s1,a4,a5
+ 428:	fff70993          	addi	s3,a4,-1
+ 42c:	99be                	add	s3,s3,a5
+ 42e:	37fd                	addiw	a5,a5,-1
+ 430:	1782                	slli	a5,a5,0x20
+ 432:	9381                	srli	a5,a5,0x20
+ 434:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 438:	fff4c583          	lbu	a1,-1(s1)
+ 43c:	854a                	mv	a0,s2
+ 43e:	f67ff0ef          	jal	3a4 <putc>
+  while(--i >= 0)
+ 442:	14fd                	addi	s1,s1,-1
+ 444:	ff349ae3          	bne	s1,s3,438 <printint+0x76>
+ 448:	74e2                	ld	s1,56(sp)
+ 44a:	79a2                	ld	s3,40(sp)
+}
+ 44c:	60a6                	ld	ra,72(sp)
+ 44e:	6406                	ld	s0,64(sp)
+ 450:	7942                	ld	s2,48(sp)
+ 452:	6161                	addi	sp,sp,80
+ 454:	8082                	ret
+    x = -xx;
+ 456:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 45a:	4885                	li	a7,1
+    x = -xx;
+ 45c:	bfad                	j	3d6 <printint+0x14>
+
+000000000000045e <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 45e:	711d                	addi	sp,sp,-96
+ 460:	ec86                	sd	ra,88(sp)
+ 462:	e8a2                	sd	s0,80(sp)
+ 464:	e0ca                	sd	s2,64(sp)
+ 466:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 468:	0005c903          	lbu	s2,0(a1)
+ 46c:	28090663          	beqz	s2,6f8 <vprintf+0x29a>
+ 470:	e4a6                	sd	s1,72(sp)
+ 472:	fc4e                	sd	s3,56(sp)
+ 474:	f852                	sd	s4,48(sp)
+ 476:	f456                	sd	s5,40(sp)
+ 478:	f05a                	sd	s6,32(sp)
+ 47a:	ec5e                	sd	s7,24(sp)
+ 47c:	e862                	sd	s8,16(sp)
+ 47e:	e466                	sd	s9,8(sp)
+ 480:	8b2a                	mv	s6,a0
+ 482:	8a2e                	mv	s4,a1
+ 484:	8bb2                	mv	s7,a2
+  state = 0;
+ 486:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 488:	4481                	li	s1,0
+ 48a:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 48c:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 490:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 494:	06c00c93          	li	s9,108
+ 498:	a005                	j	4b8 <vprintf+0x5a>
+        putc(fd, c0);
+ 49a:	85ca                	mv	a1,s2
+ 49c:	855a                	mv	a0,s6
+ 49e:	f07ff0ef          	jal	3a4 <putc>
+ 4a2:	a019                	j	4a8 <vprintf+0x4a>
+    } else if(state == '%'){
+ 4a4:	03598263          	beq	s3,s5,4c8 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4a8:	2485                	addiw	s1,s1,1
+ 4aa:	8726                	mv	a4,s1
+ 4ac:	009a07b3          	add	a5,s4,s1
+ 4b0:	0007c903          	lbu	s2,0(a5)
+ 4b4:	22090a63          	beqz	s2,6e8 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4b8:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4bc:	fe0994e3          	bnez	s3,4a4 <vprintf+0x46>
+      if(c0 == '%'){
+ 4c0:	fd579de3          	bne	a5,s5,49a <vprintf+0x3c>
+        state = '%';
+ 4c4:	89be                	mv	s3,a5
+ 4c6:	b7cd                	j	4a8 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4c8:	00ea06b3          	add	a3,s4,a4
+ 4cc:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4d0:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4d2:	c681                	beqz	a3,4da <vprintf+0x7c>
+ 4d4:	9752                	add	a4,a4,s4
+ 4d6:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4da:	05878363          	beq	a5,s8,520 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4de:	05978d63          	beq	a5,s9,538 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4e2:	07500713          	li	a4,117
+ 4e6:	0ee78763          	beq	a5,a4,5d4 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4ea:	07800713          	li	a4,120
+ 4ee:	12e78963          	beq	a5,a4,620 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4f2:	07000713          	li	a4,112
+ 4f6:	14e78e63          	beq	a5,a4,652 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4fa:	06300713          	li	a4,99
+ 4fe:	18e78e63          	beq	a5,a4,69a <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 502:	07300713          	li	a4,115
+ 506:	1ae78463          	beq	a5,a4,6ae <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 50a:	02500713          	li	a4,37
+ 50e:	04e79563          	bne	a5,a4,558 <vprintf+0xfa>
+        putc(fd, '%');
+ 512:	02500593          	li	a1,37
+ 516:	855a                	mv	a0,s6
+ 518:	e8dff0ef          	jal	3a4 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 51c:	4981                	li	s3,0
+ 51e:	b769                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 520:	008b8913          	addi	s2,s7,8
+ 524:	4685                	li	a3,1
+ 526:	4629                	li	a2,10
+ 528:	000ba583          	lw	a1,0(s7)
+ 52c:	855a                	mv	a0,s6
+ 52e:	e95ff0ef          	jal	3c2 <printint>
+ 532:	8bca                	mv	s7,s2
+      state = 0;
+ 534:	4981                	li	s3,0
+ 536:	bf8d                	j	4a8 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 538:	06400793          	li	a5,100
+ 53c:	02f68963          	beq	a3,a5,56e <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 540:	06c00793          	li	a5,108
+ 544:	04f68263          	beq	a3,a5,588 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 548:	07500793          	li	a5,117
+ 54c:	0af68063          	beq	a3,a5,5ec <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 550:	07800793          	li	a5,120
+ 554:	0ef68263          	beq	a3,a5,638 <vprintf+0x1da>
+        putc(fd, '%');
+ 558:	02500593          	li	a1,37
+ 55c:	855a                	mv	a0,s6
+ 55e:	e47ff0ef          	jal	3a4 <putc>
+        putc(fd, c0);
+ 562:	85ca                	mv	a1,s2
+ 564:	855a                	mv	a0,s6
+ 566:	e3fff0ef          	jal	3a4 <putc>
+      state = 0;
+ 56a:	4981                	li	s3,0
+ 56c:	bf35                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 56e:	008b8913          	addi	s2,s7,8
+ 572:	4685                	li	a3,1
+ 574:	4629                	li	a2,10
+ 576:	000bb583          	ld	a1,0(s7)
+ 57a:	855a                	mv	a0,s6
+ 57c:	e47ff0ef          	jal	3c2 <printint>
+        i += 1;
+ 580:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 582:	8bca                	mv	s7,s2
+      state = 0;
+ 584:	4981                	li	s3,0
+        i += 1;
+ 586:	b70d                	j	4a8 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 588:	06400793          	li	a5,100
+ 58c:	02f60763          	beq	a2,a5,5ba <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 590:	07500793          	li	a5,117
+ 594:	06f60963          	beq	a2,a5,606 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 598:	07800793          	li	a5,120
+ 59c:	faf61ee3          	bne	a2,a5,558 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5a0:	008b8913          	addi	s2,s7,8
+ 5a4:	4681                	li	a3,0
+ 5a6:	4641                	li	a2,16
+ 5a8:	000bb583          	ld	a1,0(s7)
+ 5ac:	855a                	mv	a0,s6
+ 5ae:	e15ff0ef          	jal	3c2 <printint>
+        i += 2;
+ 5b2:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5b4:	8bca                	mv	s7,s2
+      state = 0;
+ 5b6:	4981                	li	s3,0
+        i += 2;
+ 5b8:	bdc5                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5ba:	008b8913          	addi	s2,s7,8
+ 5be:	4685                	li	a3,1
+ 5c0:	4629                	li	a2,10
+ 5c2:	000bb583          	ld	a1,0(s7)
+ 5c6:	855a                	mv	a0,s6
+ 5c8:	dfbff0ef          	jal	3c2 <printint>
+        i += 2;
+ 5cc:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5ce:	8bca                	mv	s7,s2
+      state = 0;
+ 5d0:	4981                	li	s3,0
+        i += 2;
+ 5d2:	bdd9                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5d4:	008b8913          	addi	s2,s7,8
+ 5d8:	4681                	li	a3,0
+ 5da:	4629                	li	a2,10
+ 5dc:	000be583          	lwu	a1,0(s7)
+ 5e0:	855a                	mv	a0,s6
+ 5e2:	de1ff0ef          	jal	3c2 <printint>
+ 5e6:	8bca                	mv	s7,s2
+      state = 0;
+ 5e8:	4981                	li	s3,0
+ 5ea:	bd7d                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5ec:	008b8913          	addi	s2,s7,8
+ 5f0:	4681                	li	a3,0
+ 5f2:	4629                	li	a2,10
+ 5f4:	000bb583          	ld	a1,0(s7)
+ 5f8:	855a                	mv	a0,s6
+ 5fa:	dc9ff0ef          	jal	3c2 <printint>
+        i += 1;
+ 5fe:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 600:	8bca                	mv	s7,s2
+      state = 0;
+ 602:	4981                	li	s3,0
+        i += 1;
+ 604:	b555                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 606:	008b8913          	addi	s2,s7,8
+ 60a:	4681                	li	a3,0
+ 60c:	4629                	li	a2,10
+ 60e:	000bb583          	ld	a1,0(s7)
+ 612:	855a                	mv	a0,s6
+ 614:	dafff0ef          	jal	3c2 <printint>
+        i += 2;
+ 618:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 61a:	8bca                	mv	s7,s2
+      state = 0;
+ 61c:	4981                	li	s3,0
+        i += 2;
+ 61e:	b569                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 620:	008b8913          	addi	s2,s7,8
+ 624:	4681                	li	a3,0
+ 626:	4641                	li	a2,16
+ 628:	000be583          	lwu	a1,0(s7)
+ 62c:	855a                	mv	a0,s6
+ 62e:	d95ff0ef          	jal	3c2 <printint>
+ 632:	8bca                	mv	s7,s2
+      state = 0;
+ 634:	4981                	li	s3,0
+ 636:	bd8d                	j	4a8 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 638:	008b8913          	addi	s2,s7,8
+ 63c:	4681                	li	a3,0
+ 63e:	4641                	li	a2,16
+ 640:	000bb583          	ld	a1,0(s7)
+ 644:	855a                	mv	a0,s6
+ 646:	d7dff0ef          	jal	3c2 <printint>
+        i += 1;
+ 64a:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 64c:	8bca                	mv	s7,s2
+      state = 0;
+ 64e:	4981                	li	s3,0
+        i += 1;
+ 650:	bda1                	j	4a8 <vprintf+0x4a>
+ 652:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 654:	008b8d13          	addi	s10,s7,8
+ 658:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 65c:	03000593          	li	a1,48
+ 660:	855a                	mv	a0,s6
+ 662:	d43ff0ef          	jal	3a4 <putc>
+  putc(fd, 'x');
+ 666:	07800593          	li	a1,120
+ 66a:	855a                	mv	a0,s6
+ 66c:	d39ff0ef          	jal	3a4 <putc>
+ 670:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 672:	00000b97          	auipc	s7,0x0
+ 676:	276b8b93          	addi	s7,s7,630 # 8e8 <digits>
+ 67a:	03c9d793          	srli	a5,s3,0x3c
+ 67e:	97de                	add	a5,a5,s7
+ 680:	0007c583          	lbu	a1,0(a5)
+ 684:	855a                	mv	a0,s6
+ 686:	d1fff0ef          	jal	3a4 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 68a:	0992                	slli	s3,s3,0x4
+ 68c:	397d                	addiw	s2,s2,-1
+ 68e:	fe0916e3          	bnez	s2,67a <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 692:	8bea                	mv	s7,s10
+      state = 0;
+ 694:	4981                	li	s3,0
+ 696:	6d02                	ld	s10,0(sp)
+ 698:	bd01                	j	4a8 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 69a:	008b8913          	addi	s2,s7,8
+ 69e:	000bc583          	lbu	a1,0(s7)
+ 6a2:	855a                	mv	a0,s6
+ 6a4:	d01ff0ef          	jal	3a4 <putc>
+ 6a8:	8bca                	mv	s7,s2
+      state = 0;
+ 6aa:	4981                	li	s3,0
+ 6ac:	bbf5                	j	4a8 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ae:	008b8993          	addi	s3,s7,8
+ 6b2:	000bb903          	ld	s2,0(s7)
+ 6b6:	00090f63          	beqz	s2,6d4 <vprintf+0x276>
+        for(; *s; s++)
+ 6ba:	00094583          	lbu	a1,0(s2)
+ 6be:	c195                	beqz	a1,6e2 <vprintf+0x284>
+          putc(fd, *s);
+ 6c0:	855a                	mv	a0,s6
+ 6c2:	ce3ff0ef          	jal	3a4 <putc>
+        for(; *s; s++)
+ 6c6:	0905                	addi	s2,s2,1
+ 6c8:	00094583          	lbu	a1,0(s2)
+ 6cc:	f9f5                	bnez	a1,6c0 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ce:	8bce                	mv	s7,s3
+      state = 0;
+ 6d0:	4981                	li	s3,0
+ 6d2:	bbd9                	j	4a8 <vprintf+0x4a>
+          s = "(null)";
+ 6d4:	00000917          	auipc	s2,0x0
+ 6d8:	20c90913          	addi	s2,s2,524 # 8e0 <malloc+0x100>
+        for(; *s; s++)
+ 6dc:	02800593          	li	a1,40
+ 6e0:	b7c5                	j	6c0 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6e2:	8bce                	mv	s7,s3
+      state = 0;
+ 6e4:	4981                	li	s3,0
+ 6e6:	b3c9                	j	4a8 <vprintf+0x4a>
+ 6e8:	64a6                	ld	s1,72(sp)
+ 6ea:	79e2                	ld	s3,56(sp)
+ 6ec:	7a42                	ld	s4,48(sp)
+ 6ee:	7aa2                	ld	s5,40(sp)
+ 6f0:	7b02                	ld	s6,32(sp)
+ 6f2:	6be2                	ld	s7,24(sp)
+ 6f4:	6c42                	ld	s8,16(sp)
+ 6f6:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6f8:	60e6                	ld	ra,88(sp)
+ 6fa:	6446                	ld	s0,80(sp)
+ 6fc:	6906                	ld	s2,64(sp)
+ 6fe:	6125                	addi	sp,sp,96
+ 700:	8082                	ret
+
+0000000000000702 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 702:	715d                	addi	sp,sp,-80
+ 704:	ec06                	sd	ra,24(sp)
+ 706:	e822                	sd	s0,16(sp)
+ 708:	1000                	addi	s0,sp,32
+ 70a:	e010                	sd	a2,0(s0)
+ 70c:	e414                	sd	a3,8(s0)
+ 70e:	e818                	sd	a4,16(s0)
+ 710:	ec1c                	sd	a5,24(s0)
+ 712:	03043023          	sd	a6,32(s0)
+ 716:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 71a:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 71e:	8622                	mv	a2,s0
+ 720:	d3fff0ef          	jal	45e <vprintf>
+}
+ 724:	60e2                	ld	ra,24(sp)
+ 726:	6442                	ld	s0,16(sp)
+ 728:	6161                	addi	sp,sp,80
+ 72a:	8082                	ret
+
+000000000000072c <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 72c:	711d                	addi	sp,sp,-96
+ 72e:	ec06                	sd	ra,24(sp)
+ 730:	e822                	sd	s0,16(sp)
+ 732:	1000                	addi	s0,sp,32
+ 734:	e40c                	sd	a1,8(s0)
+ 736:	e810                	sd	a2,16(s0)
+ 738:	ec14                	sd	a3,24(s0)
+ 73a:	f018                	sd	a4,32(s0)
+ 73c:	f41c                	sd	a5,40(s0)
+ 73e:	03043823          	sd	a6,48(s0)
+ 742:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 746:	00840613          	addi	a2,s0,8
+ 74a:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 74e:	85aa                	mv	a1,a0
+ 750:	4505                	li	a0,1
+ 752:	d0dff0ef          	jal	45e <vprintf>
+}
+ 756:	60e2                	ld	ra,24(sp)
+ 758:	6442                	ld	s0,16(sp)
+ 75a:	6125                	addi	sp,sp,96
+ 75c:	8082                	ret
+
+000000000000075e <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 75e:	1141                	addi	sp,sp,-16
+ 760:	e422                	sd	s0,8(sp)
+ 762:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 764:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 768:	00001797          	auipc	a5,0x1
+ 76c:	8987b783          	ld	a5,-1896(a5) # 1000 <freep>
+ 770:	a02d                	j	79a <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 772:	4618                	lw	a4,8(a2)
+ 774:	9f2d                	addw	a4,a4,a1
+ 776:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 77a:	6398                	ld	a4,0(a5)
+ 77c:	6310                	ld	a2,0(a4)
+ 77e:	a83d                	j	7bc <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 780:	ff852703          	lw	a4,-8(a0)
+ 784:	9f31                	addw	a4,a4,a2
+ 786:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 788:	ff053683          	ld	a3,-16(a0)
+ 78c:	a091                	j	7d0 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 78e:	6398                	ld	a4,0(a5)
+ 790:	00e7e463          	bltu	a5,a4,798 <free+0x3a>
+ 794:	00e6ea63          	bltu	a3,a4,7a8 <free+0x4a>
+{
+ 798:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 79a:	fed7fae3          	bgeu	a5,a3,78e <free+0x30>
+ 79e:	6398                	ld	a4,0(a5)
+ 7a0:	00e6e463          	bltu	a3,a4,7a8 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7a4:	fee7eae3          	bltu	a5,a4,798 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7a8:	ff852583          	lw	a1,-8(a0)
+ 7ac:	6390                	ld	a2,0(a5)
+ 7ae:	02059813          	slli	a6,a1,0x20
+ 7b2:	01c85713          	srli	a4,a6,0x1c
+ 7b6:	9736                	add	a4,a4,a3
+ 7b8:	fae60de3          	beq	a2,a4,772 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7bc:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7c0:	4790                	lw	a2,8(a5)
+ 7c2:	02061593          	slli	a1,a2,0x20
+ 7c6:	01c5d713          	srli	a4,a1,0x1c
+ 7ca:	973e                	add	a4,a4,a5
+ 7cc:	fae68ae3          	beq	a3,a4,780 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7d0:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7d2:	00001717          	auipc	a4,0x1
+ 7d6:	82f73723          	sd	a5,-2002(a4) # 1000 <freep>
+}
+ 7da:	6422                	ld	s0,8(sp)
+ 7dc:	0141                	addi	sp,sp,16
+ 7de:	8082                	ret
+
+00000000000007e0 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7e0:	7139                	addi	sp,sp,-64
+ 7e2:	fc06                	sd	ra,56(sp)
+ 7e4:	f822                	sd	s0,48(sp)
+ 7e6:	f426                	sd	s1,40(sp)
+ 7e8:	ec4e                	sd	s3,24(sp)
+ 7ea:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7ec:	02051493          	slli	s1,a0,0x20
+ 7f0:	9081                	srli	s1,s1,0x20
+ 7f2:	04bd                	addi	s1,s1,15
+ 7f4:	8091                	srli	s1,s1,0x4
+ 7f6:	0014899b          	addiw	s3,s1,1
+ 7fa:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7fc:	00001517          	auipc	a0,0x1
+ 800:	80453503          	ld	a0,-2044(a0) # 1000 <freep>
+ 804:	c915                	beqz	a0,838 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 806:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 808:	4798                	lw	a4,8(a5)
+ 80a:	08977a63          	bgeu	a4,s1,89e <malloc+0xbe>
+ 80e:	f04a                	sd	s2,32(sp)
+ 810:	e852                	sd	s4,16(sp)
+ 812:	e456                	sd	s5,8(sp)
+ 814:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 816:	8a4e                	mv	s4,s3
+ 818:	0009871b          	sext.w	a4,s3
+ 81c:	6685                	lui	a3,0x1
+ 81e:	00d77363          	bgeu	a4,a3,824 <malloc+0x44>
+ 822:	6a05                	lui	s4,0x1
+ 824:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 828:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 82c:	00000917          	auipc	s2,0x0
+ 830:	7d490913          	addi	s2,s2,2004 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 834:	5afd                	li	s5,-1
+ 836:	a081                	j	876 <malloc+0x96>
+ 838:	f04a                	sd	s2,32(sp)
+ 83a:	e852                	sd	s4,16(sp)
+ 83c:	e456                	sd	s5,8(sp)
+ 83e:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 840:	00000797          	auipc	a5,0x0
+ 844:	7d078793          	addi	a5,a5,2000 # 1010 <base>
+ 848:	00000717          	auipc	a4,0x0
+ 84c:	7af73c23          	sd	a5,1976(a4) # 1000 <freep>
+ 850:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 852:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 856:	b7c1                	j	816 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 858:	6398                	ld	a4,0(a5)
+ 85a:	e118                	sd	a4,0(a0)
+ 85c:	a8a9                	j	8b6 <malloc+0xd6>
+  hp->s.size = nu;
+ 85e:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 862:	0541                	addi	a0,a0,16
+ 864:	efbff0ef          	jal	75e <free>
+  return freep;
+ 868:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 86c:	c12d                	beqz	a0,8ce <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 86e:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 870:	4798                	lw	a4,8(a5)
+ 872:	02977263          	bgeu	a4,s1,896 <malloc+0xb6>
+    if(p == freep)
+ 876:	00093703          	ld	a4,0(s2)
+ 87a:	853e                	mv	a0,a5
+ 87c:	fef719e3          	bne	a4,a5,86e <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 880:	8552                	mv	a0,s4
+ 882:	a47ff0ef          	jal	2c8 <sbrk>
+  if(p == SBRK_ERROR)
+ 886:	fd551ce3          	bne	a0,s5,85e <malloc+0x7e>
+        return 0;
+ 88a:	4501                	li	a0,0
+ 88c:	7902                	ld	s2,32(sp)
+ 88e:	6a42                	ld	s4,16(sp)
+ 890:	6aa2                	ld	s5,8(sp)
+ 892:	6b02                	ld	s6,0(sp)
+ 894:	a03d                	j	8c2 <malloc+0xe2>
+ 896:	7902                	ld	s2,32(sp)
+ 898:	6a42                	ld	s4,16(sp)
+ 89a:	6aa2                	ld	s5,8(sp)
+ 89c:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 89e:	fae48de3          	beq	s1,a4,858 <malloc+0x78>
+        p->s.size -= nunits;
+ 8a2:	4137073b          	subw	a4,a4,s3
+ 8a6:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8a8:	02071693          	slli	a3,a4,0x20
+ 8ac:	01c6d713          	srli	a4,a3,0x1c
+ 8b0:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 8b2:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8b6:	00000717          	auipc	a4,0x0
+ 8ba:	74a73523          	sd	a0,1866(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8be:	01078513          	addi	a0,a5,16
+  }
+}
+ 8c2:	70e2                	ld	ra,56(sp)
+ 8c4:	7442                	ld	s0,48(sp)
+ 8c6:	74a2                	ld	s1,40(sp)
+ 8c8:	69e2                	ld	s3,24(sp)
+ 8ca:	6121                	addi	sp,sp,64
+ 8cc:	8082                	ret
+ 8ce:	7902                	ld	s2,32(sp)
+ 8d0:	6a42                	ld	s4,16(sp)
+ 8d2:	6aa2                	ld	s5,8(sp)
+ 8d4:	6b02                	ld	s6,0(sp)
+ 8d6:	b7f5                	j	8c2 <malloc+0xe2>
diff -ruN xv6-riscv/user/loop.c xv62/user/loop.c
--- xv6-riscv/user/loop.c	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/loop.c	2025-09-13 15:19:52.936944437 +0000
@@ -0,0 +1,53 @@
+
+// int
+// main(int argc, char *argv[])
+// {
+//   int count = 0;
+//   int duration = 1000; // Run for limited time
+//   
+//   if(argc > 1) {
+//     duration = atoi(argv[1]);
+//   }
+//   
+//   printf("Starting loop process (PID: %d) for %d iterations\n", getpid(), duration);
+//   printf("Press Ctrl-P to see scheduler info\n");
+//   
+//   while(count < duration * 1000) {  // Make it finite to avoid infinite hanging
+//     count++;
+//     
+//     if(count % 100000 == 0) {
+//       printf("Loop process %d: count = %d\n", getpid(), count);
+//     }
+//   }
+//   
+//   printf("Loop process %d finished after %d iterations\n", getpid(), count);
+//   exit(0);
+// }
+
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+
+#define NFORK 10
+#define IO 5
+
+int main() {
+  int n, pid;
+  
+  for (n = 0; n < NFORK; n++) {
+    pid = fork();
+    if (pid < 0)
+      break;
+    if (pid == 0) {
+      if (n < IO) {
+        pause(200); // IO-bound process
+      } else {
+        for (volatile int i = 0; i < 1000000000; i++) {} // CPU-bound process
+      }
+      // printf("\nProcess %d finished\n", n);
+      exit(0);
+    }
+  }
+  exit(0);
+}
diff -ruN xv6-riscv/user/loop.d xv62/user/loop.d
--- xv6-riscv/user/loop.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/loop.d	2025-09-14 12:32:52.396883003 +0000
@@ -0,0 +1,2 @@
+user/loop.o: user/loop.c kernel/types.h kernel/stat.h user/user.h \
+ kernel/fcntl.h
Binary files xv6-riscv/user/loop.o and xv62/user/loop.o differ
diff -ruN xv6-riscv/user/loop.sym xv62/user/loop.sym
--- xv6-riscv/user/loop.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/loop.sym	2025-09-14 12:32:52.424882998 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008d8 .rodata
+0000000000000900 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 loop.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003a4 putc
+00000000000003c2 printint
+00000000000008e8 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+0000000000000078 strcpy
+000000000000038c pause
+000000000000072c printf
+0000000000000384 sys_sbrk
+0000000000000222 memmove
+0000000000000344 mknod
+0000000000000130 gets
+000000000000037c getpid
+00000000000002b4 memcpy
+00000000000007e0 malloc
+00000000000002de sbrklazy
+000000000000030c pipe
+000000000000031c write
+0000000000000354 fstat
+0000000000000702 fprintf
+000000000000032c kill
+000000000000045e vprintf
+000000000000036c chdir
+0000000000000334 exec
+0000000000000304 wait
+0000000000000314 read
+000000000000034c unlink
+000000000000027a memcmp
+00000000000002f4 fork
+00000000000002c8 sbrk
+0000000000000394 uptime
+00000000000000ea memset
+0000000000000000 main
+0000000000000094 strcmp
+0000000000000374 dup
+000000000000039c getreadcount
+00000000000001a0 stat
+000000000000035c link
+00000000000002fc exit
+0000000000000068 start
+00000000000001da atoi
+00000000000000c0 strlen
+000000000000033c open
+000000000000010c strchr
+0000000000000364 mkdir
+0000000000000324 close
+000000000000075e free
diff -ruN xv6-riscv/user/ls.asm xv62/user/ls.asm
--- xv6-riscv/user/ls.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ls.asm	2025-09-14 12:32:51.064883276 +0000
@@ -0,0 +1,1755 @@
+
+user/_ls:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <fmtname>:
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+char*
+fmtname(char *path)
+{
+   0:	7179                	addi	sp,sp,-48
+   2:	f406                	sd	ra,40(sp)
+   4:	f022                	sd	s0,32(sp)
+   6:	ec26                	sd	s1,24(sp)
+   8:	1800                	addi	s0,sp,48
+   a:	84aa                	mv	s1,a0
+  static char buf[DIRSIZ+1];
+  char *p;
+
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+   c:	2b8000ef          	jal	2c4 <strlen>
+  10:	02051793          	slli	a5,a0,0x20
+  14:	9381                	srli	a5,a5,0x20
+  16:	97a6                	add	a5,a5,s1
+  18:	02f00693          	li	a3,47
+  1c:	0097e963          	bltu	a5,s1,2e <fmtname+0x2e>
+  20:	0007c703          	lbu	a4,0(a5)
+  24:	00d70563          	beq	a4,a3,2e <fmtname+0x2e>
+  28:	17fd                	addi	a5,a5,-1
+  2a:	fe97fbe3          	bgeu	a5,s1,20 <fmtname+0x20>
+    ;
+  p++;
+  2e:	00178493          	addi	s1,a5,1
+
+  // Return blank-padded name.
+  if(strlen(p) >= DIRSIZ)
+  32:	8526                	mv	a0,s1
+  34:	290000ef          	jal	2c4 <strlen>
+  38:	2501                	sext.w	a0,a0
+  3a:	47b5                	li	a5,13
+  3c:	00a7f863          	bgeu	a5,a0,4c <fmtname+0x4c>
+    return p;
+  memmove(buf, p, strlen(p));
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  buf[sizeof(buf)-1] = '\0';
+  return buf;
+}
+  40:	8526                	mv	a0,s1
+  42:	70a2                	ld	ra,40(sp)
+  44:	7402                	ld	s0,32(sp)
+  46:	64e2                	ld	s1,24(sp)
+  48:	6145                	addi	sp,sp,48
+  4a:	8082                	ret
+  4c:	e84a                	sd	s2,16(sp)
+  4e:	e44e                	sd	s3,8(sp)
+  memmove(buf, p, strlen(p));
+  50:	8526                	mv	a0,s1
+  52:	272000ef          	jal	2c4 <strlen>
+  56:	00002997          	auipc	s3,0x2
+  5a:	fba98993          	addi	s3,s3,-70 # 2010 <buf.0>
+  5e:	0005061b          	sext.w	a2,a0
+  62:	85a6                	mv	a1,s1
+  64:	854e                	mv	a0,s3
+  66:	3c0000ef          	jal	426 <memmove>
+  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
+  6a:	8526                	mv	a0,s1
+  6c:	258000ef          	jal	2c4 <strlen>
+  70:	0005091b          	sext.w	s2,a0
+  74:	8526                	mv	a0,s1
+  76:	24e000ef          	jal	2c4 <strlen>
+  7a:	1902                	slli	s2,s2,0x20
+  7c:	02095913          	srli	s2,s2,0x20
+  80:	4639                	li	a2,14
+  82:	9e09                	subw	a2,a2,a0
+  84:	02000593          	li	a1,32
+  88:	01298533          	add	a0,s3,s2
+  8c:	262000ef          	jal	2ee <memset>
+  buf[sizeof(buf)-1] = '\0';
+  90:	00098723          	sb	zero,14(s3)
+  return buf;
+  94:	84ce                	mv	s1,s3
+  96:	6942                	ld	s2,16(sp)
+  98:	69a2                	ld	s3,8(sp)
+  9a:	b75d                	j	40 <fmtname+0x40>
+
+000000000000009c <ls>:
+
+void
+ls(char *path)
+{
+  9c:	d9010113          	addi	sp,sp,-624
+  a0:	26113423          	sd	ra,616(sp)
+  a4:	26813023          	sd	s0,608(sp)
+  a8:	25213823          	sd	s2,592(sp)
+  ac:	1c80                	addi	s0,sp,624
+  ae:	892a                	mv	s2,a0
+  char buf[512], *p;
+  int fd;
+  struct dirent de;
+  struct stat st;
+
+  if((fd = open(path, O_RDONLY)) < 0){
+  b0:	4581                	li	a1,0
+  b2:	48e000ef          	jal	540 <open>
+  b6:	06054363          	bltz	a0,11c <ls+0x80>
+  ba:	24913c23          	sd	s1,600(sp)
+  be:	84aa                	mv	s1,a0
+    fprintf(2, "ls: cannot open %s\n", path);
+    return;
+  }
+
+  if(fstat(fd, &st) < 0){
+  c0:	d9840593          	addi	a1,s0,-616
+  c4:	494000ef          	jal	558 <fstat>
+  c8:	06054363          	bltz	a0,12e <ls+0x92>
+    fprintf(2, "ls: cannot stat %s\n", path);
+    close(fd);
+    return;
+  }
+
+  switch(st.type){
+  cc:	da041783          	lh	a5,-608(s0)
+  d0:	4705                	li	a4,1
+  d2:	06e78c63          	beq	a5,a4,14a <ls+0xae>
+  d6:	37f9                	addiw	a5,a5,-2
+  d8:	17c2                	slli	a5,a5,0x30
+  da:	93c1                	srli	a5,a5,0x30
+  dc:	02f76263          	bltu	a4,a5,100 <ls+0x64>
+  case T_DEVICE:
+  case T_FILE:
+    printf("%s %d %d %d\n", fmtname(path), st.type, st.ino, (int) st.size);
+  e0:	854a                	mv	a0,s2
+  e2:	f1fff0ef          	jal	0 <fmtname>
+  e6:	85aa                	mv	a1,a0
+  e8:	da842703          	lw	a4,-600(s0)
+  ec:	d9c42683          	lw	a3,-612(s0)
+  f0:	da041603          	lh	a2,-608(s0)
+  f4:	00001517          	auipc	a0,0x1
+  f8:	a1c50513          	addi	a0,a0,-1508 # b10 <malloc+0x12c>
+  fc:	035000ef          	jal	930 <printf>
+      }
+      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, (int) st.size);
+    }
+    break;
+  }
+  close(fd);
+ 100:	8526                	mv	a0,s1
+ 102:	426000ef          	jal	528 <close>
+ 106:	25813483          	ld	s1,600(sp)
+}
+ 10a:	26813083          	ld	ra,616(sp)
+ 10e:	26013403          	ld	s0,608(sp)
+ 112:	25013903          	ld	s2,592(sp)
+ 116:	27010113          	addi	sp,sp,624
+ 11a:	8082                	ret
+    fprintf(2, "ls: cannot open %s\n", path);
+ 11c:	864a                	mv	a2,s2
+ 11e:	00001597          	auipc	a1,0x1
+ 122:	9c258593          	addi	a1,a1,-1598 # ae0 <malloc+0xfc>
+ 126:	4509                	li	a0,2
+ 128:	7de000ef          	jal	906 <fprintf>
+    return;
+ 12c:	bff9                	j	10a <ls+0x6e>
+    fprintf(2, "ls: cannot stat %s\n", path);
+ 12e:	864a                	mv	a2,s2
+ 130:	00001597          	auipc	a1,0x1
+ 134:	9c858593          	addi	a1,a1,-1592 # af8 <malloc+0x114>
+ 138:	4509                	li	a0,2
+ 13a:	7cc000ef          	jal	906 <fprintf>
+    close(fd);
+ 13e:	8526                	mv	a0,s1
+ 140:	3e8000ef          	jal	528 <close>
+    return;
+ 144:	25813483          	ld	s1,600(sp)
+ 148:	b7c9                	j	10a <ls+0x6e>
+    if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+ 14a:	854a                	mv	a0,s2
+ 14c:	178000ef          	jal	2c4 <strlen>
+ 150:	2541                	addiw	a0,a0,16
+ 152:	20000793          	li	a5,512
+ 156:	00a7f963          	bgeu	a5,a0,168 <ls+0xcc>
+      printf("ls: path too long\n");
+ 15a:	00001517          	auipc	a0,0x1
+ 15e:	9c650513          	addi	a0,a0,-1594 # b20 <malloc+0x13c>
+ 162:	7ce000ef          	jal	930 <printf>
+      break;
+ 166:	bf69                	j	100 <ls+0x64>
+ 168:	25313423          	sd	s3,584(sp)
+ 16c:	25413023          	sd	s4,576(sp)
+ 170:	23513c23          	sd	s5,568(sp)
+    strcpy(buf, path);
+ 174:	85ca                	mv	a1,s2
+ 176:	dc040513          	addi	a0,s0,-576
+ 17a:	102000ef          	jal	27c <strcpy>
+    p = buf+strlen(buf);
+ 17e:	dc040513          	addi	a0,s0,-576
+ 182:	142000ef          	jal	2c4 <strlen>
+ 186:	1502                	slli	a0,a0,0x20
+ 188:	9101                	srli	a0,a0,0x20
+ 18a:	dc040793          	addi	a5,s0,-576
+ 18e:	00a78933          	add	s2,a5,a0
+    *p++ = '/';
+ 192:	00190993          	addi	s3,s2,1
+ 196:	02f00793          	li	a5,47
+ 19a:	00f90023          	sb	a5,0(s2)
+      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, (int) st.size);
+ 19e:	00001a17          	auipc	s4,0x1
+ 1a2:	972a0a13          	addi	s4,s4,-1678 # b10 <malloc+0x12c>
+        printf("ls: cannot stat %s\n", buf);
+ 1a6:	00001a97          	auipc	s5,0x1
+ 1aa:	952a8a93          	addi	s5,s5,-1710 # af8 <malloc+0x114>
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 1ae:	a031                	j	1ba <ls+0x11e>
+        printf("ls: cannot stat %s\n", buf);
+ 1b0:	dc040593          	addi	a1,s0,-576
+ 1b4:	8556                	mv	a0,s5
+ 1b6:	77a000ef          	jal	930 <printf>
+    while(read(fd, &de, sizeof(de)) == sizeof(de)){
+ 1ba:	4641                	li	a2,16
+ 1bc:	db040593          	addi	a1,s0,-592
+ 1c0:	8526                	mv	a0,s1
+ 1c2:	356000ef          	jal	518 <read>
+ 1c6:	47c1                	li	a5,16
+ 1c8:	04f51463          	bne	a0,a5,210 <ls+0x174>
+      if(de.inum == 0)
+ 1cc:	db045783          	lhu	a5,-592(s0)
+ 1d0:	d7ed                	beqz	a5,1ba <ls+0x11e>
+      memmove(p, de.name, DIRSIZ);
+ 1d2:	4639                	li	a2,14
+ 1d4:	db240593          	addi	a1,s0,-590
+ 1d8:	854e                	mv	a0,s3
+ 1da:	24c000ef          	jal	426 <memmove>
+      p[DIRSIZ] = 0;
+ 1de:	000907a3          	sb	zero,15(s2)
+      if(stat(buf, &st) < 0){
+ 1e2:	d9840593          	addi	a1,s0,-616
+ 1e6:	dc040513          	addi	a0,s0,-576
+ 1ea:	1ba000ef          	jal	3a4 <stat>
+ 1ee:	fc0541e3          	bltz	a0,1b0 <ls+0x114>
+      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, (int) st.size);
+ 1f2:	dc040513          	addi	a0,s0,-576
+ 1f6:	e0bff0ef          	jal	0 <fmtname>
+ 1fa:	85aa                	mv	a1,a0
+ 1fc:	da842703          	lw	a4,-600(s0)
+ 200:	d9c42683          	lw	a3,-612(s0)
+ 204:	da041603          	lh	a2,-608(s0)
+ 208:	8552                	mv	a0,s4
+ 20a:	726000ef          	jal	930 <printf>
+ 20e:	b775                	j	1ba <ls+0x11e>
+ 210:	24813983          	ld	s3,584(sp)
+ 214:	24013a03          	ld	s4,576(sp)
+ 218:	23813a83          	ld	s5,568(sp)
+ 21c:	b5d5                	j	100 <ls+0x64>
+
+000000000000021e <main>:
+
+int
+main(int argc, char *argv[])
+{
+ 21e:	1101                	addi	sp,sp,-32
+ 220:	ec06                	sd	ra,24(sp)
+ 222:	e822                	sd	s0,16(sp)
+ 224:	1000                	addi	s0,sp,32
+  int i;
+
+  if(argc < 2){
+ 226:	4785                	li	a5,1
+ 228:	02a7d763          	bge	a5,a0,256 <main+0x38>
+ 22c:	e426                	sd	s1,8(sp)
+ 22e:	e04a                	sd	s2,0(sp)
+ 230:	00858493          	addi	s1,a1,8
+ 234:	ffe5091b          	addiw	s2,a0,-2
+ 238:	02091793          	slli	a5,s2,0x20
+ 23c:	01d7d913          	srli	s2,a5,0x1d
+ 240:	05c1                	addi	a1,a1,16
+ 242:	992e                	add	s2,s2,a1
+    ls(".");
+    exit(0);
+  }
+  for(i=1; i<argc; i++)
+    ls(argv[i]);
+ 244:	6088                	ld	a0,0(s1)
+ 246:	e57ff0ef          	jal	9c <ls>
+  for(i=1; i<argc; i++)
+ 24a:	04a1                	addi	s1,s1,8
+ 24c:	ff249ce3          	bne	s1,s2,244 <main+0x26>
+  exit(0);
+ 250:	4501                	li	a0,0
+ 252:	2ae000ef          	jal	500 <exit>
+ 256:	e426                	sd	s1,8(sp)
+ 258:	e04a                	sd	s2,0(sp)
+    ls(".");
+ 25a:	00001517          	auipc	a0,0x1
+ 25e:	8de50513          	addi	a0,a0,-1826 # b38 <malloc+0x154>
+ 262:	e3bff0ef          	jal	9c <ls>
+    exit(0);
+ 266:	4501                	li	a0,0
+ 268:	298000ef          	jal	500 <exit>
+
+000000000000026c <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+ 26c:	1141                	addi	sp,sp,-16
+ 26e:	e406                	sd	ra,8(sp)
+ 270:	e022                	sd	s0,0(sp)
+ 272:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+ 274:	fabff0ef          	jal	21e <main>
+  exit(r);
+ 278:	288000ef          	jal	500 <exit>
+
+000000000000027c <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+ 27c:	1141                	addi	sp,sp,-16
+ 27e:	e422                	sd	s0,8(sp)
+ 280:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 282:	87aa                	mv	a5,a0
+ 284:	0585                	addi	a1,a1,1
+ 286:	0785                	addi	a5,a5,1
+ 288:	fff5c703          	lbu	a4,-1(a1)
+ 28c:	fee78fa3          	sb	a4,-1(a5)
+ 290:	fb75                	bnez	a4,284 <strcpy+0x8>
+    ;
+  return os;
+}
+ 292:	6422                	ld	s0,8(sp)
+ 294:	0141                	addi	sp,sp,16
+ 296:	8082                	ret
+
+0000000000000298 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 298:	1141                	addi	sp,sp,-16
+ 29a:	e422                	sd	s0,8(sp)
+ 29c:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 29e:	00054783          	lbu	a5,0(a0)
+ 2a2:	cb91                	beqz	a5,2b6 <strcmp+0x1e>
+ 2a4:	0005c703          	lbu	a4,0(a1)
+ 2a8:	00f71763          	bne	a4,a5,2b6 <strcmp+0x1e>
+    p++, q++;
+ 2ac:	0505                	addi	a0,a0,1
+ 2ae:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 2b0:	00054783          	lbu	a5,0(a0)
+ 2b4:	fbe5                	bnez	a5,2a4 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 2b6:	0005c503          	lbu	a0,0(a1)
+}
+ 2ba:	40a7853b          	subw	a0,a5,a0
+ 2be:	6422                	ld	s0,8(sp)
+ 2c0:	0141                	addi	sp,sp,16
+ 2c2:	8082                	ret
+
+00000000000002c4 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 2c4:	1141                	addi	sp,sp,-16
+ 2c6:	e422                	sd	s0,8(sp)
+ 2c8:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 2ca:	00054783          	lbu	a5,0(a0)
+ 2ce:	cf91                	beqz	a5,2ea <strlen+0x26>
+ 2d0:	0505                	addi	a0,a0,1
+ 2d2:	87aa                	mv	a5,a0
+ 2d4:	86be                	mv	a3,a5
+ 2d6:	0785                	addi	a5,a5,1
+ 2d8:	fff7c703          	lbu	a4,-1(a5)
+ 2dc:	ff65                	bnez	a4,2d4 <strlen+0x10>
+ 2de:	40a6853b          	subw	a0,a3,a0
+ 2e2:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 2e4:	6422                	ld	s0,8(sp)
+ 2e6:	0141                	addi	sp,sp,16
+ 2e8:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 2ea:	4501                	li	a0,0
+ 2ec:	bfe5                	j	2e4 <strlen+0x20>
+
+00000000000002ee <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 2ee:	1141                	addi	sp,sp,-16
+ 2f0:	e422                	sd	s0,8(sp)
+ 2f2:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 2f4:	ca19                	beqz	a2,30a <memset+0x1c>
+ 2f6:	87aa                	mv	a5,a0
+ 2f8:	1602                	slli	a2,a2,0x20
+ 2fa:	9201                	srli	a2,a2,0x20
+ 2fc:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 300:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 304:	0785                	addi	a5,a5,1
+ 306:	fee79de3          	bne	a5,a4,300 <memset+0x12>
+  }
+  return dst;
+}
+ 30a:	6422                	ld	s0,8(sp)
+ 30c:	0141                	addi	sp,sp,16
+ 30e:	8082                	ret
+
+0000000000000310 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 310:	1141                	addi	sp,sp,-16
+ 312:	e422                	sd	s0,8(sp)
+ 314:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 316:	00054783          	lbu	a5,0(a0)
+ 31a:	cb99                	beqz	a5,330 <strchr+0x20>
+    if(*s == c)
+ 31c:	00f58763          	beq	a1,a5,32a <strchr+0x1a>
+  for(; *s; s++)
+ 320:	0505                	addi	a0,a0,1
+ 322:	00054783          	lbu	a5,0(a0)
+ 326:	fbfd                	bnez	a5,31c <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 328:	4501                	li	a0,0
+}
+ 32a:	6422                	ld	s0,8(sp)
+ 32c:	0141                	addi	sp,sp,16
+ 32e:	8082                	ret
+  return 0;
+ 330:	4501                	li	a0,0
+ 332:	bfe5                	j	32a <strchr+0x1a>
+
+0000000000000334 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 334:	711d                	addi	sp,sp,-96
+ 336:	ec86                	sd	ra,88(sp)
+ 338:	e8a2                	sd	s0,80(sp)
+ 33a:	e4a6                	sd	s1,72(sp)
+ 33c:	e0ca                	sd	s2,64(sp)
+ 33e:	fc4e                	sd	s3,56(sp)
+ 340:	f852                	sd	s4,48(sp)
+ 342:	f456                	sd	s5,40(sp)
+ 344:	f05a                	sd	s6,32(sp)
+ 346:	ec5e                	sd	s7,24(sp)
+ 348:	1080                	addi	s0,sp,96
+ 34a:	8baa                	mv	s7,a0
+ 34c:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 34e:	892a                	mv	s2,a0
+ 350:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 352:	4aa9                	li	s5,10
+ 354:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 356:	89a6                	mv	s3,s1
+ 358:	2485                	addiw	s1,s1,1
+ 35a:	0344d663          	bge	s1,s4,386 <gets+0x52>
+    cc = read(0, &c, 1);
+ 35e:	4605                	li	a2,1
+ 360:	faf40593          	addi	a1,s0,-81
+ 364:	4501                	li	a0,0
+ 366:	1b2000ef          	jal	518 <read>
+    if(cc < 1)
+ 36a:	00a05e63          	blez	a0,386 <gets+0x52>
+    buf[i++] = c;
+ 36e:	faf44783          	lbu	a5,-81(s0)
+ 372:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 376:	01578763          	beq	a5,s5,384 <gets+0x50>
+ 37a:	0905                	addi	s2,s2,1
+ 37c:	fd679de3          	bne	a5,s6,356 <gets+0x22>
+    buf[i++] = c;
+ 380:	89a6                	mv	s3,s1
+ 382:	a011                	j	386 <gets+0x52>
+ 384:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 386:	99de                	add	s3,s3,s7
+ 388:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 38c:	855e                	mv	a0,s7
+ 38e:	60e6                	ld	ra,88(sp)
+ 390:	6446                	ld	s0,80(sp)
+ 392:	64a6                	ld	s1,72(sp)
+ 394:	6906                	ld	s2,64(sp)
+ 396:	79e2                	ld	s3,56(sp)
+ 398:	7a42                	ld	s4,48(sp)
+ 39a:	7aa2                	ld	s5,40(sp)
+ 39c:	7b02                	ld	s6,32(sp)
+ 39e:	6be2                	ld	s7,24(sp)
+ 3a0:	6125                	addi	sp,sp,96
+ 3a2:	8082                	ret
+
+00000000000003a4 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 3a4:	1101                	addi	sp,sp,-32
+ 3a6:	ec06                	sd	ra,24(sp)
+ 3a8:	e822                	sd	s0,16(sp)
+ 3aa:	e04a                	sd	s2,0(sp)
+ 3ac:	1000                	addi	s0,sp,32
+ 3ae:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 3b0:	4581                	li	a1,0
+ 3b2:	18e000ef          	jal	540 <open>
+  if(fd < 0)
+ 3b6:	02054263          	bltz	a0,3da <stat+0x36>
+ 3ba:	e426                	sd	s1,8(sp)
+ 3bc:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 3be:	85ca                	mv	a1,s2
+ 3c0:	198000ef          	jal	558 <fstat>
+ 3c4:	892a                	mv	s2,a0
+  close(fd);
+ 3c6:	8526                	mv	a0,s1
+ 3c8:	160000ef          	jal	528 <close>
+  return r;
+ 3cc:	64a2                	ld	s1,8(sp)
+}
+ 3ce:	854a                	mv	a0,s2
+ 3d0:	60e2                	ld	ra,24(sp)
+ 3d2:	6442                	ld	s0,16(sp)
+ 3d4:	6902                	ld	s2,0(sp)
+ 3d6:	6105                	addi	sp,sp,32
+ 3d8:	8082                	ret
+    return -1;
+ 3da:	597d                	li	s2,-1
+ 3dc:	bfcd                	j	3ce <stat+0x2a>
+
+00000000000003de <atoi>:
+
+int
+atoi(const char *s)
+{
+ 3de:	1141                	addi	sp,sp,-16
+ 3e0:	e422                	sd	s0,8(sp)
+ 3e2:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 3e4:	00054683          	lbu	a3,0(a0)
+ 3e8:	fd06879b          	addiw	a5,a3,-48
+ 3ec:	0ff7f793          	zext.b	a5,a5
+ 3f0:	4625                	li	a2,9
+ 3f2:	02f66863          	bltu	a2,a5,422 <atoi+0x44>
+ 3f6:	872a                	mv	a4,a0
+  n = 0;
+ 3f8:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 3fa:	0705                	addi	a4,a4,1
+ 3fc:	0025179b          	slliw	a5,a0,0x2
+ 400:	9fa9                	addw	a5,a5,a0
+ 402:	0017979b          	slliw	a5,a5,0x1
+ 406:	9fb5                	addw	a5,a5,a3
+ 408:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 40c:	00074683          	lbu	a3,0(a4)
+ 410:	fd06879b          	addiw	a5,a3,-48
+ 414:	0ff7f793          	zext.b	a5,a5
+ 418:	fef671e3          	bgeu	a2,a5,3fa <atoi+0x1c>
+  return n;
+}
+ 41c:	6422                	ld	s0,8(sp)
+ 41e:	0141                	addi	sp,sp,16
+ 420:	8082                	ret
+  n = 0;
+ 422:	4501                	li	a0,0
+ 424:	bfe5                	j	41c <atoi+0x3e>
+
+0000000000000426 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 426:	1141                	addi	sp,sp,-16
+ 428:	e422                	sd	s0,8(sp)
+ 42a:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 42c:	02b57463          	bgeu	a0,a1,454 <memmove+0x2e>
+    while(n-- > 0)
+ 430:	00c05f63          	blez	a2,44e <memmove+0x28>
+ 434:	1602                	slli	a2,a2,0x20
+ 436:	9201                	srli	a2,a2,0x20
+ 438:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 43c:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 43e:	0585                	addi	a1,a1,1
+ 440:	0705                	addi	a4,a4,1
+ 442:	fff5c683          	lbu	a3,-1(a1)
+ 446:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 44a:	fef71ae3          	bne	a4,a5,43e <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 44e:	6422                	ld	s0,8(sp)
+ 450:	0141                	addi	sp,sp,16
+ 452:	8082                	ret
+    dst += n;
+ 454:	00c50733          	add	a4,a0,a2
+    src += n;
+ 458:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 45a:	fec05ae3          	blez	a2,44e <memmove+0x28>
+ 45e:	fff6079b          	addiw	a5,a2,-1
+ 462:	1782                	slli	a5,a5,0x20
+ 464:	9381                	srli	a5,a5,0x20
+ 466:	fff7c793          	not	a5,a5
+ 46a:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 46c:	15fd                	addi	a1,a1,-1
+ 46e:	177d                	addi	a4,a4,-1
+ 470:	0005c683          	lbu	a3,0(a1)
+ 474:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 478:	fee79ae3          	bne	a5,a4,46c <memmove+0x46>
+ 47c:	bfc9                	j	44e <memmove+0x28>
+
+000000000000047e <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 47e:	1141                	addi	sp,sp,-16
+ 480:	e422                	sd	s0,8(sp)
+ 482:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 484:	ca05                	beqz	a2,4b4 <memcmp+0x36>
+ 486:	fff6069b          	addiw	a3,a2,-1
+ 48a:	1682                	slli	a3,a3,0x20
+ 48c:	9281                	srli	a3,a3,0x20
+ 48e:	0685                	addi	a3,a3,1
+ 490:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 492:	00054783          	lbu	a5,0(a0)
+ 496:	0005c703          	lbu	a4,0(a1)
+ 49a:	00e79863          	bne	a5,a4,4aa <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 49e:	0505                	addi	a0,a0,1
+    p2++;
+ 4a0:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 4a2:	fed518e3          	bne	a0,a3,492 <memcmp+0x14>
+  }
+  return 0;
+ 4a6:	4501                	li	a0,0
+ 4a8:	a019                	j	4ae <memcmp+0x30>
+      return *p1 - *p2;
+ 4aa:	40e7853b          	subw	a0,a5,a4
+}
+ 4ae:	6422                	ld	s0,8(sp)
+ 4b0:	0141                	addi	sp,sp,16
+ 4b2:	8082                	ret
+  return 0;
+ 4b4:	4501                	li	a0,0
+ 4b6:	bfe5                	j	4ae <memcmp+0x30>
+
+00000000000004b8 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 4b8:	1141                	addi	sp,sp,-16
+ 4ba:	e406                	sd	ra,8(sp)
+ 4bc:	e022                	sd	s0,0(sp)
+ 4be:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 4c0:	f67ff0ef          	jal	426 <memmove>
+}
+ 4c4:	60a2                	ld	ra,8(sp)
+ 4c6:	6402                	ld	s0,0(sp)
+ 4c8:	0141                	addi	sp,sp,16
+ 4ca:	8082                	ret
+
+00000000000004cc <sbrk>:
+
+char *
+sbrk(int n) {
+ 4cc:	1141                	addi	sp,sp,-16
+ 4ce:	e406                	sd	ra,8(sp)
+ 4d0:	e022                	sd	s0,0(sp)
+ 4d2:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 4d4:	4585                	li	a1,1
+ 4d6:	0b2000ef          	jal	588 <sys_sbrk>
+}
+ 4da:	60a2                	ld	ra,8(sp)
+ 4dc:	6402                	ld	s0,0(sp)
+ 4de:	0141                	addi	sp,sp,16
+ 4e0:	8082                	ret
+
+00000000000004e2 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 4e2:	1141                	addi	sp,sp,-16
+ 4e4:	e406                	sd	ra,8(sp)
+ 4e6:	e022                	sd	s0,0(sp)
+ 4e8:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 4ea:	4589                	li	a1,2
+ 4ec:	09c000ef          	jal	588 <sys_sbrk>
+}
+ 4f0:	60a2                	ld	ra,8(sp)
+ 4f2:	6402                	ld	s0,0(sp)
+ 4f4:	0141                	addi	sp,sp,16
+ 4f6:	8082                	ret
+
+00000000000004f8 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 4f8:	4885                	li	a7,1
+ ecall
+ 4fa:	00000073          	ecall
+ ret
+ 4fe:	8082                	ret
+
+0000000000000500 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 500:	4889                	li	a7,2
+ ecall
+ 502:	00000073          	ecall
+ ret
+ 506:	8082                	ret
+
+0000000000000508 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 508:	488d                	li	a7,3
+ ecall
+ 50a:	00000073          	ecall
+ ret
+ 50e:	8082                	ret
+
+0000000000000510 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 510:	4891                	li	a7,4
+ ecall
+ 512:	00000073          	ecall
+ ret
+ 516:	8082                	ret
+
+0000000000000518 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 518:	4895                	li	a7,5
+ ecall
+ 51a:	00000073          	ecall
+ ret
+ 51e:	8082                	ret
+
+0000000000000520 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 520:	48c1                	li	a7,16
+ ecall
+ 522:	00000073          	ecall
+ ret
+ 526:	8082                	ret
+
+0000000000000528 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 528:	48d5                	li	a7,21
+ ecall
+ 52a:	00000073          	ecall
+ ret
+ 52e:	8082                	ret
+
+0000000000000530 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 530:	4899                	li	a7,6
+ ecall
+ 532:	00000073          	ecall
+ ret
+ 536:	8082                	ret
+
+0000000000000538 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 538:	489d                	li	a7,7
+ ecall
+ 53a:	00000073          	ecall
+ ret
+ 53e:	8082                	ret
+
+0000000000000540 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 540:	48bd                	li	a7,15
+ ecall
+ 542:	00000073          	ecall
+ ret
+ 546:	8082                	ret
+
+0000000000000548 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 548:	48c5                	li	a7,17
+ ecall
+ 54a:	00000073          	ecall
+ ret
+ 54e:	8082                	ret
+
+0000000000000550 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 550:	48c9                	li	a7,18
+ ecall
+ 552:	00000073          	ecall
+ ret
+ 556:	8082                	ret
+
+0000000000000558 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 558:	48a1                	li	a7,8
+ ecall
+ 55a:	00000073          	ecall
+ ret
+ 55e:	8082                	ret
+
+0000000000000560 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 560:	48cd                	li	a7,19
+ ecall
+ 562:	00000073          	ecall
+ ret
+ 566:	8082                	ret
+
+0000000000000568 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 568:	48d1                	li	a7,20
+ ecall
+ 56a:	00000073          	ecall
+ ret
+ 56e:	8082                	ret
+
+0000000000000570 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 570:	48a5                	li	a7,9
+ ecall
+ 572:	00000073          	ecall
+ ret
+ 576:	8082                	ret
+
+0000000000000578 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 578:	48a9                	li	a7,10
+ ecall
+ 57a:	00000073          	ecall
+ ret
+ 57e:	8082                	ret
+
+0000000000000580 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 580:	48ad                	li	a7,11
+ ecall
+ 582:	00000073          	ecall
+ ret
+ 586:	8082                	ret
+
+0000000000000588 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 588:	48b1                	li	a7,12
+ ecall
+ 58a:	00000073          	ecall
+ ret
+ 58e:	8082                	ret
+
+0000000000000590 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 590:	48b5                	li	a7,13
+ ecall
+ 592:	00000073          	ecall
+ ret
+ 596:	8082                	ret
+
+0000000000000598 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 598:	48b9                	li	a7,14
+ ecall
+ 59a:	00000073          	ecall
+ ret
+ 59e:	8082                	ret
+
+00000000000005a0 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 5a0:	48d9                	li	a7,22
+ ecall
+ 5a2:	00000073          	ecall
+ ret
+ 5a6:	8082                	ret
+
+00000000000005a8 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 5a8:	1101                	addi	sp,sp,-32
+ 5aa:	ec06                	sd	ra,24(sp)
+ 5ac:	e822                	sd	s0,16(sp)
+ 5ae:	1000                	addi	s0,sp,32
+ 5b0:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 5b4:	4605                	li	a2,1
+ 5b6:	fef40593          	addi	a1,s0,-17
+ 5ba:	f67ff0ef          	jal	520 <write>
+}
+ 5be:	60e2                	ld	ra,24(sp)
+ 5c0:	6442                	ld	s0,16(sp)
+ 5c2:	6105                	addi	sp,sp,32
+ 5c4:	8082                	ret
+
+00000000000005c6 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 5c6:	715d                	addi	sp,sp,-80
+ 5c8:	e486                	sd	ra,72(sp)
+ 5ca:	e0a2                	sd	s0,64(sp)
+ 5cc:	f84a                	sd	s2,48(sp)
+ 5ce:	0880                	addi	s0,sp,80
+ 5d0:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 5d2:	c299                	beqz	a3,5d8 <printint+0x12>
+ 5d4:	0805c363          	bltz	a1,65a <printint+0x94>
+  neg = 0;
+ 5d8:	4881                	li	a7,0
+ 5da:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 5de:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 5e0:	00000517          	auipc	a0,0x0
+ 5e4:	56850513          	addi	a0,a0,1384 # b48 <digits>
+ 5e8:	883e                	mv	a6,a5
+ 5ea:	2785                	addiw	a5,a5,1
+ 5ec:	02c5f733          	remu	a4,a1,a2
+ 5f0:	972a                	add	a4,a4,a0
+ 5f2:	00074703          	lbu	a4,0(a4)
+ 5f6:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 5fa:	872e                	mv	a4,a1
+ 5fc:	02c5d5b3          	divu	a1,a1,a2
+ 600:	0685                	addi	a3,a3,1
+ 602:	fec773e3          	bgeu	a4,a2,5e8 <printint+0x22>
+  if(neg)
+ 606:	00088b63          	beqz	a7,61c <printint+0x56>
+    buf[i++] = '-';
+ 60a:	fd078793          	addi	a5,a5,-48
+ 60e:	97a2                	add	a5,a5,s0
+ 610:	02d00713          	li	a4,45
+ 614:	fee78423          	sb	a4,-24(a5)
+ 618:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 61c:	02f05a63          	blez	a5,650 <printint+0x8a>
+ 620:	fc26                	sd	s1,56(sp)
+ 622:	f44e                	sd	s3,40(sp)
+ 624:	fb840713          	addi	a4,s0,-72
+ 628:	00f704b3          	add	s1,a4,a5
+ 62c:	fff70993          	addi	s3,a4,-1
+ 630:	99be                	add	s3,s3,a5
+ 632:	37fd                	addiw	a5,a5,-1
+ 634:	1782                	slli	a5,a5,0x20
+ 636:	9381                	srli	a5,a5,0x20
+ 638:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 63c:	fff4c583          	lbu	a1,-1(s1)
+ 640:	854a                	mv	a0,s2
+ 642:	f67ff0ef          	jal	5a8 <putc>
+  while(--i >= 0)
+ 646:	14fd                	addi	s1,s1,-1
+ 648:	ff349ae3          	bne	s1,s3,63c <printint+0x76>
+ 64c:	74e2                	ld	s1,56(sp)
+ 64e:	79a2                	ld	s3,40(sp)
+}
+ 650:	60a6                	ld	ra,72(sp)
+ 652:	6406                	ld	s0,64(sp)
+ 654:	7942                	ld	s2,48(sp)
+ 656:	6161                	addi	sp,sp,80
+ 658:	8082                	ret
+    x = -xx;
+ 65a:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 65e:	4885                	li	a7,1
+    x = -xx;
+ 660:	bfad                	j	5da <printint+0x14>
+
+0000000000000662 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 662:	711d                	addi	sp,sp,-96
+ 664:	ec86                	sd	ra,88(sp)
+ 666:	e8a2                	sd	s0,80(sp)
+ 668:	e0ca                	sd	s2,64(sp)
+ 66a:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 66c:	0005c903          	lbu	s2,0(a1)
+ 670:	28090663          	beqz	s2,8fc <vprintf+0x29a>
+ 674:	e4a6                	sd	s1,72(sp)
+ 676:	fc4e                	sd	s3,56(sp)
+ 678:	f852                	sd	s4,48(sp)
+ 67a:	f456                	sd	s5,40(sp)
+ 67c:	f05a                	sd	s6,32(sp)
+ 67e:	ec5e                	sd	s7,24(sp)
+ 680:	e862                	sd	s8,16(sp)
+ 682:	e466                	sd	s9,8(sp)
+ 684:	8b2a                	mv	s6,a0
+ 686:	8a2e                	mv	s4,a1
+ 688:	8bb2                	mv	s7,a2
+  state = 0;
+ 68a:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 68c:	4481                	li	s1,0
+ 68e:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 690:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 694:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 698:	06c00c93          	li	s9,108
+ 69c:	a005                	j	6bc <vprintf+0x5a>
+        putc(fd, c0);
+ 69e:	85ca                	mv	a1,s2
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	f07ff0ef          	jal	5a8 <putc>
+ 6a6:	a019                	j	6ac <vprintf+0x4a>
+    } else if(state == '%'){
+ 6a8:	03598263          	beq	s3,s5,6cc <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 6ac:	2485                	addiw	s1,s1,1
+ 6ae:	8726                	mv	a4,s1
+ 6b0:	009a07b3          	add	a5,s4,s1
+ 6b4:	0007c903          	lbu	s2,0(a5)
+ 6b8:	22090a63          	beqz	s2,8ec <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 6bc:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 6c0:	fe0994e3          	bnez	s3,6a8 <vprintf+0x46>
+      if(c0 == '%'){
+ 6c4:	fd579de3          	bne	a5,s5,69e <vprintf+0x3c>
+        state = '%';
+ 6c8:	89be                	mv	s3,a5
+ 6ca:	b7cd                	j	6ac <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 6cc:	00ea06b3          	add	a3,s4,a4
+ 6d0:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 6d4:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 6d6:	c681                	beqz	a3,6de <vprintf+0x7c>
+ 6d8:	9752                	add	a4,a4,s4
+ 6da:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 6de:	05878363          	beq	a5,s8,724 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 6e2:	05978d63          	beq	a5,s9,73c <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 6e6:	07500713          	li	a4,117
+ 6ea:	0ee78763          	beq	a5,a4,7d8 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 6ee:	07800713          	li	a4,120
+ 6f2:	12e78963          	beq	a5,a4,824 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 6f6:	07000713          	li	a4,112
+ 6fa:	14e78e63          	beq	a5,a4,856 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 6fe:	06300713          	li	a4,99
+ 702:	18e78e63          	beq	a5,a4,89e <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 706:	07300713          	li	a4,115
+ 70a:	1ae78463          	beq	a5,a4,8b2 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 70e:	02500713          	li	a4,37
+ 712:	04e79563          	bne	a5,a4,75c <vprintf+0xfa>
+        putc(fd, '%');
+ 716:	02500593          	li	a1,37
+ 71a:	855a                	mv	a0,s6
+ 71c:	e8dff0ef          	jal	5a8 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 720:	4981                	li	s3,0
+ 722:	b769                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 724:	008b8913          	addi	s2,s7,8
+ 728:	4685                	li	a3,1
+ 72a:	4629                	li	a2,10
+ 72c:	000ba583          	lw	a1,0(s7)
+ 730:	855a                	mv	a0,s6
+ 732:	e95ff0ef          	jal	5c6 <printint>
+ 736:	8bca                	mv	s7,s2
+      state = 0;
+ 738:	4981                	li	s3,0
+ 73a:	bf8d                	j	6ac <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 73c:	06400793          	li	a5,100
+ 740:	02f68963          	beq	a3,a5,772 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 744:	06c00793          	li	a5,108
+ 748:	04f68263          	beq	a3,a5,78c <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 74c:	07500793          	li	a5,117
+ 750:	0af68063          	beq	a3,a5,7f0 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 754:	07800793          	li	a5,120
+ 758:	0ef68263          	beq	a3,a5,83c <vprintf+0x1da>
+        putc(fd, '%');
+ 75c:	02500593          	li	a1,37
+ 760:	855a                	mv	a0,s6
+ 762:	e47ff0ef          	jal	5a8 <putc>
+        putc(fd, c0);
+ 766:	85ca                	mv	a1,s2
+ 768:	855a                	mv	a0,s6
+ 76a:	e3fff0ef          	jal	5a8 <putc>
+      state = 0;
+ 76e:	4981                	li	s3,0
+ 770:	bf35                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 772:	008b8913          	addi	s2,s7,8
+ 776:	4685                	li	a3,1
+ 778:	4629                	li	a2,10
+ 77a:	000bb583          	ld	a1,0(s7)
+ 77e:	855a                	mv	a0,s6
+ 780:	e47ff0ef          	jal	5c6 <printint>
+        i += 1;
+ 784:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 786:	8bca                	mv	s7,s2
+      state = 0;
+ 788:	4981                	li	s3,0
+        i += 1;
+ 78a:	b70d                	j	6ac <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 78c:	06400793          	li	a5,100
+ 790:	02f60763          	beq	a2,a5,7be <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 794:	07500793          	li	a5,117
+ 798:	06f60963          	beq	a2,a5,80a <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 79c:	07800793          	li	a5,120
+ 7a0:	faf61ee3          	bne	a2,a5,75c <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 7a4:	008b8913          	addi	s2,s7,8
+ 7a8:	4681                	li	a3,0
+ 7aa:	4641                	li	a2,16
+ 7ac:	000bb583          	ld	a1,0(s7)
+ 7b0:	855a                	mv	a0,s6
+ 7b2:	e15ff0ef          	jal	5c6 <printint>
+        i += 2;
+ 7b6:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 7b8:	8bca                	mv	s7,s2
+      state = 0;
+ 7ba:	4981                	li	s3,0
+        i += 2;
+ 7bc:	bdc5                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 7be:	008b8913          	addi	s2,s7,8
+ 7c2:	4685                	li	a3,1
+ 7c4:	4629                	li	a2,10
+ 7c6:	000bb583          	ld	a1,0(s7)
+ 7ca:	855a                	mv	a0,s6
+ 7cc:	dfbff0ef          	jal	5c6 <printint>
+        i += 2;
+ 7d0:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 7d2:	8bca                	mv	s7,s2
+      state = 0;
+ 7d4:	4981                	li	s3,0
+        i += 2;
+ 7d6:	bdd9                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 7d8:	008b8913          	addi	s2,s7,8
+ 7dc:	4681                	li	a3,0
+ 7de:	4629                	li	a2,10
+ 7e0:	000be583          	lwu	a1,0(s7)
+ 7e4:	855a                	mv	a0,s6
+ 7e6:	de1ff0ef          	jal	5c6 <printint>
+ 7ea:	8bca                	mv	s7,s2
+      state = 0;
+ 7ec:	4981                	li	s3,0
+ 7ee:	bd7d                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 7f0:	008b8913          	addi	s2,s7,8
+ 7f4:	4681                	li	a3,0
+ 7f6:	4629                	li	a2,10
+ 7f8:	000bb583          	ld	a1,0(s7)
+ 7fc:	855a                	mv	a0,s6
+ 7fe:	dc9ff0ef          	jal	5c6 <printint>
+        i += 1;
+ 802:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 804:	8bca                	mv	s7,s2
+      state = 0;
+ 806:	4981                	li	s3,0
+        i += 1;
+ 808:	b555                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 80a:	008b8913          	addi	s2,s7,8
+ 80e:	4681                	li	a3,0
+ 810:	4629                	li	a2,10
+ 812:	000bb583          	ld	a1,0(s7)
+ 816:	855a                	mv	a0,s6
+ 818:	dafff0ef          	jal	5c6 <printint>
+        i += 2;
+ 81c:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 81e:	8bca                	mv	s7,s2
+      state = 0;
+ 820:	4981                	li	s3,0
+        i += 2;
+ 822:	b569                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 824:	008b8913          	addi	s2,s7,8
+ 828:	4681                	li	a3,0
+ 82a:	4641                	li	a2,16
+ 82c:	000be583          	lwu	a1,0(s7)
+ 830:	855a                	mv	a0,s6
+ 832:	d95ff0ef          	jal	5c6 <printint>
+ 836:	8bca                	mv	s7,s2
+      state = 0;
+ 838:	4981                	li	s3,0
+ 83a:	bd8d                	j	6ac <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 83c:	008b8913          	addi	s2,s7,8
+ 840:	4681                	li	a3,0
+ 842:	4641                	li	a2,16
+ 844:	000bb583          	ld	a1,0(s7)
+ 848:	855a                	mv	a0,s6
+ 84a:	d7dff0ef          	jal	5c6 <printint>
+        i += 1;
+ 84e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 850:	8bca                	mv	s7,s2
+      state = 0;
+ 852:	4981                	li	s3,0
+        i += 1;
+ 854:	bda1                	j	6ac <vprintf+0x4a>
+ 856:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 858:	008b8d13          	addi	s10,s7,8
+ 85c:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 860:	03000593          	li	a1,48
+ 864:	855a                	mv	a0,s6
+ 866:	d43ff0ef          	jal	5a8 <putc>
+  putc(fd, 'x');
+ 86a:	07800593          	li	a1,120
+ 86e:	855a                	mv	a0,s6
+ 870:	d39ff0ef          	jal	5a8 <putc>
+ 874:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 876:	00000b97          	auipc	s7,0x0
+ 87a:	2d2b8b93          	addi	s7,s7,722 # b48 <digits>
+ 87e:	03c9d793          	srli	a5,s3,0x3c
+ 882:	97de                	add	a5,a5,s7
+ 884:	0007c583          	lbu	a1,0(a5)
+ 888:	855a                	mv	a0,s6
+ 88a:	d1fff0ef          	jal	5a8 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 88e:	0992                	slli	s3,s3,0x4
+ 890:	397d                	addiw	s2,s2,-1
+ 892:	fe0916e3          	bnez	s2,87e <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 896:	8bea                	mv	s7,s10
+      state = 0;
+ 898:	4981                	li	s3,0
+ 89a:	6d02                	ld	s10,0(sp)
+ 89c:	bd01                	j	6ac <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 89e:	008b8913          	addi	s2,s7,8
+ 8a2:	000bc583          	lbu	a1,0(s7)
+ 8a6:	855a                	mv	a0,s6
+ 8a8:	d01ff0ef          	jal	5a8 <putc>
+ 8ac:	8bca                	mv	s7,s2
+      state = 0;
+ 8ae:	4981                	li	s3,0
+ 8b0:	bbf5                	j	6ac <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 8b2:	008b8993          	addi	s3,s7,8
+ 8b6:	000bb903          	ld	s2,0(s7)
+ 8ba:	00090f63          	beqz	s2,8d8 <vprintf+0x276>
+        for(; *s; s++)
+ 8be:	00094583          	lbu	a1,0(s2)
+ 8c2:	c195                	beqz	a1,8e6 <vprintf+0x284>
+          putc(fd, *s);
+ 8c4:	855a                	mv	a0,s6
+ 8c6:	ce3ff0ef          	jal	5a8 <putc>
+        for(; *s; s++)
+ 8ca:	0905                	addi	s2,s2,1
+ 8cc:	00094583          	lbu	a1,0(s2)
+ 8d0:	f9f5                	bnez	a1,8c4 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 8d2:	8bce                	mv	s7,s3
+      state = 0;
+ 8d4:	4981                	li	s3,0
+ 8d6:	bbd9                	j	6ac <vprintf+0x4a>
+          s = "(null)";
+ 8d8:	00000917          	auipc	s2,0x0
+ 8dc:	26890913          	addi	s2,s2,616 # b40 <malloc+0x15c>
+        for(; *s; s++)
+ 8e0:	02800593          	li	a1,40
+ 8e4:	b7c5                	j	8c4 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 8e6:	8bce                	mv	s7,s3
+      state = 0;
+ 8e8:	4981                	li	s3,0
+ 8ea:	b3c9                	j	6ac <vprintf+0x4a>
+ 8ec:	64a6                	ld	s1,72(sp)
+ 8ee:	79e2                	ld	s3,56(sp)
+ 8f0:	7a42                	ld	s4,48(sp)
+ 8f2:	7aa2                	ld	s5,40(sp)
+ 8f4:	7b02                	ld	s6,32(sp)
+ 8f6:	6be2                	ld	s7,24(sp)
+ 8f8:	6c42                	ld	s8,16(sp)
+ 8fa:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 8fc:	60e6                	ld	ra,88(sp)
+ 8fe:	6446                	ld	s0,80(sp)
+ 900:	6906                	ld	s2,64(sp)
+ 902:	6125                	addi	sp,sp,96
+ 904:	8082                	ret
+
+0000000000000906 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 906:	715d                	addi	sp,sp,-80
+ 908:	ec06                	sd	ra,24(sp)
+ 90a:	e822                	sd	s0,16(sp)
+ 90c:	1000                	addi	s0,sp,32
+ 90e:	e010                	sd	a2,0(s0)
+ 910:	e414                	sd	a3,8(s0)
+ 912:	e818                	sd	a4,16(s0)
+ 914:	ec1c                	sd	a5,24(s0)
+ 916:	03043023          	sd	a6,32(s0)
+ 91a:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 91e:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 922:	8622                	mv	a2,s0
+ 924:	d3fff0ef          	jal	662 <vprintf>
+}
+ 928:	60e2                	ld	ra,24(sp)
+ 92a:	6442                	ld	s0,16(sp)
+ 92c:	6161                	addi	sp,sp,80
+ 92e:	8082                	ret
+
+0000000000000930 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 930:	711d                	addi	sp,sp,-96
+ 932:	ec06                	sd	ra,24(sp)
+ 934:	e822                	sd	s0,16(sp)
+ 936:	1000                	addi	s0,sp,32
+ 938:	e40c                	sd	a1,8(s0)
+ 93a:	e810                	sd	a2,16(s0)
+ 93c:	ec14                	sd	a3,24(s0)
+ 93e:	f018                	sd	a4,32(s0)
+ 940:	f41c                	sd	a5,40(s0)
+ 942:	03043823          	sd	a6,48(s0)
+ 946:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 94a:	00840613          	addi	a2,s0,8
+ 94e:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 952:	85aa                	mv	a1,a0
+ 954:	4505                	li	a0,1
+ 956:	d0dff0ef          	jal	662 <vprintf>
+}
+ 95a:	60e2                	ld	ra,24(sp)
+ 95c:	6442                	ld	s0,16(sp)
+ 95e:	6125                	addi	sp,sp,96
+ 960:	8082                	ret
+
+0000000000000962 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 962:	1141                	addi	sp,sp,-16
+ 964:	e422                	sd	s0,8(sp)
+ 966:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 968:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 96c:	00001797          	auipc	a5,0x1
+ 970:	6947b783          	ld	a5,1684(a5) # 2000 <freep>
+ 974:	a02d                	j	99e <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 976:	4618                	lw	a4,8(a2)
+ 978:	9f2d                	addw	a4,a4,a1
+ 97a:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 97e:	6398                	ld	a4,0(a5)
+ 980:	6310                	ld	a2,0(a4)
+ 982:	a83d                	j	9c0 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 984:	ff852703          	lw	a4,-8(a0)
+ 988:	9f31                	addw	a4,a4,a2
+ 98a:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 98c:	ff053683          	ld	a3,-16(a0)
+ 990:	a091                	j	9d4 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 992:	6398                	ld	a4,0(a5)
+ 994:	00e7e463          	bltu	a5,a4,99c <free+0x3a>
+ 998:	00e6ea63          	bltu	a3,a4,9ac <free+0x4a>
+{
+ 99c:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 99e:	fed7fae3          	bgeu	a5,a3,992 <free+0x30>
+ 9a2:	6398                	ld	a4,0(a5)
+ 9a4:	00e6e463          	bltu	a3,a4,9ac <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 9a8:	fee7eae3          	bltu	a5,a4,99c <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 9ac:	ff852583          	lw	a1,-8(a0)
+ 9b0:	6390                	ld	a2,0(a5)
+ 9b2:	02059813          	slli	a6,a1,0x20
+ 9b6:	01c85713          	srli	a4,a6,0x1c
+ 9ba:	9736                	add	a4,a4,a3
+ 9bc:	fae60de3          	beq	a2,a4,976 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 9c0:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 9c4:	4790                	lw	a2,8(a5)
+ 9c6:	02061593          	slli	a1,a2,0x20
+ 9ca:	01c5d713          	srli	a4,a1,0x1c
+ 9ce:	973e                	add	a4,a4,a5
+ 9d0:	fae68ae3          	beq	a3,a4,984 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 9d4:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 9d6:	00001717          	auipc	a4,0x1
+ 9da:	62f73523          	sd	a5,1578(a4) # 2000 <freep>
+}
+ 9de:	6422                	ld	s0,8(sp)
+ 9e0:	0141                	addi	sp,sp,16
+ 9e2:	8082                	ret
+
+00000000000009e4 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 9e4:	7139                	addi	sp,sp,-64
+ 9e6:	fc06                	sd	ra,56(sp)
+ 9e8:	f822                	sd	s0,48(sp)
+ 9ea:	f426                	sd	s1,40(sp)
+ 9ec:	ec4e                	sd	s3,24(sp)
+ 9ee:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 9f0:	02051493          	slli	s1,a0,0x20
+ 9f4:	9081                	srli	s1,s1,0x20
+ 9f6:	04bd                	addi	s1,s1,15
+ 9f8:	8091                	srli	s1,s1,0x4
+ 9fa:	0014899b          	addiw	s3,s1,1
+ 9fe:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ a00:	00001517          	auipc	a0,0x1
+ a04:	60053503          	ld	a0,1536(a0) # 2000 <freep>
+ a08:	c915                	beqz	a0,a3c <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a0a:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ a0c:	4798                	lw	a4,8(a5)
+ a0e:	08977a63          	bgeu	a4,s1,aa2 <malloc+0xbe>
+ a12:	f04a                	sd	s2,32(sp)
+ a14:	e852                	sd	s4,16(sp)
+ a16:	e456                	sd	s5,8(sp)
+ a18:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ a1a:	8a4e                	mv	s4,s3
+ a1c:	0009871b          	sext.w	a4,s3
+ a20:	6685                	lui	a3,0x1
+ a22:	00d77363          	bgeu	a4,a3,a28 <malloc+0x44>
+ a26:	6a05                	lui	s4,0x1
+ a28:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ a2c:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ a30:	00001917          	auipc	s2,0x1
+ a34:	5d090913          	addi	s2,s2,1488 # 2000 <freep>
+  if(p == SBRK_ERROR)
+ a38:	5afd                	li	s5,-1
+ a3a:	a081                	j	a7a <malloc+0x96>
+ a3c:	f04a                	sd	s2,32(sp)
+ a3e:	e852                	sd	s4,16(sp)
+ a40:	e456                	sd	s5,8(sp)
+ a42:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ a44:	00001797          	auipc	a5,0x1
+ a48:	5dc78793          	addi	a5,a5,1500 # 2020 <base>
+ a4c:	00001717          	auipc	a4,0x1
+ a50:	5af73a23          	sd	a5,1460(a4) # 2000 <freep>
+ a54:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ a56:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ a5a:	b7c1                	j	a1a <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ a5c:	6398                	ld	a4,0(a5)
+ a5e:	e118                	sd	a4,0(a0)
+ a60:	a8a9                	j	aba <malloc+0xd6>
+  hp->s.size = nu;
+ a62:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ a66:	0541                	addi	a0,a0,16
+ a68:	efbff0ef          	jal	962 <free>
+  return freep;
+ a6c:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ a70:	c12d                	beqz	a0,ad2 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ a72:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ a74:	4798                	lw	a4,8(a5)
+ a76:	02977263          	bgeu	a4,s1,a9a <malloc+0xb6>
+    if(p == freep)
+ a7a:	00093703          	ld	a4,0(s2)
+ a7e:	853e                	mv	a0,a5
+ a80:	fef719e3          	bne	a4,a5,a72 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ a84:	8552                	mv	a0,s4
+ a86:	a47ff0ef          	jal	4cc <sbrk>
+  if(p == SBRK_ERROR)
+ a8a:	fd551ce3          	bne	a0,s5,a62 <malloc+0x7e>
+        return 0;
+ a8e:	4501                	li	a0,0
+ a90:	7902                	ld	s2,32(sp)
+ a92:	6a42                	ld	s4,16(sp)
+ a94:	6aa2                	ld	s5,8(sp)
+ a96:	6b02                	ld	s6,0(sp)
+ a98:	a03d                	j	ac6 <malloc+0xe2>
+ a9a:	7902                	ld	s2,32(sp)
+ a9c:	6a42                	ld	s4,16(sp)
+ a9e:	6aa2                	ld	s5,8(sp)
+ aa0:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ aa2:	fae48de3          	beq	s1,a4,a5c <malloc+0x78>
+        p->s.size -= nunits;
+ aa6:	4137073b          	subw	a4,a4,s3
+ aaa:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ aac:	02071693          	slli	a3,a4,0x20
+ ab0:	01c6d713          	srli	a4,a3,0x1c
+ ab4:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ ab6:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ aba:	00001717          	auipc	a4,0x1
+ abe:	54a73323          	sd	a0,1350(a4) # 2000 <freep>
+      return (void*)(p + 1);
+ ac2:	01078513          	addi	a0,a5,16
+  }
+}
+ ac6:	70e2                	ld	ra,56(sp)
+ ac8:	7442                	ld	s0,48(sp)
+ aca:	74a2                	ld	s1,40(sp)
+ acc:	69e2                	ld	s3,24(sp)
+ ace:	6121                	addi	sp,sp,64
+ ad0:	8082                	ret
+ ad2:	7902                	ld	s2,32(sp)
+ ad4:	6a42                	ld	s4,16(sp)
+ ad6:	6aa2                	ld	s5,8(sp)
+ ad8:	6b02                	ld	s6,0(sp)
+ ada:	b7f5                	j	ac6 <malloc+0xe2>
diff -ruN xv6-riscv/user/ls.d xv62/user/ls.d
--- xv6-riscv/user/ls.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ls.d	2025-09-14 12:32:51.044883281 +0000
@@ -0,0 +1,2 @@
+user/ls.o: user/ls.c kernel/types.h kernel/stat.h user/user.h kernel/fs.h \
+ kernel/fcntl.h
Binary files xv6-riscv/user/ls.o and xv62/user/ls.o differ
diff -ruN xv6-riscv/user/ls.sym xv62/user/ls.sym
--- xv6-riscv/user/ls.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ls.sym	2025-09-14 12:32:51.068883276 +0000
@@ -0,0 +1,69 @@
+0000000000000000 .text
+0000000000000ae0 .rodata
+0000000000000b60 .eh_frame
+0000000000002000 .data
+0000000000002000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 ls.c
+0000000000002010 buf.0
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000005a8 putc
+00000000000005c6 printint
+0000000000000b48 digits
+0000000000000000 umalloc.c
+0000000000002000 freep
+0000000000002020 base
+000000000000027c strcpy
+0000000000000000 fmtname
+0000000000000590 pause
+0000000000000930 printf
+0000000000000588 sys_sbrk
+0000000000000426 memmove
+0000000000000548 mknod
+0000000000000334 gets
+0000000000000580 getpid
+00000000000004b8 memcpy
+00000000000009e4 malloc
+00000000000004e2 sbrklazy
+0000000000000510 pipe
+0000000000000520 write
+0000000000000558 fstat
+0000000000000906 fprintf
+0000000000000530 kill
+0000000000000662 vprintf
+0000000000000570 chdir
+0000000000000538 exec
+0000000000000508 wait
+0000000000000518 read
+0000000000000550 unlink
+000000000000047e memcmp
+00000000000004f8 fork
+00000000000004cc sbrk
+0000000000000598 uptime
+00000000000002ee memset
+000000000000021e main
+0000000000000298 strcmp
+0000000000000578 dup
+00000000000005a0 getreadcount
+00000000000003a4 stat
+0000000000000560 link
+000000000000009c ls
+0000000000000500 exit
+000000000000026c start
+00000000000003de atoi
+00000000000002c4 strlen
+0000000000000540 open
+0000000000000310 strchr
+0000000000000568 mkdir
+0000000000000528 close
+0000000000000962 free
diff -ruN xv6-riscv/user/mkdir.asm xv62/user/mkdir.asm
--- xv6-riscv/user/mkdir.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/mkdir.asm	2025-09-14 12:32:51.112883267 +0000
@@ -0,0 +1,1519 @@
+
+user/_mkdir:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	1000                	addi	s0,sp,32
+  int i;
+
+  if(argc < 2){
+   8:	4785                	li	a5,1
+   a:	02a7d763          	bge	a5,a0,38 <main+0x38>
+   e:	e426                	sd	s1,8(sp)
+  10:	e04a                	sd	s2,0(sp)
+  12:	00858493          	addi	s1,a1,8
+  16:	ffe5091b          	addiw	s2,a0,-2
+  1a:	02091793          	slli	a5,s2,0x20
+  1e:	01d7d913          	srli	s2,a5,0x1d
+  22:	05c1                	addi	a1,a1,16
+  24:	992e                	add	s2,s2,a1
+    fprintf(2, "Usage: mkdir files...\n");
+    exit(1);
+  }
+
+  for(i = 1; i < argc; i++){
+    if(mkdir(argv[i]) < 0){
+  26:	6088                	ld	a0,0(s1)
+  28:	33a000ef          	jal	362 <mkdir>
+  2c:	02054263          	bltz	a0,50 <main+0x50>
+  for(i = 1; i < argc; i++){
+  30:	04a1                	addi	s1,s1,8
+  32:	ff249ae3          	bne	s1,s2,26 <main+0x26>
+  36:	a02d                	j	60 <main+0x60>
+  38:	e426                	sd	s1,8(sp)
+  3a:	e04a                	sd	s2,0(sp)
+    fprintf(2, "Usage: mkdir files...\n");
+  3c:	00001597          	auipc	a1,0x1
+  40:	8a458593          	addi	a1,a1,-1884 # 8e0 <malloc+0x102>
+  44:	4509                	li	a0,2
+  46:	6ba000ef          	jal	700 <fprintf>
+    exit(1);
+  4a:	4505                	li	a0,1
+  4c:	2ae000ef          	jal	2fa <exit>
+      fprintf(2, "mkdir: %s failed to create\n", argv[i]);
+  50:	6090                	ld	a2,0(s1)
+  52:	00001597          	auipc	a1,0x1
+  56:	8a658593          	addi	a1,a1,-1882 # 8f8 <malloc+0x11a>
+  5a:	4509                	li	a0,2
+  5c:	6a4000ef          	jal	700 <fprintf>
+      break;
+    }
+  }
+
+  exit(0);
+  60:	4501                	li	a0,0
+  62:	298000ef          	jal	2fa <exit>
+
+0000000000000066 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  66:	1141                	addi	sp,sp,-16
+  68:	e406                	sd	ra,8(sp)
+  6a:	e022                	sd	s0,0(sp)
+  6c:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  6e:	f93ff0ef          	jal	0 <main>
+  exit(r);
+  72:	288000ef          	jal	2fa <exit>
+
+0000000000000076 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  76:	1141                	addi	sp,sp,-16
+  78:	e422                	sd	s0,8(sp)
+  7a:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  7c:	87aa                	mv	a5,a0
+  7e:	0585                	addi	a1,a1,1
+  80:	0785                	addi	a5,a5,1
+  82:	fff5c703          	lbu	a4,-1(a1)
+  86:	fee78fa3          	sb	a4,-1(a5)
+  8a:	fb75                	bnez	a4,7e <strcpy+0x8>
+    ;
+  return os;
+}
+  8c:	6422                	ld	s0,8(sp)
+  8e:	0141                	addi	sp,sp,16
+  90:	8082                	ret
+
+0000000000000092 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  92:	1141                	addi	sp,sp,-16
+  94:	e422                	sd	s0,8(sp)
+  96:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  98:	00054783          	lbu	a5,0(a0)
+  9c:	cb91                	beqz	a5,b0 <strcmp+0x1e>
+  9e:	0005c703          	lbu	a4,0(a1)
+  a2:	00f71763          	bne	a4,a5,b0 <strcmp+0x1e>
+    p++, q++;
+  a6:	0505                	addi	a0,a0,1
+  a8:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  aa:	00054783          	lbu	a5,0(a0)
+  ae:	fbe5                	bnez	a5,9e <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  b0:	0005c503          	lbu	a0,0(a1)
+}
+  b4:	40a7853b          	subw	a0,a5,a0
+  b8:	6422                	ld	s0,8(sp)
+  ba:	0141                	addi	sp,sp,16
+  bc:	8082                	ret
+
+00000000000000be <strlen>:
+
+uint
+strlen(const char *s)
+{
+  be:	1141                	addi	sp,sp,-16
+  c0:	e422                	sd	s0,8(sp)
+  c2:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  c4:	00054783          	lbu	a5,0(a0)
+  c8:	cf91                	beqz	a5,e4 <strlen+0x26>
+  ca:	0505                	addi	a0,a0,1
+  cc:	87aa                	mv	a5,a0
+  ce:	86be                	mv	a3,a5
+  d0:	0785                	addi	a5,a5,1
+  d2:	fff7c703          	lbu	a4,-1(a5)
+  d6:	ff65                	bnez	a4,ce <strlen+0x10>
+  d8:	40a6853b          	subw	a0,a3,a0
+  dc:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  de:	6422                	ld	s0,8(sp)
+  e0:	0141                	addi	sp,sp,16
+  e2:	8082                	ret
+  for(n = 0; s[n]; n++)
+  e4:	4501                	li	a0,0
+  e6:	bfe5                	j	de <strlen+0x20>
+
+00000000000000e8 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  e8:	1141                	addi	sp,sp,-16
+  ea:	e422                	sd	s0,8(sp)
+  ec:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  ee:	ca19                	beqz	a2,104 <memset+0x1c>
+  f0:	87aa                	mv	a5,a0
+  f2:	1602                	slli	a2,a2,0x20
+  f4:	9201                	srli	a2,a2,0x20
+  f6:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  fa:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+  fe:	0785                	addi	a5,a5,1
+ 100:	fee79de3          	bne	a5,a4,fa <memset+0x12>
+  }
+  return dst;
+}
+ 104:	6422                	ld	s0,8(sp)
+ 106:	0141                	addi	sp,sp,16
+ 108:	8082                	ret
+
+000000000000010a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 10a:	1141                	addi	sp,sp,-16
+ 10c:	e422                	sd	s0,8(sp)
+ 10e:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 110:	00054783          	lbu	a5,0(a0)
+ 114:	cb99                	beqz	a5,12a <strchr+0x20>
+    if(*s == c)
+ 116:	00f58763          	beq	a1,a5,124 <strchr+0x1a>
+  for(; *s; s++)
+ 11a:	0505                	addi	a0,a0,1
+ 11c:	00054783          	lbu	a5,0(a0)
+ 120:	fbfd                	bnez	a5,116 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 122:	4501                	li	a0,0
+}
+ 124:	6422                	ld	s0,8(sp)
+ 126:	0141                	addi	sp,sp,16
+ 128:	8082                	ret
+  return 0;
+ 12a:	4501                	li	a0,0
+ 12c:	bfe5                	j	124 <strchr+0x1a>
+
+000000000000012e <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 12e:	711d                	addi	sp,sp,-96
+ 130:	ec86                	sd	ra,88(sp)
+ 132:	e8a2                	sd	s0,80(sp)
+ 134:	e4a6                	sd	s1,72(sp)
+ 136:	e0ca                	sd	s2,64(sp)
+ 138:	fc4e                	sd	s3,56(sp)
+ 13a:	f852                	sd	s4,48(sp)
+ 13c:	f456                	sd	s5,40(sp)
+ 13e:	f05a                	sd	s6,32(sp)
+ 140:	ec5e                	sd	s7,24(sp)
+ 142:	1080                	addi	s0,sp,96
+ 144:	8baa                	mv	s7,a0
+ 146:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 148:	892a                	mv	s2,a0
+ 14a:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 14c:	4aa9                	li	s5,10
+ 14e:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 150:	89a6                	mv	s3,s1
+ 152:	2485                	addiw	s1,s1,1
+ 154:	0344d663          	bge	s1,s4,180 <gets+0x52>
+    cc = read(0, &c, 1);
+ 158:	4605                	li	a2,1
+ 15a:	faf40593          	addi	a1,s0,-81
+ 15e:	4501                	li	a0,0
+ 160:	1b2000ef          	jal	312 <read>
+    if(cc < 1)
+ 164:	00a05e63          	blez	a0,180 <gets+0x52>
+    buf[i++] = c;
+ 168:	faf44783          	lbu	a5,-81(s0)
+ 16c:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 170:	01578763          	beq	a5,s5,17e <gets+0x50>
+ 174:	0905                	addi	s2,s2,1
+ 176:	fd679de3          	bne	a5,s6,150 <gets+0x22>
+    buf[i++] = c;
+ 17a:	89a6                	mv	s3,s1
+ 17c:	a011                	j	180 <gets+0x52>
+ 17e:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 180:	99de                	add	s3,s3,s7
+ 182:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 186:	855e                	mv	a0,s7
+ 188:	60e6                	ld	ra,88(sp)
+ 18a:	6446                	ld	s0,80(sp)
+ 18c:	64a6                	ld	s1,72(sp)
+ 18e:	6906                	ld	s2,64(sp)
+ 190:	79e2                	ld	s3,56(sp)
+ 192:	7a42                	ld	s4,48(sp)
+ 194:	7aa2                	ld	s5,40(sp)
+ 196:	7b02                	ld	s6,32(sp)
+ 198:	6be2                	ld	s7,24(sp)
+ 19a:	6125                	addi	sp,sp,96
+ 19c:	8082                	ret
+
+000000000000019e <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 19e:	1101                	addi	sp,sp,-32
+ 1a0:	ec06                	sd	ra,24(sp)
+ 1a2:	e822                	sd	s0,16(sp)
+ 1a4:	e04a                	sd	s2,0(sp)
+ 1a6:	1000                	addi	s0,sp,32
+ 1a8:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1aa:	4581                	li	a1,0
+ 1ac:	18e000ef          	jal	33a <open>
+  if(fd < 0)
+ 1b0:	02054263          	bltz	a0,1d4 <stat+0x36>
+ 1b4:	e426                	sd	s1,8(sp)
+ 1b6:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1b8:	85ca                	mv	a1,s2
+ 1ba:	198000ef          	jal	352 <fstat>
+ 1be:	892a                	mv	s2,a0
+  close(fd);
+ 1c0:	8526                	mv	a0,s1
+ 1c2:	160000ef          	jal	322 <close>
+  return r;
+ 1c6:	64a2                	ld	s1,8(sp)
+}
+ 1c8:	854a                	mv	a0,s2
+ 1ca:	60e2                	ld	ra,24(sp)
+ 1cc:	6442                	ld	s0,16(sp)
+ 1ce:	6902                	ld	s2,0(sp)
+ 1d0:	6105                	addi	sp,sp,32
+ 1d2:	8082                	ret
+    return -1;
+ 1d4:	597d                	li	s2,-1
+ 1d6:	bfcd                	j	1c8 <stat+0x2a>
+
+00000000000001d8 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1d8:	1141                	addi	sp,sp,-16
+ 1da:	e422                	sd	s0,8(sp)
+ 1dc:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1de:	00054683          	lbu	a3,0(a0)
+ 1e2:	fd06879b          	addiw	a5,a3,-48
+ 1e6:	0ff7f793          	zext.b	a5,a5
+ 1ea:	4625                	li	a2,9
+ 1ec:	02f66863          	bltu	a2,a5,21c <atoi+0x44>
+ 1f0:	872a                	mv	a4,a0
+  n = 0;
+ 1f2:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1f4:	0705                	addi	a4,a4,1
+ 1f6:	0025179b          	slliw	a5,a0,0x2
+ 1fa:	9fa9                	addw	a5,a5,a0
+ 1fc:	0017979b          	slliw	a5,a5,0x1
+ 200:	9fb5                	addw	a5,a5,a3
+ 202:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 206:	00074683          	lbu	a3,0(a4)
+ 20a:	fd06879b          	addiw	a5,a3,-48
+ 20e:	0ff7f793          	zext.b	a5,a5
+ 212:	fef671e3          	bgeu	a2,a5,1f4 <atoi+0x1c>
+  return n;
+}
+ 216:	6422                	ld	s0,8(sp)
+ 218:	0141                	addi	sp,sp,16
+ 21a:	8082                	ret
+  n = 0;
+ 21c:	4501                	li	a0,0
+ 21e:	bfe5                	j	216 <atoi+0x3e>
+
+0000000000000220 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 220:	1141                	addi	sp,sp,-16
+ 222:	e422                	sd	s0,8(sp)
+ 224:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 226:	02b57463          	bgeu	a0,a1,24e <memmove+0x2e>
+    while(n-- > 0)
+ 22a:	00c05f63          	blez	a2,248 <memmove+0x28>
+ 22e:	1602                	slli	a2,a2,0x20
+ 230:	9201                	srli	a2,a2,0x20
+ 232:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 236:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 238:	0585                	addi	a1,a1,1
+ 23a:	0705                	addi	a4,a4,1
+ 23c:	fff5c683          	lbu	a3,-1(a1)
+ 240:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 244:	fef71ae3          	bne	a4,a5,238 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 248:	6422                	ld	s0,8(sp)
+ 24a:	0141                	addi	sp,sp,16
+ 24c:	8082                	ret
+    dst += n;
+ 24e:	00c50733          	add	a4,a0,a2
+    src += n;
+ 252:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 254:	fec05ae3          	blez	a2,248 <memmove+0x28>
+ 258:	fff6079b          	addiw	a5,a2,-1
+ 25c:	1782                	slli	a5,a5,0x20
+ 25e:	9381                	srli	a5,a5,0x20
+ 260:	fff7c793          	not	a5,a5
+ 264:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 266:	15fd                	addi	a1,a1,-1
+ 268:	177d                	addi	a4,a4,-1
+ 26a:	0005c683          	lbu	a3,0(a1)
+ 26e:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 272:	fee79ae3          	bne	a5,a4,266 <memmove+0x46>
+ 276:	bfc9                	j	248 <memmove+0x28>
+
+0000000000000278 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 278:	1141                	addi	sp,sp,-16
+ 27a:	e422                	sd	s0,8(sp)
+ 27c:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 27e:	ca05                	beqz	a2,2ae <memcmp+0x36>
+ 280:	fff6069b          	addiw	a3,a2,-1
+ 284:	1682                	slli	a3,a3,0x20
+ 286:	9281                	srli	a3,a3,0x20
+ 288:	0685                	addi	a3,a3,1
+ 28a:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 28c:	00054783          	lbu	a5,0(a0)
+ 290:	0005c703          	lbu	a4,0(a1)
+ 294:	00e79863          	bne	a5,a4,2a4 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 298:	0505                	addi	a0,a0,1
+    p2++;
+ 29a:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 29c:	fed518e3          	bne	a0,a3,28c <memcmp+0x14>
+  }
+  return 0;
+ 2a0:	4501                	li	a0,0
+ 2a2:	a019                	j	2a8 <memcmp+0x30>
+      return *p1 - *p2;
+ 2a4:	40e7853b          	subw	a0,a5,a4
+}
+ 2a8:	6422                	ld	s0,8(sp)
+ 2aa:	0141                	addi	sp,sp,16
+ 2ac:	8082                	ret
+  return 0;
+ 2ae:	4501                	li	a0,0
+ 2b0:	bfe5                	j	2a8 <memcmp+0x30>
+
+00000000000002b2 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2b2:	1141                	addi	sp,sp,-16
+ 2b4:	e406                	sd	ra,8(sp)
+ 2b6:	e022                	sd	s0,0(sp)
+ 2b8:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2ba:	f67ff0ef          	jal	220 <memmove>
+}
+ 2be:	60a2                	ld	ra,8(sp)
+ 2c0:	6402                	ld	s0,0(sp)
+ 2c2:	0141                	addi	sp,sp,16
+ 2c4:	8082                	ret
+
+00000000000002c6 <sbrk>:
+
+char *
+sbrk(int n) {
+ 2c6:	1141                	addi	sp,sp,-16
+ 2c8:	e406                	sd	ra,8(sp)
+ 2ca:	e022                	sd	s0,0(sp)
+ 2cc:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2ce:	4585                	li	a1,1
+ 2d0:	0b2000ef          	jal	382 <sys_sbrk>
+}
+ 2d4:	60a2                	ld	ra,8(sp)
+ 2d6:	6402                	ld	s0,0(sp)
+ 2d8:	0141                	addi	sp,sp,16
+ 2da:	8082                	ret
+
+00000000000002dc <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2dc:	1141                	addi	sp,sp,-16
+ 2de:	e406                	sd	ra,8(sp)
+ 2e0:	e022                	sd	s0,0(sp)
+ 2e2:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2e4:	4589                	li	a1,2
+ 2e6:	09c000ef          	jal	382 <sys_sbrk>
+}
+ 2ea:	60a2                	ld	ra,8(sp)
+ 2ec:	6402                	ld	s0,0(sp)
+ 2ee:	0141                	addi	sp,sp,16
+ 2f0:	8082                	ret
+
+00000000000002f2 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2f2:	4885                	li	a7,1
+ ecall
+ 2f4:	00000073          	ecall
+ ret
+ 2f8:	8082                	ret
+
+00000000000002fa <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2fa:	4889                	li	a7,2
+ ecall
+ 2fc:	00000073          	ecall
+ ret
+ 300:	8082                	ret
+
+0000000000000302 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 302:	488d                	li	a7,3
+ ecall
+ 304:	00000073          	ecall
+ ret
+ 308:	8082                	ret
+
+000000000000030a <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 30a:	4891                	li	a7,4
+ ecall
+ 30c:	00000073          	ecall
+ ret
+ 310:	8082                	ret
+
+0000000000000312 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 312:	4895                	li	a7,5
+ ecall
+ 314:	00000073          	ecall
+ ret
+ 318:	8082                	ret
+
+000000000000031a <write>:
+.global write
+write:
+ li a7, SYS_write
+ 31a:	48c1                	li	a7,16
+ ecall
+ 31c:	00000073          	ecall
+ ret
+ 320:	8082                	ret
+
+0000000000000322 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 322:	48d5                	li	a7,21
+ ecall
+ 324:	00000073          	ecall
+ ret
+ 328:	8082                	ret
+
+000000000000032a <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 32a:	4899                	li	a7,6
+ ecall
+ 32c:	00000073          	ecall
+ ret
+ 330:	8082                	ret
+
+0000000000000332 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 332:	489d                	li	a7,7
+ ecall
+ 334:	00000073          	ecall
+ ret
+ 338:	8082                	ret
+
+000000000000033a <open>:
+.global open
+open:
+ li a7, SYS_open
+ 33a:	48bd                	li	a7,15
+ ecall
+ 33c:	00000073          	ecall
+ ret
+ 340:	8082                	ret
+
+0000000000000342 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 342:	48c5                	li	a7,17
+ ecall
+ 344:	00000073          	ecall
+ ret
+ 348:	8082                	ret
+
+000000000000034a <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 34a:	48c9                	li	a7,18
+ ecall
+ 34c:	00000073          	ecall
+ ret
+ 350:	8082                	ret
+
+0000000000000352 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 352:	48a1                	li	a7,8
+ ecall
+ 354:	00000073          	ecall
+ ret
+ 358:	8082                	ret
+
+000000000000035a <link>:
+.global link
+link:
+ li a7, SYS_link
+ 35a:	48cd                	li	a7,19
+ ecall
+ 35c:	00000073          	ecall
+ ret
+ 360:	8082                	ret
+
+0000000000000362 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 362:	48d1                	li	a7,20
+ ecall
+ 364:	00000073          	ecall
+ ret
+ 368:	8082                	ret
+
+000000000000036a <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 36a:	48a5                	li	a7,9
+ ecall
+ 36c:	00000073          	ecall
+ ret
+ 370:	8082                	ret
+
+0000000000000372 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 372:	48a9                	li	a7,10
+ ecall
+ 374:	00000073          	ecall
+ ret
+ 378:	8082                	ret
+
+000000000000037a <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 37a:	48ad                	li	a7,11
+ ecall
+ 37c:	00000073          	ecall
+ ret
+ 380:	8082                	ret
+
+0000000000000382 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 382:	48b1                	li	a7,12
+ ecall
+ 384:	00000073          	ecall
+ ret
+ 388:	8082                	ret
+
+000000000000038a <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 38a:	48b5                	li	a7,13
+ ecall
+ 38c:	00000073          	ecall
+ ret
+ 390:	8082                	ret
+
+0000000000000392 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 392:	48b9                	li	a7,14
+ ecall
+ 394:	00000073          	ecall
+ ret
+ 398:	8082                	ret
+
+000000000000039a <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 39a:	48d9                	li	a7,22
+ ecall
+ 39c:	00000073          	ecall
+ ret
+ 3a0:	8082                	ret
+
+00000000000003a2 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3a2:	1101                	addi	sp,sp,-32
+ 3a4:	ec06                	sd	ra,24(sp)
+ 3a6:	e822                	sd	s0,16(sp)
+ 3a8:	1000                	addi	s0,sp,32
+ 3aa:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 3ae:	4605                	li	a2,1
+ 3b0:	fef40593          	addi	a1,s0,-17
+ 3b4:	f67ff0ef          	jal	31a <write>
+}
+ 3b8:	60e2                	ld	ra,24(sp)
+ 3ba:	6442                	ld	s0,16(sp)
+ 3bc:	6105                	addi	sp,sp,32
+ 3be:	8082                	ret
+
+00000000000003c0 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3c0:	715d                	addi	sp,sp,-80
+ 3c2:	e486                	sd	ra,72(sp)
+ 3c4:	e0a2                	sd	s0,64(sp)
+ 3c6:	f84a                	sd	s2,48(sp)
+ 3c8:	0880                	addi	s0,sp,80
+ 3ca:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3cc:	c299                	beqz	a3,3d2 <printint+0x12>
+ 3ce:	0805c363          	bltz	a1,454 <printint+0x94>
+  neg = 0;
+ 3d2:	4881                	li	a7,0
+ 3d4:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3d8:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3da:	00000517          	auipc	a0,0x0
+ 3de:	54650513          	addi	a0,a0,1350 # 920 <digits>
+ 3e2:	883e                	mv	a6,a5
+ 3e4:	2785                	addiw	a5,a5,1
+ 3e6:	02c5f733          	remu	a4,a1,a2
+ 3ea:	972a                	add	a4,a4,a0
+ 3ec:	00074703          	lbu	a4,0(a4)
+ 3f0:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3f4:	872e                	mv	a4,a1
+ 3f6:	02c5d5b3          	divu	a1,a1,a2
+ 3fa:	0685                	addi	a3,a3,1
+ 3fc:	fec773e3          	bgeu	a4,a2,3e2 <printint+0x22>
+  if(neg)
+ 400:	00088b63          	beqz	a7,416 <printint+0x56>
+    buf[i++] = '-';
+ 404:	fd078793          	addi	a5,a5,-48
+ 408:	97a2                	add	a5,a5,s0
+ 40a:	02d00713          	li	a4,45
+ 40e:	fee78423          	sb	a4,-24(a5)
+ 412:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 416:	02f05a63          	blez	a5,44a <printint+0x8a>
+ 41a:	fc26                	sd	s1,56(sp)
+ 41c:	f44e                	sd	s3,40(sp)
+ 41e:	fb840713          	addi	a4,s0,-72
+ 422:	00f704b3          	add	s1,a4,a5
+ 426:	fff70993          	addi	s3,a4,-1
+ 42a:	99be                	add	s3,s3,a5
+ 42c:	37fd                	addiw	a5,a5,-1
+ 42e:	1782                	slli	a5,a5,0x20
+ 430:	9381                	srli	a5,a5,0x20
+ 432:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 436:	fff4c583          	lbu	a1,-1(s1)
+ 43a:	854a                	mv	a0,s2
+ 43c:	f67ff0ef          	jal	3a2 <putc>
+  while(--i >= 0)
+ 440:	14fd                	addi	s1,s1,-1
+ 442:	ff349ae3          	bne	s1,s3,436 <printint+0x76>
+ 446:	74e2                	ld	s1,56(sp)
+ 448:	79a2                	ld	s3,40(sp)
+}
+ 44a:	60a6                	ld	ra,72(sp)
+ 44c:	6406                	ld	s0,64(sp)
+ 44e:	7942                	ld	s2,48(sp)
+ 450:	6161                	addi	sp,sp,80
+ 452:	8082                	ret
+    x = -xx;
+ 454:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 458:	4885                	li	a7,1
+    x = -xx;
+ 45a:	bfad                	j	3d4 <printint+0x14>
+
+000000000000045c <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 45c:	711d                	addi	sp,sp,-96
+ 45e:	ec86                	sd	ra,88(sp)
+ 460:	e8a2                	sd	s0,80(sp)
+ 462:	e0ca                	sd	s2,64(sp)
+ 464:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 466:	0005c903          	lbu	s2,0(a1)
+ 46a:	28090663          	beqz	s2,6f6 <vprintf+0x29a>
+ 46e:	e4a6                	sd	s1,72(sp)
+ 470:	fc4e                	sd	s3,56(sp)
+ 472:	f852                	sd	s4,48(sp)
+ 474:	f456                	sd	s5,40(sp)
+ 476:	f05a                	sd	s6,32(sp)
+ 478:	ec5e                	sd	s7,24(sp)
+ 47a:	e862                	sd	s8,16(sp)
+ 47c:	e466                	sd	s9,8(sp)
+ 47e:	8b2a                	mv	s6,a0
+ 480:	8a2e                	mv	s4,a1
+ 482:	8bb2                	mv	s7,a2
+  state = 0;
+ 484:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 486:	4481                	li	s1,0
+ 488:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 48a:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 48e:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 492:	06c00c93          	li	s9,108
+ 496:	a005                	j	4b6 <vprintf+0x5a>
+        putc(fd, c0);
+ 498:	85ca                	mv	a1,s2
+ 49a:	855a                	mv	a0,s6
+ 49c:	f07ff0ef          	jal	3a2 <putc>
+ 4a0:	a019                	j	4a6 <vprintf+0x4a>
+    } else if(state == '%'){
+ 4a2:	03598263          	beq	s3,s5,4c6 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4a6:	2485                	addiw	s1,s1,1
+ 4a8:	8726                	mv	a4,s1
+ 4aa:	009a07b3          	add	a5,s4,s1
+ 4ae:	0007c903          	lbu	s2,0(a5)
+ 4b2:	22090a63          	beqz	s2,6e6 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4b6:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4ba:	fe0994e3          	bnez	s3,4a2 <vprintf+0x46>
+      if(c0 == '%'){
+ 4be:	fd579de3          	bne	a5,s5,498 <vprintf+0x3c>
+        state = '%';
+ 4c2:	89be                	mv	s3,a5
+ 4c4:	b7cd                	j	4a6 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4c6:	00ea06b3          	add	a3,s4,a4
+ 4ca:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4ce:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4d0:	c681                	beqz	a3,4d8 <vprintf+0x7c>
+ 4d2:	9752                	add	a4,a4,s4
+ 4d4:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4d8:	05878363          	beq	a5,s8,51e <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4dc:	05978d63          	beq	a5,s9,536 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4e0:	07500713          	li	a4,117
+ 4e4:	0ee78763          	beq	a5,a4,5d2 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4e8:	07800713          	li	a4,120
+ 4ec:	12e78963          	beq	a5,a4,61e <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4f0:	07000713          	li	a4,112
+ 4f4:	14e78e63          	beq	a5,a4,650 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4f8:	06300713          	li	a4,99
+ 4fc:	18e78e63          	beq	a5,a4,698 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 500:	07300713          	li	a4,115
+ 504:	1ae78463          	beq	a5,a4,6ac <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 508:	02500713          	li	a4,37
+ 50c:	04e79563          	bne	a5,a4,556 <vprintf+0xfa>
+        putc(fd, '%');
+ 510:	02500593          	li	a1,37
+ 514:	855a                	mv	a0,s6
+ 516:	e8dff0ef          	jal	3a2 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 51a:	4981                	li	s3,0
+ 51c:	b769                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 51e:	008b8913          	addi	s2,s7,8
+ 522:	4685                	li	a3,1
+ 524:	4629                	li	a2,10
+ 526:	000ba583          	lw	a1,0(s7)
+ 52a:	855a                	mv	a0,s6
+ 52c:	e95ff0ef          	jal	3c0 <printint>
+ 530:	8bca                	mv	s7,s2
+      state = 0;
+ 532:	4981                	li	s3,0
+ 534:	bf8d                	j	4a6 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 536:	06400793          	li	a5,100
+ 53a:	02f68963          	beq	a3,a5,56c <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 53e:	06c00793          	li	a5,108
+ 542:	04f68263          	beq	a3,a5,586 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 546:	07500793          	li	a5,117
+ 54a:	0af68063          	beq	a3,a5,5ea <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 54e:	07800793          	li	a5,120
+ 552:	0ef68263          	beq	a3,a5,636 <vprintf+0x1da>
+        putc(fd, '%');
+ 556:	02500593          	li	a1,37
+ 55a:	855a                	mv	a0,s6
+ 55c:	e47ff0ef          	jal	3a2 <putc>
+        putc(fd, c0);
+ 560:	85ca                	mv	a1,s2
+ 562:	855a                	mv	a0,s6
+ 564:	e3fff0ef          	jal	3a2 <putc>
+      state = 0;
+ 568:	4981                	li	s3,0
+ 56a:	bf35                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 56c:	008b8913          	addi	s2,s7,8
+ 570:	4685                	li	a3,1
+ 572:	4629                	li	a2,10
+ 574:	000bb583          	ld	a1,0(s7)
+ 578:	855a                	mv	a0,s6
+ 57a:	e47ff0ef          	jal	3c0 <printint>
+        i += 1;
+ 57e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 580:	8bca                	mv	s7,s2
+      state = 0;
+ 582:	4981                	li	s3,0
+        i += 1;
+ 584:	b70d                	j	4a6 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 586:	06400793          	li	a5,100
+ 58a:	02f60763          	beq	a2,a5,5b8 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 58e:	07500793          	li	a5,117
+ 592:	06f60963          	beq	a2,a5,604 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 596:	07800793          	li	a5,120
+ 59a:	faf61ee3          	bne	a2,a5,556 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 59e:	008b8913          	addi	s2,s7,8
+ 5a2:	4681                	li	a3,0
+ 5a4:	4641                	li	a2,16
+ 5a6:	000bb583          	ld	a1,0(s7)
+ 5aa:	855a                	mv	a0,s6
+ 5ac:	e15ff0ef          	jal	3c0 <printint>
+        i += 2;
+ 5b0:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5b2:	8bca                	mv	s7,s2
+      state = 0;
+ 5b4:	4981                	li	s3,0
+        i += 2;
+ 5b6:	bdc5                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5b8:	008b8913          	addi	s2,s7,8
+ 5bc:	4685                	li	a3,1
+ 5be:	4629                	li	a2,10
+ 5c0:	000bb583          	ld	a1,0(s7)
+ 5c4:	855a                	mv	a0,s6
+ 5c6:	dfbff0ef          	jal	3c0 <printint>
+        i += 2;
+ 5ca:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5cc:	8bca                	mv	s7,s2
+      state = 0;
+ 5ce:	4981                	li	s3,0
+        i += 2;
+ 5d0:	bdd9                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5d2:	008b8913          	addi	s2,s7,8
+ 5d6:	4681                	li	a3,0
+ 5d8:	4629                	li	a2,10
+ 5da:	000be583          	lwu	a1,0(s7)
+ 5de:	855a                	mv	a0,s6
+ 5e0:	de1ff0ef          	jal	3c0 <printint>
+ 5e4:	8bca                	mv	s7,s2
+      state = 0;
+ 5e6:	4981                	li	s3,0
+ 5e8:	bd7d                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5ea:	008b8913          	addi	s2,s7,8
+ 5ee:	4681                	li	a3,0
+ 5f0:	4629                	li	a2,10
+ 5f2:	000bb583          	ld	a1,0(s7)
+ 5f6:	855a                	mv	a0,s6
+ 5f8:	dc9ff0ef          	jal	3c0 <printint>
+        i += 1;
+ 5fc:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5fe:	8bca                	mv	s7,s2
+      state = 0;
+ 600:	4981                	li	s3,0
+        i += 1;
+ 602:	b555                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 604:	008b8913          	addi	s2,s7,8
+ 608:	4681                	li	a3,0
+ 60a:	4629                	li	a2,10
+ 60c:	000bb583          	ld	a1,0(s7)
+ 610:	855a                	mv	a0,s6
+ 612:	dafff0ef          	jal	3c0 <printint>
+        i += 2;
+ 616:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 618:	8bca                	mv	s7,s2
+      state = 0;
+ 61a:	4981                	li	s3,0
+        i += 2;
+ 61c:	b569                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 61e:	008b8913          	addi	s2,s7,8
+ 622:	4681                	li	a3,0
+ 624:	4641                	li	a2,16
+ 626:	000be583          	lwu	a1,0(s7)
+ 62a:	855a                	mv	a0,s6
+ 62c:	d95ff0ef          	jal	3c0 <printint>
+ 630:	8bca                	mv	s7,s2
+      state = 0;
+ 632:	4981                	li	s3,0
+ 634:	bd8d                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 636:	008b8913          	addi	s2,s7,8
+ 63a:	4681                	li	a3,0
+ 63c:	4641                	li	a2,16
+ 63e:	000bb583          	ld	a1,0(s7)
+ 642:	855a                	mv	a0,s6
+ 644:	d7dff0ef          	jal	3c0 <printint>
+        i += 1;
+ 648:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 64a:	8bca                	mv	s7,s2
+      state = 0;
+ 64c:	4981                	li	s3,0
+        i += 1;
+ 64e:	bda1                	j	4a6 <vprintf+0x4a>
+ 650:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 652:	008b8d13          	addi	s10,s7,8
+ 656:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 65a:	03000593          	li	a1,48
+ 65e:	855a                	mv	a0,s6
+ 660:	d43ff0ef          	jal	3a2 <putc>
+  putc(fd, 'x');
+ 664:	07800593          	li	a1,120
+ 668:	855a                	mv	a0,s6
+ 66a:	d39ff0ef          	jal	3a2 <putc>
+ 66e:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 670:	00000b97          	auipc	s7,0x0
+ 674:	2b0b8b93          	addi	s7,s7,688 # 920 <digits>
+ 678:	03c9d793          	srli	a5,s3,0x3c
+ 67c:	97de                	add	a5,a5,s7
+ 67e:	0007c583          	lbu	a1,0(a5)
+ 682:	855a                	mv	a0,s6
+ 684:	d1fff0ef          	jal	3a2 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 688:	0992                	slli	s3,s3,0x4
+ 68a:	397d                	addiw	s2,s2,-1
+ 68c:	fe0916e3          	bnez	s2,678 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 690:	8bea                	mv	s7,s10
+      state = 0;
+ 692:	4981                	li	s3,0
+ 694:	6d02                	ld	s10,0(sp)
+ 696:	bd01                	j	4a6 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 698:	008b8913          	addi	s2,s7,8
+ 69c:	000bc583          	lbu	a1,0(s7)
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	d01ff0ef          	jal	3a2 <putc>
+ 6a6:	8bca                	mv	s7,s2
+      state = 0;
+ 6a8:	4981                	li	s3,0
+ 6aa:	bbf5                	j	4a6 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ac:	008b8993          	addi	s3,s7,8
+ 6b0:	000bb903          	ld	s2,0(s7)
+ 6b4:	00090f63          	beqz	s2,6d2 <vprintf+0x276>
+        for(; *s; s++)
+ 6b8:	00094583          	lbu	a1,0(s2)
+ 6bc:	c195                	beqz	a1,6e0 <vprintf+0x284>
+          putc(fd, *s);
+ 6be:	855a                	mv	a0,s6
+ 6c0:	ce3ff0ef          	jal	3a2 <putc>
+        for(; *s; s++)
+ 6c4:	0905                	addi	s2,s2,1
+ 6c6:	00094583          	lbu	a1,0(s2)
+ 6ca:	f9f5                	bnez	a1,6be <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6cc:	8bce                	mv	s7,s3
+      state = 0;
+ 6ce:	4981                	li	s3,0
+ 6d0:	bbd9                	j	4a6 <vprintf+0x4a>
+          s = "(null)";
+ 6d2:	00000917          	auipc	s2,0x0
+ 6d6:	24690913          	addi	s2,s2,582 # 918 <malloc+0x13a>
+        for(; *s; s++)
+ 6da:	02800593          	li	a1,40
+ 6de:	b7c5                	j	6be <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6e0:	8bce                	mv	s7,s3
+      state = 0;
+ 6e2:	4981                	li	s3,0
+ 6e4:	b3c9                	j	4a6 <vprintf+0x4a>
+ 6e6:	64a6                	ld	s1,72(sp)
+ 6e8:	79e2                	ld	s3,56(sp)
+ 6ea:	7a42                	ld	s4,48(sp)
+ 6ec:	7aa2                	ld	s5,40(sp)
+ 6ee:	7b02                	ld	s6,32(sp)
+ 6f0:	6be2                	ld	s7,24(sp)
+ 6f2:	6c42                	ld	s8,16(sp)
+ 6f4:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6f6:	60e6                	ld	ra,88(sp)
+ 6f8:	6446                	ld	s0,80(sp)
+ 6fa:	6906                	ld	s2,64(sp)
+ 6fc:	6125                	addi	sp,sp,96
+ 6fe:	8082                	ret
+
+0000000000000700 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 700:	715d                	addi	sp,sp,-80
+ 702:	ec06                	sd	ra,24(sp)
+ 704:	e822                	sd	s0,16(sp)
+ 706:	1000                	addi	s0,sp,32
+ 708:	e010                	sd	a2,0(s0)
+ 70a:	e414                	sd	a3,8(s0)
+ 70c:	e818                	sd	a4,16(s0)
+ 70e:	ec1c                	sd	a5,24(s0)
+ 710:	03043023          	sd	a6,32(s0)
+ 714:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 718:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 71c:	8622                	mv	a2,s0
+ 71e:	d3fff0ef          	jal	45c <vprintf>
+}
+ 722:	60e2                	ld	ra,24(sp)
+ 724:	6442                	ld	s0,16(sp)
+ 726:	6161                	addi	sp,sp,80
+ 728:	8082                	ret
+
+000000000000072a <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 72a:	711d                	addi	sp,sp,-96
+ 72c:	ec06                	sd	ra,24(sp)
+ 72e:	e822                	sd	s0,16(sp)
+ 730:	1000                	addi	s0,sp,32
+ 732:	e40c                	sd	a1,8(s0)
+ 734:	e810                	sd	a2,16(s0)
+ 736:	ec14                	sd	a3,24(s0)
+ 738:	f018                	sd	a4,32(s0)
+ 73a:	f41c                	sd	a5,40(s0)
+ 73c:	03043823          	sd	a6,48(s0)
+ 740:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 744:	00840613          	addi	a2,s0,8
+ 748:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 74c:	85aa                	mv	a1,a0
+ 74e:	4505                	li	a0,1
+ 750:	d0dff0ef          	jal	45c <vprintf>
+}
+ 754:	60e2                	ld	ra,24(sp)
+ 756:	6442                	ld	s0,16(sp)
+ 758:	6125                	addi	sp,sp,96
+ 75a:	8082                	ret
+
+000000000000075c <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 75c:	1141                	addi	sp,sp,-16
+ 75e:	e422                	sd	s0,8(sp)
+ 760:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 762:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 766:	00001797          	auipc	a5,0x1
+ 76a:	89a7b783          	ld	a5,-1894(a5) # 1000 <freep>
+ 76e:	a02d                	j	798 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 770:	4618                	lw	a4,8(a2)
+ 772:	9f2d                	addw	a4,a4,a1
+ 774:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 778:	6398                	ld	a4,0(a5)
+ 77a:	6310                	ld	a2,0(a4)
+ 77c:	a83d                	j	7ba <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 77e:	ff852703          	lw	a4,-8(a0)
+ 782:	9f31                	addw	a4,a4,a2
+ 784:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 786:	ff053683          	ld	a3,-16(a0)
+ 78a:	a091                	j	7ce <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 78c:	6398                	ld	a4,0(a5)
+ 78e:	00e7e463          	bltu	a5,a4,796 <free+0x3a>
+ 792:	00e6ea63          	bltu	a3,a4,7a6 <free+0x4a>
+{
+ 796:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 798:	fed7fae3          	bgeu	a5,a3,78c <free+0x30>
+ 79c:	6398                	ld	a4,0(a5)
+ 79e:	00e6e463          	bltu	a3,a4,7a6 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7a2:	fee7eae3          	bltu	a5,a4,796 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7a6:	ff852583          	lw	a1,-8(a0)
+ 7aa:	6390                	ld	a2,0(a5)
+ 7ac:	02059813          	slli	a6,a1,0x20
+ 7b0:	01c85713          	srli	a4,a6,0x1c
+ 7b4:	9736                	add	a4,a4,a3
+ 7b6:	fae60de3          	beq	a2,a4,770 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7ba:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7be:	4790                	lw	a2,8(a5)
+ 7c0:	02061593          	slli	a1,a2,0x20
+ 7c4:	01c5d713          	srli	a4,a1,0x1c
+ 7c8:	973e                	add	a4,a4,a5
+ 7ca:	fae68ae3          	beq	a3,a4,77e <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7ce:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7d0:	00001717          	auipc	a4,0x1
+ 7d4:	82f73823          	sd	a5,-2000(a4) # 1000 <freep>
+}
+ 7d8:	6422                	ld	s0,8(sp)
+ 7da:	0141                	addi	sp,sp,16
+ 7dc:	8082                	ret
+
+00000000000007de <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7de:	7139                	addi	sp,sp,-64
+ 7e0:	fc06                	sd	ra,56(sp)
+ 7e2:	f822                	sd	s0,48(sp)
+ 7e4:	f426                	sd	s1,40(sp)
+ 7e6:	ec4e                	sd	s3,24(sp)
+ 7e8:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7ea:	02051493          	slli	s1,a0,0x20
+ 7ee:	9081                	srli	s1,s1,0x20
+ 7f0:	04bd                	addi	s1,s1,15
+ 7f2:	8091                	srli	s1,s1,0x4
+ 7f4:	0014899b          	addiw	s3,s1,1
+ 7f8:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7fa:	00001517          	auipc	a0,0x1
+ 7fe:	80653503          	ld	a0,-2042(a0) # 1000 <freep>
+ 802:	c915                	beqz	a0,836 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 804:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 806:	4798                	lw	a4,8(a5)
+ 808:	08977a63          	bgeu	a4,s1,89c <malloc+0xbe>
+ 80c:	f04a                	sd	s2,32(sp)
+ 80e:	e852                	sd	s4,16(sp)
+ 810:	e456                	sd	s5,8(sp)
+ 812:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 814:	8a4e                	mv	s4,s3
+ 816:	0009871b          	sext.w	a4,s3
+ 81a:	6685                	lui	a3,0x1
+ 81c:	00d77363          	bgeu	a4,a3,822 <malloc+0x44>
+ 820:	6a05                	lui	s4,0x1
+ 822:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 826:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 82a:	00000917          	auipc	s2,0x0
+ 82e:	7d690913          	addi	s2,s2,2006 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 832:	5afd                	li	s5,-1
+ 834:	a081                	j	874 <malloc+0x96>
+ 836:	f04a                	sd	s2,32(sp)
+ 838:	e852                	sd	s4,16(sp)
+ 83a:	e456                	sd	s5,8(sp)
+ 83c:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 83e:	00000797          	auipc	a5,0x0
+ 842:	7d278793          	addi	a5,a5,2002 # 1010 <base>
+ 846:	00000717          	auipc	a4,0x0
+ 84a:	7af73d23          	sd	a5,1978(a4) # 1000 <freep>
+ 84e:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 850:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 854:	b7c1                	j	814 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 856:	6398                	ld	a4,0(a5)
+ 858:	e118                	sd	a4,0(a0)
+ 85a:	a8a9                	j	8b4 <malloc+0xd6>
+  hp->s.size = nu;
+ 85c:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 860:	0541                	addi	a0,a0,16
+ 862:	efbff0ef          	jal	75c <free>
+  return freep;
+ 866:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 86a:	c12d                	beqz	a0,8cc <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 86c:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 86e:	4798                	lw	a4,8(a5)
+ 870:	02977263          	bgeu	a4,s1,894 <malloc+0xb6>
+    if(p == freep)
+ 874:	00093703          	ld	a4,0(s2)
+ 878:	853e                	mv	a0,a5
+ 87a:	fef719e3          	bne	a4,a5,86c <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 87e:	8552                	mv	a0,s4
+ 880:	a47ff0ef          	jal	2c6 <sbrk>
+  if(p == SBRK_ERROR)
+ 884:	fd551ce3          	bne	a0,s5,85c <malloc+0x7e>
+        return 0;
+ 888:	4501                	li	a0,0
+ 88a:	7902                	ld	s2,32(sp)
+ 88c:	6a42                	ld	s4,16(sp)
+ 88e:	6aa2                	ld	s5,8(sp)
+ 890:	6b02                	ld	s6,0(sp)
+ 892:	a03d                	j	8c0 <malloc+0xe2>
+ 894:	7902                	ld	s2,32(sp)
+ 896:	6a42                	ld	s4,16(sp)
+ 898:	6aa2                	ld	s5,8(sp)
+ 89a:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 89c:	fae48de3          	beq	s1,a4,856 <malloc+0x78>
+        p->s.size -= nunits;
+ 8a0:	4137073b          	subw	a4,a4,s3
+ 8a4:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8a6:	02071693          	slli	a3,a4,0x20
+ 8aa:	01c6d713          	srli	a4,a3,0x1c
+ 8ae:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 8b0:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8b4:	00000717          	auipc	a4,0x0
+ 8b8:	74a73623          	sd	a0,1868(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8bc:	01078513          	addi	a0,a5,16
+  }
+}
+ 8c0:	70e2                	ld	ra,56(sp)
+ 8c2:	7442                	ld	s0,48(sp)
+ 8c4:	74a2                	ld	s1,40(sp)
+ 8c6:	69e2                	ld	s3,24(sp)
+ 8c8:	6121                	addi	sp,sp,64
+ 8ca:	8082                	ret
+ 8cc:	7902                	ld	s2,32(sp)
+ 8ce:	6a42                	ld	s4,16(sp)
+ 8d0:	6aa2                	ld	s5,8(sp)
+ 8d2:	6b02                	ld	s6,0(sp)
+ 8d4:	b7f5                	j	8c0 <malloc+0xe2>
diff -ruN xv6-riscv/user/mkdir.d xv62/user/mkdir.d
--- xv6-riscv/user/mkdir.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/mkdir.d	2025-09-14 12:32:51.100883269 +0000
@@ -0,0 +1 @@
+user/mkdir.o: user/mkdir.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/mkdir.o and xv62/user/mkdir.o differ
diff -ruN xv6-riscv/user/mkdir.sym xv62/user/mkdir.sym
--- xv6-riscv/user/mkdir.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/mkdir.sym	2025-09-14 12:32:51.116883266 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008d8 .rodata
+0000000000000938 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 mkdir.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003a2 putc
+00000000000003c0 printint
+0000000000000920 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+0000000000000076 strcpy
+000000000000038a pause
+000000000000072a printf
+0000000000000382 sys_sbrk
+0000000000000220 memmove
+0000000000000342 mknod
+000000000000012e gets
+000000000000037a getpid
+00000000000002b2 memcpy
+00000000000007de malloc
+00000000000002dc sbrklazy
+000000000000030a pipe
+000000000000031a write
+0000000000000352 fstat
+0000000000000700 fprintf
+000000000000032a kill
+000000000000045c vprintf
+000000000000036a chdir
+0000000000000332 exec
+0000000000000302 wait
+0000000000000312 read
+000000000000034a unlink
+0000000000000278 memcmp
+00000000000002f2 fork
+00000000000002c6 sbrk
+0000000000000392 uptime
+00000000000000e8 memset
+0000000000000000 main
+0000000000000092 strcmp
+0000000000000372 dup
+000000000000039a getreadcount
+000000000000019e stat
+000000000000035a link
+00000000000002fa exit
+0000000000000066 start
+00000000000001d8 atoi
+00000000000000be strlen
+000000000000033a open
+000000000000010a strchr
+0000000000000362 mkdir
+0000000000000322 close
+000000000000075c free
diff -ruN xv6-riscv/user/printf.d xv62/user/printf.d
--- xv6-riscv/user/printf.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/printf.d	2025-09-14 12:32:50.512883390 +0000
@@ -0,0 +1,2 @@
+user/printf.o: user/printf.c kernel/types.h kernel/stat.h user/user.h \
+ /usr/lib/gcc-cross/riscv64-linux-gnu/13/include/stdarg.h
Binary files xv6-riscv/user/printf.o and xv62/user/printf.o differ
diff -ruN xv6-riscv/user/readcount.asm xv62/user/readcount.asm
--- xv6-riscv/user/readcount.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/readcount.asm	2025-09-14 12:32:52.356883012 +0000
@@ -0,0 +1,1564 @@
+
+user/_readcount:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+   0:	7135                	addi	sp,sp,-160
+   2:	ed06                	sd	ra,152(sp)
+   4:	e922                	sd	s0,144(sp)
+   6:	e14a                	sd	s2,128(sp)
+   8:	1100                	addi	s0,sp,160
+    char buf[101];
+    int fd;
+    int before, after, n;
+
+    before = getreadcount();
+   a:	3ee000ef          	jal	3f8 <getreadcount>
+   e:	892a                	mv	s2,a0
+    printf("Initial Count: %d\n", before);
+  10:	85aa                	mv	a1,a0
+  12:	00001517          	auipc	a0,0x1
+  16:	92e50513          	addi	a0,a0,-1746 # 940 <malloc+0x104>
+  1a:	76e000ef          	jal	788 <printf>
+
+    fd = open("README", 0); //im making the assumption that we hahd to implement this guy for readme file and not
+  1e:	4581                	li	a1,0
+  20:	00001517          	auipc	a0,0x1
+  24:	93850513          	addi	a0,a0,-1736 # 958 <malloc+0x11c>
+  28:	370000ef          	jal	398 <open>
+    //for arbitrary files since its not even mentioned properly :((
+    if(fd < 0){
+  2c:	06054263          	bltz	a0,90 <main+0x90>
+  30:	e526                	sd	s1,136(sp)
+  32:	fcce                	sd	s3,120(sp)
+  34:	84aa                	mv	s1,a0
+        printf("README prolly doesnt exist\n");
+        exit(1);
+    }
+
+    n = read(fd, buf, 100);
+  36:	06400613          	li	a2,100
+  3a:	f6840593          	addi	a1,s0,-152
+  3e:	332000ef          	jal	370 <read>
+  42:	89aa                	mv	s3,a0
+    if(n < 0){
+  44:	06054163          	bltz	a0,a6 <main+0xa6>
+        printf("Not able to read\n");
+    } else {
+        
+        if(n < 100) buf[n] = '\0';
+  48:	06300793          	li	a5,99
+  4c:	00a7c763          	blt	a5,a0,5a <main+0x5a>
+  50:	fd050793          	addi	a5,a0,-48
+  54:	97a2                	add	a5,a5,s0
+  56:	f8078c23          	sb	zero,-104(a5)
+    }
+    close(fd);
+  5a:	8526                	mv	a0,s1
+  5c:	324000ef          	jal	380 <close>
+
+    after = getreadcount();
+  60:	398000ef          	jal	3f8 <getreadcount>
+  64:	84aa                	mv	s1,a0
+    printf("Bytes reading...: %d\n", n);
+  66:	85ce                	mv	a1,s3
+  68:	00001517          	auipc	a0,0x1
+  6c:	93050513          	addi	a0,a0,-1744 # 998 <malloc+0x15c>
+  70:	718000ef          	jal	788 <printf>
+    printf("Bytes afterrr: %d\n", after);
+  74:	85a6                	mv	a1,s1
+  76:	00001517          	auipc	a0,0x1
+  7a:	93a50513          	addi	a0,a0,-1734 # 9b0 <malloc+0x174>
+  7e:	70a000ef          	jal	788 <printf>
+
+    // verification also gib extra marks plej
+    if(after - before != n){
+  82:	4124863b          	subw	a2,s1,s2
+  86:	03361763          	bne	a2,s3,b4 <main+0xb4>
+        printf("Warning: expected increase %d, observed %d\n", n, after - before);
+    }
+
+    exit(0);
+  8a:	4501                	li	a0,0
+  8c:	2cc000ef          	jal	358 <exit>
+  90:	e526                	sd	s1,136(sp)
+  92:	fcce                	sd	s3,120(sp)
+        printf("README prolly doesnt exist\n");
+  94:	00001517          	auipc	a0,0x1
+  98:	8cc50513          	addi	a0,a0,-1844 # 960 <malloc+0x124>
+  9c:	6ec000ef          	jal	788 <printf>
+        exit(1);
+  a0:	4505                	li	a0,1
+  a2:	2b6000ef          	jal	358 <exit>
+        printf("Not able to read\n");
+  a6:	00001517          	auipc	a0,0x1
+  aa:	8da50513          	addi	a0,a0,-1830 # 980 <malloc+0x144>
+  ae:	6da000ef          	jal	788 <printf>
+  b2:	b765                	j	5a <main+0x5a>
+        printf("Warning: expected increase %d, observed %d\n", n, after - before);
+  b4:	85ce                	mv	a1,s3
+  b6:	00001517          	auipc	a0,0x1
+  ba:	91250513          	addi	a0,a0,-1774 # 9c8 <malloc+0x18c>
+  be:	6ca000ef          	jal	788 <printf>
+  c2:	b7e1                	j	8a <main+0x8a>
+
+00000000000000c4 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  c4:	1141                	addi	sp,sp,-16
+  c6:	e406                	sd	ra,8(sp)
+  c8:	e022                	sd	s0,0(sp)
+  ca:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  cc:	f35ff0ef          	jal	0 <main>
+  exit(r);
+  d0:	288000ef          	jal	358 <exit>
+
+00000000000000d4 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  d4:	1141                	addi	sp,sp,-16
+  d6:	e422                	sd	s0,8(sp)
+  d8:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  da:	87aa                	mv	a5,a0
+  dc:	0585                	addi	a1,a1,1
+  de:	0785                	addi	a5,a5,1
+  e0:	fff5c703          	lbu	a4,-1(a1)
+  e4:	fee78fa3          	sb	a4,-1(a5)
+  e8:	fb75                	bnez	a4,dc <strcpy+0x8>
+    ;
+  return os;
+}
+  ea:	6422                	ld	s0,8(sp)
+  ec:	0141                	addi	sp,sp,16
+  ee:	8082                	ret
+
+00000000000000f0 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  f0:	1141                	addi	sp,sp,-16
+  f2:	e422                	sd	s0,8(sp)
+  f4:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  f6:	00054783          	lbu	a5,0(a0)
+  fa:	cb91                	beqz	a5,10e <strcmp+0x1e>
+  fc:	0005c703          	lbu	a4,0(a1)
+ 100:	00f71763          	bne	a4,a5,10e <strcmp+0x1e>
+    p++, q++;
+ 104:	0505                	addi	a0,a0,1
+ 106:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 108:	00054783          	lbu	a5,0(a0)
+ 10c:	fbe5                	bnez	a5,fc <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 10e:	0005c503          	lbu	a0,0(a1)
+}
+ 112:	40a7853b          	subw	a0,a5,a0
+ 116:	6422                	ld	s0,8(sp)
+ 118:	0141                	addi	sp,sp,16
+ 11a:	8082                	ret
+
+000000000000011c <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 11c:	1141                	addi	sp,sp,-16
+ 11e:	e422                	sd	s0,8(sp)
+ 120:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 122:	00054783          	lbu	a5,0(a0)
+ 126:	cf91                	beqz	a5,142 <strlen+0x26>
+ 128:	0505                	addi	a0,a0,1
+ 12a:	87aa                	mv	a5,a0
+ 12c:	86be                	mv	a3,a5
+ 12e:	0785                	addi	a5,a5,1
+ 130:	fff7c703          	lbu	a4,-1(a5)
+ 134:	ff65                	bnez	a4,12c <strlen+0x10>
+ 136:	40a6853b          	subw	a0,a3,a0
+ 13a:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 13c:	6422                	ld	s0,8(sp)
+ 13e:	0141                	addi	sp,sp,16
+ 140:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 142:	4501                	li	a0,0
+ 144:	bfe5                	j	13c <strlen+0x20>
+
+0000000000000146 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 146:	1141                	addi	sp,sp,-16
+ 148:	e422                	sd	s0,8(sp)
+ 14a:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 14c:	ca19                	beqz	a2,162 <memset+0x1c>
+ 14e:	87aa                	mv	a5,a0
+ 150:	1602                	slli	a2,a2,0x20
+ 152:	9201                	srli	a2,a2,0x20
+ 154:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 158:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 15c:	0785                	addi	a5,a5,1
+ 15e:	fee79de3          	bne	a5,a4,158 <memset+0x12>
+  }
+  return dst;
+}
+ 162:	6422                	ld	s0,8(sp)
+ 164:	0141                	addi	sp,sp,16
+ 166:	8082                	ret
+
+0000000000000168 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 168:	1141                	addi	sp,sp,-16
+ 16a:	e422                	sd	s0,8(sp)
+ 16c:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 16e:	00054783          	lbu	a5,0(a0)
+ 172:	cb99                	beqz	a5,188 <strchr+0x20>
+    if(*s == c)
+ 174:	00f58763          	beq	a1,a5,182 <strchr+0x1a>
+  for(; *s; s++)
+ 178:	0505                	addi	a0,a0,1
+ 17a:	00054783          	lbu	a5,0(a0)
+ 17e:	fbfd                	bnez	a5,174 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 180:	4501                	li	a0,0
+}
+ 182:	6422                	ld	s0,8(sp)
+ 184:	0141                	addi	sp,sp,16
+ 186:	8082                	ret
+  return 0;
+ 188:	4501                	li	a0,0
+ 18a:	bfe5                	j	182 <strchr+0x1a>
+
+000000000000018c <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 18c:	711d                	addi	sp,sp,-96
+ 18e:	ec86                	sd	ra,88(sp)
+ 190:	e8a2                	sd	s0,80(sp)
+ 192:	e4a6                	sd	s1,72(sp)
+ 194:	e0ca                	sd	s2,64(sp)
+ 196:	fc4e                	sd	s3,56(sp)
+ 198:	f852                	sd	s4,48(sp)
+ 19a:	f456                	sd	s5,40(sp)
+ 19c:	f05a                	sd	s6,32(sp)
+ 19e:	ec5e                	sd	s7,24(sp)
+ 1a0:	1080                	addi	s0,sp,96
+ 1a2:	8baa                	mv	s7,a0
+ 1a4:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1a6:	892a                	mv	s2,a0
+ 1a8:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1aa:	4aa9                	li	s5,10
+ 1ac:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1ae:	89a6                	mv	s3,s1
+ 1b0:	2485                	addiw	s1,s1,1
+ 1b2:	0344d663          	bge	s1,s4,1de <gets+0x52>
+    cc = read(0, &c, 1);
+ 1b6:	4605                	li	a2,1
+ 1b8:	faf40593          	addi	a1,s0,-81
+ 1bc:	4501                	li	a0,0
+ 1be:	1b2000ef          	jal	370 <read>
+    if(cc < 1)
+ 1c2:	00a05e63          	blez	a0,1de <gets+0x52>
+    buf[i++] = c;
+ 1c6:	faf44783          	lbu	a5,-81(s0)
+ 1ca:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1ce:	01578763          	beq	a5,s5,1dc <gets+0x50>
+ 1d2:	0905                	addi	s2,s2,1
+ 1d4:	fd679de3          	bne	a5,s6,1ae <gets+0x22>
+    buf[i++] = c;
+ 1d8:	89a6                	mv	s3,s1
+ 1da:	a011                	j	1de <gets+0x52>
+ 1dc:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1de:	99de                	add	s3,s3,s7
+ 1e0:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1e4:	855e                	mv	a0,s7
+ 1e6:	60e6                	ld	ra,88(sp)
+ 1e8:	6446                	ld	s0,80(sp)
+ 1ea:	64a6                	ld	s1,72(sp)
+ 1ec:	6906                	ld	s2,64(sp)
+ 1ee:	79e2                	ld	s3,56(sp)
+ 1f0:	7a42                	ld	s4,48(sp)
+ 1f2:	7aa2                	ld	s5,40(sp)
+ 1f4:	7b02                	ld	s6,32(sp)
+ 1f6:	6be2                	ld	s7,24(sp)
+ 1f8:	6125                	addi	sp,sp,96
+ 1fa:	8082                	ret
+
+00000000000001fc <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 1fc:	1101                	addi	sp,sp,-32
+ 1fe:	ec06                	sd	ra,24(sp)
+ 200:	e822                	sd	s0,16(sp)
+ 202:	e04a                	sd	s2,0(sp)
+ 204:	1000                	addi	s0,sp,32
+ 206:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 208:	4581                	li	a1,0
+ 20a:	18e000ef          	jal	398 <open>
+  if(fd < 0)
+ 20e:	02054263          	bltz	a0,232 <stat+0x36>
+ 212:	e426                	sd	s1,8(sp)
+ 214:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 216:	85ca                	mv	a1,s2
+ 218:	198000ef          	jal	3b0 <fstat>
+ 21c:	892a                	mv	s2,a0
+  close(fd);
+ 21e:	8526                	mv	a0,s1
+ 220:	160000ef          	jal	380 <close>
+  return r;
+ 224:	64a2                	ld	s1,8(sp)
+}
+ 226:	854a                	mv	a0,s2
+ 228:	60e2                	ld	ra,24(sp)
+ 22a:	6442                	ld	s0,16(sp)
+ 22c:	6902                	ld	s2,0(sp)
+ 22e:	6105                	addi	sp,sp,32
+ 230:	8082                	ret
+    return -1;
+ 232:	597d                	li	s2,-1
+ 234:	bfcd                	j	226 <stat+0x2a>
+
+0000000000000236 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 236:	1141                	addi	sp,sp,-16
+ 238:	e422                	sd	s0,8(sp)
+ 23a:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 23c:	00054683          	lbu	a3,0(a0)
+ 240:	fd06879b          	addiw	a5,a3,-48
+ 244:	0ff7f793          	zext.b	a5,a5
+ 248:	4625                	li	a2,9
+ 24a:	02f66863          	bltu	a2,a5,27a <atoi+0x44>
+ 24e:	872a                	mv	a4,a0
+  n = 0;
+ 250:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 252:	0705                	addi	a4,a4,1
+ 254:	0025179b          	slliw	a5,a0,0x2
+ 258:	9fa9                	addw	a5,a5,a0
+ 25a:	0017979b          	slliw	a5,a5,0x1
+ 25e:	9fb5                	addw	a5,a5,a3
+ 260:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 264:	00074683          	lbu	a3,0(a4)
+ 268:	fd06879b          	addiw	a5,a3,-48
+ 26c:	0ff7f793          	zext.b	a5,a5
+ 270:	fef671e3          	bgeu	a2,a5,252 <atoi+0x1c>
+  return n;
+}
+ 274:	6422                	ld	s0,8(sp)
+ 276:	0141                	addi	sp,sp,16
+ 278:	8082                	ret
+  n = 0;
+ 27a:	4501                	li	a0,0
+ 27c:	bfe5                	j	274 <atoi+0x3e>
+
+000000000000027e <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 27e:	1141                	addi	sp,sp,-16
+ 280:	e422                	sd	s0,8(sp)
+ 282:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 284:	02b57463          	bgeu	a0,a1,2ac <memmove+0x2e>
+    while(n-- > 0)
+ 288:	00c05f63          	blez	a2,2a6 <memmove+0x28>
+ 28c:	1602                	slli	a2,a2,0x20
+ 28e:	9201                	srli	a2,a2,0x20
+ 290:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 294:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 296:	0585                	addi	a1,a1,1
+ 298:	0705                	addi	a4,a4,1
+ 29a:	fff5c683          	lbu	a3,-1(a1)
+ 29e:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2a2:	fef71ae3          	bne	a4,a5,296 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2a6:	6422                	ld	s0,8(sp)
+ 2a8:	0141                	addi	sp,sp,16
+ 2aa:	8082                	ret
+    dst += n;
+ 2ac:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2b0:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2b2:	fec05ae3          	blez	a2,2a6 <memmove+0x28>
+ 2b6:	fff6079b          	addiw	a5,a2,-1
+ 2ba:	1782                	slli	a5,a5,0x20
+ 2bc:	9381                	srli	a5,a5,0x20
+ 2be:	fff7c793          	not	a5,a5
+ 2c2:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2c4:	15fd                	addi	a1,a1,-1
+ 2c6:	177d                	addi	a4,a4,-1
+ 2c8:	0005c683          	lbu	a3,0(a1)
+ 2cc:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2d0:	fee79ae3          	bne	a5,a4,2c4 <memmove+0x46>
+ 2d4:	bfc9                	j	2a6 <memmove+0x28>
+
+00000000000002d6 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2d6:	1141                	addi	sp,sp,-16
+ 2d8:	e422                	sd	s0,8(sp)
+ 2da:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2dc:	ca05                	beqz	a2,30c <memcmp+0x36>
+ 2de:	fff6069b          	addiw	a3,a2,-1
+ 2e2:	1682                	slli	a3,a3,0x20
+ 2e4:	9281                	srli	a3,a3,0x20
+ 2e6:	0685                	addi	a3,a3,1
+ 2e8:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2ea:	00054783          	lbu	a5,0(a0)
+ 2ee:	0005c703          	lbu	a4,0(a1)
+ 2f2:	00e79863          	bne	a5,a4,302 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 2f6:	0505                	addi	a0,a0,1
+    p2++;
+ 2f8:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 2fa:	fed518e3          	bne	a0,a3,2ea <memcmp+0x14>
+  }
+  return 0;
+ 2fe:	4501                	li	a0,0
+ 300:	a019                	j	306 <memcmp+0x30>
+      return *p1 - *p2;
+ 302:	40e7853b          	subw	a0,a5,a4
+}
+ 306:	6422                	ld	s0,8(sp)
+ 308:	0141                	addi	sp,sp,16
+ 30a:	8082                	ret
+  return 0;
+ 30c:	4501                	li	a0,0
+ 30e:	bfe5                	j	306 <memcmp+0x30>
+
+0000000000000310 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 310:	1141                	addi	sp,sp,-16
+ 312:	e406                	sd	ra,8(sp)
+ 314:	e022                	sd	s0,0(sp)
+ 316:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 318:	f67ff0ef          	jal	27e <memmove>
+}
+ 31c:	60a2                	ld	ra,8(sp)
+ 31e:	6402                	ld	s0,0(sp)
+ 320:	0141                	addi	sp,sp,16
+ 322:	8082                	ret
+
+0000000000000324 <sbrk>:
+
+char *
+sbrk(int n) {
+ 324:	1141                	addi	sp,sp,-16
+ 326:	e406                	sd	ra,8(sp)
+ 328:	e022                	sd	s0,0(sp)
+ 32a:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 32c:	4585                	li	a1,1
+ 32e:	0b2000ef          	jal	3e0 <sys_sbrk>
+}
+ 332:	60a2                	ld	ra,8(sp)
+ 334:	6402                	ld	s0,0(sp)
+ 336:	0141                	addi	sp,sp,16
+ 338:	8082                	ret
+
+000000000000033a <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 33a:	1141                	addi	sp,sp,-16
+ 33c:	e406                	sd	ra,8(sp)
+ 33e:	e022                	sd	s0,0(sp)
+ 340:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 342:	4589                	li	a1,2
+ 344:	09c000ef          	jal	3e0 <sys_sbrk>
+}
+ 348:	60a2                	ld	ra,8(sp)
+ 34a:	6402                	ld	s0,0(sp)
+ 34c:	0141                	addi	sp,sp,16
+ 34e:	8082                	ret
+
+0000000000000350 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 350:	4885                	li	a7,1
+ ecall
+ 352:	00000073          	ecall
+ ret
+ 356:	8082                	ret
+
+0000000000000358 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 358:	4889                	li	a7,2
+ ecall
+ 35a:	00000073          	ecall
+ ret
+ 35e:	8082                	ret
+
+0000000000000360 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 360:	488d                	li	a7,3
+ ecall
+ 362:	00000073          	ecall
+ ret
+ 366:	8082                	ret
+
+0000000000000368 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 368:	4891                	li	a7,4
+ ecall
+ 36a:	00000073          	ecall
+ ret
+ 36e:	8082                	ret
+
+0000000000000370 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 370:	4895                	li	a7,5
+ ecall
+ 372:	00000073          	ecall
+ ret
+ 376:	8082                	ret
+
+0000000000000378 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 378:	48c1                	li	a7,16
+ ecall
+ 37a:	00000073          	ecall
+ ret
+ 37e:	8082                	ret
+
+0000000000000380 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 380:	48d5                	li	a7,21
+ ecall
+ 382:	00000073          	ecall
+ ret
+ 386:	8082                	ret
+
+0000000000000388 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 388:	4899                	li	a7,6
+ ecall
+ 38a:	00000073          	ecall
+ ret
+ 38e:	8082                	ret
+
+0000000000000390 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 390:	489d                	li	a7,7
+ ecall
+ 392:	00000073          	ecall
+ ret
+ 396:	8082                	ret
+
+0000000000000398 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 398:	48bd                	li	a7,15
+ ecall
+ 39a:	00000073          	ecall
+ ret
+ 39e:	8082                	ret
+
+00000000000003a0 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3a0:	48c5                	li	a7,17
+ ecall
+ 3a2:	00000073          	ecall
+ ret
+ 3a6:	8082                	ret
+
+00000000000003a8 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3a8:	48c9                	li	a7,18
+ ecall
+ 3aa:	00000073          	ecall
+ ret
+ 3ae:	8082                	ret
+
+00000000000003b0 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3b0:	48a1                	li	a7,8
+ ecall
+ 3b2:	00000073          	ecall
+ ret
+ 3b6:	8082                	ret
+
+00000000000003b8 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3b8:	48cd                	li	a7,19
+ ecall
+ 3ba:	00000073          	ecall
+ ret
+ 3be:	8082                	ret
+
+00000000000003c0 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3c0:	48d1                	li	a7,20
+ ecall
+ 3c2:	00000073          	ecall
+ ret
+ 3c6:	8082                	ret
+
+00000000000003c8 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3c8:	48a5                	li	a7,9
+ ecall
+ 3ca:	00000073          	ecall
+ ret
+ 3ce:	8082                	ret
+
+00000000000003d0 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3d0:	48a9                	li	a7,10
+ ecall
+ 3d2:	00000073          	ecall
+ ret
+ 3d6:	8082                	ret
+
+00000000000003d8 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3d8:	48ad                	li	a7,11
+ ecall
+ 3da:	00000073          	ecall
+ ret
+ 3de:	8082                	ret
+
+00000000000003e0 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3e0:	48b1                	li	a7,12
+ ecall
+ 3e2:	00000073          	ecall
+ ret
+ 3e6:	8082                	ret
+
+00000000000003e8 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3e8:	48b5                	li	a7,13
+ ecall
+ 3ea:	00000073          	ecall
+ ret
+ 3ee:	8082                	ret
+
+00000000000003f0 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 3f0:	48b9                	li	a7,14
+ ecall
+ 3f2:	00000073          	ecall
+ ret
+ 3f6:	8082                	ret
+
+00000000000003f8 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 3f8:	48d9                	li	a7,22
+ ecall
+ 3fa:	00000073          	ecall
+ ret
+ 3fe:	8082                	ret
+
+0000000000000400 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 400:	1101                	addi	sp,sp,-32
+ 402:	ec06                	sd	ra,24(sp)
+ 404:	e822                	sd	s0,16(sp)
+ 406:	1000                	addi	s0,sp,32
+ 408:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 40c:	4605                	li	a2,1
+ 40e:	fef40593          	addi	a1,s0,-17
+ 412:	f67ff0ef          	jal	378 <write>
+}
+ 416:	60e2                	ld	ra,24(sp)
+ 418:	6442                	ld	s0,16(sp)
+ 41a:	6105                	addi	sp,sp,32
+ 41c:	8082                	ret
+
+000000000000041e <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 41e:	715d                	addi	sp,sp,-80
+ 420:	e486                	sd	ra,72(sp)
+ 422:	e0a2                	sd	s0,64(sp)
+ 424:	f84a                	sd	s2,48(sp)
+ 426:	0880                	addi	s0,sp,80
+ 428:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 42a:	c299                	beqz	a3,430 <printint+0x12>
+ 42c:	0805c363          	bltz	a1,4b2 <printint+0x94>
+  neg = 0;
+ 430:	4881                	li	a7,0
+ 432:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 436:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 438:	00000517          	auipc	a0,0x0
+ 43c:	5c850513          	addi	a0,a0,1480 # a00 <digits>
+ 440:	883e                	mv	a6,a5
+ 442:	2785                	addiw	a5,a5,1
+ 444:	02c5f733          	remu	a4,a1,a2
+ 448:	972a                	add	a4,a4,a0
+ 44a:	00074703          	lbu	a4,0(a4)
+ 44e:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 452:	872e                	mv	a4,a1
+ 454:	02c5d5b3          	divu	a1,a1,a2
+ 458:	0685                	addi	a3,a3,1
+ 45a:	fec773e3          	bgeu	a4,a2,440 <printint+0x22>
+  if(neg)
+ 45e:	00088b63          	beqz	a7,474 <printint+0x56>
+    buf[i++] = '-';
+ 462:	fd078793          	addi	a5,a5,-48
+ 466:	97a2                	add	a5,a5,s0
+ 468:	02d00713          	li	a4,45
+ 46c:	fee78423          	sb	a4,-24(a5)
+ 470:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 474:	02f05a63          	blez	a5,4a8 <printint+0x8a>
+ 478:	fc26                	sd	s1,56(sp)
+ 47a:	f44e                	sd	s3,40(sp)
+ 47c:	fb840713          	addi	a4,s0,-72
+ 480:	00f704b3          	add	s1,a4,a5
+ 484:	fff70993          	addi	s3,a4,-1
+ 488:	99be                	add	s3,s3,a5
+ 48a:	37fd                	addiw	a5,a5,-1
+ 48c:	1782                	slli	a5,a5,0x20
+ 48e:	9381                	srli	a5,a5,0x20
+ 490:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 494:	fff4c583          	lbu	a1,-1(s1)
+ 498:	854a                	mv	a0,s2
+ 49a:	f67ff0ef          	jal	400 <putc>
+  while(--i >= 0)
+ 49e:	14fd                	addi	s1,s1,-1
+ 4a0:	ff349ae3          	bne	s1,s3,494 <printint+0x76>
+ 4a4:	74e2                	ld	s1,56(sp)
+ 4a6:	79a2                	ld	s3,40(sp)
+}
+ 4a8:	60a6                	ld	ra,72(sp)
+ 4aa:	6406                	ld	s0,64(sp)
+ 4ac:	7942                	ld	s2,48(sp)
+ 4ae:	6161                	addi	sp,sp,80
+ 4b0:	8082                	ret
+    x = -xx;
+ 4b2:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4b6:	4885                	li	a7,1
+    x = -xx;
+ 4b8:	bfad                	j	432 <printint+0x14>
+
+00000000000004ba <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4ba:	711d                	addi	sp,sp,-96
+ 4bc:	ec86                	sd	ra,88(sp)
+ 4be:	e8a2                	sd	s0,80(sp)
+ 4c0:	e0ca                	sd	s2,64(sp)
+ 4c2:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 4c4:	0005c903          	lbu	s2,0(a1)
+ 4c8:	28090663          	beqz	s2,754 <vprintf+0x29a>
+ 4cc:	e4a6                	sd	s1,72(sp)
+ 4ce:	fc4e                	sd	s3,56(sp)
+ 4d0:	f852                	sd	s4,48(sp)
+ 4d2:	f456                	sd	s5,40(sp)
+ 4d4:	f05a                	sd	s6,32(sp)
+ 4d6:	ec5e                	sd	s7,24(sp)
+ 4d8:	e862                	sd	s8,16(sp)
+ 4da:	e466                	sd	s9,8(sp)
+ 4dc:	8b2a                	mv	s6,a0
+ 4de:	8a2e                	mv	s4,a1
+ 4e0:	8bb2                	mv	s7,a2
+  state = 0;
+ 4e2:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 4e4:	4481                	li	s1,0
+ 4e6:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 4e8:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 4ec:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4f0:	06c00c93          	li	s9,108
+ 4f4:	a005                	j	514 <vprintf+0x5a>
+        putc(fd, c0);
+ 4f6:	85ca                	mv	a1,s2
+ 4f8:	855a                	mv	a0,s6
+ 4fa:	f07ff0ef          	jal	400 <putc>
+ 4fe:	a019                	j	504 <vprintf+0x4a>
+    } else if(state == '%'){
+ 500:	03598263          	beq	s3,s5,524 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 504:	2485                	addiw	s1,s1,1
+ 506:	8726                	mv	a4,s1
+ 508:	009a07b3          	add	a5,s4,s1
+ 50c:	0007c903          	lbu	s2,0(a5)
+ 510:	22090a63          	beqz	s2,744 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 514:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 518:	fe0994e3          	bnez	s3,500 <vprintf+0x46>
+      if(c0 == '%'){
+ 51c:	fd579de3          	bne	a5,s5,4f6 <vprintf+0x3c>
+        state = '%';
+ 520:	89be                	mv	s3,a5
+ 522:	b7cd                	j	504 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 524:	00ea06b3          	add	a3,s4,a4
+ 528:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 52c:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 52e:	c681                	beqz	a3,536 <vprintf+0x7c>
+ 530:	9752                	add	a4,a4,s4
+ 532:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 536:	05878363          	beq	a5,s8,57c <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 53a:	05978d63          	beq	a5,s9,594 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 53e:	07500713          	li	a4,117
+ 542:	0ee78763          	beq	a5,a4,630 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 546:	07800713          	li	a4,120
+ 54a:	12e78963          	beq	a5,a4,67c <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 54e:	07000713          	li	a4,112
+ 552:	14e78e63          	beq	a5,a4,6ae <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 556:	06300713          	li	a4,99
+ 55a:	18e78e63          	beq	a5,a4,6f6 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 55e:	07300713          	li	a4,115
+ 562:	1ae78463          	beq	a5,a4,70a <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 566:	02500713          	li	a4,37
+ 56a:	04e79563          	bne	a5,a4,5b4 <vprintf+0xfa>
+        putc(fd, '%');
+ 56e:	02500593          	li	a1,37
+ 572:	855a                	mv	a0,s6
+ 574:	e8dff0ef          	jal	400 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 578:	4981                	li	s3,0
+ 57a:	b769                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 57c:	008b8913          	addi	s2,s7,8
+ 580:	4685                	li	a3,1
+ 582:	4629                	li	a2,10
+ 584:	000ba583          	lw	a1,0(s7)
+ 588:	855a                	mv	a0,s6
+ 58a:	e95ff0ef          	jal	41e <printint>
+ 58e:	8bca                	mv	s7,s2
+      state = 0;
+ 590:	4981                	li	s3,0
+ 592:	bf8d                	j	504 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 594:	06400793          	li	a5,100
+ 598:	02f68963          	beq	a3,a5,5ca <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 59c:	06c00793          	li	a5,108
+ 5a0:	04f68263          	beq	a3,a5,5e4 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 5a4:	07500793          	li	a5,117
+ 5a8:	0af68063          	beq	a3,a5,648 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5ac:	07800793          	li	a5,120
+ 5b0:	0ef68263          	beq	a3,a5,694 <vprintf+0x1da>
+        putc(fd, '%');
+ 5b4:	02500593          	li	a1,37
+ 5b8:	855a                	mv	a0,s6
+ 5ba:	e47ff0ef          	jal	400 <putc>
+        putc(fd, c0);
+ 5be:	85ca                	mv	a1,s2
+ 5c0:	855a                	mv	a0,s6
+ 5c2:	e3fff0ef          	jal	400 <putc>
+      state = 0;
+ 5c6:	4981                	li	s3,0
+ 5c8:	bf35                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5ca:	008b8913          	addi	s2,s7,8
+ 5ce:	4685                	li	a3,1
+ 5d0:	4629                	li	a2,10
+ 5d2:	000bb583          	ld	a1,0(s7)
+ 5d6:	855a                	mv	a0,s6
+ 5d8:	e47ff0ef          	jal	41e <printint>
+        i += 1;
+ 5dc:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5de:	8bca                	mv	s7,s2
+      state = 0;
+ 5e0:	4981                	li	s3,0
+        i += 1;
+ 5e2:	b70d                	j	504 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5e4:	06400793          	li	a5,100
+ 5e8:	02f60763          	beq	a2,a5,616 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 5ec:	07500793          	li	a5,117
+ 5f0:	06f60963          	beq	a2,a5,662 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 5f4:	07800793          	li	a5,120
+ 5f8:	faf61ee3          	bne	a2,a5,5b4 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5fc:	008b8913          	addi	s2,s7,8
+ 600:	4681                	li	a3,0
+ 602:	4641                	li	a2,16
+ 604:	000bb583          	ld	a1,0(s7)
+ 608:	855a                	mv	a0,s6
+ 60a:	e15ff0ef          	jal	41e <printint>
+        i += 2;
+ 60e:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 610:	8bca                	mv	s7,s2
+      state = 0;
+ 612:	4981                	li	s3,0
+        i += 2;
+ 614:	bdc5                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 616:	008b8913          	addi	s2,s7,8
+ 61a:	4685                	li	a3,1
+ 61c:	4629                	li	a2,10
+ 61e:	000bb583          	ld	a1,0(s7)
+ 622:	855a                	mv	a0,s6
+ 624:	dfbff0ef          	jal	41e <printint>
+        i += 2;
+ 628:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 62a:	8bca                	mv	s7,s2
+      state = 0;
+ 62c:	4981                	li	s3,0
+        i += 2;
+ 62e:	bdd9                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 630:	008b8913          	addi	s2,s7,8
+ 634:	4681                	li	a3,0
+ 636:	4629                	li	a2,10
+ 638:	000be583          	lwu	a1,0(s7)
+ 63c:	855a                	mv	a0,s6
+ 63e:	de1ff0ef          	jal	41e <printint>
+ 642:	8bca                	mv	s7,s2
+      state = 0;
+ 644:	4981                	li	s3,0
+ 646:	bd7d                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 648:	008b8913          	addi	s2,s7,8
+ 64c:	4681                	li	a3,0
+ 64e:	4629                	li	a2,10
+ 650:	000bb583          	ld	a1,0(s7)
+ 654:	855a                	mv	a0,s6
+ 656:	dc9ff0ef          	jal	41e <printint>
+        i += 1;
+ 65a:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 65c:	8bca                	mv	s7,s2
+      state = 0;
+ 65e:	4981                	li	s3,0
+        i += 1;
+ 660:	b555                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 662:	008b8913          	addi	s2,s7,8
+ 666:	4681                	li	a3,0
+ 668:	4629                	li	a2,10
+ 66a:	000bb583          	ld	a1,0(s7)
+ 66e:	855a                	mv	a0,s6
+ 670:	dafff0ef          	jal	41e <printint>
+        i += 2;
+ 674:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 676:	8bca                	mv	s7,s2
+      state = 0;
+ 678:	4981                	li	s3,0
+        i += 2;
+ 67a:	b569                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 67c:	008b8913          	addi	s2,s7,8
+ 680:	4681                	li	a3,0
+ 682:	4641                	li	a2,16
+ 684:	000be583          	lwu	a1,0(s7)
+ 688:	855a                	mv	a0,s6
+ 68a:	d95ff0ef          	jal	41e <printint>
+ 68e:	8bca                	mv	s7,s2
+      state = 0;
+ 690:	4981                	li	s3,0
+ 692:	bd8d                	j	504 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 694:	008b8913          	addi	s2,s7,8
+ 698:	4681                	li	a3,0
+ 69a:	4641                	li	a2,16
+ 69c:	000bb583          	ld	a1,0(s7)
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	d7dff0ef          	jal	41e <printint>
+        i += 1;
+ 6a6:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6a8:	8bca                	mv	s7,s2
+      state = 0;
+ 6aa:	4981                	li	s3,0
+        i += 1;
+ 6ac:	bda1                	j	504 <vprintf+0x4a>
+ 6ae:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6b0:	008b8d13          	addi	s10,s7,8
+ 6b4:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6b8:	03000593          	li	a1,48
+ 6bc:	855a                	mv	a0,s6
+ 6be:	d43ff0ef          	jal	400 <putc>
+  putc(fd, 'x');
+ 6c2:	07800593          	li	a1,120
+ 6c6:	855a                	mv	a0,s6
+ 6c8:	d39ff0ef          	jal	400 <putc>
+ 6cc:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 6ce:	00000b97          	auipc	s7,0x0
+ 6d2:	332b8b93          	addi	s7,s7,818 # a00 <digits>
+ 6d6:	03c9d793          	srli	a5,s3,0x3c
+ 6da:	97de                	add	a5,a5,s7
+ 6dc:	0007c583          	lbu	a1,0(a5)
+ 6e0:	855a                	mv	a0,s6
+ 6e2:	d1fff0ef          	jal	400 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 6e6:	0992                	slli	s3,s3,0x4
+ 6e8:	397d                	addiw	s2,s2,-1
+ 6ea:	fe0916e3          	bnez	s2,6d6 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 6ee:	8bea                	mv	s7,s10
+      state = 0;
+ 6f0:	4981                	li	s3,0
+ 6f2:	6d02                	ld	s10,0(sp)
+ 6f4:	bd01                	j	504 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 6f6:	008b8913          	addi	s2,s7,8
+ 6fa:	000bc583          	lbu	a1,0(s7)
+ 6fe:	855a                	mv	a0,s6
+ 700:	d01ff0ef          	jal	400 <putc>
+ 704:	8bca                	mv	s7,s2
+      state = 0;
+ 706:	4981                	li	s3,0
+ 708:	bbf5                	j	504 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 70a:	008b8993          	addi	s3,s7,8
+ 70e:	000bb903          	ld	s2,0(s7)
+ 712:	00090f63          	beqz	s2,730 <vprintf+0x276>
+        for(; *s; s++)
+ 716:	00094583          	lbu	a1,0(s2)
+ 71a:	c195                	beqz	a1,73e <vprintf+0x284>
+          putc(fd, *s);
+ 71c:	855a                	mv	a0,s6
+ 71e:	ce3ff0ef          	jal	400 <putc>
+        for(; *s; s++)
+ 722:	0905                	addi	s2,s2,1
+ 724:	00094583          	lbu	a1,0(s2)
+ 728:	f9f5                	bnez	a1,71c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 72a:	8bce                	mv	s7,s3
+      state = 0;
+ 72c:	4981                	li	s3,0
+ 72e:	bbd9                	j	504 <vprintf+0x4a>
+          s = "(null)";
+ 730:	00000917          	auipc	s2,0x0
+ 734:	2c890913          	addi	s2,s2,712 # 9f8 <malloc+0x1bc>
+        for(; *s; s++)
+ 738:	02800593          	li	a1,40
+ 73c:	b7c5                	j	71c <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 73e:	8bce                	mv	s7,s3
+      state = 0;
+ 740:	4981                	li	s3,0
+ 742:	b3c9                	j	504 <vprintf+0x4a>
+ 744:	64a6                	ld	s1,72(sp)
+ 746:	79e2                	ld	s3,56(sp)
+ 748:	7a42                	ld	s4,48(sp)
+ 74a:	7aa2                	ld	s5,40(sp)
+ 74c:	7b02                	ld	s6,32(sp)
+ 74e:	6be2                	ld	s7,24(sp)
+ 750:	6c42                	ld	s8,16(sp)
+ 752:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 754:	60e6                	ld	ra,88(sp)
+ 756:	6446                	ld	s0,80(sp)
+ 758:	6906                	ld	s2,64(sp)
+ 75a:	6125                	addi	sp,sp,96
+ 75c:	8082                	ret
+
+000000000000075e <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 75e:	715d                	addi	sp,sp,-80
+ 760:	ec06                	sd	ra,24(sp)
+ 762:	e822                	sd	s0,16(sp)
+ 764:	1000                	addi	s0,sp,32
+ 766:	e010                	sd	a2,0(s0)
+ 768:	e414                	sd	a3,8(s0)
+ 76a:	e818                	sd	a4,16(s0)
+ 76c:	ec1c                	sd	a5,24(s0)
+ 76e:	03043023          	sd	a6,32(s0)
+ 772:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 776:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 77a:	8622                	mv	a2,s0
+ 77c:	d3fff0ef          	jal	4ba <vprintf>
+}
+ 780:	60e2                	ld	ra,24(sp)
+ 782:	6442                	ld	s0,16(sp)
+ 784:	6161                	addi	sp,sp,80
+ 786:	8082                	ret
+
+0000000000000788 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 788:	711d                	addi	sp,sp,-96
+ 78a:	ec06                	sd	ra,24(sp)
+ 78c:	e822                	sd	s0,16(sp)
+ 78e:	1000                	addi	s0,sp,32
+ 790:	e40c                	sd	a1,8(s0)
+ 792:	e810                	sd	a2,16(s0)
+ 794:	ec14                	sd	a3,24(s0)
+ 796:	f018                	sd	a4,32(s0)
+ 798:	f41c                	sd	a5,40(s0)
+ 79a:	03043823          	sd	a6,48(s0)
+ 79e:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7a2:	00840613          	addi	a2,s0,8
+ 7a6:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7aa:	85aa                	mv	a1,a0
+ 7ac:	4505                	li	a0,1
+ 7ae:	d0dff0ef          	jal	4ba <vprintf>
+}
+ 7b2:	60e2                	ld	ra,24(sp)
+ 7b4:	6442                	ld	s0,16(sp)
+ 7b6:	6125                	addi	sp,sp,96
+ 7b8:	8082                	ret
+
+00000000000007ba <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7ba:	1141                	addi	sp,sp,-16
+ 7bc:	e422                	sd	s0,8(sp)
+ 7be:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7c0:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7c4:	00001797          	auipc	a5,0x1
+ 7c8:	83c7b783          	ld	a5,-1988(a5) # 1000 <freep>
+ 7cc:	a02d                	j	7f6 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 7ce:	4618                	lw	a4,8(a2)
+ 7d0:	9f2d                	addw	a4,a4,a1
+ 7d2:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7d6:	6398                	ld	a4,0(a5)
+ 7d8:	6310                	ld	a2,0(a4)
+ 7da:	a83d                	j	818 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 7dc:	ff852703          	lw	a4,-8(a0)
+ 7e0:	9f31                	addw	a4,a4,a2
+ 7e2:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 7e4:	ff053683          	ld	a3,-16(a0)
+ 7e8:	a091                	j	82c <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7ea:	6398                	ld	a4,0(a5)
+ 7ec:	00e7e463          	bltu	a5,a4,7f4 <free+0x3a>
+ 7f0:	00e6ea63          	bltu	a3,a4,804 <free+0x4a>
+{
+ 7f4:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7f6:	fed7fae3          	bgeu	a5,a3,7ea <free+0x30>
+ 7fa:	6398                	ld	a4,0(a5)
+ 7fc:	00e6e463          	bltu	a3,a4,804 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 800:	fee7eae3          	bltu	a5,a4,7f4 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 804:	ff852583          	lw	a1,-8(a0)
+ 808:	6390                	ld	a2,0(a5)
+ 80a:	02059813          	slli	a6,a1,0x20
+ 80e:	01c85713          	srli	a4,a6,0x1c
+ 812:	9736                	add	a4,a4,a3
+ 814:	fae60de3          	beq	a2,a4,7ce <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 818:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 81c:	4790                	lw	a2,8(a5)
+ 81e:	02061593          	slli	a1,a2,0x20
+ 822:	01c5d713          	srli	a4,a1,0x1c
+ 826:	973e                	add	a4,a4,a5
+ 828:	fae68ae3          	beq	a3,a4,7dc <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 82c:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 82e:	00000717          	auipc	a4,0x0
+ 832:	7cf73923          	sd	a5,2002(a4) # 1000 <freep>
+}
+ 836:	6422                	ld	s0,8(sp)
+ 838:	0141                	addi	sp,sp,16
+ 83a:	8082                	ret
+
+000000000000083c <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 83c:	7139                	addi	sp,sp,-64
+ 83e:	fc06                	sd	ra,56(sp)
+ 840:	f822                	sd	s0,48(sp)
+ 842:	f426                	sd	s1,40(sp)
+ 844:	ec4e                	sd	s3,24(sp)
+ 846:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 848:	02051493          	slli	s1,a0,0x20
+ 84c:	9081                	srli	s1,s1,0x20
+ 84e:	04bd                	addi	s1,s1,15
+ 850:	8091                	srli	s1,s1,0x4
+ 852:	0014899b          	addiw	s3,s1,1
+ 856:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 858:	00000517          	auipc	a0,0x0
+ 85c:	7a853503          	ld	a0,1960(a0) # 1000 <freep>
+ 860:	c915                	beqz	a0,894 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 862:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 864:	4798                	lw	a4,8(a5)
+ 866:	08977a63          	bgeu	a4,s1,8fa <malloc+0xbe>
+ 86a:	f04a                	sd	s2,32(sp)
+ 86c:	e852                	sd	s4,16(sp)
+ 86e:	e456                	sd	s5,8(sp)
+ 870:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 872:	8a4e                	mv	s4,s3
+ 874:	0009871b          	sext.w	a4,s3
+ 878:	6685                	lui	a3,0x1
+ 87a:	00d77363          	bgeu	a4,a3,880 <malloc+0x44>
+ 87e:	6a05                	lui	s4,0x1
+ 880:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 884:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 888:	00000917          	auipc	s2,0x0
+ 88c:	77890913          	addi	s2,s2,1912 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 890:	5afd                	li	s5,-1
+ 892:	a081                	j	8d2 <malloc+0x96>
+ 894:	f04a                	sd	s2,32(sp)
+ 896:	e852                	sd	s4,16(sp)
+ 898:	e456                	sd	s5,8(sp)
+ 89a:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 89c:	00000797          	auipc	a5,0x0
+ 8a0:	77478793          	addi	a5,a5,1908 # 1010 <base>
+ 8a4:	00000717          	auipc	a4,0x0
+ 8a8:	74f73e23          	sd	a5,1884(a4) # 1000 <freep>
+ 8ac:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8ae:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8b2:	b7c1                	j	872 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8b4:	6398                	ld	a4,0(a5)
+ 8b6:	e118                	sd	a4,0(a0)
+ 8b8:	a8a9                	j	912 <malloc+0xd6>
+  hp->s.size = nu;
+ 8ba:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8be:	0541                	addi	a0,a0,16
+ 8c0:	efbff0ef          	jal	7ba <free>
+  return freep;
+ 8c4:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 8c8:	c12d                	beqz	a0,92a <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8ca:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8cc:	4798                	lw	a4,8(a5)
+ 8ce:	02977263          	bgeu	a4,s1,8f2 <malloc+0xb6>
+    if(p == freep)
+ 8d2:	00093703          	ld	a4,0(s2)
+ 8d6:	853e                	mv	a0,a5
+ 8d8:	fef719e3          	bne	a4,a5,8ca <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 8dc:	8552                	mv	a0,s4
+ 8de:	a47ff0ef          	jal	324 <sbrk>
+  if(p == SBRK_ERROR)
+ 8e2:	fd551ce3          	bne	a0,s5,8ba <malloc+0x7e>
+        return 0;
+ 8e6:	4501                	li	a0,0
+ 8e8:	7902                	ld	s2,32(sp)
+ 8ea:	6a42                	ld	s4,16(sp)
+ 8ec:	6aa2                	ld	s5,8(sp)
+ 8ee:	6b02                	ld	s6,0(sp)
+ 8f0:	a03d                	j	91e <malloc+0xe2>
+ 8f2:	7902                	ld	s2,32(sp)
+ 8f4:	6a42                	ld	s4,16(sp)
+ 8f6:	6aa2                	ld	s5,8(sp)
+ 8f8:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 8fa:	fae48de3          	beq	s1,a4,8b4 <malloc+0x78>
+        p->s.size -= nunits;
+ 8fe:	4137073b          	subw	a4,a4,s3
+ 902:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 904:	02071693          	slli	a3,a4,0x20
+ 908:	01c6d713          	srli	a4,a3,0x1c
+ 90c:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 90e:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 912:	00000717          	auipc	a4,0x0
+ 916:	6ea73723          	sd	a0,1774(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 91a:	01078513          	addi	a0,a5,16
+  }
+}
+ 91e:	70e2                	ld	ra,56(sp)
+ 920:	7442                	ld	s0,48(sp)
+ 922:	74a2                	ld	s1,40(sp)
+ 924:	69e2                	ld	s3,24(sp)
+ 926:	6121                	addi	sp,sp,64
+ 928:	8082                	ret
+ 92a:	7902                	ld	s2,32(sp)
+ 92c:	6a42                	ld	s4,16(sp)
+ 92e:	6aa2                	ld	s5,8(sp)
+ 930:	6b02                	ld	s6,0(sp)
+ 932:	b7f5                	j	91e <malloc+0xe2>
diff -ruN xv6-riscv/user/readcount.c xv62/user/readcount.c
--- xv6-riscv/user/readcount.c	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/readcount.c	2025-09-13 17:47:40.472059312 +0000
@@ -0,0 +1,41 @@
+// user/readcount.c
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[])
+{
+    char buf[101];
+    int fd;
+    int before, after, n;
+
+    before = getreadcount();
+    printf("Initial Count: %d\n", before);
+
+    fd = open("README", 0); //im making the assumption that we hahd to implement this guy for readme file and not
+    //for arbitrary files since its not even mentioned properly :((
+    if(fd < 0){
+        printf("README prolly doesnt exist\n");
+        exit(1);
+    }
+
+    n = read(fd, buf, 100);
+    if(n < 0){
+        printf("Not able to read\n");
+    } else {
+        
+        if(n < 100) buf[n] = '\0';
+    }
+    close(fd);
+
+    after = getreadcount();
+    printf("Bytes reading...: %d\n", n);
+    printf("Bytes afterrr: %d\n", after);
+
+    // verification also gib extra marks plej
+    if(after - before != n){
+        printf("Warning: expected increase %d, observed %d\n", n, after - before);
+    }
+
+    exit(0);
+}
diff -ruN xv6-riscv/user/readcount.d xv62/user/readcount.d
--- xv6-riscv/user/readcount.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/readcount.d	2025-09-14 12:32:52.344883014 +0000
@@ -0,0 +1,2 @@
+user/readcount.o: user/readcount.c kernel/types.h kernel/stat.h \
+ user/user.h
Binary files xv6-riscv/user/readcount.o and xv62/user/readcount.o differ
diff -ruN xv6-riscv/user/readcount.sym xv62/user/readcount.sym
--- xv6-riscv/user/readcount.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/readcount.sym	2025-09-14 12:32:52.360883011 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+0000000000000938 .rodata
+0000000000000a18 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 readcount.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000400 putc
+000000000000041e printint
+0000000000000a00 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+00000000000000d4 strcpy
+00000000000003e8 pause
+0000000000000788 printf
+00000000000003e0 sys_sbrk
+000000000000027e memmove
+00000000000003a0 mknod
+000000000000018c gets
+00000000000003d8 getpid
+0000000000000310 memcpy
+000000000000083c malloc
+000000000000033a sbrklazy
+0000000000000368 pipe
+0000000000000378 write
+00000000000003b0 fstat
+000000000000075e fprintf
+0000000000000388 kill
+00000000000004ba vprintf
+00000000000003c8 chdir
+0000000000000390 exec
+0000000000000360 wait
+0000000000000370 read
+00000000000003a8 unlink
+00000000000002d6 memcmp
+0000000000000350 fork
+0000000000000324 sbrk
+00000000000003f0 uptime
+0000000000000146 memset
+0000000000000000 main
+00000000000000f0 strcmp
+00000000000003d0 dup
+00000000000003f8 getreadcount
+00000000000001fc stat
+00000000000003b8 link
+0000000000000358 exit
+00000000000000c4 start
+0000000000000236 atoi
+000000000000011c strlen
+0000000000000398 open
+0000000000000168 strchr
+00000000000003c0 mkdir
+0000000000000380 close
+00000000000007ba free
diff -ruN xv6-riscv/user/rm.asm xv62/user/rm.asm
--- xv6-riscv/user/rm.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/rm.asm	2025-09-14 12:32:51.152883258 +0000
@@ -0,0 +1,1519 @@
+
+user/_rm:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	1101                	addi	sp,sp,-32
+   2:	ec06                	sd	ra,24(sp)
+   4:	e822                	sd	s0,16(sp)
+   6:	1000                	addi	s0,sp,32
+  int i;
+
+  if(argc < 2){
+   8:	4785                	li	a5,1
+   a:	02a7d763          	bge	a5,a0,38 <main+0x38>
+   e:	e426                	sd	s1,8(sp)
+  10:	e04a                	sd	s2,0(sp)
+  12:	00858493          	addi	s1,a1,8
+  16:	ffe5091b          	addiw	s2,a0,-2
+  1a:	02091793          	slli	a5,s2,0x20
+  1e:	01d7d913          	srli	s2,a5,0x1d
+  22:	05c1                	addi	a1,a1,16
+  24:	992e                	add	s2,s2,a1
+    fprintf(2, "Usage: rm files...\n");
+    exit(1);
+  }
+
+  for(i = 1; i < argc; i++){
+    if(unlink(argv[i]) < 0){
+  26:	6088                	ld	a0,0(s1)
+  28:	322000ef          	jal	34a <unlink>
+  2c:	02054263          	bltz	a0,50 <main+0x50>
+  for(i = 1; i < argc; i++){
+  30:	04a1                	addi	s1,s1,8
+  32:	ff249ae3          	bne	s1,s2,26 <main+0x26>
+  36:	a02d                	j	60 <main+0x60>
+  38:	e426                	sd	s1,8(sp)
+  3a:	e04a                	sd	s2,0(sp)
+    fprintf(2, "Usage: rm files...\n");
+  3c:	00001597          	auipc	a1,0x1
+  40:	8a458593          	addi	a1,a1,-1884 # 8e0 <malloc+0x102>
+  44:	4509                	li	a0,2
+  46:	6ba000ef          	jal	700 <fprintf>
+    exit(1);
+  4a:	4505                	li	a0,1
+  4c:	2ae000ef          	jal	2fa <exit>
+      fprintf(2, "rm: %s failed to delete\n", argv[i]);
+  50:	6090                	ld	a2,0(s1)
+  52:	00001597          	auipc	a1,0x1
+  56:	8a658593          	addi	a1,a1,-1882 # 8f8 <malloc+0x11a>
+  5a:	4509                	li	a0,2
+  5c:	6a4000ef          	jal	700 <fprintf>
+      break;
+    }
+  }
+
+  exit(0);
+  60:	4501                	li	a0,0
+  62:	298000ef          	jal	2fa <exit>
+
+0000000000000066 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  66:	1141                	addi	sp,sp,-16
+  68:	e406                	sd	ra,8(sp)
+  6a:	e022                	sd	s0,0(sp)
+  6c:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  6e:	f93ff0ef          	jal	0 <main>
+  exit(r);
+  72:	288000ef          	jal	2fa <exit>
+
+0000000000000076 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  76:	1141                	addi	sp,sp,-16
+  78:	e422                	sd	s0,8(sp)
+  7a:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  7c:	87aa                	mv	a5,a0
+  7e:	0585                	addi	a1,a1,1
+  80:	0785                	addi	a5,a5,1
+  82:	fff5c703          	lbu	a4,-1(a1)
+  86:	fee78fa3          	sb	a4,-1(a5)
+  8a:	fb75                	bnez	a4,7e <strcpy+0x8>
+    ;
+  return os;
+}
+  8c:	6422                	ld	s0,8(sp)
+  8e:	0141                	addi	sp,sp,16
+  90:	8082                	ret
+
+0000000000000092 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  92:	1141                	addi	sp,sp,-16
+  94:	e422                	sd	s0,8(sp)
+  96:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  98:	00054783          	lbu	a5,0(a0)
+  9c:	cb91                	beqz	a5,b0 <strcmp+0x1e>
+  9e:	0005c703          	lbu	a4,0(a1)
+  a2:	00f71763          	bne	a4,a5,b0 <strcmp+0x1e>
+    p++, q++;
+  a6:	0505                	addi	a0,a0,1
+  a8:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  aa:	00054783          	lbu	a5,0(a0)
+  ae:	fbe5                	bnez	a5,9e <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  b0:	0005c503          	lbu	a0,0(a1)
+}
+  b4:	40a7853b          	subw	a0,a5,a0
+  b8:	6422                	ld	s0,8(sp)
+  ba:	0141                	addi	sp,sp,16
+  bc:	8082                	ret
+
+00000000000000be <strlen>:
+
+uint
+strlen(const char *s)
+{
+  be:	1141                	addi	sp,sp,-16
+  c0:	e422                	sd	s0,8(sp)
+  c2:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  c4:	00054783          	lbu	a5,0(a0)
+  c8:	cf91                	beqz	a5,e4 <strlen+0x26>
+  ca:	0505                	addi	a0,a0,1
+  cc:	87aa                	mv	a5,a0
+  ce:	86be                	mv	a3,a5
+  d0:	0785                	addi	a5,a5,1
+  d2:	fff7c703          	lbu	a4,-1(a5)
+  d6:	ff65                	bnez	a4,ce <strlen+0x10>
+  d8:	40a6853b          	subw	a0,a3,a0
+  dc:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  de:	6422                	ld	s0,8(sp)
+  e0:	0141                	addi	sp,sp,16
+  e2:	8082                	ret
+  for(n = 0; s[n]; n++)
+  e4:	4501                	li	a0,0
+  e6:	bfe5                	j	de <strlen+0x20>
+
+00000000000000e8 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  e8:	1141                	addi	sp,sp,-16
+  ea:	e422                	sd	s0,8(sp)
+  ec:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  ee:	ca19                	beqz	a2,104 <memset+0x1c>
+  f0:	87aa                	mv	a5,a0
+  f2:	1602                	slli	a2,a2,0x20
+  f4:	9201                	srli	a2,a2,0x20
+  f6:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  fa:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+  fe:	0785                	addi	a5,a5,1
+ 100:	fee79de3          	bne	a5,a4,fa <memset+0x12>
+  }
+  return dst;
+}
+ 104:	6422                	ld	s0,8(sp)
+ 106:	0141                	addi	sp,sp,16
+ 108:	8082                	ret
+
+000000000000010a <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 10a:	1141                	addi	sp,sp,-16
+ 10c:	e422                	sd	s0,8(sp)
+ 10e:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 110:	00054783          	lbu	a5,0(a0)
+ 114:	cb99                	beqz	a5,12a <strchr+0x20>
+    if(*s == c)
+ 116:	00f58763          	beq	a1,a5,124 <strchr+0x1a>
+  for(; *s; s++)
+ 11a:	0505                	addi	a0,a0,1
+ 11c:	00054783          	lbu	a5,0(a0)
+ 120:	fbfd                	bnez	a5,116 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 122:	4501                	li	a0,0
+}
+ 124:	6422                	ld	s0,8(sp)
+ 126:	0141                	addi	sp,sp,16
+ 128:	8082                	ret
+  return 0;
+ 12a:	4501                	li	a0,0
+ 12c:	bfe5                	j	124 <strchr+0x1a>
+
+000000000000012e <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 12e:	711d                	addi	sp,sp,-96
+ 130:	ec86                	sd	ra,88(sp)
+ 132:	e8a2                	sd	s0,80(sp)
+ 134:	e4a6                	sd	s1,72(sp)
+ 136:	e0ca                	sd	s2,64(sp)
+ 138:	fc4e                	sd	s3,56(sp)
+ 13a:	f852                	sd	s4,48(sp)
+ 13c:	f456                	sd	s5,40(sp)
+ 13e:	f05a                	sd	s6,32(sp)
+ 140:	ec5e                	sd	s7,24(sp)
+ 142:	1080                	addi	s0,sp,96
+ 144:	8baa                	mv	s7,a0
+ 146:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 148:	892a                	mv	s2,a0
+ 14a:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 14c:	4aa9                	li	s5,10
+ 14e:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 150:	89a6                	mv	s3,s1
+ 152:	2485                	addiw	s1,s1,1
+ 154:	0344d663          	bge	s1,s4,180 <gets+0x52>
+    cc = read(0, &c, 1);
+ 158:	4605                	li	a2,1
+ 15a:	faf40593          	addi	a1,s0,-81
+ 15e:	4501                	li	a0,0
+ 160:	1b2000ef          	jal	312 <read>
+    if(cc < 1)
+ 164:	00a05e63          	blez	a0,180 <gets+0x52>
+    buf[i++] = c;
+ 168:	faf44783          	lbu	a5,-81(s0)
+ 16c:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 170:	01578763          	beq	a5,s5,17e <gets+0x50>
+ 174:	0905                	addi	s2,s2,1
+ 176:	fd679de3          	bne	a5,s6,150 <gets+0x22>
+    buf[i++] = c;
+ 17a:	89a6                	mv	s3,s1
+ 17c:	a011                	j	180 <gets+0x52>
+ 17e:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 180:	99de                	add	s3,s3,s7
+ 182:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 186:	855e                	mv	a0,s7
+ 188:	60e6                	ld	ra,88(sp)
+ 18a:	6446                	ld	s0,80(sp)
+ 18c:	64a6                	ld	s1,72(sp)
+ 18e:	6906                	ld	s2,64(sp)
+ 190:	79e2                	ld	s3,56(sp)
+ 192:	7a42                	ld	s4,48(sp)
+ 194:	7aa2                	ld	s5,40(sp)
+ 196:	7b02                	ld	s6,32(sp)
+ 198:	6be2                	ld	s7,24(sp)
+ 19a:	6125                	addi	sp,sp,96
+ 19c:	8082                	ret
+
+000000000000019e <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 19e:	1101                	addi	sp,sp,-32
+ 1a0:	ec06                	sd	ra,24(sp)
+ 1a2:	e822                	sd	s0,16(sp)
+ 1a4:	e04a                	sd	s2,0(sp)
+ 1a6:	1000                	addi	s0,sp,32
+ 1a8:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 1aa:	4581                	li	a1,0
+ 1ac:	18e000ef          	jal	33a <open>
+  if(fd < 0)
+ 1b0:	02054263          	bltz	a0,1d4 <stat+0x36>
+ 1b4:	e426                	sd	s1,8(sp)
+ 1b6:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 1b8:	85ca                	mv	a1,s2
+ 1ba:	198000ef          	jal	352 <fstat>
+ 1be:	892a                	mv	s2,a0
+  close(fd);
+ 1c0:	8526                	mv	a0,s1
+ 1c2:	160000ef          	jal	322 <close>
+  return r;
+ 1c6:	64a2                	ld	s1,8(sp)
+}
+ 1c8:	854a                	mv	a0,s2
+ 1ca:	60e2                	ld	ra,24(sp)
+ 1cc:	6442                	ld	s0,16(sp)
+ 1ce:	6902                	ld	s2,0(sp)
+ 1d0:	6105                	addi	sp,sp,32
+ 1d2:	8082                	ret
+    return -1;
+ 1d4:	597d                	li	s2,-1
+ 1d6:	bfcd                	j	1c8 <stat+0x2a>
+
+00000000000001d8 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 1d8:	1141                	addi	sp,sp,-16
+ 1da:	e422                	sd	s0,8(sp)
+ 1dc:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 1de:	00054683          	lbu	a3,0(a0)
+ 1e2:	fd06879b          	addiw	a5,a3,-48
+ 1e6:	0ff7f793          	zext.b	a5,a5
+ 1ea:	4625                	li	a2,9
+ 1ec:	02f66863          	bltu	a2,a5,21c <atoi+0x44>
+ 1f0:	872a                	mv	a4,a0
+  n = 0;
+ 1f2:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1f4:	0705                	addi	a4,a4,1
+ 1f6:	0025179b          	slliw	a5,a0,0x2
+ 1fa:	9fa9                	addw	a5,a5,a0
+ 1fc:	0017979b          	slliw	a5,a5,0x1
+ 200:	9fb5                	addw	a5,a5,a3
+ 202:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 206:	00074683          	lbu	a3,0(a4)
+ 20a:	fd06879b          	addiw	a5,a3,-48
+ 20e:	0ff7f793          	zext.b	a5,a5
+ 212:	fef671e3          	bgeu	a2,a5,1f4 <atoi+0x1c>
+  return n;
+}
+ 216:	6422                	ld	s0,8(sp)
+ 218:	0141                	addi	sp,sp,16
+ 21a:	8082                	ret
+  n = 0;
+ 21c:	4501                	li	a0,0
+ 21e:	bfe5                	j	216 <atoi+0x3e>
+
+0000000000000220 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 220:	1141                	addi	sp,sp,-16
+ 222:	e422                	sd	s0,8(sp)
+ 224:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 226:	02b57463          	bgeu	a0,a1,24e <memmove+0x2e>
+    while(n-- > 0)
+ 22a:	00c05f63          	blez	a2,248 <memmove+0x28>
+ 22e:	1602                	slli	a2,a2,0x20
+ 230:	9201                	srli	a2,a2,0x20
+ 232:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 236:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 238:	0585                	addi	a1,a1,1
+ 23a:	0705                	addi	a4,a4,1
+ 23c:	fff5c683          	lbu	a3,-1(a1)
+ 240:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 244:	fef71ae3          	bne	a4,a5,238 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 248:	6422                	ld	s0,8(sp)
+ 24a:	0141                	addi	sp,sp,16
+ 24c:	8082                	ret
+    dst += n;
+ 24e:	00c50733          	add	a4,a0,a2
+    src += n;
+ 252:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 254:	fec05ae3          	blez	a2,248 <memmove+0x28>
+ 258:	fff6079b          	addiw	a5,a2,-1
+ 25c:	1782                	slli	a5,a5,0x20
+ 25e:	9381                	srli	a5,a5,0x20
+ 260:	fff7c793          	not	a5,a5
+ 264:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 266:	15fd                	addi	a1,a1,-1
+ 268:	177d                	addi	a4,a4,-1
+ 26a:	0005c683          	lbu	a3,0(a1)
+ 26e:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 272:	fee79ae3          	bne	a5,a4,266 <memmove+0x46>
+ 276:	bfc9                	j	248 <memmove+0x28>
+
+0000000000000278 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 278:	1141                	addi	sp,sp,-16
+ 27a:	e422                	sd	s0,8(sp)
+ 27c:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 27e:	ca05                	beqz	a2,2ae <memcmp+0x36>
+ 280:	fff6069b          	addiw	a3,a2,-1
+ 284:	1682                	slli	a3,a3,0x20
+ 286:	9281                	srli	a3,a3,0x20
+ 288:	0685                	addi	a3,a3,1
+ 28a:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 28c:	00054783          	lbu	a5,0(a0)
+ 290:	0005c703          	lbu	a4,0(a1)
+ 294:	00e79863          	bne	a5,a4,2a4 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 298:	0505                	addi	a0,a0,1
+    p2++;
+ 29a:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 29c:	fed518e3          	bne	a0,a3,28c <memcmp+0x14>
+  }
+  return 0;
+ 2a0:	4501                	li	a0,0
+ 2a2:	a019                	j	2a8 <memcmp+0x30>
+      return *p1 - *p2;
+ 2a4:	40e7853b          	subw	a0,a5,a4
+}
+ 2a8:	6422                	ld	s0,8(sp)
+ 2aa:	0141                	addi	sp,sp,16
+ 2ac:	8082                	ret
+  return 0;
+ 2ae:	4501                	li	a0,0
+ 2b0:	bfe5                	j	2a8 <memcmp+0x30>
+
+00000000000002b2 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 2b2:	1141                	addi	sp,sp,-16
+ 2b4:	e406                	sd	ra,8(sp)
+ 2b6:	e022                	sd	s0,0(sp)
+ 2b8:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 2ba:	f67ff0ef          	jal	220 <memmove>
+}
+ 2be:	60a2                	ld	ra,8(sp)
+ 2c0:	6402                	ld	s0,0(sp)
+ 2c2:	0141                	addi	sp,sp,16
+ 2c4:	8082                	ret
+
+00000000000002c6 <sbrk>:
+
+char *
+sbrk(int n) {
+ 2c6:	1141                	addi	sp,sp,-16
+ 2c8:	e406                	sd	ra,8(sp)
+ 2ca:	e022                	sd	s0,0(sp)
+ 2cc:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 2ce:	4585                	li	a1,1
+ 2d0:	0b2000ef          	jal	382 <sys_sbrk>
+}
+ 2d4:	60a2                	ld	ra,8(sp)
+ 2d6:	6402                	ld	s0,0(sp)
+ 2d8:	0141                	addi	sp,sp,16
+ 2da:	8082                	ret
+
+00000000000002dc <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 2dc:	1141                	addi	sp,sp,-16
+ 2de:	e406                	sd	ra,8(sp)
+ 2e0:	e022                	sd	s0,0(sp)
+ 2e2:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 2e4:	4589                	li	a1,2
+ 2e6:	09c000ef          	jal	382 <sys_sbrk>
+}
+ 2ea:	60a2                	ld	ra,8(sp)
+ 2ec:	6402                	ld	s0,0(sp)
+ 2ee:	0141                	addi	sp,sp,16
+ 2f0:	8082                	ret
+
+00000000000002f2 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2f2:	4885                	li	a7,1
+ ecall
+ 2f4:	00000073          	ecall
+ ret
+ 2f8:	8082                	ret
+
+00000000000002fa <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2fa:	4889                	li	a7,2
+ ecall
+ 2fc:	00000073          	ecall
+ ret
+ 300:	8082                	ret
+
+0000000000000302 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 302:	488d                	li	a7,3
+ ecall
+ 304:	00000073          	ecall
+ ret
+ 308:	8082                	ret
+
+000000000000030a <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 30a:	4891                	li	a7,4
+ ecall
+ 30c:	00000073          	ecall
+ ret
+ 310:	8082                	ret
+
+0000000000000312 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 312:	4895                	li	a7,5
+ ecall
+ 314:	00000073          	ecall
+ ret
+ 318:	8082                	ret
+
+000000000000031a <write>:
+.global write
+write:
+ li a7, SYS_write
+ 31a:	48c1                	li	a7,16
+ ecall
+ 31c:	00000073          	ecall
+ ret
+ 320:	8082                	ret
+
+0000000000000322 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 322:	48d5                	li	a7,21
+ ecall
+ 324:	00000073          	ecall
+ ret
+ 328:	8082                	ret
+
+000000000000032a <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 32a:	4899                	li	a7,6
+ ecall
+ 32c:	00000073          	ecall
+ ret
+ 330:	8082                	ret
+
+0000000000000332 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 332:	489d                	li	a7,7
+ ecall
+ 334:	00000073          	ecall
+ ret
+ 338:	8082                	ret
+
+000000000000033a <open>:
+.global open
+open:
+ li a7, SYS_open
+ 33a:	48bd                	li	a7,15
+ ecall
+ 33c:	00000073          	ecall
+ ret
+ 340:	8082                	ret
+
+0000000000000342 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 342:	48c5                	li	a7,17
+ ecall
+ 344:	00000073          	ecall
+ ret
+ 348:	8082                	ret
+
+000000000000034a <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 34a:	48c9                	li	a7,18
+ ecall
+ 34c:	00000073          	ecall
+ ret
+ 350:	8082                	ret
+
+0000000000000352 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 352:	48a1                	li	a7,8
+ ecall
+ 354:	00000073          	ecall
+ ret
+ 358:	8082                	ret
+
+000000000000035a <link>:
+.global link
+link:
+ li a7, SYS_link
+ 35a:	48cd                	li	a7,19
+ ecall
+ 35c:	00000073          	ecall
+ ret
+ 360:	8082                	ret
+
+0000000000000362 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 362:	48d1                	li	a7,20
+ ecall
+ 364:	00000073          	ecall
+ ret
+ 368:	8082                	ret
+
+000000000000036a <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 36a:	48a5                	li	a7,9
+ ecall
+ 36c:	00000073          	ecall
+ ret
+ 370:	8082                	ret
+
+0000000000000372 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 372:	48a9                	li	a7,10
+ ecall
+ 374:	00000073          	ecall
+ ret
+ 378:	8082                	ret
+
+000000000000037a <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 37a:	48ad                	li	a7,11
+ ecall
+ 37c:	00000073          	ecall
+ ret
+ 380:	8082                	ret
+
+0000000000000382 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 382:	48b1                	li	a7,12
+ ecall
+ 384:	00000073          	ecall
+ ret
+ 388:	8082                	ret
+
+000000000000038a <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 38a:	48b5                	li	a7,13
+ ecall
+ 38c:	00000073          	ecall
+ ret
+ 390:	8082                	ret
+
+0000000000000392 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 392:	48b9                	li	a7,14
+ ecall
+ 394:	00000073          	ecall
+ ret
+ 398:	8082                	ret
+
+000000000000039a <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 39a:	48d9                	li	a7,22
+ ecall
+ 39c:	00000073          	ecall
+ ret
+ 3a0:	8082                	ret
+
+00000000000003a2 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 3a2:	1101                	addi	sp,sp,-32
+ 3a4:	ec06                	sd	ra,24(sp)
+ 3a6:	e822                	sd	s0,16(sp)
+ 3a8:	1000                	addi	s0,sp,32
+ 3aa:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 3ae:	4605                	li	a2,1
+ 3b0:	fef40593          	addi	a1,s0,-17
+ 3b4:	f67ff0ef          	jal	31a <write>
+}
+ 3b8:	60e2                	ld	ra,24(sp)
+ 3ba:	6442                	ld	s0,16(sp)
+ 3bc:	6105                	addi	sp,sp,32
+ 3be:	8082                	ret
+
+00000000000003c0 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 3c0:	715d                	addi	sp,sp,-80
+ 3c2:	e486                	sd	ra,72(sp)
+ 3c4:	e0a2                	sd	s0,64(sp)
+ 3c6:	f84a                	sd	s2,48(sp)
+ 3c8:	0880                	addi	s0,sp,80
+ 3ca:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 3cc:	c299                	beqz	a3,3d2 <printint+0x12>
+ 3ce:	0805c363          	bltz	a1,454 <printint+0x94>
+  neg = 0;
+ 3d2:	4881                	li	a7,0
+ 3d4:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 3d8:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 3da:	00000517          	auipc	a0,0x0
+ 3de:	54650513          	addi	a0,a0,1350 # 920 <digits>
+ 3e2:	883e                	mv	a6,a5
+ 3e4:	2785                	addiw	a5,a5,1
+ 3e6:	02c5f733          	remu	a4,a1,a2
+ 3ea:	972a                	add	a4,a4,a0
+ 3ec:	00074703          	lbu	a4,0(a4)
+ 3f0:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3f4:	872e                	mv	a4,a1
+ 3f6:	02c5d5b3          	divu	a1,a1,a2
+ 3fa:	0685                	addi	a3,a3,1
+ 3fc:	fec773e3          	bgeu	a4,a2,3e2 <printint+0x22>
+  if(neg)
+ 400:	00088b63          	beqz	a7,416 <printint+0x56>
+    buf[i++] = '-';
+ 404:	fd078793          	addi	a5,a5,-48
+ 408:	97a2                	add	a5,a5,s0
+ 40a:	02d00713          	li	a4,45
+ 40e:	fee78423          	sb	a4,-24(a5)
+ 412:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 416:	02f05a63          	blez	a5,44a <printint+0x8a>
+ 41a:	fc26                	sd	s1,56(sp)
+ 41c:	f44e                	sd	s3,40(sp)
+ 41e:	fb840713          	addi	a4,s0,-72
+ 422:	00f704b3          	add	s1,a4,a5
+ 426:	fff70993          	addi	s3,a4,-1
+ 42a:	99be                	add	s3,s3,a5
+ 42c:	37fd                	addiw	a5,a5,-1
+ 42e:	1782                	slli	a5,a5,0x20
+ 430:	9381                	srli	a5,a5,0x20
+ 432:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 436:	fff4c583          	lbu	a1,-1(s1)
+ 43a:	854a                	mv	a0,s2
+ 43c:	f67ff0ef          	jal	3a2 <putc>
+  while(--i >= 0)
+ 440:	14fd                	addi	s1,s1,-1
+ 442:	ff349ae3          	bne	s1,s3,436 <printint+0x76>
+ 446:	74e2                	ld	s1,56(sp)
+ 448:	79a2                	ld	s3,40(sp)
+}
+ 44a:	60a6                	ld	ra,72(sp)
+ 44c:	6406                	ld	s0,64(sp)
+ 44e:	7942                	ld	s2,48(sp)
+ 450:	6161                	addi	sp,sp,80
+ 452:	8082                	ret
+    x = -xx;
+ 454:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 458:	4885                	li	a7,1
+    x = -xx;
+ 45a:	bfad                	j	3d4 <printint+0x14>
+
+000000000000045c <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 45c:	711d                	addi	sp,sp,-96
+ 45e:	ec86                	sd	ra,88(sp)
+ 460:	e8a2                	sd	s0,80(sp)
+ 462:	e0ca                	sd	s2,64(sp)
+ 464:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 466:	0005c903          	lbu	s2,0(a1)
+ 46a:	28090663          	beqz	s2,6f6 <vprintf+0x29a>
+ 46e:	e4a6                	sd	s1,72(sp)
+ 470:	fc4e                	sd	s3,56(sp)
+ 472:	f852                	sd	s4,48(sp)
+ 474:	f456                	sd	s5,40(sp)
+ 476:	f05a                	sd	s6,32(sp)
+ 478:	ec5e                	sd	s7,24(sp)
+ 47a:	e862                	sd	s8,16(sp)
+ 47c:	e466                	sd	s9,8(sp)
+ 47e:	8b2a                	mv	s6,a0
+ 480:	8a2e                	mv	s4,a1
+ 482:	8bb2                	mv	s7,a2
+  state = 0;
+ 484:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 486:	4481                	li	s1,0
+ 488:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 48a:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 48e:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 492:	06c00c93          	li	s9,108
+ 496:	a005                	j	4b6 <vprintf+0x5a>
+        putc(fd, c0);
+ 498:	85ca                	mv	a1,s2
+ 49a:	855a                	mv	a0,s6
+ 49c:	f07ff0ef          	jal	3a2 <putc>
+ 4a0:	a019                	j	4a6 <vprintf+0x4a>
+    } else if(state == '%'){
+ 4a2:	03598263          	beq	s3,s5,4c6 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 4a6:	2485                	addiw	s1,s1,1
+ 4a8:	8726                	mv	a4,s1
+ 4aa:	009a07b3          	add	a5,s4,s1
+ 4ae:	0007c903          	lbu	s2,0(a5)
+ 4b2:	22090a63          	beqz	s2,6e6 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 4b6:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 4ba:	fe0994e3          	bnez	s3,4a2 <vprintf+0x46>
+      if(c0 == '%'){
+ 4be:	fd579de3          	bne	a5,s5,498 <vprintf+0x3c>
+        state = '%';
+ 4c2:	89be                	mv	s3,a5
+ 4c4:	b7cd                	j	4a6 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 4c6:	00ea06b3          	add	a3,s4,a4
+ 4ca:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 4ce:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 4d0:	c681                	beqz	a3,4d8 <vprintf+0x7c>
+ 4d2:	9752                	add	a4,a4,s4
+ 4d4:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 4d8:	05878363          	beq	a5,s8,51e <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4dc:	05978d63          	beq	a5,s9,536 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 4e0:	07500713          	li	a4,117
+ 4e4:	0ee78763          	beq	a5,a4,5d2 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4e8:	07800713          	li	a4,120
+ 4ec:	12e78963          	beq	a5,a4,61e <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4f0:	07000713          	li	a4,112
+ 4f4:	14e78e63          	beq	a5,a4,650 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4f8:	06300713          	li	a4,99
+ 4fc:	18e78e63          	beq	a5,a4,698 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 500:	07300713          	li	a4,115
+ 504:	1ae78463          	beq	a5,a4,6ac <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 508:	02500713          	li	a4,37
+ 50c:	04e79563          	bne	a5,a4,556 <vprintf+0xfa>
+        putc(fd, '%');
+ 510:	02500593          	li	a1,37
+ 514:	855a                	mv	a0,s6
+ 516:	e8dff0ef          	jal	3a2 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 51a:	4981                	li	s3,0
+ 51c:	b769                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 51e:	008b8913          	addi	s2,s7,8
+ 522:	4685                	li	a3,1
+ 524:	4629                	li	a2,10
+ 526:	000ba583          	lw	a1,0(s7)
+ 52a:	855a                	mv	a0,s6
+ 52c:	e95ff0ef          	jal	3c0 <printint>
+ 530:	8bca                	mv	s7,s2
+      state = 0;
+ 532:	4981                	li	s3,0
+ 534:	bf8d                	j	4a6 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 536:	06400793          	li	a5,100
+ 53a:	02f68963          	beq	a3,a5,56c <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 53e:	06c00793          	li	a5,108
+ 542:	04f68263          	beq	a3,a5,586 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 546:	07500793          	li	a5,117
+ 54a:	0af68063          	beq	a3,a5,5ea <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 54e:	07800793          	li	a5,120
+ 552:	0ef68263          	beq	a3,a5,636 <vprintf+0x1da>
+        putc(fd, '%');
+ 556:	02500593          	li	a1,37
+ 55a:	855a                	mv	a0,s6
+ 55c:	e47ff0ef          	jal	3a2 <putc>
+        putc(fd, c0);
+ 560:	85ca                	mv	a1,s2
+ 562:	855a                	mv	a0,s6
+ 564:	e3fff0ef          	jal	3a2 <putc>
+      state = 0;
+ 568:	4981                	li	s3,0
+ 56a:	bf35                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 56c:	008b8913          	addi	s2,s7,8
+ 570:	4685                	li	a3,1
+ 572:	4629                	li	a2,10
+ 574:	000bb583          	ld	a1,0(s7)
+ 578:	855a                	mv	a0,s6
+ 57a:	e47ff0ef          	jal	3c0 <printint>
+        i += 1;
+ 57e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 580:	8bca                	mv	s7,s2
+      state = 0;
+ 582:	4981                	li	s3,0
+        i += 1;
+ 584:	b70d                	j	4a6 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 586:	06400793          	li	a5,100
+ 58a:	02f60763          	beq	a2,a5,5b8 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 58e:	07500793          	li	a5,117
+ 592:	06f60963          	beq	a2,a5,604 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 596:	07800793          	li	a5,120
+ 59a:	faf61ee3          	bne	a2,a5,556 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 59e:	008b8913          	addi	s2,s7,8
+ 5a2:	4681                	li	a3,0
+ 5a4:	4641                	li	a2,16
+ 5a6:	000bb583          	ld	a1,0(s7)
+ 5aa:	855a                	mv	a0,s6
+ 5ac:	e15ff0ef          	jal	3c0 <printint>
+        i += 2;
+ 5b0:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5b2:	8bca                	mv	s7,s2
+      state = 0;
+ 5b4:	4981                	li	s3,0
+        i += 2;
+ 5b6:	bdc5                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5b8:	008b8913          	addi	s2,s7,8
+ 5bc:	4685                	li	a3,1
+ 5be:	4629                	li	a2,10
+ 5c0:	000bb583          	ld	a1,0(s7)
+ 5c4:	855a                	mv	a0,s6
+ 5c6:	dfbff0ef          	jal	3c0 <printint>
+        i += 2;
+ 5ca:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5cc:	8bca                	mv	s7,s2
+      state = 0;
+ 5ce:	4981                	li	s3,0
+        i += 2;
+ 5d0:	bdd9                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 5d2:	008b8913          	addi	s2,s7,8
+ 5d6:	4681                	li	a3,0
+ 5d8:	4629                	li	a2,10
+ 5da:	000be583          	lwu	a1,0(s7)
+ 5de:	855a                	mv	a0,s6
+ 5e0:	de1ff0ef          	jal	3c0 <printint>
+ 5e4:	8bca                	mv	s7,s2
+      state = 0;
+ 5e6:	4981                	li	s3,0
+ 5e8:	bd7d                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5ea:	008b8913          	addi	s2,s7,8
+ 5ee:	4681                	li	a3,0
+ 5f0:	4629                	li	a2,10
+ 5f2:	000bb583          	ld	a1,0(s7)
+ 5f6:	855a                	mv	a0,s6
+ 5f8:	dc9ff0ef          	jal	3c0 <printint>
+        i += 1;
+ 5fc:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5fe:	8bca                	mv	s7,s2
+      state = 0;
+ 600:	4981                	li	s3,0
+        i += 1;
+ 602:	b555                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 604:	008b8913          	addi	s2,s7,8
+ 608:	4681                	li	a3,0
+ 60a:	4629                	li	a2,10
+ 60c:	000bb583          	ld	a1,0(s7)
+ 610:	855a                	mv	a0,s6
+ 612:	dafff0ef          	jal	3c0 <printint>
+        i += 2;
+ 616:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 618:	8bca                	mv	s7,s2
+      state = 0;
+ 61a:	4981                	li	s3,0
+        i += 2;
+ 61c:	b569                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 61e:	008b8913          	addi	s2,s7,8
+ 622:	4681                	li	a3,0
+ 624:	4641                	li	a2,16
+ 626:	000be583          	lwu	a1,0(s7)
+ 62a:	855a                	mv	a0,s6
+ 62c:	d95ff0ef          	jal	3c0 <printint>
+ 630:	8bca                	mv	s7,s2
+      state = 0;
+ 632:	4981                	li	s3,0
+ 634:	bd8d                	j	4a6 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 636:	008b8913          	addi	s2,s7,8
+ 63a:	4681                	li	a3,0
+ 63c:	4641                	li	a2,16
+ 63e:	000bb583          	ld	a1,0(s7)
+ 642:	855a                	mv	a0,s6
+ 644:	d7dff0ef          	jal	3c0 <printint>
+        i += 1;
+ 648:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 64a:	8bca                	mv	s7,s2
+      state = 0;
+ 64c:	4981                	li	s3,0
+        i += 1;
+ 64e:	bda1                	j	4a6 <vprintf+0x4a>
+ 650:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 652:	008b8d13          	addi	s10,s7,8
+ 656:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 65a:	03000593          	li	a1,48
+ 65e:	855a                	mv	a0,s6
+ 660:	d43ff0ef          	jal	3a2 <putc>
+  putc(fd, 'x');
+ 664:	07800593          	li	a1,120
+ 668:	855a                	mv	a0,s6
+ 66a:	d39ff0ef          	jal	3a2 <putc>
+ 66e:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 670:	00000b97          	auipc	s7,0x0
+ 674:	2b0b8b93          	addi	s7,s7,688 # 920 <digits>
+ 678:	03c9d793          	srli	a5,s3,0x3c
+ 67c:	97de                	add	a5,a5,s7
+ 67e:	0007c583          	lbu	a1,0(a5)
+ 682:	855a                	mv	a0,s6
+ 684:	d1fff0ef          	jal	3a2 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 688:	0992                	slli	s3,s3,0x4
+ 68a:	397d                	addiw	s2,s2,-1
+ 68c:	fe0916e3          	bnez	s2,678 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 690:	8bea                	mv	s7,s10
+      state = 0;
+ 692:	4981                	li	s3,0
+ 694:	6d02                	ld	s10,0(sp)
+ 696:	bd01                	j	4a6 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 698:	008b8913          	addi	s2,s7,8
+ 69c:	000bc583          	lbu	a1,0(s7)
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	d01ff0ef          	jal	3a2 <putc>
+ 6a6:	8bca                	mv	s7,s2
+      state = 0;
+ 6a8:	4981                	li	s3,0
+ 6aa:	bbf5                	j	4a6 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 6ac:	008b8993          	addi	s3,s7,8
+ 6b0:	000bb903          	ld	s2,0(s7)
+ 6b4:	00090f63          	beqz	s2,6d2 <vprintf+0x276>
+        for(; *s; s++)
+ 6b8:	00094583          	lbu	a1,0(s2)
+ 6bc:	c195                	beqz	a1,6e0 <vprintf+0x284>
+          putc(fd, *s);
+ 6be:	855a                	mv	a0,s6
+ 6c0:	ce3ff0ef          	jal	3a2 <putc>
+        for(; *s; s++)
+ 6c4:	0905                	addi	s2,s2,1
+ 6c6:	00094583          	lbu	a1,0(s2)
+ 6ca:	f9f5                	bnez	a1,6be <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6cc:	8bce                	mv	s7,s3
+      state = 0;
+ 6ce:	4981                	li	s3,0
+ 6d0:	bbd9                	j	4a6 <vprintf+0x4a>
+          s = "(null)";
+ 6d2:	00000917          	auipc	s2,0x0
+ 6d6:	24690913          	addi	s2,s2,582 # 918 <malloc+0x13a>
+        for(; *s; s++)
+ 6da:	02800593          	li	a1,40
+ 6de:	b7c5                	j	6be <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 6e0:	8bce                	mv	s7,s3
+      state = 0;
+ 6e2:	4981                	li	s3,0
+ 6e4:	b3c9                	j	4a6 <vprintf+0x4a>
+ 6e6:	64a6                	ld	s1,72(sp)
+ 6e8:	79e2                	ld	s3,56(sp)
+ 6ea:	7a42                	ld	s4,48(sp)
+ 6ec:	7aa2                	ld	s5,40(sp)
+ 6ee:	7b02                	ld	s6,32(sp)
+ 6f0:	6be2                	ld	s7,24(sp)
+ 6f2:	6c42                	ld	s8,16(sp)
+ 6f4:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6f6:	60e6                	ld	ra,88(sp)
+ 6f8:	6446                	ld	s0,80(sp)
+ 6fa:	6906                	ld	s2,64(sp)
+ 6fc:	6125                	addi	sp,sp,96
+ 6fe:	8082                	ret
+
+0000000000000700 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 700:	715d                	addi	sp,sp,-80
+ 702:	ec06                	sd	ra,24(sp)
+ 704:	e822                	sd	s0,16(sp)
+ 706:	1000                	addi	s0,sp,32
+ 708:	e010                	sd	a2,0(s0)
+ 70a:	e414                	sd	a3,8(s0)
+ 70c:	e818                	sd	a4,16(s0)
+ 70e:	ec1c                	sd	a5,24(s0)
+ 710:	03043023          	sd	a6,32(s0)
+ 714:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 718:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 71c:	8622                	mv	a2,s0
+ 71e:	d3fff0ef          	jal	45c <vprintf>
+}
+ 722:	60e2                	ld	ra,24(sp)
+ 724:	6442                	ld	s0,16(sp)
+ 726:	6161                	addi	sp,sp,80
+ 728:	8082                	ret
+
+000000000000072a <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 72a:	711d                	addi	sp,sp,-96
+ 72c:	ec06                	sd	ra,24(sp)
+ 72e:	e822                	sd	s0,16(sp)
+ 730:	1000                	addi	s0,sp,32
+ 732:	e40c                	sd	a1,8(s0)
+ 734:	e810                	sd	a2,16(s0)
+ 736:	ec14                	sd	a3,24(s0)
+ 738:	f018                	sd	a4,32(s0)
+ 73a:	f41c                	sd	a5,40(s0)
+ 73c:	03043823          	sd	a6,48(s0)
+ 740:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 744:	00840613          	addi	a2,s0,8
+ 748:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 74c:	85aa                	mv	a1,a0
+ 74e:	4505                	li	a0,1
+ 750:	d0dff0ef          	jal	45c <vprintf>
+}
+ 754:	60e2                	ld	ra,24(sp)
+ 756:	6442                	ld	s0,16(sp)
+ 758:	6125                	addi	sp,sp,96
+ 75a:	8082                	ret
+
+000000000000075c <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 75c:	1141                	addi	sp,sp,-16
+ 75e:	e422                	sd	s0,8(sp)
+ 760:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 762:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 766:	00001797          	auipc	a5,0x1
+ 76a:	89a7b783          	ld	a5,-1894(a5) # 1000 <freep>
+ 76e:	a02d                	j	798 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 770:	4618                	lw	a4,8(a2)
+ 772:	9f2d                	addw	a4,a4,a1
+ 774:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 778:	6398                	ld	a4,0(a5)
+ 77a:	6310                	ld	a2,0(a4)
+ 77c:	a83d                	j	7ba <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 77e:	ff852703          	lw	a4,-8(a0)
+ 782:	9f31                	addw	a4,a4,a2
+ 784:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 786:	ff053683          	ld	a3,-16(a0)
+ 78a:	a091                	j	7ce <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 78c:	6398                	ld	a4,0(a5)
+ 78e:	00e7e463          	bltu	a5,a4,796 <free+0x3a>
+ 792:	00e6ea63          	bltu	a3,a4,7a6 <free+0x4a>
+{
+ 796:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 798:	fed7fae3          	bgeu	a5,a3,78c <free+0x30>
+ 79c:	6398                	ld	a4,0(a5)
+ 79e:	00e6e463          	bltu	a3,a4,7a6 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7a2:	fee7eae3          	bltu	a5,a4,796 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 7a6:	ff852583          	lw	a1,-8(a0)
+ 7aa:	6390                	ld	a2,0(a5)
+ 7ac:	02059813          	slli	a6,a1,0x20
+ 7b0:	01c85713          	srli	a4,a6,0x1c
+ 7b4:	9736                	add	a4,a4,a3
+ 7b6:	fae60de3          	beq	a2,a4,770 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7ba:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 7be:	4790                	lw	a2,8(a5)
+ 7c0:	02061593          	slli	a1,a2,0x20
+ 7c4:	01c5d713          	srli	a4,a1,0x1c
+ 7c8:	973e                	add	a4,a4,a5
+ 7ca:	fae68ae3          	beq	a3,a4,77e <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 7ce:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 7d0:	00001717          	auipc	a4,0x1
+ 7d4:	82f73823          	sd	a5,-2000(a4) # 1000 <freep>
+}
+ 7d8:	6422                	ld	s0,8(sp)
+ 7da:	0141                	addi	sp,sp,16
+ 7dc:	8082                	ret
+
+00000000000007de <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 7de:	7139                	addi	sp,sp,-64
+ 7e0:	fc06                	sd	ra,56(sp)
+ 7e2:	f822                	sd	s0,48(sp)
+ 7e4:	f426                	sd	s1,40(sp)
+ 7e6:	ec4e                	sd	s3,24(sp)
+ 7e8:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7ea:	02051493          	slli	s1,a0,0x20
+ 7ee:	9081                	srli	s1,s1,0x20
+ 7f0:	04bd                	addi	s1,s1,15
+ 7f2:	8091                	srli	s1,s1,0x4
+ 7f4:	0014899b          	addiw	s3,s1,1
+ 7f8:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7fa:	00001517          	auipc	a0,0x1
+ 7fe:	80653503          	ld	a0,-2042(a0) # 1000 <freep>
+ 802:	c915                	beqz	a0,836 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 804:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 806:	4798                	lw	a4,8(a5)
+ 808:	08977a63          	bgeu	a4,s1,89c <malloc+0xbe>
+ 80c:	f04a                	sd	s2,32(sp)
+ 80e:	e852                	sd	s4,16(sp)
+ 810:	e456                	sd	s5,8(sp)
+ 812:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 814:	8a4e                	mv	s4,s3
+ 816:	0009871b          	sext.w	a4,s3
+ 81a:	6685                	lui	a3,0x1
+ 81c:	00d77363          	bgeu	a4,a3,822 <malloc+0x44>
+ 820:	6a05                	lui	s4,0x1
+ 822:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 826:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 82a:	00000917          	auipc	s2,0x0
+ 82e:	7d690913          	addi	s2,s2,2006 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 832:	5afd                	li	s5,-1
+ 834:	a081                	j	874 <malloc+0x96>
+ 836:	f04a                	sd	s2,32(sp)
+ 838:	e852                	sd	s4,16(sp)
+ 83a:	e456                	sd	s5,8(sp)
+ 83c:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 83e:	00000797          	auipc	a5,0x0
+ 842:	7d278793          	addi	a5,a5,2002 # 1010 <base>
+ 846:	00000717          	auipc	a4,0x0
+ 84a:	7af73d23          	sd	a5,1978(a4) # 1000 <freep>
+ 84e:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 850:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 854:	b7c1                	j	814 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 856:	6398                	ld	a4,0(a5)
+ 858:	e118                	sd	a4,0(a0)
+ 85a:	a8a9                	j	8b4 <malloc+0xd6>
+  hp->s.size = nu;
+ 85c:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 860:	0541                	addi	a0,a0,16
+ 862:	efbff0ef          	jal	75c <free>
+  return freep;
+ 866:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 86a:	c12d                	beqz	a0,8cc <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 86c:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 86e:	4798                	lw	a4,8(a5)
+ 870:	02977263          	bgeu	a4,s1,894 <malloc+0xb6>
+    if(p == freep)
+ 874:	00093703          	ld	a4,0(s2)
+ 878:	853e                	mv	a0,a5
+ 87a:	fef719e3          	bne	a4,a5,86c <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 87e:	8552                	mv	a0,s4
+ 880:	a47ff0ef          	jal	2c6 <sbrk>
+  if(p == SBRK_ERROR)
+ 884:	fd551ce3          	bne	a0,s5,85c <malloc+0x7e>
+        return 0;
+ 888:	4501                	li	a0,0
+ 88a:	7902                	ld	s2,32(sp)
+ 88c:	6a42                	ld	s4,16(sp)
+ 88e:	6aa2                	ld	s5,8(sp)
+ 890:	6b02                	ld	s6,0(sp)
+ 892:	a03d                	j	8c0 <malloc+0xe2>
+ 894:	7902                	ld	s2,32(sp)
+ 896:	6a42                	ld	s4,16(sp)
+ 898:	6aa2                	ld	s5,8(sp)
+ 89a:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 89c:	fae48de3          	beq	s1,a4,856 <malloc+0x78>
+        p->s.size -= nunits;
+ 8a0:	4137073b          	subw	a4,a4,s3
+ 8a4:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 8a6:	02071693          	slli	a3,a4,0x20
+ 8aa:	01c6d713          	srli	a4,a3,0x1c
+ 8ae:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 8b0:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 8b4:	00000717          	auipc	a4,0x0
+ 8b8:	74a73623          	sd	a0,1868(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 8bc:	01078513          	addi	a0,a5,16
+  }
+}
+ 8c0:	70e2                	ld	ra,56(sp)
+ 8c2:	7442                	ld	s0,48(sp)
+ 8c4:	74a2                	ld	s1,40(sp)
+ 8c6:	69e2                	ld	s3,24(sp)
+ 8c8:	6121                	addi	sp,sp,64
+ 8ca:	8082                	ret
+ 8cc:	7902                	ld	s2,32(sp)
+ 8ce:	6a42                	ld	s4,16(sp)
+ 8d0:	6aa2                	ld	s5,8(sp)
+ 8d2:	6b02                	ld	s6,0(sp)
+ 8d4:	b7f5                	j	8c0 <malloc+0xe2>
diff -ruN xv6-riscv/user/rm.d xv62/user/rm.d
--- xv6-riscv/user/rm.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/rm.d	2025-09-14 12:32:51.140883261 +0000
@@ -0,0 +1 @@
+user/rm.o: user/rm.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/rm.o and xv62/user/rm.o differ
diff -ruN xv6-riscv/user/rm.sym xv62/user/rm.sym
--- xv6-riscv/user/rm.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/rm.sym	2025-09-14 12:32:51.152883258 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+00000000000008d8 .rodata
+0000000000000938 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 rm.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+00000000000003a2 putc
+00000000000003c0 printint
+0000000000000920 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+0000000000000076 strcpy
+000000000000038a pause
+000000000000072a printf
+0000000000000382 sys_sbrk
+0000000000000220 memmove
+0000000000000342 mknod
+000000000000012e gets
+000000000000037a getpid
+00000000000002b2 memcpy
+00000000000007de malloc
+00000000000002dc sbrklazy
+000000000000030a pipe
+000000000000031a write
+0000000000000352 fstat
+0000000000000700 fprintf
+000000000000032a kill
+000000000000045c vprintf
+000000000000036a chdir
+0000000000000332 exec
+0000000000000302 wait
+0000000000000312 read
+000000000000034a unlink
+0000000000000278 memcmp
+00000000000002f2 fork
+00000000000002c6 sbrk
+0000000000000392 uptime
+00000000000000e8 memset
+0000000000000000 main
+0000000000000092 strcmp
+0000000000000372 dup
+000000000000039a getreadcount
+000000000000019e stat
+000000000000035a link
+00000000000002fa exit
+0000000000000066 start
+00000000000001d8 atoi
+00000000000000be strlen
+000000000000033a open
+000000000000010a strchr
+0000000000000362 mkdir
+0000000000000322 close
+000000000000075c free
diff -ruN xv6-riscv/user/sh.asm xv62/user/sh.asm
--- xv6-riscv/user/sh.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/sh.asm	2025-09-14 12:32:51.276883233 +0000
@@ -0,0 +1,2789 @@
+
+user/_sh:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <getcmd>:
+  exit(0);
+}
+
+int
+getcmd(char *buf, int nbuf)
+{
+       0:	1101                	addi	sp,sp,-32
+       2:	ec06                	sd	ra,24(sp)
+       4:	e822                	sd	s0,16(sp)
+       6:	e426                	sd	s1,8(sp)
+       8:	e04a                	sd	s2,0(sp)
+       a:	1000                	addi	s0,sp,32
+       c:	84aa                	mv	s1,a0
+       e:	892e                	mv	s2,a1
+  write(2, "$ ", 2);
+      10:	4609                	li	a2,2
+      12:	00001597          	auipc	a1,0x1
+      16:	1fe58593          	addi	a1,a1,510 # 1210 <malloc+0xfe>
+      1a:	4509                	li	a0,2
+      1c:	433000ef          	jal	c4e <write>
+  memset(buf, 0, nbuf);
+      20:	864a                	mv	a2,s2
+      22:	4581                	li	a1,0
+      24:	8526                	mv	a0,s1
+      26:	1f7000ef          	jal	a1c <memset>
+  gets(buf, nbuf);
+      2a:	85ca                	mv	a1,s2
+      2c:	8526                	mv	a0,s1
+      2e:	235000ef          	jal	a62 <gets>
+  if(buf[0] == 0) // EOF
+      32:	0004c503          	lbu	a0,0(s1)
+      36:	00153513          	seqz	a0,a0
+    return -1;
+  return 0;
+}
+      3a:	40a00533          	neg	a0,a0
+      3e:	60e2                	ld	ra,24(sp)
+      40:	6442                	ld	s0,16(sp)
+      42:	64a2                	ld	s1,8(sp)
+      44:	6902                	ld	s2,0(sp)
+      46:	6105                	addi	sp,sp,32
+      48:	8082                	ret
+
+000000000000004a <panic>:
+  exit(0);
+}
+
+void
+panic(char *s)
+{
+      4a:	1141                	addi	sp,sp,-16
+      4c:	e406                	sd	ra,8(sp)
+      4e:	e022                	sd	s0,0(sp)
+      50:	0800                	addi	s0,sp,16
+      52:	862a                	mv	a2,a0
+  fprintf(2, "%s\n", s);
+      54:	00001597          	auipc	a1,0x1
+      58:	1cc58593          	addi	a1,a1,460 # 1220 <malloc+0x10e>
+      5c:	4509                	li	a0,2
+      5e:	7d7000ef          	jal	1034 <fprintf>
+  exit(1);
+      62:	4505                	li	a0,1
+      64:	3cb000ef          	jal	c2e <exit>
+
+0000000000000068 <fork1>:
+}
+
+int
+fork1(void)
+{
+      68:	1141                	addi	sp,sp,-16
+      6a:	e406                	sd	ra,8(sp)
+      6c:	e022                	sd	s0,0(sp)
+      6e:	0800                	addi	s0,sp,16
+  int pid;
+
+  pid = fork();
+      70:	3b7000ef          	jal	c26 <fork>
+  if(pid == -1)
+      74:	57fd                	li	a5,-1
+      76:	00f50663          	beq	a0,a5,82 <fork1+0x1a>
+    panic("fork");
+  return pid;
+}
+      7a:	60a2                	ld	ra,8(sp)
+      7c:	6402                	ld	s0,0(sp)
+      7e:	0141                	addi	sp,sp,16
+      80:	8082                	ret
+    panic("fork");
+      82:	00001517          	auipc	a0,0x1
+      86:	1a650513          	addi	a0,a0,422 # 1228 <malloc+0x116>
+      8a:	fc1ff0ef          	jal	4a <panic>
+
+000000000000008e <runcmd>:
+{
+      8e:	7179                	addi	sp,sp,-48
+      90:	f406                	sd	ra,40(sp)
+      92:	f022                	sd	s0,32(sp)
+      94:	1800                	addi	s0,sp,48
+  if(cmd == 0)
+      96:	c115                	beqz	a0,ba <runcmd+0x2c>
+      98:	ec26                	sd	s1,24(sp)
+      9a:	84aa                	mv	s1,a0
+  switch(cmd->type){
+      9c:	4118                	lw	a4,0(a0)
+      9e:	4795                	li	a5,5
+      a0:	02e7e163          	bltu	a5,a4,c2 <runcmd+0x34>
+      a4:	00056783          	lwu	a5,0(a0)
+      a8:	078a                	slli	a5,a5,0x2
+      aa:	00001717          	auipc	a4,0x1
+      ae:	27e70713          	addi	a4,a4,638 # 1328 <malloc+0x216>
+      b2:	97ba                	add	a5,a5,a4
+      b4:	439c                	lw	a5,0(a5)
+      b6:	97ba                	add	a5,a5,a4
+      b8:	8782                	jr	a5
+      ba:	ec26                	sd	s1,24(sp)
+    exit(1);
+      bc:	4505                	li	a0,1
+      be:	371000ef          	jal	c2e <exit>
+    panic("runcmd");
+      c2:	00001517          	auipc	a0,0x1
+      c6:	16e50513          	addi	a0,a0,366 # 1230 <malloc+0x11e>
+      ca:	f81ff0ef          	jal	4a <panic>
+    if(ecmd->argv[0] == 0)
+      ce:	6508                	ld	a0,8(a0)
+      d0:	c105                	beqz	a0,f0 <runcmd+0x62>
+    exec(ecmd->argv[0], ecmd->argv);
+      d2:	00848593          	addi	a1,s1,8
+      d6:	391000ef          	jal	c66 <exec>
+    fprintf(2, "exec %s failed\n", ecmd->argv[0]);
+      da:	6490                	ld	a2,8(s1)
+      dc:	00001597          	auipc	a1,0x1
+      e0:	15c58593          	addi	a1,a1,348 # 1238 <malloc+0x126>
+      e4:	4509                	li	a0,2
+      e6:	74f000ef          	jal	1034 <fprintf>
+  exit(0);
+      ea:	4501                	li	a0,0
+      ec:	343000ef          	jal	c2e <exit>
+      exit(1);
+      f0:	4505                	li	a0,1
+      f2:	33d000ef          	jal	c2e <exit>
+    close(rcmd->fd);
+      f6:	5148                	lw	a0,36(a0)
+      f8:	35f000ef          	jal	c56 <close>
+    if(open(rcmd->file, rcmd->mode) < 0){
+      fc:	508c                	lw	a1,32(s1)
+      fe:	6888                	ld	a0,16(s1)
+     100:	36f000ef          	jal	c6e <open>
+     104:	00054563          	bltz	a0,10e <runcmd+0x80>
+    runcmd(rcmd->cmd);
+     108:	6488                	ld	a0,8(s1)
+     10a:	f85ff0ef          	jal	8e <runcmd>
+      fprintf(2, "open %s failed\n", rcmd->file);
+     10e:	6890                	ld	a2,16(s1)
+     110:	00001597          	auipc	a1,0x1
+     114:	13858593          	addi	a1,a1,312 # 1248 <malloc+0x136>
+     118:	4509                	li	a0,2
+     11a:	71b000ef          	jal	1034 <fprintf>
+      exit(1);
+     11e:	4505                	li	a0,1
+     120:	30f000ef          	jal	c2e <exit>
+    if(fork1() == 0)
+     124:	f45ff0ef          	jal	68 <fork1>
+     128:	e501                	bnez	a0,130 <runcmd+0xa2>
+      runcmd(lcmd->left);
+     12a:	6488                	ld	a0,8(s1)
+     12c:	f63ff0ef          	jal	8e <runcmd>
+    wait(0);
+     130:	4501                	li	a0,0
+     132:	305000ef          	jal	c36 <wait>
+    runcmd(lcmd->right);
+     136:	6888                	ld	a0,16(s1)
+     138:	f57ff0ef          	jal	8e <runcmd>
+    if(pipe(p) < 0)
+     13c:	fd840513          	addi	a0,s0,-40
+     140:	2ff000ef          	jal	c3e <pipe>
+     144:	02054763          	bltz	a0,172 <runcmd+0xe4>
+    if(fork1() == 0){
+     148:	f21ff0ef          	jal	68 <fork1>
+     14c:	e90d                	bnez	a0,17e <runcmd+0xf0>
+      close(1);
+     14e:	4505                	li	a0,1
+     150:	307000ef          	jal	c56 <close>
+      dup(p[1]);
+     154:	fdc42503          	lw	a0,-36(s0)
+     158:	34f000ef          	jal	ca6 <dup>
+      close(p[0]);
+     15c:	fd842503          	lw	a0,-40(s0)
+     160:	2f7000ef          	jal	c56 <close>
+      close(p[1]);
+     164:	fdc42503          	lw	a0,-36(s0)
+     168:	2ef000ef          	jal	c56 <close>
+      runcmd(pcmd->left);
+     16c:	6488                	ld	a0,8(s1)
+     16e:	f21ff0ef          	jal	8e <runcmd>
+      panic("pipe");
+     172:	00001517          	auipc	a0,0x1
+     176:	0e650513          	addi	a0,a0,230 # 1258 <malloc+0x146>
+     17a:	ed1ff0ef          	jal	4a <panic>
+    if(fork1() == 0){
+     17e:	eebff0ef          	jal	68 <fork1>
+     182:	e115                	bnez	a0,1a6 <runcmd+0x118>
+      close(0);
+     184:	2d3000ef          	jal	c56 <close>
+      dup(p[0]);
+     188:	fd842503          	lw	a0,-40(s0)
+     18c:	31b000ef          	jal	ca6 <dup>
+      close(p[0]);
+     190:	fd842503          	lw	a0,-40(s0)
+     194:	2c3000ef          	jal	c56 <close>
+      close(p[1]);
+     198:	fdc42503          	lw	a0,-36(s0)
+     19c:	2bb000ef          	jal	c56 <close>
+      runcmd(pcmd->right);
+     1a0:	6888                	ld	a0,16(s1)
+     1a2:	eedff0ef          	jal	8e <runcmd>
+    close(p[0]);
+     1a6:	fd842503          	lw	a0,-40(s0)
+     1aa:	2ad000ef          	jal	c56 <close>
+    close(p[1]);
+     1ae:	fdc42503          	lw	a0,-36(s0)
+     1b2:	2a5000ef          	jal	c56 <close>
+    wait(0);
+     1b6:	4501                	li	a0,0
+     1b8:	27f000ef          	jal	c36 <wait>
+    wait(0);
+     1bc:	4501                	li	a0,0
+     1be:	279000ef          	jal	c36 <wait>
+    break;
+     1c2:	b725                	j	ea <runcmd+0x5c>
+    if(fork1() == 0)
+     1c4:	ea5ff0ef          	jal	68 <fork1>
+     1c8:	f20511e3          	bnez	a0,ea <runcmd+0x5c>
+      runcmd(bcmd->cmd);
+     1cc:	6488                	ld	a0,8(s1)
+     1ce:	ec1ff0ef          	jal	8e <runcmd>
+
+00000000000001d2 <execcmd>:
+//PAGEBREAK!
+// Constructors
+
+struct cmd*
+execcmd(void)
+{
+     1d2:	1101                	addi	sp,sp,-32
+     1d4:	ec06                	sd	ra,24(sp)
+     1d6:	e822                	sd	s0,16(sp)
+     1d8:	e426                	sd	s1,8(sp)
+     1da:	1000                	addi	s0,sp,32
+  struct execcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     1dc:	0a800513          	li	a0,168
+     1e0:	733000ef          	jal	1112 <malloc>
+     1e4:	84aa                	mv	s1,a0
+  memset(cmd, 0, sizeof(*cmd));
+     1e6:	0a800613          	li	a2,168
+     1ea:	4581                	li	a1,0
+     1ec:	031000ef          	jal	a1c <memset>
+  cmd->type = EXEC;
+     1f0:	4785                	li	a5,1
+     1f2:	c09c                	sw	a5,0(s1)
+  return (struct cmd*)cmd;
+}
+     1f4:	8526                	mv	a0,s1
+     1f6:	60e2                	ld	ra,24(sp)
+     1f8:	6442                	ld	s0,16(sp)
+     1fa:	64a2                	ld	s1,8(sp)
+     1fc:	6105                	addi	sp,sp,32
+     1fe:	8082                	ret
+
+0000000000000200 <redircmd>:
+
+struct cmd*
+redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
+{
+     200:	7139                	addi	sp,sp,-64
+     202:	fc06                	sd	ra,56(sp)
+     204:	f822                	sd	s0,48(sp)
+     206:	f426                	sd	s1,40(sp)
+     208:	f04a                	sd	s2,32(sp)
+     20a:	ec4e                	sd	s3,24(sp)
+     20c:	e852                	sd	s4,16(sp)
+     20e:	e456                	sd	s5,8(sp)
+     210:	e05a                	sd	s6,0(sp)
+     212:	0080                	addi	s0,sp,64
+     214:	8b2a                	mv	s6,a0
+     216:	8aae                	mv	s5,a1
+     218:	8a32                	mv	s4,a2
+     21a:	89b6                	mv	s3,a3
+     21c:	893a                	mv	s2,a4
+  struct redircmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     21e:	02800513          	li	a0,40
+     222:	6f1000ef          	jal	1112 <malloc>
+     226:	84aa                	mv	s1,a0
+  memset(cmd, 0, sizeof(*cmd));
+     228:	02800613          	li	a2,40
+     22c:	4581                	li	a1,0
+     22e:	7ee000ef          	jal	a1c <memset>
+  cmd->type = REDIR;
+     232:	4789                	li	a5,2
+     234:	c09c                	sw	a5,0(s1)
+  cmd->cmd = subcmd;
+     236:	0164b423          	sd	s6,8(s1)
+  cmd->file = file;
+     23a:	0154b823          	sd	s5,16(s1)
+  cmd->efile = efile;
+     23e:	0144bc23          	sd	s4,24(s1)
+  cmd->mode = mode;
+     242:	0334a023          	sw	s3,32(s1)
+  cmd->fd = fd;
+     246:	0324a223          	sw	s2,36(s1)
+  return (struct cmd*)cmd;
+}
+     24a:	8526                	mv	a0,s1
+     24c:	70e2                	ld	ra,56(sp)
+     24e:	7442                	ld	s0,48(sp)
+     250:	74a2                	ld	s1,40(sp)
+     252:	7902                	ld	s2,32(sp)
+     254:	69e2                	ld	s3,24(sp)
+     256:	6a42                	ld	s4,16(sp)
+     258:	6aa2                	ld	s5,8(sp)
+     25a:	6b02                	ld	s6,0(sp)
+     25c:	6121                	addi	sp,sp,64
+     25e:	8082                	ret
+
+0000000000000260 <pipecmd>:
+
+struct cmd*
+pipecmd(struct cmd *left, struct cmd *right)
+{
+     260:	7179                	addi	sp,sp,-48
+     262:	f406                	sd	ra,40(sp)
+     264:	f022                	sd	s0,32(sp)
+     266:	ec26                	sd	s1,24(sp)
+     268:	e84a                	sd	s2,16(sp)
+     26a:	e44e                	sd	s3,8(sp)
+     26c:	1800                	addi	s0,sp,48
+     26e:	89aa                	mv	s3,a0
+     270:	892e                	mv	s2,a1
+  struct pipecmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     272:	4561                	li	a0,24
+     274:	69f000ef          	jal	1112 <malloc>
+     278:	84aa                	mv	s1,a0
+  memset(cmd, 0, sizeof(*cmd));
+     27a:	4661                	li	a2,24
+     27c:	4581                	li	a1,0
+     27e:	79e000ef          	jal	a1c <memset>
+  cmd->type = PIPE;
+     282:	478d                	li	a5,3
+     284:	c09c                	sw	a5,0(s1)
+  cmd->left = left;
+     286:	0134b423          	sd	s3,8(s1)
+  cmd->right = right;
+     28a:	0124b823          	sd	s2,16(s1)
+  return (struct cmd*)cmd;
+}
+     28e:	8526                	mv	a0,s1
+     290:	70a2                	ld	ra,40(sp)
+     292:	7402                	ld	s0,32(sp)
+     294:	64e2                	ld	s1,24(sp)
+     296:	6942                	ld	s2,16(sp)
+     298:	69a2                	ld	s3,8(sp)
+     29a:	6145                	addi	sp,sp,48
+     29c:	8082                	ret
+
+000000000000029e <listcmd>:
+
+struct cmd*
+listcmd(struct cmd *left, struct cmd *right)
+{
+     29e:	7179                	addi	sp,sp,-48
+     2a0:	f406                	sd	ra,40(sp)
+     2a2:	f022                	sd	s0,32(sp)
+     2a4:	ec26                	sd	s1,24(sp)
+     2a6:	e84a                	sd	s2,16(sp)
+     2a8:	e44e                	sd	s3,8(sp)
+     2aa:	1800                	addi	s0,sp,48
+     2ac:	89aa                	mv	s3,a0
+     2ae:	892e                	mv	s2,a1
+  struct listcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     2b0:	4561                	li	a0,24
+     2b2:	661000ef          	jal	1112 <malloc>
+     2b6:	84aa                	mv	s1,a0
+  memset(cmd, 0, sizeof(*cmd));
+     2b8:	4661                	li	a2,24
+     2ba:	4581                	li	a1,0
+     2bc:	760000ef          	jal	a1c <memset>
+  cmd->type = LIST;
+     2c0:	4791                	li	a5,4
+     2c2:	c09c                	sw	a5,0(s1)
+  cmd->left = left;
+     2c4:	0134b423          	sd	s3,8(s1)
+  cmd->right = right;
+     2c8:	0124b823          	sd	s2,16(s1)
+  return (struct cmd*)cmd;
+}
+     2cc:	8526                	mv	a0,s1
+     2ce:	70a2                	ld	ra,40(sp)
+     2d0:	7402                	ld	s0,32(sp)
+     2d2:	64e2                	ld	s1,24(sp)
+     2d4:	6942                	ld	s2,16(sp)
+     2d6:	69a2                	ld	s3,8(sp)
+     2d8:	6145                	addi	sp,sp,48
+     2da:	8082                	ret
+
+00000000000002dc <backcmd>:
+
+struct cmd*
+backcmd(struct cmd *subcmd)
+{
+     2dc:	1101                	addi	sp,sp,-32
+     2de:	ec06                	sd	ra,24(sp)
+     2e0:	e822                	sd	s0,16(sp)
+     2e2:	e426                	sd	s1,8(sp)
+     2e4:	e04a                	sd	s2,0(sp)
+     2e6:	1000                	addi	s0,sp,32
+     2e8:	892a                	mv	s2,a0
+  struct backcmd *cmd;
+
+  cmd = malloc(sizeof(*cmd));
+     2ea:	4541                	li	a0,16
+     2ec:	627000ef          	jal	1112 <malloc>
+     2f0:	84aa                	mv	s1,a0
+  memset(cmd, 0, sizeof(*cmd));
+     2f2:	4641                	li	a2,16
+     2f4:	4581                	li	a1,0
+     2f6:	726000ef          	jal	a1c <memset>
+  cmd->type = BACK;
+     2fa:	4795                	li	a5,5
+     2fc:	c09c                	sw	a5,0(s1)
+  cmd->cmd = subcmd;
+     2fe:	0124b423          	sd	s2,8(s1)
+  return (struct cmd*)cmd;
+}
+     302:	8526                	mv	a0,s1
+     304:	60e2                	ld	ra,24(sp)
+     306:	6442                	ld	s0,16(sp)
+     308:	64a2                	ld	s1,8(sp)
+     30a:	6902                	ld	s2,0(sp)
+     30c:	6105                	addi	sp,sp,32
+     30e:	8082                	ret
+
+0000000000000310 <gettoken>:
+char whitespace[] = " \t\r\n\v";
+char symbols[] = "<|>&;()";
+
+int
+gettoken(char **ps, char *es, char **q, char **eq)
+{
+     310:	7139                	addi	sp,sp,-64
+     312:	fc06                	sd	ra,56(sp)
+     314:	f822                	sd	s0,48(sp)
+     316:	f426                	sd	s1,40(sp)
+     318:	f04a                	sd	s2,32(sp)
+     31a:	ec4e                	sd	s3,24(sp)
+     31c:	e852                	sd	s4,16(sp)
+     31e:	e456                	sd	s5,8(sp)
+     320:	e05a                	sd	s6,0(sp)
+     322:	0080                	addi	s0,sp,64
+     324:	8a2a                	mv	s4,a0
+     326:	892e                	mv	s2,a1
+     328:	8ab2                	mv	s5,a2
+     32a:	8b36                	mv	s6,a3
+  char *s;
+  int ret;
+
+  s = *ps;
+     32c:	6104                	ld	s1,0(a0)
+  while(s < es && strchr(whitespace, *s))
+     32e:	00002997          	auipc	s3,0x2
+     332:	cda98993          	addi	s3,s3,-806 # 2008 <whitespace>
+     336:	00b4fc63          	bgeu	s1,a1,34e <gettoken+0x3e>
+     33a:	0004c583          	lbu	a1,0(s1)
+     33e:	854e                	mv	a0,s3
+     340:	6fe000ef          	jal	a3e <strchr>
+     344:	c509                	beqz	a0,34e <gettoken+0x3e>
+    s++;
+     346:	0485                	addi	s1,s1,1
+  while(s < es && strchr(whitespace, *s))
+     348:	fe9919e3          	bne	s2,s1,33a <gettoken+0x2a>
+     34c:	84ca                	mv	s1,s2
+  if(q)
+     34e:	000a8463          	beqz	s5,356 <gettoken+0x46>
+    *q = s;
+     352:	009ab023          	sd	s1,0(s5)
+  ret = *s;
+     356:	0004c783          	lbu	a5,0(s1)
+     35a:	00078a9b          	sext.w	s5,a5
+  switch(*s){
+     35e:	03c00713          	li	a4,60
+     362:	06f76463          	bltu	a4,a5,3ca <gettoken+0xba>
+     366:	03a00713          	li	a4,58
+     36a:	00f76e63          	bltu	a4,a5,386 <gettoken+0x76>
+     36e:	cf89                	beqz	a5,388 <gettoken+0x78>
+     370:	02600713          	li	a4,38
+     374:	00e78963          	beq	a5,a4,386 <gettoken+0x76>
+     378:	fd87879b          	addiw	a5,a5,-40
+     37c:	0ff7f793          	zext.b	a5,a5
+     380:	4705                	li	a4,1
+     382:	06f76b63          	bltu	a4,a5,3f8 <gettoken+0xe8>
+  case '(':
+  case ')':
+  case ';':
+  case '&':
+  case '<':
+    s++;
+     386:	0485                	addi	s1,s1,1
+    ret = 'a';
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+      s++;
+    break;
+  }
+  if(eq)
+     388:	000b0463          	beqz	s6,390 <gettoken+0x80>
+    *eq = s;
+     38c:	009b3023          	sd	s1,0(s6)
+
+  while(s < es && strchr(whitespace, *s))
+     390:	00002997          	auipc	s3,0x2
+     394:	c7898993          	addi	s3,s3,-904 # 2008 <whitespace>
+     398:	0124fc63          	bgeu	s1,s2,3b0 <gettoken+0xa0>
+     39c:	0004c583          	lbu	a1,0(s1)
+     3a0:	854e                	mv	a0,s3
+     3a2:	69c000ef          	jal	a3e <strchr>
+     3a6:	c509                	beqz	a0,3b0 <gettoken+0xa0>
+    s++;
+     3a8:	0485                	addi	s1,s1,1
+  while(s < es && strchr(whitespace, *s))
+     3aa:	fe9919e3          	bne	s2,s1,39c <gettoken+0x8c>
+     3ae:	84ca                	mv	s1,s2
+  *ps = s;
+     3b0:	009a3023          	sd	s1,0(s4)
+  return ret;
+}
+     3b4:	8556                	mv	a0,s5
+     3b6:	70e2                	ld	ra,56(sp)
+     3b8:	7442                	ld	s0,48(sp)
+     3ba:	74a2                	ld	s1,40(sp)
+     3bc:	7902                	ld	s2,32(sp)
+     3be:	69e2                	ld	s3,24(sp)
+     3c0:	6a42                	ld	s4,16(sp)
+     3c2:	6aa2                	ld	s5,8(sp)
+     3c4:	6b02                	ld	s6,0(sp)
+     3c6:	6121                	addi	sp,sp,64
+     3c8:	8082                	ret
+  switch(*s){
+     3ca:	03e00713          	li	a4,62
+     3ce:	02e79163          	bne	a5,a4,3f0 <gettoken+0xe0>
+    s++;
+     3d2:	00148693          	addi	a3,s1,1
+    if(*s == '>'){
+     3d6:	0014c703          	lbu	a4,1(s1)
+     3da:	03e00793          	li	a5,62
+      s++;
+     3de:	0489                	addi	s1,s1,2
+      ret = '+';
+     3e0:	02b00a93          	li	s5,43
+    if(*s == '>'){
+     3e4:	faf702e3          	beq	a4,a5,388 <gettoken+0x78>
+    s++;
+     3e8:	84b6                	mv	s1,a3
+  ret = *s;
+     3ea:	03e00a93          	li	s5,62
+     3ee:	bf69                	j	388 <gettoken+0x78>
+  switch(*s){
+     3f0:	07c00713          	li	a4,124
+     3f4:	f8e789e3          	beq	a5,a4,386 <gettoken+0x76>
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     3f8:	00002997          	auipc	s3,0x2
+     3fc:	c1098993          	addi	s3,s3,-1008 # 2008 <whitespace>
+     400:	00002a97          	auipc	s5,0x2
+     404:	c00a8a93          	addi	s5,s5,-1024 # 2000 <symbols>
+     408:	0324fd63          	bgeu	s1,s2,442 <gettoken+0x132>
+     40c:	0004c583          	lbu	a1,0(s1)
+     410:	854e                	mv	a0,s3
+     412:	62c000ef          	jal	a3e <strchr>
+     416:	e11d                	bnez	a0,43c <gettoken+0x12c>
+     418:	0004c583          	lbu	a1,0(s1)
+     41c:	8556                	mv	a0,s5
+     41e:	620000ef          	jal	a3e <strchr>
+     422:	e911                	bnez	a0,436 <gettoken+0x126>
+      s++;
+     424:	0485                	addi	s1,s1,1
+    while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
+     426:	fe9913e3          	bne	s2,s1,40c <gettoken+0xfc>
+  if(eq)
+     42a:	84ca                	mv	s1,s2
+    ret = 'a';
+     42c:	06100a93          	li	s5,97
+  if(eq)
+     430:	f40b1ee3          	bnez	s6,38c <gettoken+0x7c>
+     434:	bfb5                	j	3b0 <gettoken+0xa0>
+    ret = 'a';
+     436:	06100a93          	li	s5,97
+     43a:	b7b9                	j	388 <gettoken+0x78>
+     43c:	06100a93          	li	s5,97
+     440:	b7a1                	j	388 <gettoken+0x78>
+     442:	06100a93          	li	s5,97
+  if(eq)
+     446:	f40b13e3          	bnez	s6,38c <gettoken+0x7c>
+     44a:	b79d                	j	3b0 <gettoken+0xa0>
+
+000000000000044c <peek>:
+
+int
+peek(char **ps, char *es, char *toks)
+{
+     44c:	7139                	addi	sp,sp,-64
+     44e:	fc06                	sd	ra,56(sp)
+     450:	f822                	sd	s0,48(sp)
+     452:	f426                	sd	s1,40(sp)
+     454:	f04a                	sd	s2,32(sp)
+     456:	ec4e                	sd	s3,24(sp)
+     458:	e852                	sd	s4,16(sp)
+     45a:	e456                	sd	s5,8(sp)
+     45c:	0080                	addi	s0,sp,64
+     45e:	8a2a                	mv	s4,a0
+     460:	892e                	mv	s2,a1
+     462:	8ab2                	mv	s5,a2
+  char *s;
+
+  s = *ps;
+     464:	6104                	ld	s1,0(a0)
+  while(s < es && strchr(whitespace, *s))
+     466:	00002997          	auipc	s3,0x2
+     46a:	ba298993          	addi	s3,s3,-1118 # 2008 <whitespace>
+     46e:	00b4fc63          	bgeu	s1,a1,486 <peek+0x3a>
+     472:	0004c583          	lbu	a1,0(s1)
+     476:	854e                	mv	a0,s3
+     478:	5c6000ef          	jal	a3e <strchr>
+     47c:	c509                	beqz	a0,486 <peek+0x3a>
+    s++;
+     47e:	0485                	addi	s1,s1,1
+  while(s < es && strchr(whitespace, *s))
+     480:	fe9919e3          	bne	s2,s1,472 <peek+0x26>
+     484:	84ca                	mv	s1,s2
+  *ps = s;
+     486:	009a3023          	sd	s1,0(s4)
+  return *s && strchr(toks, *s);
+     48a:	0004c583          	lbu	a1,0(s1)
+     48e:	4501                	li	a0,0
+     490:	e991                	bnez	a1,4a4 <peek+0x58>
+}
+     492:	70e2                	ld	ra,56(sp)
+     494:	7442                	ld	s0,48(sp)
+     496:	74a2                	ld	s1,40(sp)
+     498:	7902                	ld	s2,32(sp)
+     49a:	69e2                	ld	s3,24(sp)
+     49c:	6a42                	ld	s4,16(sp)
+     49e:	6aa2                	ld	s5,8(sp)
+     4a0:	6121                	addi	sp,sp,64
+     4a2:	8082                	ret
+  return *s && strchr(toks, *s);
+     4a4:	8556                	mv	a0,s5
+     4a6:	598000ef          	jal	a3e <strchr>
+     4aa:	00a03533          	snez	a0,a0
+     4ae:	b7d5                	j	492 <peek+0x46>
+
+00000000000004b0 <parseredirs>:
+  return cmd;
+}
+
+struct cmd*
+parseredirs(struct cmd *cmd, char **ps, char *es)
+{
+     4b0:	711d                	addi	sp,sp,-96
+     4b2:	ec86                	sd	ra,88(sp)
+     4b4:	e8a2                	sd	s0,80(sp)
+     4b6:	e4a6                	sd	s1,72(sp)
+     4b8:	e0ca                	sd	s2,64(sp)
+     4ba:	fc4e                	sd	s3,56(sp)
+     4bc:	f852                	sd	s4,48(sp)
+     4be:	f456                	sd	s5,40(sp)
+     4c0:	f05a                	sd	s6,32(sp)
+     4c2:	ec5e                	sd	s7,24(sp)
+     4c4:	1080                	addi	s0,sp,96
+     4c6:	8a2a                	mv	s4,a0
+     4c8:	89ae                	mv	s3,a1
+     4ca:	8932                	mv	s2,a2
+  int tok;
+  char *q, *eq;
+
+  while(peek(ps, es, "<>")){
+     4cc:	00001a97          	auipc	s5,0x1
+     4d0:	db4a8a93          	addi	s5,s5,-588 # 1280 <malloc+0x16e>
+    tok = gettoken(ps, es, 0, 0);
+    if(gettoken(ps, es, &q, &eq) != 'a')
+     4d4:	06100b13          	li	s6,97
+      panic("missing file for redirection");
+    switch(tok){
+     4d8:	03c00b93          	li	s7,60
+  while(peek(ps, es, "<>")){
+     4dc:	a00d                	j	4fe <parseredirs+0x4e>
+      panic("missing file for redirection");
+     4de:	00001517          	auipc	a0,0x1
+     4e2:	d8250513          	addi	a0,a0,-638 # 1260 <malloc+0x14e>
+     4e6:	b65ff0ef          	jal	4a <panic>
+    case '<':
+      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
+     4ea:	4701                	li	a4,0
+     4ec:	4681                	li	a3,0
+     4ee:	fa043603          	ld	a2,-96(s0)
+     4f2:	fa843583          	ld	a1,-88(s0)
+     4f6:	8552                	mv	a0,s4
+     4f8:	d09ff0ef          	jal	200 <redircmd>
+     4fc:	8a2a                	mv	s4,a0
+  while(peek(ps, es, "<>")){
+     4fe:	8656                	mv	a2,s5
+     500:	85ca                	mv	a1,s2
+     502:	854e                	mv	a0,s3
+     504:	f49ff0ef          	jal	44c <peek>
+     508:	c525                	beqz	a0,570 <parseredirs+0xc0>
+    tok = gettoken(ps, es, 0, 0);
+     50a:	4681                	li	a3,0
+     50c:	4601                	li	a2,0
+     50e:	85ca                	mv	a1,s2
+     510:	854e                	mv	a0,s3
+     512:	dffff0ef          	jal	310 <gettoken>
+     516:	84aa                	mv	s1,a0
+    if(gettoken(ps, es, &q, &eq) != 'a')
+     518:	fa040693          	addi	a3,s0,-96
+     51c:	fa840613          	addi	a2,s0,-88
+     520:	85ca                	mv	a1,s2
+     522:	854e                	mv	a0,s3
+     524:	dedff0ef          	jal	310 <gettoken>
+     528:	fb651be3          	bne	a0,s6,4de <parseredirs+0x2e>
+    switch(tok){
+     52c:	fb748fe3          	beq	s1,s7,4ea <parseredirs+0x3a>
+     530:	03e00793          	li	a5,62
+     534:	02f48263          	beq	s1,a5,558 <parseredirs+0xa8>
+     538:	02b00793          	li	a5,43
+     53c:	fcf491e3          	bne	s1,a5,4fe <parseredirs+0x4e>
+      break;
+    case '>':
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE|O_TRUNC, 1);
+      break;
+    case '+':  // >>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
+     540:	4705                	li	a4,1
+     542:	20100693          	li	a3,513
+     546:	fa043603          	ld	a2,-96(s0)
+     54a:	fa843583          	ld	a1,-88(s0)
+     54e:	8552                	mv	a0,s4
+     550:	cb1ff0ef          	jal	200 <redircmd>
+     554:	8a2a                	mv	s4,a0
+      break;
+     556:	b765                	j	4fe <parseredirs+0x4e>
+      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE|O_TRUNC, 1);
+     558:	4705                	li	a4,1
+     55a:	60100693          	li	a3,1537
+     55e:	fa043603          	ld	a2,-96(s0)
+     562:	fa843583          	ld	a1,-88(s0)
+     566:	8552                	mv	a0,s4
+     568:	c99ff0ef          	jal	200 <redircmd>
+     56c:	8a2a                	mv	s4,a0
+      break;
+     56e:	bf41                	j	4fe <parseredirs+0x4e>
+    }
+  }
+  return cmd;
+}
+     570:	8552                	mv	a0,s4
+     572:	60e6                	ld	ra,88(sp)
+     574:	6446                	ld	s0,80(sp)
+     576:	64a6                	ld	s1,72(sp)
+     578:	6906                	ld	s2,64(sp)
+     57a:	79e2                	ld	s3,56(sp)
+     57c:	7a42                	ld	s4,48(sp)
+     57e:	7aa2                	ld	s5,40(sp)
+     580:	7b02                	ld	s6,32(sp)
+     582:	6be2                	ld	s7,24(sp)
+     584:	6125                	addi	sp,sp,96
+     586:	8082                	ret
+
+0000000000000588 <parseexec>:
+  return cmd;
+}
+
+struct cmd*
+parseexec(char **ps, char *es)
+{
+     588:	7159                	addi	sp,sp,-112
+     58a:	f486                	sd	ra,104(sp)
+     58c:	f0a2                	sd	s0,96(sp)
+     58e:	eca6                	sd	s1,88(sp)
+     590:	e0d2                	sd	s4,64(sp)
+     592:	fc56                	sd	s5,56(sp)
+     594:	1880                	addi	s0,sp,112
+     596:	8a2a                	mv	s4,a0
+     598:	8aae                	mv	s5,a1
+  char *q, *eq;
+  int tok, argc;
+  struct execcmd *cmd;
+  struct cmd *ret;
+
+  if(peek(ps, es, "("))
+     59a:	00001617          	auipc	a2,0x1
+     59e:	cee60613          	addi	a2,a2,-786 # 1288 <malloc+0x176>
+     5a2:	eabff0ef          	jal	44c <peek>
+     5a6:	e915                	bnez	a0,5da <parseexec+0x52>
+     5a8:	e8ca                	sd	s2,80(sp)
+     5aa:	e4ce                	sd	s3,72(sp)
+     5ac:	f85a                	sd	s6,48(sp)
+     5ae:	f45e                	sd	s7,40(sp)
+     5b0:	f062                	sd	s8,32(sp)
+     5b2:	ec66                	sd	s9,24(sp)
+     5b4:	89aa                	mv	s3,a0
+    return parseblock(ps, es);
+
+  ret = execcmd();
+     5b6:	c1dff0ef          	jal	1d2 <execcmd>
+     5ba:	8c2a                	mv	s8,a0
+  cmd = (struct execcmd*)ret;
+
+  argc = 0;
+  ret = parseredirs(ret, ps, es);
+     5bc:	8656                	mv	a2,s5
+     5be:	85d2                	mv	a1,s4
+     5c0:	ef1ff0ef          	jal	4b0 <parseredirs>
+     5c4:	84aa                	mv	s1,a0
+  while(!peek(ps, es, "|)&;")){
+     5c6:	008c0913          	addi	s2,s8,8
+     5ca:	00001b17          	auipc	s6,0x1
+     5ce:	cdeb0b13          	addi	s6,s6,-802 # 12a8 <malloc+0x196>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+      break;
+    if(tok != 'a')
+     5d2:	06100c93          	li	s9,97
+      panic("syntax");
+    cmd->argv[argc] = q;
+    cmd->eargv[argc] = eq;
+    argc++;
+    if(argc >= MAXARGS)
+     5d6:	4ba9                	li	s7,10
+  while(!peek(ps, es, "|)&;")){
+     5d8:	a815                	j	60c <parseexec+0x84>
+    return parseblock(ps, es);
+     5da:	85d6                	mv	a1,s5
+     5dc:	8552                	mv	a0,s4
+     5de:	170000ef          	jal	74e <parseblock>
+     5e2:	84aa                	mv	s1,a0
+    ret = parseredirs(ret, ps, es);
+  }
+  cmd->argv[argc] = 0;
+  cmd->eargv[argc] = 0;
+  return ret;
+}
+     5e4:	8526                	mv	a0,s1
+     5e6:	70a6                	ld	ra,104(sp)
+     5e8:	7406                	ld	s0,96(sp)
+     5ea:	64e6                	ld	s1,88(sp)
+     5ec:	6a06                	ld	s4,64(sp)
+     5ee:	7ae2                	ld	s5,56(sp)
+     5f0:	6165                	addi	sp,sp,112
+     5f2:	8082                	ret
+      panic("syntax");
+     5f4:	00001517          	auipc	a0,0x1
+     5f8:	c9c50513          	addi	a0,a0,-868 # 1290 <malloc+0x17e>
+     5fc:	a4fff0ef          	jal	4a <panic>
+    ret = parseredirs(ret, ps, es);
+     600:	8656                	mv	a2,s5
+     602:	85d2                	mv	a1,s4
+     604:	8526                	mv	a0,s1
+     606:	eabff0ef          	jal	4b0 <parseredirs>
+     60a:	84aa                	mv	s1,a0
+  while(!peek(ps, es, "|)&;")){
+     60c:	865a                	mv	a2,s6
+     60e:	85d6                	mv	a1,s5
+     610:	8552                	mv	a0,s4
+     612:	e3bff0ef          	jal	44c <peek>
+     616:	ed15                	bnez	a0,652 <parseexec+0xca>
+    if((tok=gettoken(ps, es, &q, &eq)) == 0)
+     618:	f9040693          	addi	a3,s0,-112
+     61c:	f9840613          	addi	a2,s0,-104
+     620:	85d6                	mv	a1,s5
+     622:	8552                	mv	a0,s4
+     624:	cedff0ef          	jal	310 <gettoken>
+     628:	c50d                	beqz	a0,652 <parseexec+0xca>
+    if(tok != 'a')
+     62a:	fd9515e3          	bne	a0,s9,5f4 <parseexec+0x6c>
+    cmd->argv[argc] = q;
+     62e:	f9843783          	ld	a5,-104(s0)
+     632:	00f93023          	sd	a5,0(s2)
+    cmd->eargv[argc] = eq;
+     636:	f9043783          	ld	a5,-112(s0)
+     63a:	04f93823          	sd	a5,80(s2)
+    argc++;
+     63e:	2985                	addiw	s3,s3,1
+    if(argc >= MAXARGS)
+     640:	0921                	addi	s2,s2,8
+     642:	fb799fe3          	bne	s3,s7,600 <parseexec+0x78>
+      panic("too many args");
+     646:	00001517          	auipc	a0,0x1
+     64a:	c5250513          	addi	a0,a0,-942 # 1298 <malloc+0x186>
+     64e:	9fdff0ef          	jal	4a <panic>
+  cmd->argv[argc] = 0;
+     652:	098e                	slli	s3,s3,0x3
+     654:	9c4e                	add	s8,s8,s3
+     656:	000c3423          	sd	zero,8(s8)
+  cmd->eargv[argc] = 0;
+     65a:	040c3c23          	sd	zero,88(s8)
+     65e:	6946                	ld	s2,80(sp)
+     660:	69a6                	ld	s3,72(sp)
+     662:	7b42                	ld	s6,48(sp)
+     664:	7ba2                	ld	s7,40(sp)
+     666:	7c02                	ld	s8,32(sp)
+     668:	6ce2                	ld	s9,24(sp)
+  return ret;
+     66a:	bfad                	j	5e4 <parseexec+0x5c>
+
+000000000000066c <parsepipe>:
+{
+     66c:	7179                	addi	sp,sp,-48
+     66e:	f406                	sd	ra,40(sp)
+     670:	f022                	sd	s0,32(sp)
+     672:	ec26                	sd	s1,24(sp)
+     674:	e84a                	sd	s2,16(sp)
+     676:	e44e                	sd	s3,8(sp)
+     678:	1800                	addi	s0,sp,48
+     67a:	892a                	mv	s2,a0
+     67c:	89ae                	mv	s3,a1
+  cmd = parseexec(ps, es);
+     67e:	f0bff0ef          	jal	588 <parseexec>
+     682:	84aa                	mv	s1,a0
+  if(peek(ps, es, "|")){
+     684:	00001617          	auipc	a2,0x1
+     688:	c2c60613          	addi	a2,a2,-980 # 12b0 <malloc+0x19e>
+     68c:	85ce                	mv	a1,s3
+     68e:	854a                	mv	a0,s2
+     690:	dbdff0ef          	jal	44c <peek>
+     694:	e909                	bnez	a0,6a6 <parsepipe+0x3a>
+}
+     696:	8526                	mv	a0,s1
+     698:	70a2                	ld	ra,40(sp)
+     69a:	7402                	ld	s0,32(sp)
+     69c:	64e2                	ld	s1,24(sp)
+     69e:	6942                	ld	s2,16(sp)
+     6a0:	69a2                	ld	s3,8(sp)
+     6a2:	6145                	addi	sp,sp,48
+     6a4:	8082                	ret
+    gettoken(ps, es, 0, 0);
+     6a6:	4681                	li	a3,0
+     6a8:	4601                	li	a2,0
+     6aa:	85ce                	mv	a1,s3
+     6ac:	854a                	mv	a0,s2
+     6ae:	c63ff0ef          	jal	310 <gettoken>
+    cmd = pipecmd(cmd, parsepipe(ps, es));
+     6b2:	85ce                	mv	a1,s3
+     6b4:	854a                	mv	a0,s2
+     6b6:	fb7ff0ef          	jal	66c <parsepipe>
+     6ba:	85aa                	mv	a1,a0
+     6bc:	8526                	mv	a0,s1
+     6be:	ba3ff0ef          	jal	260 <pipecmd>
+     6c2:	84aa                	mv	s1,a0
+  return cmd;
+     6c4:	bfc9                	j	696 <parsepipe+0x2a>
+
+00000000000006c6 <parseline>:
+{
+     6c6:	7179                	addi	sp,sp,-48
+     6c8:	f406                	sd	ra,40(sp)
+     6ca:	f022                	sd	s0,32(sp)
+     6cc:	ec26                	sd	s1,24(sp)
+     6ce:	e84a                	sd	s2,16(sp)
+     6d0:	e44e                	sd	s3,8(sp)
+     6d2:	e052                	sd	s4,0(sp)
+     6d4:	1800                	addi	s0,sp,48
+     6d6:	892a                	mv	s2,a0
+     6d8:	89ae                	mv	s3,a1
+  cmd = parsepipe(ps, es);
+     6da:	f93ff0ef          	jal	66c <parsepipe>
+     6de:	84aa                	mv	s1,a0
+  while(peek(ps, es, "&")){
+     6e0:	00001a17          	auipc	s4,0x1
+     6e4:	bd8a0a13          	addi	s4,s4,-1064 # 12b8 <malloc+0x1a6>
+     6e8:	a819                	j	6fe <parseline+0x38>
+    gettoken(ps, es, 0, 0);
+     6ea:	4681                	li	a3,0
+     6ec:	4601                	li	a2,0
+     6ee:	85ce                	mv	a1,s3
+     6f0:	854a                	mv	a0,s2
+     6f2:	c1fff0ef          	jal	310 <gettoken>
+    cmd = backcmd(cmd);
+     6f6:	8526                	mv	a0,s1
+     6f8:	be5ff0ef          	jal	2dc <backcmd>
+     6fc:	84aa                	mv	s1,a0
+  while(peek(ps, es, "&")){
+     6fe:	8652                	mv	a2,s4
+     700:	85ce                	mv	a1,s3
+     702:	854a                	mv	a0,s2
+     704:	d49ff0ef          	jal	44c <peek>
+     708:	f16d                	bnez	a0,6ea <parseline+0x24>
+  if(peek(ps, es, ";")){
+     70a:	00001617          	auipc	a2,0x1
+     70e:	bb660613          	addi	a2,a2,-1098 # 12c0 <malloc+0x1ae>
+     712:	85ce                	mv	a1,s3
+     714:	854a                	mv	a0,s2
+     716:	d37ff0ef          	jal	44c <peek>
+     71a:	e911                	bnez	a0,72e <parseline+0x68>
+}
+     71c:	8526                	mv	a0,s1
+     71e:	70a2                	ld	ra,40(sp)
+     720:	7402                	ld	s0,32(sp)
+     722:	64e2                	ld	s1,24(sp)
+     724:	6942                	ld	s2,16(sp)
+     726:	69a2                	ld	s3,8(sp)
+     728:	6a02                	ld	s4,0(sp)
+     72a:	6145                	addi	sp,sp,48
+     72c:	8082                	ret
+    gettoken(ps, es, 0, 0);
+     72e:	4681                	li	a3,0
+     730:	4601                	li	a2,0
+     732:	85ce                	mv	a1,s3
+     734:	854a                	mv	a0,s2
+     736:	bdbff0ef          	jal	310 <gettoken>
+    cmd = listcmd(cmd, parseline(ps, es));
+     73a:	85ce                	mv	a1,s3
+     73c:	854a                	mv	a0,s2
+     73e:	f89ff0ef          	jal	6c6 <parseline>
+     742:	85aa                	mv	a1,a0
+     744:	8526                	mv	a0,s1
+     746:	b59ff0ef          	jal	29e <listcmd>
+     74a:	84aa                	mv	s1,a0
+  return cmd;
+     74c:	bfc1                	j	71c <parseline+0x56>
+
+000000000000074e <parseblock>:
+{
+     74e:	7179                	addi	sp,sp,-48
+     750:	f406                	sd	ra,40(sp)
+     752:	f022                	sd	s0,32(sp)
+     754:	ec26                	sd	s1,24(sp)
+     756:	e84a                	sd	s2,16(sp)
+     758:	e44e                	sd	s3,8(sp)
+     75a:	1800                	addi	s0,sp,48
+     75c:	84aa                	mv	s1,a0
+     75e:	892e                	mv	s2,a1
+  if(!peek(ps, es, "("))
+     760:	00001617          	auipc	a2,0x1
+     764:	b2860613          	addi	a2,a2,-1240 # 1288 <malloc+0x176>
+     768:	ce5ff0ef          	jal	44c <peek>
+     76c:	c539                	beqz	a0,7ba <parseblock+0x6c>
+  gettoken(ps, es, 0, 0);
+     76e:	4681                	li	a3,0
+     770:	4601                	li	a2,0
+     772:	85ca                	mv	a1,s2
+     774:	8526                	mv	a0,s1
+     776:	b9bff0ef          	jal	310 <gettoken>
+  cmd = parseline(ps, es);
+     77a:	85ca                	mv	a1,s2
+     77c:	8526                	mv	a0,s1
+     77e:	f49ff0ef          	jal	6c6 <parseline>
+     782:	89aa                	mv	s3,a0
+  if(!peek(ps, es, ")"))
+     784:	00001617          	auipc	a2,0x1
+     788:	b5460613          	addi	a2,a2,-1196 # 12d8 <malloc+0x1c6>
+     78c:	85ca                	mv	a1,s2
+     78e:	8526                	mv	a0,s1
+     790:	cbdff0ef          	jal	44c <peek>
+     794:	c90d                	beqz	a0,7c6 <parseblock+0x78>
+  gettoken(ps, es, 0, 0);
+     796:	4681                	li	a3,0
+     798:	4601                	li	a2,0
+     79a:	85ca                	mv	a1,s2
+     79c:	8526                	mv	a0,s1
+     79e:	b73ff0ef          	jal	310 <gettoken>
+  cmd = parseredirs(cmd, ps, es);
+     7a2:	864a                	mv	a2,s2
+     7a4:	85a6                	mv	a1,s1
+     7a6:	854e                	mv	a0,s3
+     7a8:	d09ff0ef          	jal	4b0 <parseredirs>
+}
+     7ac:	70a2                	ld	ra,40(sp)
+     7ae:	7402                	ld	s0,32(sp)
+     7b0:	64e2                	ld	s1,24(sp)
+     7b2:	6942                	ld	s2,16(sp)
+     7b4:	69a2                	ld	s3,8(sp)
+     7b6:	6145                	addi	sp,sp,48
+     7b8:	8082                	ret
+    panic("parseblock");
+     7ba:	00001517          	auipc	a0,0x1
+     7be:	b0e50513          	addi	a0,a0,-1266 # 12c8 <malloc+0x1b6>
+     7c2:	889ff0ef          	jal	4a <panic>
+    panic("syntax - missing )");
+     7c6:	00001517          	auipc	a0,0x1
+     7ca:	b1a50513          	addi	a0,a0,-1254 # 12e0 <malloc+0x1ce>
+     7ce:	87dff0ef          	jal	4a <panic>
+
+00000000000007d2 <nulterminate>:
+
+// NUL-terminate all the counted strings.
+struct cmd*
+nulterminate(struct cmd *cmd)
+{
+     7d2:	1101                	addi	sp,sp,-32
+     7d4:	ec06                	sd	ra,24(sp)
+     7d6:	e822                	sd	s0,16(sp)
+     7d8:	e426                	sd	s1,8(sp)
+     7da:	1000                	addi	s0,sp,32
+     7dc:	84aa                	mv	s1,a0
+  struct execcmd *ecmd;
+  struct listcmd *lcmd;
+  struct pipecmd *pcmd;
+  struct redircmd *rcmd;
+
+  if(cmd == 0)
+     7de:	c131                	beqz	a0,822 <nulterminate+0x50>
+    return 0;
+
+  switch(cmd->type){
+     7e0:	4118                	lw	a4,0(a0)
+     7e2:	4795                	li	a5,5
+     7e4:	02e7ef63          	bltu	a5,a4,822 <nulterminate+0x50>
+     7e8:	00056783          	lwu	a5,0(a0)
+     7ec:	078a                	slli	a5,a5,0x2
+     7ee:	00001717          	auipc	a4,0x1
+     7f2:	b5270713          	addi	a4,a4,-1198 # 1340 <malloc+0x22e>
+     7f6:	97ba                	add	a5,a5,a4
+     7f8:	439c                	lw	a5,0(a5)
+     7fa:	97ba                	add	a5,a5,a4
+     7fc:	8782                	jr	a5
+  case EXEC:
+    ecmd = (struct execcmd*)cmd;
+    for(i=0; ecmd->argv[i]; i++)
+     7fe:	651c                	ld	a5,8(a0)
+     800:	c38d                	beqz	a5,822 <nulterminate+0x50>
+     802:	01050793          	addi	a5,a0,16
+      *ecmd->eargv[i] = 0;
+     806:	67b8                	ld	a4,72(a5)
+     808:	00070023          	sb	zero,0(a4)
+    for(i=0; ecmd->argv[i]; i++)
+     80c:	07a1                	addi	a5,a5,8
+     80e:	ff87b703          	ld	a4,-8(a5)
+     812:	fb75                	bnez	a4,806 <nulterminate+0x34>
+     814:	a039                	j	822 <nulterminate+0x50>
+    break;
+
+  case REDIR:
+    rcmd = (struct redircmd*)cmd;
+    nulterminate(rcmd->cmd);
+     816:	6508                	ld	a0,8(a0)
+     818:	fbbff0ef          	jal	7d2 <nulterminate>
+    *rcmd->efile = 0;
+     81c:	6c9c                	ld	a5,24(s1)
+     81e:	00078023          	sb	zero,0(a5)
+    bcmd = (struct backcmd*)cmd;
+    nulterminate(bcmd->cmd);
+    break;
+  }
+  return cmd;
+}
+     822:	8526                	mv	a0,s1
+     824:	60e2                	ld	ra,24(sp)
+     826:	6442                	ld	s0,16(sp)
+     828:	64a2                	ld	s1,8(sp)
+     82a:	6105                	addi	sp,sp,32
+     82c:	8082                	ret
+    nulterminate(pcmd->left);
+     82e:	6508                	ld	a0,8(a0)
+     830:	fa3ff0ef          	jal	7d2 <nulterminate>
+    nulterminate(pcmd->right);
+     834:	6888                	ld	a0,16(s1)
+     836:	f9dff0ef          	jal	7d2 <nulterminate>
+    break;
+     83a:	b7e5                	j	822 <nulterminate+0x50>
+    nulterminate(lcmd->left);
+     83c:	6508                	ld	a0,8(a0)
+     83e:	f95ff0ef          	jal	7d2 <nulterminate>
+    nulterminate(lcmd->right);
+     842:	6888                	ld	a0,16(s1)
+     844:	f8fff0ef          	jal	7d2 <nulterminate>
+    break;
+     848:	bfe9                	j	822 <nulterminate+0x50>
+    nulterminate(bcmd->cmd);
+     84a:	6508                	ld	a0,8(a0)
+     84c:	f87ff0ef          	jal	7d2 <nulterminate>
+    break;
+     850:	bfc9                	j	822 <nulterminate+0x50>
+
+0000000000000852 <parsecmd>:
+{
+     852:	7179                	addi	sp,sp,-48
+     854:	f406                	sd	ra,40(sp)
+     856:	f022                	sd	s0,32(sp)
+     858:	ec26                	sd	s1,24(sp)
+     85a:	e84a                	sd	s2,16(sp)
+     85c:	1800                	addi	s0,sp,48
+     85e:	fca43c23          	sd	a0,-40(s0)
+  es = s + strlen(s);
+     862:	84aa                	mv	s1,a0
+     864:	18e000ef          	jal	9f2 <strlen>
+     868:	1502                	slli	a0,a0,0x20
+     86a:	9101                	srli	a0,a0,0x20
+     86c:	94aa                	add	s1,s1,a0
+  cmd = parseline(&s, es);
+     86e:	85a6                	mv	a1,s1
+     870:	fd840513          	addi	a0,s0,-40
+     874:	e53ff0ef          	jal	6c6 <parseline>
+     878:	892a                	mv	s2,a0
+  peek(&s, es, "");
+     87a:	00001617          	auipc	a2,0x1
+     87e:	99e60613          	addi	a2,a2,-1634 # 1218 <malloc+0x106>
+     882:	85a6                	mv	a1,s1
+     884:	fd840513          	addi	a0,s0,-40
+     888:	bc5ff0ef          	jal	44c <peek>
+  if(s != es){
+     88c:	fd843603          	ld	a2,-40(s0)
+     890:	00961c63          	bne	a2,s1,8a8 <parsecmd+0x56>
+  nulterminate(cmd);
+     894:	854a                	mv	a0,s2
+     896:	f3dff0ef          	jal	7d2 <nulterminate>
+}
+     89a:	854a                	mv	a0,s2
+     89c:	70a2                	ld	ra,40(sp)
+     89e:	7402                	ld	s0,32(sp)
+     8a0:	64e2                	ld	s1,24(sp)
+     8a2:	6942                	ld	s2,16(sp)
+     8a4:	6145                	addi	sp,sp,48
+     8a6:	8082                	ret
+    fprintf(2, "leftovers: %s\n", s);
+     8a8:	00001597          	auipc	a1,0x1
+     8ac:	a5058593          	addi	a1,a1,-1456 # 12f8 <malloc+0x1e6>
+     8b0:	4509                	li	a0,2
+     8b2:	782000ef          	jal	1034 <fprintf>
+    panic("syntax");
+     8b6:	00001517          	auipc	a0,0x1
+     8ba:	9da50513          	addi	a0,a0,-1574 # 1290 <malloc+0x17e>
+     8be:	f8cff0ef          	jal	4a <panic>
+
+00000000000008c2 <main>:
+{
+     8c2:	7139                	addi	sp,sp,-64
+     8c4:	fc06                	sd	ra,56(sp)
+     8c6:	f822                	sd	s0,48(sp)
+     8c8:	f426                	sd	s1,40(sp)
+     8ca:	f04a                	sd	s2,32(sp)
+     8cc:	ec4e                	sd	s3,24(sp)
+     8ce:	e852                	sd	s4,16(sp)
+     8d0:	e456                	sd	s5,8(sp)
+     8d2:	e05a                	sd	s6,0(sp)
+     8d4:	0080                	addi	s0,sp,64
+  while((fd = open("console", O_RDWR)) >= 0){
+     8d6:	00001497          	auipc	s1,0x1
+     8da:	a3248493          	addi	s1,s1,-1486 # 1308 <malloc+0x1f6>
+     8de:	4589                	li	a1,2
+     8e0:	8526                	mv	a0,s1
+     8e2:	38c000ef          	jal	c6e <open>
+     8e6:	00054763          	bltz	a0,8f4 <main+0x32>
+    if(fd >= 3){
+     8ea:	4789                	li	a5,2
+     8ec:	fea7d9e3          	bge	a5,a0,8de <main+0x1c>
+      close(fd);
+     8f0:	366000ef          	jal	c56 <close>
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     8f4:	00001a17          	auipc	s4,0x1
+     8f8:	72ca0a13          	addi	s4,s4,1836 # 2020 <buf.0>
+    while (*cmd == ' ' || *cmd == '\t')
+     8fc:	02000913          	li	s2,32
+     900:	49a5                	li	s3,9
+    if (*cmd == '\n') // is a blank command
+     902:	4aa9                	li	s5,10
+    if(cmd[0] == 'c' && cmd[1] == 'd' && cmd[2] == ' '){
+     904:	06300b13          	li	s6,99
+     908:	a805                	j	938 <main+0x76>
+      cmd++;
+     90a:	0485                	addi	s1,s1,1
+    while (*cmd == ' ' || *cmd == '\t')
+     90c:	0004c783          	lbu	a5,0(s1)
+     910:	ff278de3          	beq	a5,s2,90a <main+0x48>
+     914:	ff378be3          	beq	a5,s3,90a <main+0x48>
+    if (*cmd == '\n') // is a blank command
+     918:	03578063          	beq	a5,s5,938 <main+0x76>
+    if(cmd[0] == 'c' && cmd[1] == 'd' && cmd[2] == ' '){
+     91c:	01679863          	bne	a5,s6,92c <main+0x6a>
+     920:	0014c703          	lbu	a4,1(s1)
+     924:	06400793          	li	a5,100
+     928:	02f70463          	beq	a4,a5,950 <main+0x8e>
+      if(fork1() == 0)
+     92c:	f3cff0ef          	jal	68 <fork1>
+     930:	cd29                	beqz	a0,98a <main+0xc8>
+      wait(0);
+     932:	4501                	li	a0,0
+     934:	302000ef          	jal	c36 <wait>
+  while(getcmd(buf, sizeof(buf)) >= 0){
+     938:	06400593          	li	a1,100
+     93c:	8552                	mv	a0,s4
+     93e:	ec2ff0ef          	jal	0 <getcmd>
+     942:	04054963          	bltz	a0,994 <main+0xd2>
+    char *cmd = buf;
+     946:	00001497          	auipc	s1,0x1
+     94a:	6da48493          	addi	s1,s1,1754 # 2020 <buf.0>
+     94e:	bf7d                	j	90c <main+0x4a>
+    if(cmd[0] == 'c' && cmd[1] == 'd' && cmd[2] == ' '){
+     950:	0024c783          	lbu	a5,2(s1)
+     954:	fd279ce3          	bne	a5,s2,92c <main+0x6a>
+      cmd[strlen(cmd)-1] = 0;  // chop \n
+     958:	8526                	mv	a0,s1
+     95a:	098000ef          	jal	9f2 <strlen>
+     95e:	fff5079b          	addiw	a5,a0,-1
+     962:	1782                	slli	a5,a5,0x20
+     964:	9381                	srli	a5,a5,0x20
+     966:	97a6                	add	a5,a5,s1
+     968:	00078023          	sb	zero,0(a5)
+      if(chdir(cmd+3) < 0)
+     96c:	048d                	addi	s1,s1,3
+     96e:	8526                	mv	a0,s1
+     970:	32e000ef          	jal	c9e <chdir>
+     974:	fc0552e3          	bgez	a0,938 <main+0x76>
+        fprintf(2, "cannot cd %s\n", cmd+3);
+     978:	8626                	mv	a2,s1
+     97a:	00001597          	auipc	a1,0x1
+     97e:	99658593          	addi	a1,a1,-1642 # 1310 <malloc+0x1fe>
+     982:	4509                	li	a0,2
+     984:	6b0000ef          	jal	1034 <fprintf>
+     988:	bf45                	j	938 <main+0x76>
+        runcmd(parsecmd(cmd));
+     98a:	8526                	mv	a0,s1
+     98c:	ec7ff0ef          	jal	852 <parsecmd>
+     990:	efeff0ef          	jal	8e <runcmd>
+  exit(0);
+     994:	4501                	li	a0,0
+     996:	298000ef          	jal	c2e <exit>
+
+000000000000099a <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+     99a:	1141                	addi	sp,sp,-16
+     99c:	e406                	sd	ra,8(sp)
+     99e:	e022                	sd	s0,0(sp)
+     9a0:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+     9a2:	f21ff0ef          	jal	8c2 <main>
+  exit(r);
+     9a6:	288000ef          	jal	c2e <exit>
+
+00000000000009aa <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+     9aa:	1141                	addi	sp,sp,-16
+     9ac:	e422                	sd	s0,8(sp)
+     9ae:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+     9b0:	87aa                	mv	a5,a0
+     9b2:	0585                	addi	a1,a1,1
+     9b4:	0785                	addi	a5,a5,1
+     9b6:	fff5c703          	lbu	a4,-1(a1)
+     9ba:	fee78fa3          	sb	a4,-1(a5)
+     9be:	fb75                	bnez	a4,9b2 <strcpy+0x8>
+    ;
+  return os;
+}
+     9c0:	6422                	ld	s0,8(sp)
+     9c2:	0141                	addi	sp,sp,16
+     9c4:	8082                	ret
+
+00000000000009c6 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+     9c6:	1141                	addi	sp,sp,-16
+     9c8:	e422                	sd	s0,8(sp)
+     9ca:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+     9cc:	00054783          	lbu	a5,0(a0)
+     9d0:	cb91                	beqz	a5,9e4 <strcmp+0x1e>
+     9d2:	0005c703          	lbu	a4,0(a1)
+     9d6:	00f71763          	bne	a4,a5,9e4 <strcmp+0x1e>
+    p++, q++;
+     9da:	0505                	addi	a0,a0,1
+     9dc:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+     9de:	00054783          	lbu	a5,0(a0)
+     9e2:	fbe5                	bnez	a5,9d2 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+     9e4:	0005c503          	lbu	a0,0(a1)
+}
+     9e8:	40a7853b          	subw	a0,a5,a0
+     9ec:	6422                	ld	s0,8(sp)
+     9ee:	0141                	addi	sp,sp,16
+     9f0:	8082                	ret
+
+00000000000009f2 <strlen>:
+
+uint
+strlen(const char *s)
+{
+     9f2:	1141                	addi	sp,sp,-16
+     9f4:	e422                	sd	s0,8(sp)
+     9f6:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+     9f8:	00054783          	lbu	a5,0(a0)
+     9fc:	cf91                	beqz	a5,a18 <strlen+0x26>
+     9fe:	0505                	addi	a0,a0,1
+     a00:	87aa                	mv	a5,a0
+     a02:	86be                	mv	a3,a5
+     a04:	0785                	addi	a5,a5,1
+     a06:	fff7c703          	lbu	a4,-1(a5)
+     a0a:	ff65                	bnez	a4,a02 <strlen+0x10>
+     a0c:	40a6853b          	subw	a0,a3,a0
+     a10:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+     a12:	6422                	ld	s0,8(sp)
+     a14:	0141                	addi	sp,sp,16
+     a16:	8082                	ret
+  for(n = 0; s[n]; n++)
+     a18:	4501                	li	a0,0
+     a1a:	bfe5                	j	a12 <strlen+0x20>
+
+0000000000000a1c <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+     a1c:	1141                	addi	sp,sp,-16
+     a1e:	e422                	sd	s0,8(sp)
+     a20:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+     a22:	ca19                	beqz	a2,a38 <memset+0x1c>
+     a24:	87aa                	mv	a5,a0
+     a26:	1602                	slli	a2,a2,0x20
+     a28:	9201                	srli	a2,a2,0x20
+     a2a:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+     a2e:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+     a32:	0785                	addi	a5,a5,1
+     a34:	fee79de3          	bne	a5,a4,a2e <memset+0x12>
+  }
+  return dst;
+}
+     a38:	6422                	ld	s0,8(sp)
+     a3a:	0141                	addi	sp,sp,16
+     a3c:	8082                	ret
+
+0000000000000a3e <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+     a3e:	1141                	addi	sp,sp,-16
+     a40:	e422                	sd	s0,8(sp)
+     a42:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+     a44:	00054783          	lbu	a5,0(a0)
+     a48:	cb99                	beqz	a5,a5e <strchr+0x20>
+    if(*s == c)
+     a4a:	00f58763          	beq	a1,a5,a58 <strchr+0x1a>
+  for(; *s; s++)
+     a4e:	0505                	addi	a0,a0,1
+     a50:	00054783          	lbu	a5,0(a0)
+     a54:	fbfd                	bnez	a5,a4a <strchr+0xc>
+      return (char*)s;
+  return 0;
+     a56:	4501                	li	a0,0
+}
+     a58:	6422                	ld	s0,8(sp)
+     a5a:	0141                	addi	sp,sp,16
+     a5c:	8082                	ret
+  return 0;
+     a5e:	4501                	li	a0,0
+     a60:	bfe5                	j	a58 <strchr+0x1a>
+
+0000000000000a62 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+     a62:	711d                	addi	sp,sp,-96
+     a64:	ec86                	sd	ra,88(sp)
+     a66:	e8a2                	sd	s0,80(sp)
+     a68:	e4a6                	sd	s1,72(sp)
+     a6a:	e0ca                	sd	s2,64(sp)
+     a6c:	fc4e                	sd	s3,56(sp)
+     a6e:	f852                	sd	s4,48(sp)
+     a70:	f456                	sd	s5,40(sp)
+     a72:	f05a                	sd	s6,32(sp)
+     a74:	ec5e                	sd	s7,24(sp)
+     a76:	1080                	addi	s0,sp,96
+     a78:	8baa                	mv	s7,a0
+     a7a:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+     a7c:	892a                	mv	s2,a0
+     a7e:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+     a80:	4aa9                	li	s5,10
+     a82:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+     a84:	89a6                	mv	s3,s1
+     a86:	2485                	addiw	s1,s1,1
+     a88:	0344d663          	bge	s1,s4,ab4 <gets+0x52>
+    cc = read(0, &c, 1);
+     a8c:	4605                	li	a2,1
+     a8e:	faf40593          	addi	a1,s0,-81
+     a92:	4501                	li	a0,0
+     a94:	1b2000ef          	jal	c46 <read>
+    if(cc < 1)
+     a98:	00a05e63          	blez	a0,ab4 <gets+0x52>
+    buf[i++] = c;
+     a9c:	faf44783          	lbu	a5,-81(s0)
+     aa0:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+     aa4:	01578763          	beq	a5,s5,ab2 <gets+0x50>
+     aa8:	0905                	addi	s2,s2,1
+     aaa:	fd679de3          	bne	a5,s6,a84 <gets+0x22>
+    buf[i++] = c;
+     aae:	89a6                	mv	s3,s1
+     ab0:	a011                	j	ab4 <gets+0x52>
+     ab2:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+     ab4:	99de                	add	s3,s3,s7
+     ab6:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+     aba:	855e                	mv	a0,s7
+     abc:	60e6                	ld	ra,88(sp)
+     abe:	6446                	ld	s0,80(sp)
+     ac0:	64a6                	ld	s1,72(sp)
+     ac2:	6906                	ld	s2,64(sp)
+     ac4:	79e2                	ld	s3,56(sp)
+     ac6:	7a42                	ld	s4,48(sp)
+     ac8:	7aa2                	ld	s5,40(sp)
+     aca:	7b02                	ld	s6,32(sp)
+     acc:	6be2                	ld	s7,24(sp)
+     ace:	6125                	addi	sp,sp,96
+     ad0:	8082                	ret
+
+0000000000000ad2 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+     ad2:	1101                	addi	sp,sp,-32
+     ad4:	ec06                	sd	ra,24(sp)
+     ad6:	e822                	sd	s0,16(sp)
+     ad8:	e04a                	sd	s2,0(sp)
+     ada:	1000                	addi	s0,sp,32
+     adc:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+     ade:	4581                	li	a1,0
+     ae0:	18e000ef          	jal	c6e <open>
+  if(fd < 0)
+     ae4:	02054263          	bltz	a0,b08 <stat+0x36>
+     ae8:	e426                	sd	s1,8(sp)
+     aea:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+     aec:	85ca                	mv	a1,s2
+     aee:	198000ef          	jal	c86 <fstat>
+     af2:	892a                	mv	s2,a0
+  close(fd);
+     af4:	8526                	mv	a0,s1
+     af6:	160000ef          	jal	c56 <close>
+  return r;
+     afa:	64a2                	ld	s1,8(sp)
+}
+     afc:	854a                	mv	a0,s2
+     afe:	60e2                	ld	ra,24(sp)
+     b00:	6442                	ld	s0,16(sp)
+     b02:	6902                	ld	s2,0(sp)
+     b04:	6105                	addi	sp,sp,32
+     b06:	8082                	ret
+    return -1;
+     b08:	597d                	li	s2,-1
+     b0a:	bfcd                	j	afc <stat+0x2a>
+
+0000000000000b0c <atoi>:
+
+int
+atoi(const char *s)
+{
+     b0c:	1141                	addi	sp,sp,-16
+     b0e:	e422                	sd	s0,8(sp)
+     b10:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+     b12:	00054683          	lbu	a3,0(a0)
+     b16:	fd06879b          	addiw	a5,a3,-48
+     b1a:	0ff7f793          	zext.b	a5,a5
+     b1e:	4625                	li	a2,9
+     b20:	02f66863          	bltu	a2,a5,b50 <atoi+0x44>
+     b24:	872a                	mv	a4,a0
+  n = 0;
+     b26:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+     b28:	0705                	addi	a4,a4,1
+     b2a:	0025179b          	slliw	a5,a0,0x2
+     b2e:	9fa9                	addw	a5,a5,a0
+     b30:	0017979b          	slliw	a5,a5,0x1
+     b34:	9fb5                	addw	a5,a5,a3
+     b36:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+     b3a:	00074683          	lbu	a3,0(a4)
+     b3e:	fd06879b          	addiw	a5,a3,-48
+     b42:	0ff7f793          	zext.b	a5,a5
+     b46:	fef671e3          	bgeu	a2,a5,b28 <atoi+0x1c>
+  return n;
+}
+     b4a:	6422                	ld	s0,8(sp)
+     b4c:	0141                	addi	sp,sp,16
+     b4e:	8082                	ret
+  n = 0;
+     b50:	4501                	li	a0,0
+     b52:	bfe5                	j	b4a <atoi+0x3e>
+
+0000000000000b54 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+     b54:	1141                	addi	sp,sp,-16
+     b56:	e422                	sd	s0,8(sp)
+     b58:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+     b5a:	02b57463          	bgeu	a0,a1,b82 <memmove+0x2e>
+    while(n-- > 0)
+     b5e:	00c05f63          	blez	a2,b7c <memmove+0x28>
+     b62:	1602                	slli	a2,a2,0x20
+     b64:	9201                	srli	a2,a2,0x20
+     b66:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+     b6a:	872a                	mv	a4,a0
+      *dst++ = *src++;
+     b6c:	0585                	addi	a1,a1,1
+     b6e:	0705                	addi	a4,a4,1
+     b70:	fff5c683          	lbu	a3,-1(a1)
+     b74:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+     b78:	fef71ae3          	bne	a4,a5,b6c <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+     b7c:	6422                	ld	s0,8(sp)
+     b7e:	0141                	addi	sp,sp,16
+     b80:	8082                	ret
+    dst += n;
+     b82:	00c50733          	add	a4,a0,a2
+    src += n;
+     b86:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+     b88:	fec05ae3          	blez	a2,b7c <memmove+0x28>
+     b8c:	fff6079b          	addiw	a5,a2,-1
+     b90:	1782                	slli	a5,a5,0x20
+     b92:	9381                	srli	a5,a5,0x20
+     b94:	fff7c793          	not	a5,a5
+     b98:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+     b9a:	15fd                	addi	a1,a1,-1
+     b9c:	177d                	addi	a4,a4,-1
+     b9e:	0005c683          	lbu	a3,0(a1)
+     ba2:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+     ba6:	fee79ae3          	bne	a5,a4,b9a <memmove+0x46>
+     baa:	bfc9                	j	b7c <memmove+0x28>
+
+0000000000000bac <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+     bac:	1141                	addi	sp,sp,-16
+     bae:	e422                	sd	s0,8(sp)
+     bb0:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+     bb2:	ca05                	beqz	a2,be2 <memcmp+0x36>
+     bb4:	fff6069b          	addiw	a3,a2,-1
+     bb8:	1682                	slli	a3,a3,0x20
+     bba:	9281                	srli	a3,a3,0x20
+     bbc:	0685                	addi	a3,a3,1
+     bbe:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+     bc0:	00054783          	lbu	a5,0(a0)
+     bc4:	0005c703          	lbu	a4,0(a1)
+     bc8:	00e79863          	bne	a5,a4,bd8 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+     bcc:	0505                	addi	a0,a0,1
+    p2++;
+     bce:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+     bd0:	fed518e3          	bne	a0,a3,bc0 <memcmp+0x14>
+  }
+  return 0;
+     bd4:	4501                	li	a0,0
+     bd6:	a019                	j	bdc <memcmp+0x30>
+      return *p1 - *p2;
+     bd8:	40e7853b          	subw	a0,a5,a4
+}
+     bdc:	6422                	ld	s0,8(sp)
+     bde:	0141                	addi	sp,sp,16
+     be0:	8082                	ret
+  return 0;
+     be2:	4501                	li	a0,0
+     be4:	bfe5                	j	bdc <memcmp+0x30>
+
+0000000000000be6 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+     be6:	1141                	addi	sp,sp,-16
+     be8:	e406                	sd	ra,8(sp)
+     bea:	e022                	sd	s0,0(sp)
+     bec:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+     bee:	f67ff0ef          	jal	b54 <memmove>
+}
+     bf2:	60a2                	ld	ra,8(sp)
+     bf4:	6402                	ld	s0,0(sp)
+     bf6:	0141                	addi	sp,sp,16
+     bf8:	8082                	ret
+
+0000000000000bfa <sbrk>:
+
+char *
+sbrk(int n) {
+     bfa:	1141                	addi	sp,sp,-16
+     bfc:	e406                	sd	ra,8(sp)
+     bfe:	e022                	sd	s0,0(sp)
+     c00:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+     c02:	4585                	li	a1,1
+     c04:	0b2000ef          	jal	cb6 <sys_sbrk>
+}
+     c08:	60a2                	ld	ra,8(sp)
+     c0a:	6402                	ld	s0,0(sp)
+     c0c:	0141                	addi	sp,sp,16
+     c0e:	8082                	ret
+
+0000000000000c10 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+     c10:	1141                	addi	sp,sp,-16
+     c12:	e406                	sd	ra,8(sp)
+     c14:	e022                	sd	s0,0(sp)
+     c16:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+     c18:	4589                	li	a1,2
+     c1a:	09c000ef          	jal	cb6 <sys_sbrk>
+}
+     c1e:	60a2                	ld	ra,8(sp)
+     c20:	6402                	ld	s0,0(sp)
+     c22:	0141                	addi	sp,sp,16
+     c24:	8082                	ret
+
+0000000000000c26 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+     c26:	4885                	li	a7,1
+ ecall
+     c28:	00000073          	ecall
+ ret
+     c2c:	8082                	ret
+
+0000000000000c2e <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+     c2e:	4889                	li	a7,2
+ ecall
+     c30:	00000073          	ecall
+ ret
+     c34:	8082                	ret
+
+0000000000000c36 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+     c36:	488d                	li	a7,3
+ ecall
+     c38:	00000073          	ecall
+ ret
+     c3c:	8082                	ret
+
+0000000000000c3e <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+     c3e:	4891                	li	a7,4
+ ecall
+     c40:	00000073          	ecall
+ ret
+     c44:	8082                	ret
+
+0000000000000c46 <read>:
+.global read
+read:
+ li a7, SYS_read
+     c46:	4895                	li	a7,5
+ ecall
+     c48:	00000073          	ecall
+ ret
+     c4c:	8082                	ret
+
+0000000000000c4e <write>:
+.global write
+write:
+ li a7, SYS_write
+     c4e:	48c1                	li	a7,16
+ ecall
+     c50:	00000073          	ecall
+ ret
+     c54:	8082                	ret
+
+0000000000000c56 <close>:
+.global close
+close:
+ li a7, SYS_close
+     c56:	48d5                	li	a7,21
+ ecall
+     c58:	00000073          	ecall
+ ret
+     c5c:	8082                	ret
+
+0000000000000c5e <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+     c5e:	4899                	li	a7,6
+ ecall
+     c60:	00000073          	ecall
+ ret
+     c64:	8082                	ret
+
+0000000000000c66 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+     c66:	489d                	li	a7,7
+ ecall
+     c68:	00000073          	ecall
+ ret
+     c6c:	8082                	ret
+
+0000000000000c6e <open>:
+.global open
+open:
+ li a7, SYS_open
+     c6e:	48bd                	li	a7,15
+ ecall
+     c70:	00000073          	ecall
+ ret
+     c74:	8082                	ret
+
+0000000000000c76 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+     c76:	48c5                	li	a7,17
+ ecall
+     c78:	00000073          	ecall
+ ret
+     c7c:	8082                	ret
+
+0000000000000c7e <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+     c7e:	48c9                	li	a7,18
+ ecall
+     c80:	00000073          	ecall
+ ret
+     c84:	8082                	ret
+
+0000000000000c86 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+     c86:	48a1                	li	a7,8
+ ecall
+     c88:	00000073          	ecall
+ ret
+     c8c:	8082                	ret
+
+0000000000000c8e <link>:
+.global link
+link:
+ li a7, SYS_link
+     c8e:	48cd                	li	a7,19
+ ecall
+     c90:	00000073          	ecall
+ ret
+     c94:	8082                	ret
+
+0000000000000c96 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+     c96:	48d1                	li	a7,20
+ ecall
+     c98:	00000073          	ecall
+ ret
+     c9c:	8082                	ret
+
+0000000000000c9e <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+     c9e:	48a5                	li	a7,9
+ ecall
+     ca0:	00000073          	ecall
+ ret
+     ca4:	8082                	ret
+
+0000000000000ca6 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+     ca6:	48a9                	li	a7,10
+ ecall
+     ca8:	00000073          	ecall
+ ret
+     cac:	8082                	ret
+
+0000000000000cae <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+     cae:	48ad                	li	a7,11
+ ecall
+     cb0:	00000073          	ecall
+ ret
+     cb4:	8082                	ret
+
+0000000000000cb6 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+     cb6:	48b1                	li	a7,12
+ ecall
+     cb8:	00000073          	ecall
+ ret
+     cbc:	8082                	ret
+
+0000000000000cbe <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+     cbe:	48b5                	li	a7,13
+ ecall
+     cc0:	00000073          	ecall
+ ret
+     cc4:	8082                	ret
+
+0000000000000cc6 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+     cc6:	48b9                	li	a7,14
+ ecall
+     cc8:	00000073          	ecall
+ ret
+     ccc:	8082                	ret
+
+0000000000000cce <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+     cce:	48d9                	li	a7,22
+ ecall
+     cd0:	00000073          	ecall
+ ret
+     cd4:	8082                	ret
+
+0000000000000cd6 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+     cd6:	1101                	addi	sp,sp,-32
+     cd8:	ec06                	sd	ra,24(sp)
+     cda:	e822                	sd	s0,16(sp)
+     cdc:	1000                	addi	s0,sp,32
+     cde:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+     ce2:	4605                	li	a2,1
+     ce4:	fef40593          	addi	a1,s0,-17
+     ce8:	f67ff0ef          	jal	c4e <write>
+}
+     cec:	60e2                	ld	ra,24(sp)
+     cee:	6442                	ld	s0,16(sp)
+     cf0:	6105                	addi	sp,sp,32
+     cf2:	8082                	ret
+
+0000000000000cf4 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+     cf4:	715d                	addi	sp,sp,-80
+     cf6:	e486                	sd	ra,72(sp)
+     cf8:	e0a2                	sd	s0,64(sp)
+     cfa:	f84a                	sd	s2,48(sp)
+     cfc:	0880                	addi	s0,sp,80
+     cfe:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+     d00:	c299                	beqz	a3,d06 <printint+0x12>
+     d02:	0805c363          	bltz	a1,d88 <printint+0x94>
+  neg = 0;
+     d06:	4881                	li	a7,0
+     d08:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+     d0c:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+     d0e:	00000517          	auipc	a0,0x0
+     d12:	64a50513          	addi	a0,a0,1610 # 1358 <digits>
+     d16:	883e                	mv	a6,a5
+     d18:	2785                	addiw	a5,a5,1
+     d1a:	02c5f733          	remu	a4,a1,a2
+     d1e:	972a                	add	a4,a4,a0
+     d20:	00074703          	lbu	a4,0(a4)
+     d24:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+     d28:	872e                	mv	a4,a1
+     d2a:	02c5d5b3          	divu	a1,a1,a2
+     d2e:	0685                	addi	a3,a3,1
+     d30:	fec773e3          	bgeu	a4,a2,d16 <printint+0x22>
+  if(neg)
+     d34:	00088b63          	beqz	a7,d4a <printint+0x56>
+    buf[i++] = '-';
+     d38:	fd078793          	addi	a5,a5,-48
+     d3c:	97a2                	add	a5,a5,s0
+     d3e:	02d00713          	li	a4,45
+     d42:	fee78423          	sb	a4,-24(a5)
+     d46:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+     d4a:	02f05a63          	blez	a5,d7e <printint+0x8a>
+     d4e:	fc26                	sd	s1,56(sp)
+     d50:	f44e                	sd	s3,40(sp)
+     d52:	fb840713          	addi	a4,s0,-72
+     d56:	00f704b3          	add	s1,a4,a5
+     d5a:	fff70993          	addi	s3,a4,-1
+     d5e:	99be                	add	s3,s3,a5
+     d60:	37fd                	addiw	a5,a5,-1
+     d62:	1782                	slli	a5,a5,0x20
+     d64:	9381                	srli	a5,a5,0x20
+     d66:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+     d6a:	fff4c583          	lbu	a1,-1(s1)
+     d6e:	854a                	mv	a0,s2
+     d70:	f67ff0ef          	jal	cd6 <putc>
+  while(--i >= 0)
+     d74:	14fd                	addi	s1,s1,-1
+     d76:	ff349ae3          	bne	s1,s3,d6a <printint+0x76>
+     d7a:	74e2                	ld	s1,56(sp)
+     d7c:	79a2                	ld	s3,40(sp)
+}
+     d7e:	60a6                	ld	ra,72(sp)
+     d80:	6406                	ld	s0,64(sp)
+     d82:	7942                	ld	s2,48(sp)
+     d84:	6161                	addi	sp,sp,80
+     d86:	8082                	ret
+    x = -xx;
+     d88:	40b005b3          	neg	a1,a1
+    neg = 1;
+     d8c:	4885                	li	a7,1
+    x = -xx;
+     d8e:	bfad                	j	d08 <printint+0x14>
+
+0000000000000d90 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+     d90:	711d                	addi	sp,sp,-96
+     d92:	ec86                	sd	ra,88(sp)
+     d94:	e8a2                	sd	s0,80(sp)
+     d96:	e0ca                	sd	s2,64(sp)
+     d98:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+     d9a:	0005c903          	lbu	s2,0(a1)
+     d9e:	28090663          	beqz	s2,102a <vprintf+0x29a>
+     da2:	e4a6                	sd	s1,72(sp)
+     da4:	fc4e                	sd	s3,56(sp)
+     da6:	f852                	sd	s4,48(sp)
+     da8:	f456                	sd	s5,40(sp)
+     daa:	f05a                	sd	s6,32(sp)
+     dac:	ec5e                	sd	s7,24(sp)
+     dae:	e862                	sd	s8,16(sp)
+     db0:	e466                	sd	s9,8(sp)
+     db2:	8b2a                	mv	s6,a0
+     db4:	8a2e                	mv	s4,a1
+     db6:	8bb2                	mv	s7,a2
+  state = 0;
+     db8:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+     dba:	4481                	li	s1,0
+     dbc:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+     dbe:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+     dc2:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+     dc6:	06c00c93          	li	s9,108
+     dca:	a005                	j	dea <vprintf+0x5a>
+        putc(fd, c0);
+     dcc:	85ca                	mv	a1,s2
+     dce:	855a                	mv	a0,s6
+     dd0:	f07ff0ef          	jal	cd6 <putc>
+     dd4:	a019                	j	dda <vprintf+0x4a>
+    } else if(state == '%'){
+     dd6:	03598263          	beq	s3,s5,dfa <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+     dda:	2485                	addiw	s1,s1,1
+     ddc:	8726                	mv	a4,s1
+     dde:	009a07b3          	add	a5,s4,s1
+     de2:	0007c903          	lbu	s2,0(a5)
+     de6:	22090a63          	beqz	s2,101a <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+     dea:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+     dee:	fe0994e3          	bnez	s3,dd6 <vprintf+0x46>
+      if(c0 == '%'){
+     df2:	fd579de3          	bne	a5,s5,dcc <vprintf+0x3c>
+        state = '%';
+     df6:	89be                	mv	s3,a5
+     df8:	b7cd                	j	dda <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+     dfa:	00ea06b3          	add	a3,s4,a4
+     dfe:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+     e02:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+     e04:	c681                	beqz	a3,e0c <vprintf+0x7c>
+     e06:	9752                	add	a4,a4,s4
+     e08:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+     e0c:	05878363          	beq	a5,s8,e52 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+     e10:	05978d63          	beq	a5,s9,e6a <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+     e14:	07500713          	li	a4,117
+     e18:	0ee78763          	beq	a5,a4,f06 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+     e1c:	07800713          	li	a4,120
+     e20:	12e78963          	beq	a5,a4,f52 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+     e24:	07000713          	li	a4,112
+     e28:	14e78e63          	beq	a5,a4,f84 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+     e2c:	06300713          	li	a4,99
+     e30:	18e78e63          	beq	a5,a4,fcc <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+     e34:	07300713          	li	a4,115
+     e38:	1ae78463          	beq	a5,a4,fe0 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+     e3c:	02500713          	li	a4,37
+     e40:	04e79563          	bne	a5,a4,e8a <vprintf+0xfa>
+        putc(fd, '%');
+     e44:	02500593          	li	a1,37
+     e48:	855a                	mv	a0,s6
+     e4a:	e8dff0ef          	jal	cd6 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+     e4e:	4981                	li	s3,0
+     e50:	b769                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+     e52:	008b8913          	addi	s2,s7,8
+     e56:	4685                	li	a3,1
+     e58:	4629                	li	a2,10
+     e5a:	000ba583          	lw	a1,0(s7)
+     e5e:	855a                	mv	a0,s6
+     e60:	e95ff0ef          	jal	cf4 <printint>
+     e64:	8bca                	mv	s7,s2
+      state = 0;
+     e66:	4981                	li	s3,0
+     e68:	bf8d                	j	dda <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+     e6a:	06400793          	li	a5,100
+     e6e:	02f68963          	beq	a3,a5,ea0 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+     e72:	06c00793          	li	a5,108
+     e76:	04f68263          	beq	a3,a5,eba <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+     e7a:	07500793          	li	a5,117
+     e7e:	0af68063          	beq	a3,a5,f1e <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+     e82:	07800793          	li	a5,120
+     e86:	0ef68263          	beq	a3,a5,f6a <vprintf+0x1da>
+        putc(fd, '%');
+     e8a:	02500593          	li	a1,37
+     e8e:	855a                	mv	a0,s6
+     e90:	e47ff0ef          	jal	cd6 <putc>
+        putc(fd, c0);
+     e94:	85ca                	mv	a1,s2
+     e96:	855a                	mv	a0,s6
+     e98:	e3fff0ef          	jal	cd6 <putc>
+      state = 0;
+     e9c:	4981                	li	s3,0
+     e9e:	bf35                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     ea0:	008b8913          	addi	s2,s7,8
+     ea4:	4685                	li	a3,1
+     ea6:	4629                	li	a2,10
+     ea8:	000bb583          	ld	a1,0(s7)
+     eac:	855a                	mv	a0,s6
+     eae:	e47ff0ef          	jal	cf4 <printint>
+        i += 1;
+     eb2:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     eb4:	8bca                	mv	s7,s2
+      state = 0;
+     eb6:	4981                	li	s3,0
+        i += 1;
+     eb8:	b70d                	j	dda <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+     eba:	06400793          	li	a5,100
+     ebe:	02f60763          	beq	a2,a5,eec <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+     ec2:	07500793          	li	a5,117
+     ec6:	06f60963          	beq	a2,a5,f38 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+     eca:	07800793          	li	a5,120
+     ece:	faf61ee3          	bne	a2,a5,e8a <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     ed2:	008b8913          	addi	s2,s7,8
+     ed6:	4681                	li	a3,0
+     ed8:	4641                	li	a2,16
+     eda:	000bb583          	ld	a1,0(s7)
+     ede:	855a                	mv	a0,s6
+     ee0:	e15ff0ef          	jal	cf4 <printint>
+        i += 2;
+     ee4:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     ee6:	8bca                	mv	s7,s2
+      state = 0;
+     ee8:	4981                	li	s3,0
+        i += 2;
+     eea:	bdc5                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     eec:	008b8913          	addi	s2,s7,8
+     ef0:	4685                	li	a3,1
+     ef2:	4629                	li	a2,10
+     ef4:	000bb583          	ld	a1,0(s7)
+     ef8:	855a                	mv	a0,s6
+     efa:	dfbff0ef          	jal	cf4 <printint>
+        i += 2;
+     efe:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+     f00:	8bca                	mv	s7,s2
+      state = 0;
+     f02:	4981                	li	s3,0
+        i += 2;
+     f04:	bdd9                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+     f06:	008b8913          	addi	s2,s7,8
+     f0a:	4681                	li	a3,0
+     f0c:	4629                	li	a2,10
+     f0e:	000be583          	lwu	a1,0(s7)
+     f12:	855a                	mv	a0,s6
+     f14:	de1ff0ef          	jal	cf4 <printint>
+     f18:	8bca                	mv	s7,s2
+      state = 0;
+     f1a:	4981                	li	s3,0
+     f1c:	bd7d                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     f1e:	008b8913          	addi	s2,s7,8
+     f22:	4681                	li	a3,0
+     f24:	4629                	li	a2,10
+     f26:	000bb583          	ld	a1,0(s7)
+     f2a:	855a                	mv	a0,s6
+     f2c:	dc9ff0ef          	jal	cf4 <printint>
+        i += 1;
+     f30:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     f32:	8bca                	mv	s7,s2
+      state = 0;
+     f34:	4981                	li	s3,0
+        i += 1;
+     f36:	b555                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     f38:	008b8913          	addi	s2,s7,8
+     f3c:	4681                	li	a3,0
+     f3e:	4629                	li	a2,10
+     f40:	000bb583          	ld	a1,0(s7)
+     f44:	855a                	mv	a0,s6
+     f46:	dafff0ef          	jal	cf4 <printint>
+        i += 2;
+     f4a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+     f4c:	8bca                	mv	s7,s2
+      state = 0;
+     f4e:	4981                	li	s3,0
+        i += 2;
+     f50:	b569                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+     f52:	008b8913          	addi	s2,s7,8
+     f56:	4681                	li	a3,0
+     f58:	4641                	li	a2,16
+     f5a:	000be583          	lwu	a1,0(s7)
+     f5e:	855a                	mv	a0,s6
+     f60:	d95ff0ef          	jal	cf4 <printint>
+     f64:	8bca                	mv	s7,s2
+      state = 0;
+     f66:	4981                	li	s3,0
+     f68:	bd8d                	j	dda <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     f6a:	008b8913          	addi	s2,s7,8
+     f6e:	4681                	li	a3,0
+     f70:	4641                	li	a2,16
+     f72:	000bb583          	ld	a1,0(s7)
+     f76:	855a                	mv	a0,s6
+     f78:	d7dff0ef          	jal	cf4 <printint>
+        i += 1;
+     f7c:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+     f7e:	8bca                	mv	s7,s2
+      state = 0;
+     f80:	4981                	li	s3,0
+        i += 1;
+     f82:	bda1                	j	dda <vprintf+0x4a>
+     f84:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+     f86:	008b8d13          	addi	s10,s7,8
+     f8a:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+     f8e:	03000593          	li	a1,48
+     f92:	855a                	mv	a0,s6
+     f94:	d43ff0ef          	jal	cd6 <putc>
+  putc(fd, 'x');
+     f98:	07800593          	li	a1,120
+     f9c:	855a                	mv	a0,s6
+     f9e:	d39ff0ef          	jal	cd6 <putc>
+     fa2:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+     fa4:	00000b97          	auipc	s7,0x0
+     fa8:	3b4b8b93          	addi	s7,s7,948 # 1358 <digits>
+     fac:	03c9d793          	srli	a5,s3,0x3c
+     fb0:	97de                	add	a5,a5,s7
+     fb2:	0007c583          	lbu	a1,0(a5)
+     fb6:	855a                	mv	a0,s6
+     fb8:	d1fff0ef          	jal	cd6 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+     fbc:	0992                	slli	s3,s3,0x4
+     fbe:	397d                	addiw	s2,s2,-1
+     fc0:	fe0916e3          	bnez	s2,fac <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+     fc4:	8bea                	mv	s7,s10
+      state = 0;
+     fc6:	4981                	li	s3,0
+     fc8:	6d02                	ld	s10,0(sp)
+     fca:	bd01                	j	dda <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+     fcc:	008b8913          	addi	s2,s7,8
+     fd0:	000bc583          	lbu	a1,0(s7)
+     fd4:	855a                	mv	a0,s6
+     fd6:	d01ff0ef          	jal	cd6 <putc>
+     fda:	8bca                	mv	s7,s2
+      state = 0;
+     fdc:	4981                	li	s3,0
+     fde:	bbf5                	j	dda <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+     fe0:	008b8993          	addi	s3,s7,8
+     fe4:	000bb903          	ld	s2,0(s7)
+     fe8:	00090f63          	beqz	s2,1006 <vprintf+0x276>
+        for(; *s; s++)
+     fec:	00094583          	lbu	a1,0(s2)
+     ff0:	c195                	beqz	a1,1014 <vprintf+0x284>
+          putc(fd, *s);
+     ff2:	855a                	mv	a0,s6
+     ff4:	ce3ff0ef          	jal	cd6 <putc>
+        for(; *s; s++)
+     ff8:	0905                	addi	s2,s2,1
+     ffa:	00094583          	lbu	a1,0(s2)
+     ffe:	f9f5                	bnez	a1,ff2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+    1000:	8bce                	mv	s7,s3
+      state = 0;
+    1002:	4981                	li	s3,0
+    1004:	bbd9                	j	dda <vprintf+0x4a>
+          s = "(null)";
+    1006:	00000917          	auipc	s2,0x0
+    100a:	31a90913          	addi	s2,s2,794 # 1320 <malloc+0x20e>
+        for(; *s; s++)
+    100e:	02800593          	li	a1,40
+    1012:	b7c5                	j	ff2 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+    1014:	8bce                	mv	s7,s3
+      state = 0;
+    1016:	4981                	li	s3,0
+    1018:	b3c9                	j	dda <vprintf+0x4a>
+    101a:	64a6                	ld	s1,72(sp)
+    101c:	79e2                	ld	s3,56(sp)
+    101e:	7a42                	ld	s4,48(sp)
+    1020:	7aa2                	ld	s5,40(sp)
+    1022:	7b02                	ld	s6,32(sp)
+    1024:	6be2                	ld	s7,24(sp)
+    1026:	6c42                	ld	s8,16(sp)
+    1028:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+    102a:	60e6                	ld	ra,88(sp)
+    102c:	6446                	ld	s0,80(sp)
+    102e:	6906                	ld	s2,64(sp)
+    1030:	6125                	addi	sp,sp,96
+    1032:	8082                	ret
+
+0000000000001034 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+    1034:	715d                	addi	sp,sp,-80
+    1036:	ec06                	sd	ra,24(sp)
+    1038:	e822                	sd	s0,16(sp)
+    103a:	1000                	addi	s0,sp,32
+    103c:	e010                	sd	a2,0(s0)
+    103e:	e414                	sd	a3,8(s0)
+    1040:	e818                	sd	a4,16(s0)
+    1042:	ec1c                	sd	a5,24(s0)
+    1044:	03043023          	sd	a6,32(s0)
+    1048:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+    104c:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+    1050:	8622                	mv	a2,s0
+    1052:	d3fff0ef          	jal	d90 <vprintf>
+}
+    1056:	60e2                	ld	ra,24(sp)
+    1058:	6442                	ld	s0,16(sp)
+    105a:	6161                	addi	sp,sp,80
+    105c:	8082                	ret
+
+000000000000105e <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+    105e:	711d                	addi	sp,sp,-96
+    1060:	ec06                	sd	ra,24(sp)
+    1062:	e822                	sd	s0,16(sp)
+    1064:	1000                	addi	s0,sp,32
+    1066:	e40c                	sd	a1,8(s0)
+    1068:	e810                	sd	a2,16(s0)
+    106a:	ec14                	sd	a3,24(s0)
+    106c:	f018                	sd	a4,32(s0)
+    106e:	f41c                	sd	a5,40(s0)
+    1070:	03043823          	sd	a6,48(s0)
+    1074:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+    1078:	00840613          	addi	a2,s0,8
+    107c:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+    1080:	85aa                	mv	a1,a0
+    1082:	4505                	li	a0,1
+    1084:	d0dff0ef          	jal	d90 <vprintf>
+}
+    1088:	60e2                	ld	ra,24(sp)
+    108a:	6442                	ld	s0,16(sp)
+    108c:	6125                	addi	sp,sp,96
+    108e:	8082                	ret
+
+0000000000001090 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    1090:	1141                	addi	sp,sp,-16
+    1092:	e422                	sd	s0,8(sp)
+    1094:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    1096:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    109a:	00001797          	auipc	a5,0x1
+    109e:	f767b783          	ld	a5,-138(a5) # 2010 <freep>
+    10a2:	a02d                	j	10cc <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+    10a4:	4618                	lw	a4,8(a2)
+    10a6:	9f2d                	addw	a4,a4,a1
+    10a8:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    10ac:	6398                	ld	a4,0(a5)
+    10ae:	6310                	ld	a2,0(a4)
+    10b0:	a83d                	j	10ee <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+    10b2:	ff852703          	lw	a4,-8(a0)
+    10b6:	9f31                	addw	a4,a4,a2
+    10b8:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+    10ba:	ff053683          	ld	a3,-16(a0)
+    10be:	a091                	j	1102 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    10c0:	6398                	ld	a4,0(a5)
+    10c2:	00e7e463          	bltu	a5,a4,10ca <free+0x3a>
+    10c6:	00e6ea63          	bltu	a3,a4,10da <free+0x4a>
+{
+    10ca:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    10cc:	fed7fae3          	bgeu	a5,a3,10c0 <free+0x30>
+    10d0:	6398                	ld	a4,0(a5)
+    10d2:	00e6e463          	bltu	a3,a4,10da <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    10d6:	fee7eae3          	bltu	a5,a4,10ca <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+    10da:	ff852583          	lw	a1,-8(a0)
+    10de:	6390                	ld	a2,0(a5)
+    10e0:	02059813          	slli	a6,a1,0x20
+    10e4:	01c85713          	srli	a4,a6,0x1c
+    10e8:	9736                	add	a4,a4,a3
+    10ea:	fae60de3          	beq	a2,a4,10a4 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+    10ee:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+    10f2:	4790                	lw	a2,8(a5)
+    10f4:	02061593          	slli	a1,a2,0x20
+    10f8:	01c5d713          	srli	a4,a1,0x1c
+    10fc:	973e                	add	a4,a4,a5
+    10fe:	fae68ae3          	beq	a3,a4,10b2 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+    1102:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+    1104:	00001717          	auipc	a4,0x1
+    1108:	f0f73623          	sd	a5,-244(a4) # 2010 <freep>
+}
+    110c:	6422                	ld	s0,8(sp)
+    110e:	0141                	addi	sp,sp,16
+    1110:	8082                	ret
+
+0000000000001112 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    1112:	7139                	addi	sp,sp,-64
+    1114:	fc06                	sd	ra,56(sp)
+    1116:	f822                	sd	s0,48(sp)
+    1118:	f426                	sd	s1,40(sp)
+    111a:	ec4e                	sd	s3,24(sp)
+    111c:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    111e:	02051493          	slli	s1,a0,0x20
+    1122:	9081                	srli	s1,s1,0x20
+    1124:	04bd                	addi	s1,s1,15
+    1126:	8091                	srli	s1,s1,0x4
+    1128:	0014899b          	addiw	s3,s1,1
+    112c:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+    112e:	00001517          	auipc	a0,0x1
+    1132:	ee253503          	ld	a0,-286(a0) # 2010 <freep>
+    1136:	c915                	beqz	a0,116a <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    1138:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    113a:	4798                	lw	a4,8(a5)
+    113c:	08977a63          	bgeu	a4,s1,11d0 <malloc+0xbe>
+    1140:	f04a                	sd	s2,32(sp)
+    1142:	e852                	sd	s4,16(sp)
+    1144:	e456                	sd	s5,8(sp)
+    1146:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+    1148:	8a4e                	mv	s4,s3
+    114a:	0009871b          	sext.w	a4,s3
+    114e:	6685                	lui	a3,0x1
+    1150:	00d77363          	bgeu	a4,a3,1156 <malloc+0x44>
+    1154:	6a05                	lui	s4,0x1
+    1156:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+    115a:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    115e:	00001917          	auipc	s2,0x1
+    1162:	eb290913          	addi	s2,s2,-334 # 2010 <freep>
+  if(p == SBRK_ERROR)
+    1166:	5afd                	li	s5,-1
+    1168:	a081                	j	11a8 <malloc+0x96>
+    116a:	f04a                	sd	s2,32(sp)
+    116c:	e852                	sd	s4,16(sp)
+    116e:	e456                	sd	s5,8(sp)
+    1170:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+    1172:	00001797          	auipc	a5,0x1
+    1176:	f1678793          	addi	a5,a5,-234 # 2088 <base>
+    117a:	00001717          	auipc	a4,0x1
+    117e:	e8f73b23          	sd	a5,-362(a4) # 2010 <freep>
+    1182:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+    1184:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+    1188:	b7c1                	j	1148 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+    118a:	6398                	ld	a4,0(a5)
+    118c:	e118                	sd	a4,0(a0)
+    118e:	a8a9                	j	11e8 <malloc+0xd6>
+  hp->s.size = nu;
+    1190:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+    1194:	0541                	addi	a0,a0,16
+    1196:	efbff0ef          	jal	1090 <free>
+  return freep;
+    119a:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+    119e:	c12d                	beqz	a0,1200 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    11a0:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    11a2:	4798                	lw	a4,8(a5)
+    11a4:	02977263          	bgeu	a4,s1,11c8 <malloc+0xb6>
+    if(p == freep)
+    11a8:	00093703          	ld	a4,0(s2)
+    11ac:	853e                	mv	a0,a5
+    11ae:	fef719e3          	bne	a4,a5,11a0 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+    11b2:	8552                	mv	a0,s4
+    11b4:	a47ff0ef          	jal	bfa <sbrk>
+  if(p == SBRK_ERROR)
+    11b8:	fd551ce3          	bne	a0,s5,1190 <malloc+0x7e>
+        return 0;
+    11bc:	4501                	li	a0,0
+    11be:	7902                	ld	s2,32(sp)
+    11c0:	6a42                	ld	s4,16(sp)
+    11c2:	6aa2                	ld	s5,8(sp)
+    11c4:	6b02                	ld	s6,0(sp)
+    11c6:	a03d                	j	11f4 <malloc+0xe2>
+    11c8:	7902                	ld	s2,32(sp)
+    11ca:	6a42                	ld	s4,16(sp)
+    11cc:	6aa2                	ld	s5,8(sp)
+    11ce:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+    11d0:	fae48de3          	beq	s1,a4,118a <malloc+0x78>
+        p->s.size -= nunits;
+    11d4:	4137073b          	subw	a4,a4,s3
+    11d8:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+    11da:	02071693          	slli	a3,a4,0x20
+    11de:	01c6d713          	srli	a4,a3,0x1c
+    11e2:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+    11e4:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+    11e8:	00001717          	auipc	a4,0x1
+    11ec:	e2a73423          	sd	a0,-472(a4) # 2010 <freep>
+      return (void*)(p + 1);
+    11f0:	01078513          	addi	a0,a5,16
+  }
+}
+    11f4:	70e2                	ld	ra,56(sp)
+    11f6:	7442                	ld	s0,48(sp)
+    11f8:	74a2                	ld	s1,40(sp)
+    11fa:	69e2                	ld	s3,24(sp)
+    11fc:	6121                	addi	sp,sp,64
+    11fe:	8082                	ret
+    1200:	7902                	ld	s2,32(sp)
+    1202:	6a42                	ld	s4,16(sp)
+    1204:	6aa2                	ld	s5,8(sp)
+    1206:	6b02                	ld	s6,0(sp)
+    1208:	b7f5                	j	11f4 <malloc+0xe2>
diff -ruN xv6-riscv/user/sh.d xv62/user/sh.d
--- xv6-riscv/user/sh.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/sh.d	2025-09-14 12:32:51.252883238 +0000
@@ -0,0 +1 @@
+user/sh.o: user/sh.c kernel/types.h user/user.h kernel/fcntl.h
Binary files xv6-riscv/user/sh.o and xv62/user/sh.o differ
diff -ruN xv6-riscv/user/sh.sym xv62/user/sh.sym
--- xv6-riscv/user/sh.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/sh.sym	2025-09-14 12:32:51.276883233 +0000
@@ -0,0 +1,87 @@
+0000000000000000 .text
+0000000000001210 .rodata
+0000000000001370 .eh_frame
+0000000000002000 .data
+0000000000002010 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_ranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 sh.c
+0000000000002020 buf.0
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000cd6 putc
+0000000000000cf4 printint
+0000000000001358 digits
+0000000000000000 umalloc.c
+0000000000002010 freep
+0000000000002088 base
+00000000000009aa strcpy
+0000000000000cbe pause
+000000000000105e printf
+0000000000000cb6 sys_sbrk
+0000000000000b54 memmove
+0000000000000c76 mknod
+00000000000001d2 execcmd
+0000000000000a62 gets
+0000000000000cae getpid
+000000000000066c parsepipe
+0000000000000852 parsecmd
+0000000000000be6 memcpy
+00000000000002dc backcmd
+000000000000044c peek
+00000000000004b0 parseredirs
+0000000000000310 gettoken
+0000000000001112 malloc
+0000000000002008 whitespace
+0000000000000068 fork1
+0000000000000c10 sbrklazy
+00000000000007d2 nulterminate
+0000000000000c3e pipe
+0000000000000000 getcmd
+0000000000000c4e write
+0000000000000c86 fstat
+0000000000001034 fprintf
+0000000000000c5e kill
+0000000000000d90 vprintf
+0000000000000c9e chdir
+00000000000006c6 parseline
+000000000000008e runcmd
+000000000000074e parseblock
+0000000000000c66 exec
+0000000000000c36 wait
+0000000000002000 symbols
+0000000000000c46 read
+0000000000000588 parseexec
+0000000000000c7e unlink
+000000000000004a panic
+0000000000000bac memcmp
+0000000000000c26 fork
+0000000000000bfa sbrk
+0000000000000cc6 uptime
+0000000000000a1c memset
+00000000000008c2 main
+00000000000009c6 strcmp
+0000000000000ca6 dup
+0000000000000260 pipecmd
+0000000000000200 redircmd
+0000000000000cce getreadcount
+0000000000000ad2 stat
+0000000000000c8e link
+0000000000000c2e exit
+000000000000099a start
+0000000000000b0c atoi
+00000000000009f2 strlen
+0000000000000c6e open
+0000000000000a3e strchr
+0000000000000c96 mkdir
+0000000000000c56 close
+000000000000029e listcmd
+0000000000001090 free
diff -ruN xv6-riscv/user/stressfs.asm xv62/user/stressfs.asm
--- xv6-riscv/user/stressfs.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/stressfs.asm	2025-09-14 12:32:51.328883222 +0000
@@ -0,0 +1,1564 @@
+
+user/_stressfs:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+   0:	dd010113          	addi	sp,sp,-560
+   4:	22113423          	sd	ra,552(sp)
+   8:	22813023          	sd	s0,544(sp)
+   c:	20913c23          	sd	s1,536(sp)
+  10:	21213823          	sd	s2,528(sp)
+  14:	1c00                	addi	s0,sp,560
+  int fd, i;
+  char path[] = "stressfs0";
+  16:	00001797          	auipc	a5,0x1
+  1a:	96a78793          	addi	a5,a5,-1686 # 980 <malloc+0x130>
+  1e:	6398                	ld	a4,0(a5)
+  20:	fce43823          	sd	a4,-48(s0)
+  24:	0087d783          	lhu	a5,8(a5)
+  28:	fcf41c23          	sh	a5,-40(s0)
+  char data[512];
+
+  printf("stressfs starting\n");
+  2c:	00001517          	auipc	a0,0x1
+  30:	92450513          	addi	a0,a0,-1756 # 950 <malloc+0x100>
+  34:	768000ef          	jal	79c <printf>
+  memset(data, 'a', sizeof(data));
+  38:	20000613          	li	a2,512
+  3c:	06100593          	li	a1,97
+  40:	dd040513          	addi	a0,s0,-560
+  44:	116000ef          	jal	15a <memset>
+
+  for(i = 0; i < 4; i++)
+  48:	4481                	li	s1,0
+  4a:	4911                	li	s2,4
+    if(fork() > 0)
+  4c:	318000ef          	jal	364 <fork>
+  50:	00a04563          	bgtz	a0,5a <main+0x5a>
+  for(i = 0; i < 4; i++)
+  54:	2485                	addiw	s1,s1,1
+  56:	ff249be3          	bne	s1,s2,4c <main+0x4c>
+      break;
+
+  printf("write %d\n", i);
+  5a:	85a6                	mv	a1,s1
+  5c:	00001517          	auipc	a0,0x1
+  60:	90c50513          	addi	a0,a0,-1780 # 968 <malloc+0x118>
+  64:	738000ef          	jal	79c <printf>
+
+  path[8] += i;
+  68:	fd844783          	lbu	a5,-40(s0)
+  6c:	9fa5                	addw	a5,a5,s1
+  6e:	fcf40c23          	sb	a5,-40(s0)
+  fd = open(path, O_CREATE | O_RDWR);
+  72:	20200593          	li	a1,514
+  76:	fd040513          	addi	a0,s0,-48
+  7a:	332000ef          	jal	3ac <open>
+  7e:	892a                	mv	s2,a0
+  80:	44d1                	li	s1,20
+  for(i = 0; i < 20; i++)
+//    printf(fd, "%d\n", i);
+    write(fd, data, sizeof(data));
+  82:	20000613          	li	a2,512
+  86:	dd040593          	addi	a1,s0,-560
+  8a:	854a                	mv	a0,s2
+  8c:	300000ef          	jal	38c <write>
+  for(i = 0; i < 20; i++)
+  90:	34fd                	addiw	s1,s1,-1
+  92:	f8e5                	bnez	s1,82 <main+0x82>
+  close(fd);
+  94:	854a                	mv	a0,s2
+  96:	2fe000ef          	jal	394 <close>
+
+  printf("read\n");
+  9a:	00001517          	auipc	a0,0x1
+  9e:	8de50513          	addi	a0,a0,-1826 # 978 <malloc+0x128>
+  a2:	6fa000ef          	jal	79c <printf>
+
+  fd = open(path, O_RDONLY);
+  a6:	4581                	li	a1,0
+  a8:	fd040513          	addi	a0,s0,-48
+  ac:	300000ef          	jal	3ac <open>
+  b0:	892a                	mv	s2,a0
+  b2:	44d1                	li	s1,20
+  for (i = 0; i < 20; i++)
+    read(fd, data, sizeof(data));
+  b4:	20000613          	li	a2,512
+  b8:	dd040593          	addi	a1,s0,-560
+  bc:	854a                	mv	a0,s2
+  be:	2c6000ef          	jal	384 <read>
+  for (i = 0; i < 20; i++)
+  c2:	34fd                	addiw	s1,s1,-1
+  c4:	f8e5                	bnez	s1,b4 <main+0xb4>
+  close(fd);
+  c6:	854a                	mv	a0,s2
+  c8:	2cc000ef          	jal	394 <close>
+
+  wait(0);
+  cc:	4501                	li	a0,0
+  ce:	2a6000ef          	jal	374 <wait>
+
+  exit(0);
+  d2:	4501                	li	a0,0
+  d4:	298000ef          	jal	36c <exit>
+
+00000000000000d8 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  d8:	1141                	addi	sp,sp,-16
+  da:	e406                	sd	ra,8(sp)
+  dc:	e022                	sd	s0,0(sp)
+  de:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  e0:	f21ff0ef          	jal	0 <main>
+  exit(r);
+  e4:	288000ef          	jal	36c <exit>
+
+00000000000000e8 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  e8:	1141                	addi	sp,sp,-16
+  ea:	e422                	sd	s0,8(sp)
+  ec:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  ee:	87aa                	mv	a5,a0
+  f0:	0585                	addi	a1,a1,1
+  f2:	0785                	addi	a5,a5,1
+  f4:	fff5c703          	lbu	a4,-1(a1)
+  f8:	fee78fa3          	sb	a4,-1(a5)
+  fc:	fb75                	bnez	a4,f0 <strcpy+0x8>
+    ;
+  return os;
+}
+  fe:	6422                	ld	s0,8(sp)
+ 100:	0141                	addi	sp,sp,16
+ 102:	8082                	ret
+
+0000000000000104 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 104:	1141                	addi	sp,sp,-16
+ 106:	e422                	sd	s0,8(sp)
+ 108:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 10a:	00054783          	lbu	a5,0(a0)
+ 10e:	cb91                	beqz	a5,122 <strcmp+0x1e>
+ 110:	0005c703          	lbu	a4,0(a1)
+ 114:	00f71763          	bne	a4,a5,122 <strcmp+0x1e>
+    p++, q++;
+ 118:	0505                	addi	a0,a0,1
+ 11a:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 11c:	00054783          	lbu	a5,0(a0)
+ 120:	fbe5                	bnez	a5,110 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 122:	0005c503          	lbu	a0,0(a1)
+}
+ 126:	40a7853b          	subw	a0,a5,a0
+ 12a:	6422                	ld	s0,8(sp)
+ 12c:	0141                	addi	sp,sp,16
+ 12e:	8082                	ret
+
+0000000000000130 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 130:	1141                	addi	sp,sp,-16
+ 132:	e422                	sd	s0,8(sp)
+ 134:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 136:	00054783          	lbu	a5,0(a0)
+ 13a:	cf91                	beqz	a5,156 <strlen+0x26>
+ 13c:	0505                	addi	a0,a0,1
+ 13e:	87aa                	mv	a5,a0
+ 140:	86be                	mv	a3,a5
+ 142:	0785                	addi	a5,a5,1
+ 144:	fff7c703          	lbu	a4,-1(a5)
+ 148:	ff65                	bnez	a4,140 <strlen+0x10>
+ 14a:	40a6853b          	subw	a0,a3,a0
+ 14e:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 150:	6422                	ld	s0,8(sp)
+ 152:	0141                	addi	sp,sp,16
+ 154:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 156:	4501                	li	a0,0
+ 158:	bfe5                	j	150 <strlen+0x20>
+
+000000000000015a <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 15a:	1141                	addi	sp,sp,-16
+ 15c:	e422                	sd	s0,8(sp)
+ 15e:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 160:	ca19                	beqz	a2,176 <memset+0x1c>
+ 162:	87aa                	mv	a5,a0
+ 164:	1602                	slli	a2,a2,0x20
+ 166:	9201                	srli	a2,a2,0x20
+ 168:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 16c:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 170:	0785                	addi	a5,a5,1
+ 172:	fee79de3          	bne	a5,a4,16c <memset+0x12>
+  }
+  return dst;
+}
+ 176:	6422                	ld	s0,8(sp)
+ 178:	0141                	addi	sp,sp,16
+ 17a:	8082                	ret
+
+000000000000017c <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 17c:	1141                	addi	sp,sp,-16
+ 17e:	e422                	sd	s0,8(sp)
+ 180:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 182:	00054783          	lbu	a5,0(a0)
+ 186:	cb99                	beqz	a5,19c <strchr+0x20>
+    if(*s == c)
+ 188:	00f58763          	beq	a1,a5,196 <strchr+0x1a>
+  for(; *s; s++)
+ 18c:	0505                	addi	a0,a0,1
+ 18e:	00054783          	lbu	a5,0(a0)
+ 192:	fbfd                	bnez	a5,188 <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 194:	4501                	li	a0,0
+}
+ 196:	6422                	ld	s0,8(sp)
+ 198:	0141                	addi	sp,sp,16
+ 19a:	8082                	ret
+  return 0;
+ 19c:	4501                	li	a0,0
+ 19e:	bfe5                	j	196 <strchr+0x1a>
+
+00000000000001a0 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 1a0:	711d                	addi	sp,sp,-96
+ 1a2:	ec86                	sd	ra,88(sp)
+ 1a4:	e8a2                	sd	s0,80(sp)
+ 1a6:	e4a6                	sd	s1,72(sp)
+ 1a8:	e0ca                	sd	s2,64(sp)
+ 1aa:	fc4e                	sd	s3,56(sp)
+ 1ac:	f852                	sd	s4,48(sp)
+ 1ae:	f456                	sd	s5,40(sp)
+ 1b0:	f05a                	sd	s6,32(sp)
+ 1b2:	ec5e                	sd	s7,24(sp)
+ 1b4:	1080                	addi	s0,sp,96
+ 1b6:	8baa                	mv	s7,a0
+ 1b8:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 1ba:	892a                	mv	s2,a0
+ 1bc:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 1be:	4aa9                	li	s5,10
+ 1c0:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 1c2:	89a6                	mv	s3,s1
+ 1c4:	2485                	addiw	s1,s1,1
+ 1c6:	0344d663          	bge	s1,s4,1f2 <gets+0x52>
+    cc = read(0, &c, 1);
+ 1ca:	4605                	li	a2,1
+ 1cc:	faf40593          	addi	a1,s0,-81
+ 1d0:	4501                	li	a0,0
+ 1d2:	1b2000ef          	jal	384 <read>
+    if(cc < 1)
+ 1d6:	00a05e63          	blez	a0,1f2 <gets+0x52>
+    buf[i++] = c;
+ 1da:	faf44783          	lbu	a5,-81(s0)
+ 1de:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 1e2:	01578763          	beq	a5,s5,1f0 <gets+0x50>
+ 1e6:	0905                	addi	s2,s2,1
+ 1e8:	fd679de3          	bne	a5,s6,1c2 <gets+0x22>
+    buf[i++] = c;
+ 1ec:	89a6                	mv	s3,s1
+ 1ee:	a011                	j	1f2 <gets+0x52>
+ 1f0:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 1f2:	99de                	add	s3,s3,s7
+ 1f4:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 1f8:	855e                	mv	a0,s7
+ 1fa:	60e6                	ld	ra,88(sp)
+ 1fc:	6446                	ld	s0,80(sp)
+ 1fe:	64a6                	ld	s1,72(sp)
+ 200:	6906                	ld	s2,64(sp)
+ 202:	79e2                	ld	s3,56(sp)
+ 204:	7a42                	ld	s4,48(sp)
+ 206:	7aa2                	ld	s5,40(sp)
+ 208:	7b02                	ld	s6,32(sp)
+ 20a:	6be2                	ld	s7,24(sp)
+ 20c:	6125                	addi	sp,sp,96
+ 20e:	8082                	ret
+
+0000000000000210 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 210:	1101                	addi	sp,sp,-32
+ 212:	ec06                	sd	ra,24(sp)
+ 214:	e822                	sd	s0,16(sp)
+ 216:	e04a                	sd	s2,0(sp)
+ 218:	1000                	addi	s0,sp,32
+ 21a:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 21c:	4581                	li	a1,0
+ 21e:	18e000ef          	jal	3ac <open>
+  if(fd < 0)
+ 222:	02054263          	bltz	a0,246 <stat+0x36>
+ 226:	e426                	sd	s1,8(sp)
+ 228:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 22a:	85ca                	mv	a1,s2
+ 22c:	198000ef          	jal	3c4 <fstat>
+ 230:	892a                	mv	s2,a0
+  close(fd);
+ 232:	8526                	mv	a0,s1
+ 234:	160000ef          	jal	394 <close>
+  return r;
+ 238:	64a2                	ld	s1,8(sp)
+}
+ 23a:	854a                	mv	a0,s2
+ 23c:	60e2                	ld	ra,24(sp)
+ 23e:	6442                	ld	s0,16(sp)
+ 240:	6902                	ld	s2,0(sp)
+ 242:	6105                	addi	sp,sp,32
+ 244:	8082                	ret
+    return -1;
+ 246:	597d                	li	s2,-1
+ 248:	bfcd                	j	23a <stat+0x2a>
+
+000000000000024a <atoi>:
+
+int
+atoi(const char *s)
+{
+ 24a:	1141                	addi	sp,sp,-16
+ 24c:	e422                	sd	s0,8(sp)
+ 24e:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 250:	00054683          	lbu	a3,0(a0)
+ 254:	fd06879b          	addiw	a5,a3,-48
+ 258:	0ff7f793          	zext.b	a5,a5
+ 25c:	4625                	li	a2,9
+ 25e:	02f66863          	bltu	a2,a5,28e <atoi+0x44>
+ 262:	872a                	mv	a4,a0
+  n = 0;
+ 264:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 266:	0705                	addi	a4,a4,1
+ 268:	0025179b          	slliw	a5,a0,0x2
+ 26c:	9fa9                	addw	a5,a5,a0
+ 26e:	0017979b          	slliw	a5,a5,0x1
+ 272:	9fb5                	addw	a5,a5,a3
+ 274:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 278:	00074683          	lbu	a3,0(a4)
+ 27c:	fd06879b          	addiw	a5,a3,-48
+ 280:	0ff7f793          	zext.b	a5,a5
+ 284:	fef671e3          	bgeu	a2,a5,266 <atoi+0x1c>
+  return n;
+}
+ 288:	6422                	ld	s0,8(sp)
+ 28a:	0141                	addi	sp,sp,16
+ 28c:	8082                	ret
+  n = 0;
+ 28e:	4501                	li	a0,0
+ 290:	bfe5                	j	288 <atoi+0x3e>
+
+0000000000000292 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 292:	1141                	addi	sp,sp,-16
+ 294:	e422                	sd	s0,8(sp)
+ 296:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 298:	02b57463          	bgeu	a0,a1,2c0 <memmove+0x2e>
+    while(n-- > 0)
+ 29c:	00c05f63          	blez	a2,2ba <memmove+0x28>
+ 2a0:	1602                	slli	a2,a2,0x20
+ 2a2:	9201                	srli	a2,a2,0x20
+ 2a4:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 2a8:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 2aa:	0585                	addi	a1,a1,1
+ 2ac:	0705                	addi	a4,a4,1
+ 2ae:	fff5c683          	lbu	a3,-1(a1)
+ 2b2:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 2b6:	fef71ae3          	bne	a4,a5,2aa <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 2ba:	6422                	ld	s0,8(sp)
+ 2bc:	0141                	addi	sp,sp,16
+ 2be:	8082                	ret
+    dst += n;
+ 2c0:	00c50733          	add	a4,a0,a2
+    src += n;
+ 2c4:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 2c6:	fec05ae3          	blez	a2,2ba <memmove+0x28>
+ 2ca:	fff6079b          	addiw	a5,a2,-1
+ 2ce:	1782                	slli	a5,a5,0x20
+ 2d0:	9381                	srli	a5,a5,0x20
+ 2d2:	fff7c793          	not	a5,a5
+ 2d6:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 2d8:	15fd                	addi	a1,a1,-1
+ 2da:	177d                	addi	a4,a4,-1
+ 2dc:	0005c683          	lbu	a3,0(a1)
+ 2e0:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 2e4:	fee79ae3          	bne	a5,a4,2d8 <memmove+0x46>
+ 2e8:	bfc9                	j	2ba <memmove+0x28>
+
+00000000000002ea <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 2ea:	1141                	addi	sp,sp,-16
+ 2ec:	e422                	sd	s0,8(sp)
+ 2ee:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 2f0:	ca05                	beqz	a2,320 <memcmp+0x36>
+ 2f2:	fff6069b          	addiw	a3,a2,-1
+ 2f6:	1682                	slli	a3,a3,0x20
+ 2f8:	9281                	srli	a3,a3,0x20
+ 2fa:	0685                	addi	a3,a3,1
+ 2fc:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 2fe:	00054783          	lbu	a5,0(a0)
+ 302:	0005c703          	lbu	a4,0(a1)
+ 306:	00e79863          	bne	a5,a4,316 <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 30a:	0505                	addi	a0,a0,1
+    p2++;
+ 30c:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 30e:	fed518e3          	bne	a0,a3,2fe <memcmp+0x14>
+  }
+  return 0;
+ 312:	4501                	li	a0,0
+ 314:	a019                	j	31a <memcmp+0x30>
+      return *p1 - *p2;
+ 316:	40e7853b          	subw	a0,a5,a4
+}
+ 31a:	6422                	ld	s0,8(sp)
+ 31c:	0141                	addi	sp,sp,16
+ 31e:	8082                	ret
+  return 0;
+ 320:	4501                	li	a0,0
+ 322:	bfe5                	j	31a <memcmp+0x30>
+
+0000000000000324 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 324:	1141                	addi	sp,sp,-16
+ 326:	e406                	sd	ra,8(sp)
+ 328:	e022                	sd	s0,0(sp)
+ 32a:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 32c:	f67ff0ef          	jal	292 <memmove>
+}
+ 330:	60a2                	ld	ra,8(sp)
+ 332:	6402                	ld	s0,0(sp)
+ 334:	0141                	addi	sp,sp,16
+ 336:	8082                	ret
+
+0000000000000338 <sbrk>:
+
+char *
+sbrk(int n) {
+ 338:	1141                	addi	sp,sp,-16
+ 33a:	e406                	sd	ra,8(sp)
+ 33c:	e022                	sd	s0,0(sp)
+ 33e:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 340:	4585                	li	a1,1
+ 342:	0b2000ef          	jal	3f4 <sys_sbrk>
+}
+ 346:	60a2                	ld	ra,8(sp)
+ 348:	6402                	ld	s0,0(sp)
+ 34a:	0141                	addi	sp,sp,16
+ 34c:	8082                	ret
+
+000000000000034e <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 34e:	1141                	addi	sp,sp,-16
+ 350:	e406                	sd	ra,8(sp)
+ 352:	e022                	sd	s0,0(sp)
+ 354:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 356:	4589                	li	a1,2
+ 358:	09c000ef          	jal	3f4 <sys_sbrk>
+}
+ 35c:	60a2                	ld	ra,8(sp)
+ 35e:	6402                	ld	s0,0(sp)
+ 360:	0141                	addi	sp,sp,16
+ 362:	8082                	ret
+
+0000000000000364 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 364:	4885                	li	a7,1
+ ecall
+ 366:	00000073          	ecall
+ ret
+ 36a:	8082                	ret
+
+000000000000036c <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 36c:	4889                	li	a7,2
+ ecall
+ 36e:	00000073          	ecall
+ ret
+ 372:	8082                	ret
+
+0000000000000374 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 374:	488d                	li	a7,3
+ ecall
+ 376:	00000073          	ecall
+ ret
+ 37a:	8082                	ret
+
+000000000000037c <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 37c:	4891                	li	a7,4
+ ecall
+ 37e:	00000073          	ecall
+ ret
+ 382:	8082                	ret
+
+0000000000000384 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 384:	4895                	li	a7,5
+ ecall
+ 386:	00000073          	ecall
+ ret
+ 38a:	8082                	ret
+
+000000000000038c <write>:
+.global write
+write:
+ li a7, SYS_write
+ 38c:	48c1                	li	a7,16
+ ecall
+ 38e:	00000073          	ecall
+ ret
+ 392:	8082                	ret
+
+0000000000000394 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 394:	48d5                	li	a7,21
+ ecall
+ 396:	00000073          	ecall
+ ret
+ 39a:	8082                	ret
+
+000000000000039c <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 39c:	4899                	li	a7,6
+ ecall
+ 39e:	00000073          	ecall
+ ret
+ 3a2:	8082                	ret
+
+00000000000003a4 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 3a4:	489d                	li	a7,7
+ ecall
+ 3a6:	00000073          	ecall
+ ret
+ 3aa:	8082                	ret
+
+00000000000003ac <open>:
+.global open
+open:
+ li a7, SYS_open
+ 3ac:	48bd                	li	a7,15
+ ecall
+ 3ae:	00000073          	ecall
+ ret
+ 3b2:	8082                	ret
+
+00000000000003b4 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 3b4:	48c5                	li	a7,17
+ ecall
+ 3b6:	00000073          	ecall
+ ret
+ 3ba:	8082                	ret
+
+00000000000003bc <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 3bc:	48c9                	li	a7,18
+ ecall
+ 3be:	00000073          	ecall
+ ret
+ 3c2:	8082                	ret
+
+00000000000003c4 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 3c4:	48a1                	li	a7,8
+ ecall
+ 3c6:	00000073          	ecall
+ ret
+ 3ca:	8082                	ret
+
+00000000000003cc <link>:
+.global link
+link:
+ li a7, SYS_link
+ 3cc:	48cd                	li	a7,19
+ ecall
+ 3ce:	00000073          	ecall
+ ret
+ 3d2:	8082                	ret
+
+00000000000003d4 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 3d4:	48d1                	li	a7,20
+ ecall
+ 3d6:	00000073          	ecall
+ ret
+ 3da:	8082                	ret
+
+00000000000003dc <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 3dc:	48a5                	li	a7,9
+ ecall
+ 3de:	00000073          	ecall
+ ret
+ 3e2:	8082                	ret
+
+00000000000003e4 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 3e4:	48a9                	li	a7,10
+ ecall
+ 3e6:	00000073          	ecall
+ ret
+ 3ea:	8082                	ret
+
+00000000000003ec <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 3ec:	48ad                	li	a7,11
+ ecall
+ 3ee:	00000073          	ecall
+ ret
+ 3f2:	8082                	ret
+
+00000000000003f4 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 3f4:	48b1                	li	a7,12
+ ecall
+ 3f6:	00000073          	ecall
+ ret
+ 3fa:	8082                	ret
+
+00000000000003fc <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 3fc:	48b5                	li	a7,13
+ ecall
+ 3fe:	00000073          	ecall
+ ret
+ 402:	8082                	ret
+
+0000000000000404 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 404:	48b9                	li	a7,14
+ ecall
+ 406:	00000073          	ecall
+ ret
+ 40a:	8082                	ret
+
+000000000000040c <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 40c:	48d9                	li	a7,22
+ ecall
+ 40e:	00000073          	ecall
+ ret
+ 412:	8082                	ret
+
+0000000000000414 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 414:	1101                	addi	sp,sp,-32
+ 416:	ec06                	sd	ra,24(sp)
+ 418:	e822                	sd	s0,16(sp)
+ 41a:	1000                	addi	s0,sp,32
+ 41c:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 420:	4605                	li	a2,1
+ 422:	fef40593          	addi	a1,s0,-17
+ 426:	f67ff0ef          	jal	38c <write>
+}
+ 42a:	60e2                	ld	ra,24(sp)
+ 42c:	6442                	ld	s0,16(sp)
+ 42e:	6105                	addi	sp,sp,32
+ 430:	8082                	ret
+
+0000000000000432 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 432:	715d                	addi	sp,sp,-80
+ 434:	e486                	sd	ra,72(sp)
+ 436:	e0a2                	sd	s0,64(sp)
+ 438:	f84a                	sd	s2,48(sp)
+ 43a:	0880                	addi	s0,sp,80
+ 43c:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 43e:	c299                	beqz	a3,444 <printint+0x12>
+ 440:	0805c363          	bltz	a1,4c6 <printint+0x94>
+  neg = 0;
+ 444:	4881                	li	a7,0
+ 446:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 44a:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 44c:	00000517          	auipc	a0,0x0
+ 450:	54c50513          	addi	a0,a0,1356 # 998 <digits>
+ 454:	883e                	mv	a6,a5
+ 456:	2785                	addiw	a5,a5,1
+ 458:	02c5f733          	remu	a4,a1,a2
+ 45c:	972a                	add	a4,a4,a0
+ 45e:	00074703          	lbu	a4,0(a4)
+ 462:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 466:	872e                	mv	a4,a1
+ 468:	02c5d5b3          	divu	a1,a1,a2
+ 46c:	0685                	addi	a3,a3,1
+ 46e:	fec773e3          	bgeu	a4,a2,454 <printint+0x22>
+  if(neg)
+ 472:	00088b63          	beqz	a7,488 <printint+0x56>
+    buf[i++] = '-';
+ 476:	fd078793          	addi	a5,a5,-48
+ 47a:	97a2                	add	a5,a5,s0
+ 47c:	02d00713          	li	a4,45
+ 480:	fee78423          	sb	a4,-24(a5)
+ 484:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 488:	02f05a63          	blez	a5,4bc <printint+0x8a>
+ 48c:	fc26                	sd	s1,56(sp)
+ 48e:	f44e                	sd	s3,40(sp)
+ 490:	fb840713          	addi	a4,s0,-72
+ 494:	00f704b3          	add	s1,a4,a5
+ 498:	fff70993          	addi	s3,a4,-1
+ 49c:	99be                	add	s3,s3,a5
+ 49e:	37fd                	addiw	a5,a5,-1
+ 4a0:	1782                	slli	a5,a5,0x20
+ 4a2:	9381                	srli	a5,a5,0x20
+ 4a4:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 4a8:	fff4c583          	lbu	a1,-1(s1)
+ 4ac:	854a                	mv	a0,s2
+ 4ae:	f67ff0ef          	jal	414 <putc>
+  while(--i >= 0)
+ 4b2:	14fd                	addi	s1,s1,-1
+ 4b4:	ff349ae3          	bne	s1,s3,4a8 <printint+0x76>
+ 4b8:	74e2                	ld	s1,56(sp)
+ 4ba:	79a2                	ld	s3,40(sp)
+}
+ 4bc:	60a6                	ld	ra,72(sp)
+ 4be:	6406                	ld	s0,64(sp)
+ 4c0:	7942                	ld	s2,48(sp)
+ 4c2:	6161                	addi	sp,sp,80
+ 4c4:	8082                	ret
+    x = -xx;
+ 4c6:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 4ca:	4885                	li	a7,1
+    x = -xx;
+ 4cc:	bfad                	j	446 <printint+0x14>
+
+00000000000004ce <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 4ce:	711d                	addi	sp,sp,-96
+ 4d0:	ec86                	sd	ra,88(sp)
+ 4d2:	e8a2                	sd	s0,80(sp)
+ 4d4:	e0ca                	sd	s2,64(sp)
+ 4d6:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 4d8:	0005c903          	lbu	s2,0(a1)
+ 4dc:	28090663          	beqz	s2,768 <vprintf+0x29a>
+ 4e0:	e4a6                	sd	s1,72(sp)
+ 4e2:	fc4e                	sd	s3,56(sp)
+ 4e4:	f852                	sd	s4,48(sp)
+ 4e6:	f456                	sd	s5,40(sp)
+ 4e8:	f05a                	sd	s6,32(sp)
+ 4ea:	ec5e                	sd	s7,24(sp)
+ 4ec:	e862                	sd	s8,16(sp)
+ 4ee:	e466                	sd	s9,8(sp)
+ 4f0:	8b2a                	mv	s6,a0
+ 4f2:	8a2e                	mv	s4,a1
+ 4f4:	8bb2                	mv	s7,a2
+  state = 0;
+ 4f6:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 4f8:	4481                	li	s1,0
+ 4fa:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 4fc:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 500:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 504:	06c00c93          	li	s9,108
+ 508:	a005                	j	528 <vprintf+0x5a>
+        putc(fd, c0);
+ 50a:	85ca                	mv	a1,s2
+ 50c:	855a                	mv	a0,s6
+ 50e:	f07ff0ef          	jal	414 <putc>
+ 512:	a019                	j	518 <vprintf+0x4a>
+    } else if(state == '%'){
+ 514:	03598263          	beq	s3,s5,538 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 518:	2485                	addiw	s1,s1,1
+ 51a:	8726                	mv	a4,s1
+ 51c:	009a07b3          	add	a5,s4,s1
+ 520:	0007c903          	lbu	s2,0(a5)
+ 524:	22090a63          	beqz	s2,758 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 528:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 52c:	fe0994e3          	bnez	s3,514 <vprintf+0x46>
+      if(c0 == '%'){
+ 530:	fd579de3          	bne	a5,s5,50a <vprintf+0x3c>
+        state = '%';
+ 534:	89be                	mv	s3,a5
+ 536:	b7cd                	j	518 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 538:	00ea06b3          	add	a3,s4,a4
+ 53c:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 540:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 542:	c681                	beqz	a3,54a <vprintf+0x7c>
+ 544:	9752                	add	a4,a4,s4
+ 546:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 54a:	05878363          	beq	a5,s8,590 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 54e:	05978d63          	beq	a5,s9,5a8 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 552:	07500713          	li	a4,117
+ 556:	0ee78763          	beq	a5,a4,644 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 55a:	07800713          	li	a4,120
+ 55e:	12e78963          	beq	a5,a4,690 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 562:	07000713          	li	a4,112
+ 566:	14e78e63          	beq	a5,a4,6c2 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 56a:	06300713          	li	a4,99
+ 56e:	18e78e63          	beq	a5,a4,70a <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 572:	07300713          	li	a4,115
+ 576:	1ae78463          	beq	a5,a4,71e <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 57a:	02500713          	li	a4,37
+ 57e:	04e79563          	bne	a5,a4,5c8 <vprintf+0xfa>
+        putc(fd, '%');
+ 582:	02500593          	li	a1,37
+ 586:	855a                	mv	a0,s6
+ 588:	e8dff0ef          	jal	414 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 58c:	4981                	li	s3,0
+ 58e:	b769                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 590:	008b8913          	addi	s2,s7,8
+ 594:	4685                	li	a3,1
+ 596:	4629                	li	a2,10
+ 598:	000ba583          	lw	a1,0(s7)
+ 59c:	855a                	mv	a0,s6
+ 59e:	e95ff0ef          	jal	432 <printint>
+ 5a2:	8bca                	mv	s7,s2
+      state = 0;
+ 5a4:	4981                	li	s3,0
+ 5a6:	bf8d                	j	518 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 5a8:	06400793          	li	a5,100
+ 5ac:	02f68963          	beq	a3,a5,5de <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5b0:	06c00793          	li	a5,108
+ 5b4:	04f68263          	beq	a3,a5,5f8 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 5b8:	07500793          	li	a5,117
+ 5bc:	0af68063          	beq	a3,a5,65c <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 5c0:	07800793          	li	a5,120
+ 5c4:	0ef68263          	beq	a3,a5,6a8 <vprintf+0x1da>
+        putc(fd, '%');
+ 5c8:	02500593          	li	a1,37
+ 5cc:	855a                	mv	a0,s6
+ 5ce:	e47ff0ef          	jal	414 <putc>
+        putc(fd, c0);
+ 5d2:	85ca                	mv	a1,s2
+ 5d4:	855a                	mv	a0,s6
+ 5d6:	e3fff0ef          	jal	414 <putc>
+      state = 0;
+ 5da:	4981                	li	s3,0
+ 5dc:	bf35                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5de:	008b8913          	addi	s2,s7,8
+ 5e2:	4685                	li	a3,1
+ 5e4:	4629                	li	a2,10
+ 5e6:	000bb583          	ld	a1,0(s7)
+ 5ea:	855a                	mv	a0,s6
+ 5ec:	e47ff0ef          	jal	432 <printint>
+        i += 1;
+ 5f0:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 5f2:	8bca                	mv	s7,s2
+      state = 0;
+ 5f4:	4981                	li	s3,0
+        i += 1;
+ 5f6:	b70d                	j	518 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 5f8:	06400793          	li	a5,100
+ 5fc:	02f60763          	beq	a2,a5,62a <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 600:	07500793          	li	a5,117
+ 604:	06f60963          	beq	a2,a5,676 <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 608:	07800793          	li	a5,120
+ 60c:	faf61ee3          	bne	a2,a5,5c8 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 610:	008b8913          	addi	s2,s7,8
+ 614:	4681                	li	a3,0
+ 616:	4641                	li	a2,16
+ 618:	000bb583          	ld	a1,0(s7)
+ 61c:	855a                	mv	a0,s6
+ 61e:	e15ff0ef          	jal	432 <printint>
+        i += 2;
+ 622:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 624:	8bca                	mv	s7,s2
+      state = 0;
+ 626:	4981                	li	s3,0
+        i += 2;
+ 628:	bdc5                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 62a:	008b8913          	addi	s2,s7,8
+ 62e:	4685                	li	a3,1
+ 630:	4629                	li	a2,10
+ 632:	000bb583          	ld	a1,0(s7)
+ 636:	855a                	mv	a0,s6
+ 638:	dfbff0ef          	jal	432 <printint>
+        i += 2;
+ 63c:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 63e:	8bca                	mv	s7,s2
+      state = 0;
+ 640:	4981                	li	s3,0
+        i += 2;
+ 642:	bdd9                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 644:	008b8913          	addi	s2,s7,8
+ 648:	4681                	li	a3,0
+ 64a:	4629                	li	a2,10
+ 64c:	000be583          	lwu	a1,0(s7)
+ 650:	855a                	mv	a0,s6
+ 652:	de1ff0ef          	jal	432 <printint>
+ 656:	8bca                	mv	s7,s2
+      state = 0;
+ 658:	4981                	li	s3,0
+ 65a:	bd7d                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 65c:	008b8913          	addi	s2,s7,8
+ 660:	4681                	li	a3,0
+ 662:	4629                	li	a2,10
+ 664:	000bb583          	ld	a1,0(s7)
+ 668:	855a                	mv	a0,s6
+ 66a:	dc9ff0ef          	jal	432 <printint>
+        i += 1;
+ 66e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 670:	8bca                	mv	s7,s2
+      state = 0;
+ 672:	4981                	li	s3,0
+        i += 1;
+ 674:	b555                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 676:	008b8913          	addi	s2,s7,8
+ 67a:	4681                	li	a3,0
+ 67c:	4629                	li	a2,10
+ 67e:	000bb583          	ld	a1,0(s7)
+ 682:	855a                	mv	a0,s6
+ 684:	dafff0ef          	jal	432 <printint>
+        i += 2;
+ 688:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 68a:	8bca                	mv	s7,s2
+      state = 0;
+ 68c:	4981                	li	s3,0
+        i += 2;
+ 68e:	b569                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 690:	008b8913          	addi	s2,s7,8
+ 694:	4681                	li	a3,0
+ 696:	4641                	li	a2,16
+ 698:	000be583          	lwu	a1,0(s7)
+ 69c:	855a                	mv	a0,s6
+ 69e:	d95ff0ef          	jal	432 <printint>
+ 6a2:	8bca                	mv	s7,s2
+      state = 0;
+ 6a4:	4981                	li	s3,0
+ 6a6:	bd8d                	j	518 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6a8:	008b8913          	addi	s2,s7,8
+ 6ac:	4681                	li	a3,0
+ 6ae:	4641                	li	a2,16
+ 6b0:	000bb583          	ld	a1,0(s7)
+ 6b4:	855a                	mv	a0,s6
+ 6b6:	d7dff0ef          	jal	432 <printint>
+        i += 1;
+ 6ba:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6bc:	8bca                	mv	s7,s2
+      state = 0;
+ 6be:	4981                	li	s3,0
+        i += 1;
+ 6c0:	bda1                	j	518 <vprintf+0x4a>
+ 6c2:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 6c4:	008b8d13          	addi	s10,s7,8
+ 6c8:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 6cc:	03000593          	li	a1,48
+ 6d0:	855a                	mv	a0,s6
+ 6d2:	d43ff0ef          	jal	414 <putc>
+  putc(fd, 'x');
+ 6d6:	07800593          	li	a1,120
+ 6da:	855a                	mv	a0,s6
+ 6dc:	d39ff0ef          	jal	414 <putc>
+ 6e0:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 6e2:	00000b97          	auipc	s7,0x0
+ 6e6:	2b6b8b93          	addi	s7,s7,694 # 998 <digits>
+ 6ea:	03c9d793          	srli	a5,s3,0x3c
+ 6ee:	97de                	add	a5,a5,s7
+ 6f0:	0007c583          	lbu	a1,0(a5)
+ 6f4:	855a                	mv	a0,s6
+ 6f6:	d1fff0ef          	jal	414 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 6fa:	0992                	slli	s3,s3,0x4
+ 6fc:	397d                	addiw	s2,s2,-1
+ 6fe:	fe0916e3          	bnez	s2,6ea <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 702:	8bea                	mv	s7,s10
+      state = 0;
+ 704:	4981                	li	s3,0
+ 706:	6d02                	ld	s10,0(sp)
+ 708:	bd01                	j	518 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 70a:	008b8913          	addi	s2,s7,8
+ 70e:	000bc583          	lbu	a1,0(s7)
+ 712:	855a                	mv	a0,s6
+ 714:	d01ff0ef          	jal	414 <putc>
+ 718:	8bca                	mv	s7,s2
+      state = 0;
+ 71a:	4981                	li	s3,0
+ 71c:	bbf5                	j	518 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 71e:	008b8993          	addi	s3,s7,8
+ 722:	000bb903          	ld	s2,0(s7)
+ 726:	00090f63          	beqz	s2,744 <vprintf+0x276>
+        for(; *s; s++)
+ 72a:	00094583          	lbu	a1,0(s2)
+ 72e:	c195                	beqz	a1,752 <vprintf+0x284>
+          putc(fd, *s);
+ 730:	855a                	mv	a0,s6
+ 732:	ce3ff0ef          	jal	414 <putc>
+        for(; *s; s++)
+ 736:	0905                	addi	s2,s2,1
+ 738:	00094583          	lbu	a1,0(s2)
+ 73c:	f9f5                	bnez	a1,730 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 73e:	8bce                	mv	s7,s3
+      state = 0;
+ 740:	4981                	li	s3,0
+ 742:	bbd9                	j	518 <vprintf+0x4a>
+          s = "(null)";
+ 744:	00000917          	auipc	s2,0x0
+ 748:	24c90913          	addi	s2,s2,588 # 990 <malloc+0x140>
+        for(; *s; s++)
+ 74c:	02800593          	li	a1,40
+ 750:	b7c5                	j	730 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 752:	8bce                	mv	s7,s3
+      state = 0;
+ 754:	4981                	li	s3,0
+ 756:	b3c9                	j	518 <vprintf+0x4a>
+ 758:	64a6                	ld	s1,72(sp)
+ 75a:	79e2                	ld	s3,56(sp)
+ 75c:	7a42                	ld	s4,48(sp)
+ 75e:	7aa2                	ld	s5,40(sp)
+ 760:	7b02                	ld	s6,32(sp)
+ 762:	6be2                	ld	s7,24(sp)
+ 764:	6c42                	ld	s8,16(sp)
+ 766:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 768:	60e6                	ld	ra,88(sp)
+ 76a:	6446                	ld	s0,80(sp)
+ 76c:	6906                	ld	s2,64(sp)
+ 76e:	6125                	addi	sp,sp,96
+ 770:	8082                	ret
+
+0000000000000772 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 772:	715d                	addi	sp,sp,-80
+ 774:	ec06                	sd	ra,24(sp)
+ 776:	e822                	sd	s0,16(sp)
+ 778:	1000                	addi	s0,sp,32
+ 77a:	e010                	sd	a2,0(s0)
+ 77c:	e414                	sd	a3,8(s0)
+ 77e:	e818                	sd	a4,16(s0)
+ 780:	ec1c                	sd	a5,24(s0)
+ 782:	03043023          	sd	a6,32(s0)
+ 786:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 78a:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 78e:	8622                	mv	a2,s0
+ 790:	d3fff0ef          	jal	4ce <vprintf>
+}
+ 794:	60e2                	ld	ra,24(sp)
+ 796:	6442                	ld	s0,16(sp)
+ 798:	6161                	addi	sp,sp,80
+ 79a:	8082                	ret
+
+000000000000079c <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 79c:	711d                	addi	sp,sp,-96
+ 79e:	ec06                	sd	ra,24(sp)
+ 7a0:	e822                	sd	s0,16(sp)
+ 7a2:	1000                	addi	s0,sp,32
+ 7a4:	e40c                	sd	a1,8(s0)
+ 7a6:	e810                	sd	a2,16(s0)
+ 7a8:	ec14                	sd	a3,24(s0)
+ 7aa:	f018                	sd	a4,32(s0)
+ 7ac:	f41c                	sd	a5,40(s0)
+ 7ae:	03043823          	sd	a6,48(s0)
+ 7b2:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 7b6:	00840613          	addi	a2,s0,8
+ 7ba:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 7be:	85aa                	mv	a1,a0
+ 7c0:	4505                	li	a0,1
+ 7c2:	d0dff0ef          	jal	4ce <vprintf>
+}
+ 7c6:	60e2                	ld	ra,24(sp)
+ 7c8:	6442                	ld	s0,16(sp)
+ 7ca:	6125                	addi	sp,sp,96
+ 7cc:	8082                	ret
+
+00000000000007ce <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 7ce:	1141                	addi	sp,sp,-16
+ 7d0:	e422                	sd	s0,8(sp)
+ 7d2:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 7d4:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 7d8:	00001797          	auipc	a5,0x1
+ 7dc:	8287b783          	ld	a5,-2008(a5) # 1000 <freep>
+ 7e0:	a02d                	j	80a <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 7e2:	4618                	lw	a4,8(a2)
+ 7e4:	9f2d                	addw	a4,a4,a1
+ 7e6:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 7ea:	6398                	ld	a4,0(a5)
+ 7ec:	6310                	ld	a2,0(a4)
+ 7ee:	a83d                	j	82c <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 7f0:	ff852703          	lw	a4,-8(a0)
+ 7f4:	9f31                	addw	a4,a4,a2
+ 7f6:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 7f8:	ff053683          	ld	a3,-16(a0)
+ 7fc:	a091                	j	840 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 7fe:	6398                	ld	a4,0(a5)
+ 800:	00e7e463          	bltu	a5,a4,808 <free+0x3a>
+ 804:	00e6ea63          	bltu	a3,a4,818 <free+0x4a>
+{
+ 808:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 80a:	fed7fae3          	bgeu	a5,a3,7fe <free+0x30>
+ 80e:	6398                	ld	a4,0(a5)
+ 810:	00e6e463          	bltu	a3,a4,818 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 814:	fee7eae3          	bltu	a5,a4,808 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 818:	ff852583          	lw	a1,-8(a0)
+ 81c:	6390                	ld	a2,0(a5)
+ 81e:	02059813          	slli	a6,a1,0x20
+ 822:	01c85713          	srli	a4,a6,0x1c
+ 826:	9736                	add	a4,a4,a3
+ 828:	fae60de3          	beq	a2,a4,7e2 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 82c:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 830:	4790                	lw	a2,8(a5)
+ 832:	02061593          	slli	a1,a2,0x20
+ 836:	01c5d713          	srli	a4,a1,0x1c
+ 83a:	973e                	add	a4,a4,a5
+ 83c:	fae68ae3          	beq	a3,a4,7f0 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 840:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 842:	00000717          	auipc	a4,0x0
+ 846:	7af73f23          	sd	a5,1982(a4) # 1000 <freep>
+}
+ 84a:	6422                	ld	s0,8(sp)
+ 84c:	0141                	addi	sp,sp,16
+ 84e:	8082                	ret
+
+0000000000000850 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 850:	7139                	addi	sp,sp,-64
+ 852:	fc06                	sd	ra,56(sp)
+ 854:	f822                	sd	s0,48(sp)
+ 856:	f426                	sd	s1,40(sp)
+ 858:	ec4e                	sd	s3,24(sp)
+ 85a:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 85c:	02051493          	slli	s1,a0,0x20
+ 860:	9081                	srli	s1,s1,0x20
+ 862:	04bd                	addi	s1,s1,15
+ 864:	8091                	srli	s1,s1,0x4
+ 866:	0014899b          	addiw	s3,s1,1
+ 86a:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 86c:	00000517          	auipc	a0,0x0
+ 870:	79453503          	ld	a0,1940(a0) # 1000 <freep>
+ 874:	c915                	beqz	a0,8a8 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 876:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 878:	4798                	lw	a4,8(a5)
+ 87a:	08977a63          	bgeu	a4,s1,90e <malloc+0xbe>
+ 87e:	f04a                	sd	s2,32(sp)
+ 880:	e852                	sd	s4,16(sp)
+ 882:	e456                	sd	s5,8(sp)
+ 884:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 886:	8a4e                	mv	s4,s3
+ 888:	0009871b          	sext.w	a4,s3
+ 88c:	6685                	lui	a3,0x1
+ 88e:	00d77363          	bgeu	a4,a3,894 <malloc+0x44>
+ 892:	6a05                	lui	s4,0x1
+ 894:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 898:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 89c:	00000917          	auipc	s2,0x0
+ 8a0:	76490913          	addi	s2,s2,1892 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 8a4:	5afd                	li	s5,-1
+ 8a6:	a081                	j	8e6 <malloc+0x96>
+ 8a8:	f04a                	sd	s2,32(sp)
+ 8aa:	e852                	sd	s4,16(sp)
+ 8ac:	e456                	sd	s5,8(sp)
+ 8ae:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 8b0:	00000797          	auipc	a5,0x0
+ 8b4:	76078793          	addi	a5,a5,1888 # 1010 <base>
+ 8b8:	00000717          	auipc	a4,0x0
+ 8bc:	74f73423          	sd	a5,1864(a4) # 1000 <freep>
+ 8c0:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 8c2:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 8c6:	b7c1                	j	886 <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 8c8:	6398                	ld	a4,0(a5)
+ 8ca:	e118                	sd	a4,0(a0)
+ 8cc:	a8a9                	j	926 <malloc+0xd6>
+  hp->s.size = nu;
+ 8ce:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 8d2:	0541                	addi	a0,a0,16
+ 8d4:	efbff0ef          	jal	7ce <free>
+  return freep;
+ 8d8:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 8dc:	c12d                	beqz	a0,93e <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8de:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8e0:	4798                	lw	a4,8(a5)
+ 8e2:	02977263          	bgeu	a4,s1,906 <malloc+0xb6>
+    if(p == freep)
+ 8e6:	00093703          	ld	a4,0(s2)
+ 8ea:	853e                	mv	a0,a5
+ 8ec:	fef719e3          	bne	a4,a5,8de <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 8f0:	8552                	mv	a0,s4
+ 8f2:	a47ff0ef          	jal	338 <sbrk>
+  if(p == SBRK_ERROR)
+ 8f6:	fd551ce3          	bne	a0,s5,8ce <malloc+0x7e>
+        return 0;
+ 8fa:	4501                	li	a0,0
+ 8fc:	7902                	ld	s2,32(sp)
+ 8fe:	6a42                	ld	s4,16(sp)
+ 900:	6aa2                	ld	s5,8(sp)
+ 902:	6b02                	ld	s6,0(sp)
+ 904:	a03d                	j	932 <malloc+0xe2>
+ 906:	7902                	ld	s2,32(sp)
+ 908:	6a42                	ld	s4,16(sp)
+ 90a:	6aa2                	ld	s5,8(sp)
+ 90c:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 90e:	fae48de3          	beq	s1,a4,8c8 <malloc+0x78>
+        p->s.size -= nunits;
+ 912:	4137073b          	subw	a4,a4,s3
+ 916:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 918:	02071693          	slli	a3,a4,0x20
+ 91c:	01c6d713          	srli	a4,a3,0x1c
+ 920:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 922:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 926:	00000717          	auipc	a4,0x0
+ 92a:	6ca73d23          	sd	a0,1754(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 92e:	01078513          	addi	a0,a5,16
+  }
+}
+ 932:	70e2                	ld	ra,56(sp)
+ 934:	7442                	ld	s0,48(sp)
+ 936:	74a2                	ld	s1,40(sp)
+ 938:	69e2                	ld	s3,24(sp)
+ 93a:	6121                	addi	sp,sp,64
+ 93c:	8082                	ret
+ 93e:	7902                	ld	s2,32(sp)
+ 940:	6a42                	ld	s4,16(sp)
+ 942:	6aa2                	ld	s5,8(sp)
+ 944:	6b02                	ld	s6,0(sp)
+ 946:	b7f5                	j	932 <malloc+0xe2>
diff -ruN xv6-riscv/user/stressfs.d xv62/user/stressfs.d
--- xv6-riscv/user/stressfs.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/stressfs.d	2025-09-14 12:32:51.308883227 +0000
@@ -0,0 +1,2 @@
+user/stressfs.o: user/stressfs.c kernel/types.h kernel/stat.h user/user.h \
+ kernel/fs.h kernel/fcntl.h
Binary files xv6-riscv/user/stressfs.o and xv62/user/stressfs.o differ
diff -ruN xv6-riscv/user/stressfs.sym xv62/user/stressfs.sym
--- xv6-riscv/user/stressfs.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/stressfs.sym	2025-09-14 12:32:51.332883222 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+0000000000000948 .rodata
+00000000000009b0 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 stressfs.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000414 putc
+0000000000000432 printint
+0000000000000998 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+00000000000000e8 strcpy
+00000000000003fc pause
+000000000000079c printf
+00000000000003f4 sys_sbrk
+0000000000000292 memmove
+00000000000003b4 mknod
+00000000000001a0 gets
+00000000000003ec getpid
+0000000000000324 memcpy
+0000000000000850 malloc
+000000000000034e sbrklazy
+000000000000037c pipe
+000000000000038c write
+00000000000003c4 fstat
+0000000000000772 fprintf
+000000000000039c kill
+00000000000004ce vprintf
+00000000000003dc chdir
+00000000000003a4 exec
+0000000000000374 wait
+0000000000000384 read
+00000000000003bc unlink
+00000000000002ea memcmp
+0000000000000364 fork
+0000000000000338 sbrk
+0000000000000404 uptime
+000000000000015a memset
+0000000000000000 main
+0000000000000104 strcmp
+00000000000003e4 dup
+000000000000040c getreadcount
+0000000000000210 stat
+00000000000003cc link
+000000000000036c exit
+00000000000000d8 start
+000000000000024a atoi
+0000000000000130 strlen
+00000000000003ac open
+000000000000017c strchr
+00000000000003d4 mkdir
+0000000000000394 close
+00000000000007ce free
diff -ruN xv6-riscv/user/ulib.d xv62/user/ulib.d
--- xv6-riscv/user/ulib.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/ulib.d	2025-09-14 12:32:50.432883406 +0000
@@ -0,0 +1,2 @@
+user/ulib.o: user/ulib.c kernel/types.h kernel/stat.h kernel/fcntl.h \
+ kernel/riscv.h kernel/vm.h user/user.h
Binary files xv6-riscv/user/ulib.o and xv62/user/ulib.o differ
diff -ruN xv6-riscv/user/umalloc.d xv62/user/umalloc.d
--- xv6-riscv/user/umalloc.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/umalloc.d	2025-09-14 12:32:50.556883381 +0000
@@ -0,0 +1,2 @@
+user/umalloc.o: user/umalloc.c kernel/types.h kernel/stat.h user/user.h \
+ kernel/param.h
Binary files xv6-riscv/user/umalloc.o and xv62/user/umalloc.o differ
diff -ruN xv6-riscv/user/user.h xv62/user/user.h
--- xv6-riscv/user/user.h	2025-09-13 15:52:01.166209209 +0000
+++ xv62/user/user.h	2025-09-13 14:34:47.235630566 +0000
@@ -24,6 +24,7 @@
 char* sys_sbrk(int,int);
 int pause(int);
 int uptime(void);
+int getreadcount(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff -ruN xv6-riscv/user/usertests.asm xv62/user/usertests.asm
--- xv6-riscv/user/usertests.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/usertests.asm	2025-09-14 12:32:51.908883103 +0000
@@ -0,0 +1,9814 @@
+
+user/_usertests:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <copyinstr1>:
+}
+
+// what if you pass ridiculous string pointers to system calls?
+void
+copyinstr1(char *s)
+{
+       0:	711d                	addi	sp,sp,-96
+       2:	ec86                	sd	ra,88(sp)
+       4:	e8a2                	sd	s0,80(sp)
+       6:	e4a6                	sd	s1,72(sp)
+       8:	e0ca                	sd	s2,64(sp)
+       a:	fc4e                	sd	s3,56(sp)
+       c:	1080                	addi	s0,sp,96
+  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+       e:	00007797          	auipc	a5,0x7
+      12:	6da78793          	addi	a5,a5,1754 # 76e8 <malloc+0x2580>
+      16:	638c                	ld	a1,0(a5)
+      18:	6790                	ld	a2,8(a5)
+      1a:	6b94                	ld	a3,16(a5)
+      1c:	6f98                	ld	a4,24(a5)
+      1e:	739c                	ld	a5,32(a5)
+      20:	fab43423          	sd	a1,-88(s0)
+      24:	fac43823          	sd	a2,-80(s0)
+      28:	fad43c23          	sd	a3,-72(s0)
+      2c:	fce43023          	sd	a4,-64(s0)
+      30:	fcf43423          	sd	a5,-56(s0)
+                     0xffffffffffffffff };
+
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+      34:	fa840493          	addi	s1,s0,-88
+      38:	fd040993          	addi	s3,s0,-48
+    uint64 addr = addrs[ai];
+
+    int fd = open((char *)addr, O_CREATE|O_WRONLY);
+      3c:	0004b903          	ld	s2,0(s1)
+      40:	20100593          	li	a1,513
+      44:	854a                	mv	a0,s2
+      46:	47f040ef          	jal	4cc4 <open>
+    if(fd >= 0){
+      4a:	00055c63          	bgez	a0,62 <copyinstr1+0x62>
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+      4e:	04a1                	addi	s1,s1,8
+      50:	ff3496e3          	bne	s1,s3,3c <copyinstr1+0x3c>
+      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
+      exit(1);
+    }
+  }
+}
+      54:	60e6                	ld	ra,88(sp)
+      56:	6446                	ld	s0,80(sp)
+      58:	64a6                	ld	s1,72(sp)
+      5a:	6906                	ld	s2,64(sp)
+      5c:	79e2                	ld	s3,56(sp)
+      5e:	6125                	addi	sp,sp,96
+      60:	8082                	ret
+      printf("open(%p) returned %d, not -1\n", (void*)addr, fd);
+      62:	862a                	mv	a2,a0
+      64:	85ca                	mv	a1,s2
+      66:	00005517          	auipc	a0,0x5
+      6a:	1fa50513          	addi	a0,a0,506 # 5260 <malloc+0xf8>
+      6e:	046050ef          	jal	50b4 <printf>
+      exit(1);
+      72:	4505                	li	a0,1
+      74:	411040ef          	jal	4c84 <exit>
+
+0000000000000078 <bsstest>:
+void
+bsstest(char *s)
+{
+  int i;
+
+  for(i = 0; i < sizeof(uninit); i++){
+      78:	0000a797          	auipc	a5,0xa
+      7c:	52078793          	addi	a5,a5,1312 # a598 <uninit>
+      80:	0000d697          	auipc	a3,0xd
+      84:	c2868693          	addi	a3,a3,-984 # cca8 <buf>
+    if(uninit[i] != '\0'){
+      88:	0007c703          	lbu	a4,0(a5)
+      8c:	e709                	bnez	a4,96 <bsstest+0x1e>
+  for(i = 0; i < sizeof(uninit); i++){
+      8e:	0785                	addi	a5,a5,1
+      90:	fed79ce3          	bne	a5,a3,88 <bsstest+0x10>
+      94:	8082                	ret
+{
+      96:	1141                	addi	sp,sp,-16
+      98:	e406                	sd	ra,8(sp)
+      9a:	e022                	sd	s0,0(sp)
+      9c:	0800                	addi	s0,sp,16
+      printf("%s: bss test failed\n", s);
+      9e:	85aa                	mv	a1,a0
+      a0:	00005517          	auipc	a0,0x5
+      a4:	1e050513          	addi	a0,a0,480 # 5280 <malloc+0x118>
+      a8:	00c050ef          	jal	50b4 <printf>
+      exit(1);
+      ac:	4505                	li	a0,1
+      ae:	3d7040ef          	jal	4c84 <exit>
+
+00000000000000b2 <opentest>:
+{
+      b2:	1101                	addi	sp,sp,-32
+      b4:	ec06                	sd	ra,24(sp)
+      b6:	e822                	sd	s0,16(sp)
+      b8:	e426                	sd	s1,8(sp)
+      ba:	1000                	addi	s0,sp,32
+      bc:	84aa                	mv	s1,a0
+  fd = open("echo", 0);
+      be:	4581                	li	a1,0
+      c0:	00005517          	auipc	a0,0x5
+      c4:	1d850513          	addi	a0,a0,472 # 5298 <malloc+0x130>
+      c8:	3fd040ef          	jal	4cc4 <open>
+  if(fd < 0){
+      cc:	02054263          	bltz	a0,f0 <opentest+0x3e>
+  close(fd);
+      d0:	3dd040ef          	jal	4cac <close>
+  fd = open("doesnotexist", 0);
+      d4:	4581                	li	a1,0
+      d6:	00005517          	auipc	a0,0x5
+      da:	1e250513          	addi	a0,a0,482 # 52b8 <malloc+0x150>
+      de:	3e7040ef          	jal	4cc4 <open>
+  if(fd >= 0){
+      e2:	02055163          	bgez	a0,104 <opentest+0x52>
+}
+      e6:	60e2                	ld	ra,24(sp)
+      e8:	6442                	ld	s0,16(sp)
+      ea:	64a2                	ld	s1,8(sp)
+      ec:	6105                	addi	sp,sp,32
+      ee:	8082                	ret
+    printf("%s: open echo failed!\n", s);
+      f0:	85a6                	mv	a1,s1
+      f2:	00005517          	auipc	a0,0x5
+      f6:	1ae50513          	addi	a0,a0,430 # 52a0 <malloc+0x138>
+      fa:	7bb040ef          	jal	50b4 <printf>
+    exit(1);
+      fe:	4505                	li	a0,1
+     100:	385040ef          	jal	4c84 <exit>
+    printf("%s: open doesnotexist succeeded!\n", s);
+     104:	85a6                	mv	a1,s1
+     106:	00005517          	auipc	a0,0x5
+     10a:	1c250513          	addi	a0,a0,450 # 52c8 <malloc+0x160>
+     10e:	7a7040ef          	jal	50b4 <printf>
+    exit(1);
+     112:	4505                	li	a0,1
+     114:	371040ef          	jal	4c84 <exit>
+
+0000000000000118 <truncate2>:
+{
+     118:	7179                	addi	sp,sp,-48
+     11a:	f406                	sd	ra,40(sp)
+     11c:	f022                	sd	s0,32(sp)
+     11e:	ec26                	sd	s1,24(sp)
+     120:	e84a                	sd	s2,16(sp)
+     122:	e44e                	sd	s3,8(sp)
+     124:	1800                	addi	s0,sp,48
+     126:	89aa                	mv	s3,a0
+  unlink("truncfile");
+     128:	00005517          	auipc	a0,0x5
+     12c:	1c850513          	addi	a0,a0,456 # 52f0 <malloc+0x188>
+     130:	3a5040ef          	jal	4cd4 <unlink>
+  int fd1 = open("truncfile", O_CREATE|O_TRUNC|O_WRONLY);
+     134:	60100593          	li	a1,1537
+     138:	00005517          	auipc	a0,0x5
+     13c:	1b850513          	addi	a0,a0,440 # 52f0 <malloc+0x188>
+     140:	385040ef          	jal	4cc4 <open>
+     144:	84aa                	mv	s1,a0
+  write(fd1, "abcd", 4);
+     146:	4611                	li	a2,4
+     148:	00005597          	auipc	a1,0x5
+     14c:	1b858593          	addi	a1,a1,440 # 5300 <malloc+0x198>
+     150:	355040ef          	jal	4ca4 <write>
+  int fd2 = open("truncfile", O_TRUNC|O_WRONLY);
+     154:	40100593          	li	a1,1025
+     158:	00005517          	auipc	a0,0x5
+     15c:	19850513          	addi	a0,a0,408 # 52f0 <malloc+0x188>
+     160:	365040ef          	jal	4cc4 <open>
+     164:	892a                	mv	s2,a0
+  int n = write(fd1, "x", 1);
+     166:	4605                	li	a2,1
+     168:	00005597          	auipc	a1,0x5
+     16c:	1a058593          	addi	a1,a1,416 # 5308 <malloc+0x1a0>
+     170:	8526                	mv	a0,s1
+     172:	333040ef          	jal	4ca4 <write>
+  if(n != -1){
+     176:	57fd                	li	a5,-1
+     178:	02f51563          	bne	a0,a5,1a2 <truncate2+0x8a>
+  unlink("truncfile");
+     17c:	00005517          	auipc	a0,0x5
+     180:	17450513          	addi	a0,a0,372 # 52f0 <malloc+0x188>
+     184:	351040ef          	jal	4cd4 <unlink>
+  close(fd1);
+     188:	8526                	mv	a0,s1
+     18a:	323040ef          	jal	4cac <close>
+  close(fd2);
+     18e:	854a                	mv	a0,s2
+     190:	31d040ef          	jal	4cac <close>
+}
+     194:	70a2                	ld	ra,40(sp)
+     196:	7402                	ld	s0,32(sp)
+     198:	64e2                	ld	s1,24(sp)
+     19a:	6942                	ld	s2,16(sp)
+     19c:	69a2                	ld	s3,8(sp)
+     19e:	6145                	addi	sp,sp,48
+     1a0:	8082                	ret
+    printf("%s: write returned %d, expected -1\n", s, n);
+     1a2:	862a                	mv	a2,a0
+     1a4:	85ce                	mv	a1,s3
+     1a6:	00005517          	auipc	a0,0x5
+     1aa:	16a50513          	addi	a0,a0,362 # 5310 <malloc+0x1a8>
+     1ae:	707040ef          	jal	50b4 <printf>
+    exit(1);
+     1b2:	4505                	li	a0,1
+     1b4:	2d1040ef          	jal	4c84 <exit>
+
+00000000000001b8 <createtest>:
+{
+     1b8:	7179                	addi	sp,sp,-48
+     1ba:	f406                	sd	ra,40(sp)
+     1bc:	f022                	sd	s0,32(sp)
+     1be:	ec26                	sd	s1,24(sp)
+     1c0:	e84a                	sd	s2,16(sp)
+     1c2:	1800                	addi	s0,sp,48
+  name[0] = 'a';
+     1c4:	06100793          	li	a5,97
+     1c8:	fcf40c23          	sb	a5,-40(s0)
+  name[2] = '\0';
+     1cc:	fc040d23          	sb	zero,-38(s0)
+     1d0:	03000493          	li	s1,48
+  for(i = 0; i < N; i++){
+     1d4:	06400913          	li	s2,100
+    name[1] = '0' + i;
+     1d8:	fc940ca3          	sb	s1,-39(s0)
+    fd = open(name, O_CREATE|O_RDWR);
+     1dc:	20200593          	li	a1,514
+     1e0:	fd840513          	addi	a0,s0,-40
+     1e4:	2e1040ef          	jal	4cc4 <open>
+    close(fd);
+     1e8:	2c5040ef          	jal	4cac <close>
+  for(i = 0; i < N; i++){
+     1ec:	2485                	addiw	s1,s1,1
+     1ee:	0ff4f493          	zext.b	s1,s1
+     1f2:	ff2493e3          	bne	s1,s2,1d8 <createtest+0x20>
+  name[0] = 'a';
+     1f6:	06100793          	li	a5,97
+     1fa:	fcf40c23          	sb	a5,-40(s0)
+  name[2] = '\0';
+     1fe:	fc040d23          	sb	zero,-38(s0)
+     202:	03000493          	li	s1,48
+  for(i = 0; i < N; i++){
+     206:	06400913          	li	s2,100
+    name[1] = '0' + i;
+     20a:	fc940ca3          	sb	s1,-39(s0)
+    unlink(name);
+     20e:	fd840513          	addi	a0,s0,-40
+     212:	2c3040ef          	jal	4cd4 <unlink>
+  for(i = 0; i < N; i++){
+     216:	2485                	addiw	s1,s1,1
+     218:	0ff4f493          	zext.b	s1,s1
+     21c:	ff2497e3          	bne	s1,s2,20a <createtest+0x52>
+}
+     220:	70a2                	ld	ra,40(sp)
+     222:	7402                	ld	s0,32(sp)
+     224:	64e2                	ld	s1,24(sp)
+     226:	6942                	ld	s2,16(sp)
+     228:	6145                	addi	sp,sp,48
+     22a:	8082                	ret
+
+000000000000022c <bigwrite>:
+{
+     22c:	715d                	addi	sp,sp,-80
+     22e:	e486                	sd	ra,72(sp)
+     230:	e0a2                	sd	s0,64(sp)
+     232:	fc26                	sd	s1,56(sp)
+     234:	f84a                	sd	s2,48(sp)
+     236:	f44e                	sd	s3,40(sp)
+     238:	f052                	sd	s4,32(sp)
+     23a:	ec56                	sd	s5,24(sp)
+     23c:	e85a                	sd	s6,16(sp)
+     23e:	e45e                	sd	s7,8(sp)
+     240:	0880                	addi	s0,sp,80
+     242:	8baa                	mv	s7,a0
+  unlink("bigwrite");
+     244:	00005517          	auipc	a0,0x5
+     248:	0f450513          	addi	a0,a0,244 # 5338 <malloc+0x1d0>
+     24c:	289040ef          	jal	4cd4 <unlink>
+  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+     250:	1f300493          	li	s1,499
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+     254:	00005a97          	auipc	s5,0x5
+     258:	0e4a8a93          	addi	s5,s5,228 # 5338 <malloc+0x1d0>
+      int cc = write(fd, buf, sz);
+     25c:	0000da17          	auipc	s4,0xd
+     260:	a4ca0a13          	addi	s4,s4,-1460 # cca8 <buf>
+  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+     264:	6b0d                	lui	s6,0x3
+     266:	1c9b0b13          	addi	s6,s6,457 # 31c9 <rmdot+0x19>
+    fd = open("bigwrite", O_CREATE | O_RDWR);
+     26a:	20200593          	li	a1,514
+     26e:	8556                	mv	a0,s5
+     270:	255040ef          	jal	4cc4 <open>
+     274:	892a                	mv	s2,a0
+    if(fd < 0){
+     276:	04054563          	bltz	a0,2c0 <bigwrite+0x94>
+      int cc = write(fd, buf, sz);
+     27a:	8626                	mv	a2,s1
+     27c:	85d2                	mv	a1,s4
+     27e:	227040ef          	jal	4ca4 <write>
+     282:	89aa                	mv	s3,a0
+      if(cc != sz){
+     284:	04a49863          	bne	s1,a0,2d4 <bigwrite+0xa8>
+      int cc = write(fd, buf, sz);
+     288:	8626                	mv	a2,s1
+     28a:	85d2                	mv	a1,s4
+     28c:	854a                	mv	a0,s2
+     28e:	217040ef          	jal	4ca4 <write>
+      if(cc != sz){
+     292:	04951263          	bne	a0,s1,2d6 <bigwrite+0xaa>
+    close(fd);
+     296:	854a                	mv	a0,s2
+     298:	215040ef          	jal	4cac <close>
+    unlink("bigwrite");
+     29c:	8556                	mv	a0,s5
+     29e:	237040ef          	jal	4cd4 <unlink>
+  for(sz = 499; sz < (MAXOPBLOCKS+2)*BSIZE; sz += 471){
+     2a2:	1d74849b          	addiw	s1,s1,471
+     2a6:	fd6492e3          	bne	s1,s6,26a <bigwrite+0x3e>
+}
+     2aa:	60a6                	ld	ra,72(sp)
+     2ac:	6406                	ld	s0,64(sp)
+     2ae:	74e2                	ld	s1,56(sp)
+     2b0:	7942                	ld	s2,48(sp)
+     2b2:	79a2                	ld	s3,40(sp)
+     2b4:	7a02                	ld	s4,32(sp)
+     2b6:	6ae2                	ld	s5,24(sp)
+     2b8:	6b42                	ld	s6,16(sp)
+     2ba:	6ba2                	ld	s7,8(sp)
+     2bc:	6161                	addi	sp,sp,80
+     2be:	8082                	ret
+      printf("%s: cannot create bigwrite\n", s);
+     2c0:	85de                	mv	a1,s7
+     2c2:	00005517          	auipc	a0,0x5
+     2c6:	08650513          	addi	a0,a0,134 # 5348 <malloc+0x1e0>
+     2ca:	5eb040ef          	jal	50b4 <printf>
+      exit(1);
+     2ce:	4505                	li	a0,1
+     2d0:	1b5040ef          	jal	4c84 <exit>
+      if(cc != sz){
+     2d4:	89a6                	mv	s3,s1
+        printf("%s: write(%d) ret %d\n", s, sz, cc);
+     2d6:	86aa                	mv	a3,a0
+     2d8:	864e                	mv	a2,s3
+     2da:	85de                	mv	a1,s7
+     2dc:	00005517          	auipc	a0,0x5
+     2e0:	08c50513          	addi	a0,a0,140 # 5368 <malloc+0x200>
+     2e4:	5d1040ef          	jal	50b4 <printf>
+        exit(1);
+     2e8:	4505                	li	a0,1
+     2ea:	19b040ef          	jal	4c84 <exit>
+
+00000000000002ee <badwrite>:
+// file is deleted? if the kernel has this bug, it will panic: balloc:
+// out of blocks. assumed_free may need to be raised to be more than
+// the number of free blocks. this test takes a long time.
+void
+badwrite(char *s)
+{
+     2ee:	7179                	addi	sp,sp,-48
+     2f0:	f406                	sd	ra,40(sp)
+     2f2:	f022                	sd	s0,32(sp)
+     2f4:	ec26                	sd	s1,24(sp)
+     2f6:	e84a                	sd	s2,16(sp)
+     2f8:	e44e                	sd	s3,8(sp)
+     2fa:	e052                	sd	s4,0(sp)
+     2fc:	1800                	addi	s0,sp,48
+  int assumed_free = 600;
+  
+  unlink("junk");
+     2fe:	00005517          	auipc	a0,0x5
+     302:	08250513          	addi	a0,a0,130 # 5380 <malloc+0x218>
+     306:	1cf040ef          	jal	4cd4 <unlink>
+     30a:	25800913          	li	s2,600
+  for(int i = 0; i < assumed_free; i++){
+    int fd = open("junk", O_CREATE|O_WRONLY);
+     30e:	00005997          	auipc	s3,0x5
+     312:	07298993          	addi	s3,s3,114 # 5380 <malloc+0x218>
+    if(fd < 0){
+      printf("open junk failed\n");
+      exit(1);
+    }
+    write(fd, (char*)0xffffffffffL, 1);
+     316:	5a7d                	li	s4,-1
+     318:	018a5a13          	srli	s4,s4,0x18
+    int fd = open("junk", O_CREATE|O_WRONLY);
+     31c:	20100593          	li	a1,513
+     320:	854e                	mv	a0,s3
+     322:	1a3040ef          	jal	4cc4 <open>
+     326:	84aa                	mv	s1,a0
+    if(fd < 0){
+     328:	04054d63          	bltz	a0,382 <badwrite+0x94>
+    write(fd, (char*)0xffffffffffL, 1);
+     32c:	4605                	li	a2,1
+     32e:	85d2                	mv	a1,s4
+     330:	175040ef          	jal	4ca4 <write>
+    close(fd);
+     334:	8526                	mv	a0,s1
+     336:	177040ef          	jal	4cac <close>
+    unlink("junk");
+     33a:	854e                	mv	a0,s3
+     33c:	199040ef          	jal	4cd4 <unlink>
+  for(int i = 0; i < assumed_free; i++){
+     340:	397d                	addiw	s2,s2,-1
+     342:	fc091de3          	bnez	s2,31c <badwrite+0x2e>
+  }
+
+  int fd = open("junk", O_CREATE|O_WRONLY);
+     346:	20100593          	li	a1,513
+     34a:	00005517          	auipc	a0,0x5
+     34e:	03650513          	addi	a0,a0,54 # 5380 <malloc+0x218>
+     352:	173040ef          	jal	4cc4 <open>
+     356:	84aa                	mv	s1,a0
+  if(fd < 0){
+     358:	02054e63          	bltz	a0,394 <badwrite+0xa6>
+    printf("open junk failed\n");
+    exit(1);
+  }
+  if(write(fd, "x", 1) != 1){
+     35c:	4605                	li	a2,1
+     35e:	00005597          	auipc	a1,0x5
+     362:	faa58593          	addi	a1,a1,-86 # 5308 <malloc+0x1a0>
+     366:	13f040ef          	jal	4ca4 <write>
+     36a:	4785                	li	a5,1
+     36c:	02f50d63          	beq	a0,a5,3a6 <badwrite+0xb8>
+    printf("write failed\n");
+     370:	00005517          	auipc	a0,0x5
+     374:	03050513          	addi	a0,a0,48 # 53a0 <malloc+0x238>
+     378:	53d040ef          	jal	50b4 <printf>
+    exit(1);
+     37c:	4505                	li	a0,1
+     37e:	107040ef          	jal	4c84 <exit>
+      printf("open junk failed\n");
+     382:	00005517          	auipc	a0,0x5
+     386:	00650513          	addi	a0,a0,6 # 5388 <malloc+0x220>
+     38a:	52b040ef          	jal	50b4 <printf>
+      exit(1);
+     38e:	4505                	li	a0,1
+     390:	0f5040ef          	jal	4c84 <exit>
+    printf("open junk failed\n");
+     394:	00005517          	auipc	a0,0x5
+     398:	ff450513          	addi	a0,a0,-12 # 5388 <malloc+0x220>
+     39c:	519040ef          	jal	50b4 <printf>
+    exit(1);
+     3a0:	4505                	li	a0,1
+     3a2:	0e3040ef          	jal	4c84 <exit>
+  }
+  close(fd);
+     3a6:	8526                	mv	a0,s1
+     3a8:	105040ef          	jal	4cac <close>
+  unlink("junk");
+     3ac:	00005517          	auipc	a0,0x5
+     3b0:	fd450513          	addi	a0,a0,-44 # 5380 <malloc+0x218>
+     3b4:	121040ef          	jal	4cd4 <unlink>
+
+  exit(0);
+     3b8:	4501                	li	a0,0
+     3ba:	0cb040ef          	jal	4c84 <exit>
+
+00000000000003be <outofinodes>:
+  }
+}
+
+void
+outofinodes(char *s)
+{
+     3be:	715d                	addi	sp,sp,-80
+     3c0:	e486                	sd	ra,72(sp)
+     3c2:	e0a2                	sd	s0,64(sp)
+     3c4:	fc26                	sd	s1,56(sp)
+     3c6:	f84a                	sd	s2,48(sp)
+     3c8:	f44e                	sd	s3,40(sp)
+     3ca:	0880                	addi	s0,sp,80
+  int nzz = 32*32;
+  for(int i = 0; i < nzz; i++){
+     3cc:	4481                	li	s1,0
+    char name[32];
+    name[0] = 'z';
+     3ce:	07a00913          	li	s2,122
+  for(int i = 0; i < nzz; i++){
+     3d2:	40000993          	li	s3,1024
+    name[0] = 'z';
+     3d6:	fb240823          	sb	s2,-80(s0)
+    name[1] = 'z';
+     3da:	fb2408a3          	sb	s2,-79(s0)
+    name[2] = '0' + (i / 32);
+     3de:	41f4d71b          	sraiw	a4,s1,0x1f
+     3e2:	01b7571b          	srliw	a4,a4,0x1b
+     3e6:	009707bb          	addw	a5,a4,s1
+     3ea:	4057d69b          	sraiw	a3,a5,0x5
+     3ee:	0306869b          	addiw	a3,a3,48
+     3f2:	fad40923          	sb	a3,-78(s0)
+    name[3] = '0' + (i % 32);
+     3f6:	8bfd                	andi	a5,a5,31
+     3f8:	9f99                	subw	a5,a5,a4
+     3fa:	0307879b          	addiw	a5,a5,48
+     3fe:	faf409a3          	sb	a5,-77(s0)
+    name[4] = '\0';
+     402:	fa040a23          	sb	zero,-76(s0)
+    unlink(name);
+     406:	fb040513          	addi	a0,s0,-80
+     40a:	0cb040ef          	jal	4cd4 <unlink>
+    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+     40e:	60200593          	li	a1,1538
+     412:	fb040513          	addi	a0,s0,-80
+     416:	0af040ef          	jal	4cc4 <open>
+    if(fd < 0){
+     41a:	00054763          	bltz	a0,428 <outofinodes+0x6a>
+      // failure is eventually expected.
+      break;
+    }
+    close(fd);
+     41e:	08f040ef          	jal	4cac <close>
+  for(int i = 0; i < nzz; i++){
+     422:	2485                	addiw	s1,s1,1
+     424:	fb3499e3          	bne	s1,s3,3d6 <outofinodes+0x18>
+     428:	4481                	li	s1,0
+  }
+
+  for(int i = 0; i < nzz; i++){
+    char name[32];
+    name[0] = 'z';
+     42a:	07a00913          	li	s2,122
+  for(int i = 0; i < nzz; i++){
+     42e:	40000993          	li	s3,1024
+    name[0] = 'z';
+     432:	fb240823          	sb	s2,-80(s0)
+    name[1] = 'z';
+     436:	fb2408a3          	sb	s2,-79(s0)
+    name[2] = '0' + (i / 32);
+     43a:	41f4d71b          	sraiw	a4,s1,0x1f
+     43e:	01b7571b          	srliw	a4,a4,0x1b
+     442:	009707bb          	addw	a5,a4,s1
+     446:	4057d69b          	sraiw	a3,a5,0x5
+     44a:	0306869b          	addiw	a3,a3,48
+     44e:	fad40923          	sb	a3,-78(s0)
+    name[3] = '0' + (i % 32);
+     452:	8bfd                	andi	a5,a5,31
+     454:	9f99                	subw	a5,a5,a4
+     456:	0307879b          	addiw	a5,a5,48
+     45a:	faf409a3          	sb	a5,-77(s0)
+    name[4] = '\0';
+     45e:	fa040a23          	sb	zero,-76(s0)
+    unlink(name);
+     462:	fb040513          	addi	a0,s0,-80
+     466:	06f040ef          	jal	4cd4 <unlink>
+  for(int i = 0; i < nzz; i++){
+     46a:	2485                	addiw	s1,s1,1
+     46c:	fd3493e3          	bne	s1,s3,432 <outofinodes+0x74>
+  }
+}
+     470:	60a6                	ld	ra,72(sp)
+     472:	6406                	ld	s0,64(sp)
+     474:	74e2                	ld	s1,56(sp)
+     476:	7942                	ld	s2,48(sp)
+     478:	79a2                	ld	s3,40(sp)
+     47a:	6161                	addi	sp,sp,80
+     47c:	8082                	ret
+
+000000000000047e <copyin>:
+{
+     47e:	7159                	addi	sp,sp,-112
+     480:	f486                	sd	ra,104(sp)
+     482:	f0a2                	sd	s0,96(sp)
+     484:	eca6                	sd	s1,88(sp)
+     486:	e8ca                	sd	s2,80(sp)
+     488:	e4ce                	sd	s3,72(sp)
+     48a:	e0d2                	sd	s4,64(sp)
+     48c:	fc56                	sd	s5,56(sp)
+     48e:	1880                	addi	s0,sp,112
+  uint64 addrs[] = { 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+     490:	00007797          	auipc	a5,0x7
+     494:	25878793          	addi	a5,a5,600 # 76e8 <malloc+0x2580>
+     498:	638c                	ld	a1,0(a5)
+     49a:	6790                	ld	a2,8(a5)
+     49c:	6b94                	ld	a3,16(a5)
+     49e:	6f98                	ld	a4,24(a5)
+     4a0:	739c                	ld	a5,32(a5)
+     4a2:	f8b43c23          	sd	a1,-104(s0)
+     4a6:	fac43023          	sd	a2,-96(s0)
+     4aa:	fad43423          	sd	a3,-88(s0)
+     4ae:	fae43823          	sd	a4,-80(s0)
+     4b2:	faf43c23          	sd	a5,-72(s0)
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+     4b6:	f9840913          	addi	s2,s0,-104
+     4ba:	fc040a93          	addi	s5,s0,-64
+    int fd = open("copyin1", O_CREATE|O_WRONLY);
+     4be:	00005a17          	auipc	s4,0x5
+     4c2:	ef2a0a13          	addi	s4,s4,-270 # 53b0 <malloc+0x248>
+    uint64 addr = addrs[ai];
+     4c6:	00093983          	ld	s3,0(s2)
+    int fd = open("copyin1", O_CREATE|O_WRONLY);
+     4ca:	20100593          	li	a1,513
+     4ce:	8552                	mv	a0,s4
+     4d0:	7f4040ef          	jal	4cc4 <open>
+     4d4:	84aa                	mv	s1,a0
+    if(fd < 0){
+     4d6:	06054763          	bltz	a0,544 <copyin+0xc6>
+    int n = write(fd, (void*)addr, 8192);
+     4da:	6609                	lui	a2,0x2
+     4dc:	85ce                	mv	a1,s3
+     4de:	7c6040ef          	jal	4ca4 <write>
+    if(n >= 0){
+     4e2:	06055a63          	bgez	a0,556 <copyin+0xd8>
+    close(fd);
+     4e6:	8526                	mv	a0,s1
+     4e8:	7c4040ef          	jal	4cac <close>
+    unlink("copyin1");
+     4ec:	8552                	mv	a0,s4
+     4ee:	7e6040ef          	jal	4cd4 <unlink>
+    n = write(1, (char*)addr, 8192);
+     4f2:	6609                	lui	a2,0x2
+     4f4:	85ce                	mv	a1,s3
+     4f6:	4505                	li	a0,1
+     4f8:	7ac040ef          	jal	4ca4 <write>
+    if(n > 0){
+     4fc:	06a04863          	bgtz	a0,56c <copyin+0xee>
+    if(pipe(fds) < 0){
+     500:	f9040513          	addi	a0,s0,-112
+     504:	790040ef          	jal	4c94 <pipe>
+     508:	06054d63          	bltz	a0,582 <copyin+0x104>
+    n = write(fds[1], (char*)addr, 8192);
+     50c:	6609                	lui	a2,0x2
+     50e:	85ce                	mv	a1,s3
+     510:	f9442503          	lw	a0,-108(s0)
+     514:	790040ef          	jal	4ca4 <write>
+    if(n > 0){
+     518:	06a04e63          	bgtz	a0,594 <copyin+0x116>
+    close(fds[0]);
+     51c:	f9042503          	lw	a0,-112(s0)
+     520:	78c040ef          	jal	4cac <close>
+    close(fds[1]);
+     524:	f9442503          	lw	a0,-108(s0)
+     528:	784040ef          	jal	4cac <close>
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+     52c:	0921                	addi	s2,s2,8
+     52e:	f9591ce3          	bne	s2,s5,4c6 <copyin+0x48>
+}
+     532:	70a6                	ld	ra,104(sp)
+     534:	7406                	ld	s0,96(sp)
+     536:	64e6                	ld	s1,88(sp)
+     538:	6946                	ld	s2,80(sp)
+     53a:	69a6                	ld	s3,72(sp)
+     53c:	6a06                	ld	s4,64(sp)
+     53e:	7ae2                	ld	s5,56(sp)
+     540:	6165                	addi	sp,sp,112
+     542:	8082                	ret
+      printf("open(copyin1) failed\n");
+     544:	00005517          	auipc	a0,0x5
+     548:	e7450513          	addi	a0,a0,-396 # 53b8 <malloc+0x250>
+     54c:	369040ef          	jal	50b4 <printf>
+      exit(1);
+     550:	4505                	li	a0,1
+     552:	732040ef          	jal	4c84 <exit>
+      printf("write(fd, %p, 8192) returned %d, not -1\n", (void*)addr, n);
+     556:	862a                	mv	a2,a0
+     558:	85ce                	mv	a1,s3
+     55a:	00005517          	auipc	a0,0x5
+     55e:	e7650513          	addi	a0,a0,-394 # 53d0 <malloc+0x268>
+     562:	353040ef          	jal	50b4 <printf>
+      exit(1);
+     566:	4505                	li	a0,1
+     568:	71c040ef          	jal	4c84 <exit>
+      printf("write(1, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+     56c:	862a                	mv	a2,a0
+     56e:	85ce                	mv	a1,s3
+     570:	00005517          	auipc	a0,0x5
+     574:	e9050513          	addi	a0,a0,-368 # 5400 <malloc+0x298>
+     578:	33d040ef          	jal	50b4 <printf>
+      exit(1);
+     57c:	4505                	li	a0,1
+     57e:	706040ef          	jal	4c84 <exit>
+      printf("pipe() failed\n");
+     582:	00005517          	auipc	a0,0x5
+     586:	eae50513          	addi	a0,a0,-338 # 5430 <malloc+0x2c8>
+     58a:	32b040ef          	jal	50b4 <printf>
+      exit(1);
+     58e:	4505                	li	a0,1
+     590:	6f4040ef          	jal	4c84 <exit>
+      printf("write(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+     594:	862a                	mv	a2,a0
+     596:	85ce                	mv	a1,s3
+     598:	00005517          	auipc	a0,0x5
+     59c:	ea850513          	addi	a0,a0,-344 # 5440 <malloc+0x2d8>
+     5a0:	315040ef          	jal	50b4 <printf>
+      exit(1);
+     5a4:	4505                	li	a0,1
+     5a6:	6de040ef          	jal	4c84 <exit>
+
+00000000000005aa <copyout>:
+{
+     5aa:	7119                	addi	sp,sp,-128
+     5ac:	fc86                	sd	ra,120(sp)
+     5ae:	f8a2                	sd	s0,112(sp)
+     5b0:	f4a6                	sd	s1,104(sp)
+     5b2:	f0ca                	sd	s2,96(sp)
+     5b4:	ecce                	sd	s3,88(sp)
+     5b6:	e8d2                	sd	s4,80(sp)
+     5b8:	e4d6                	sd	s5,72(sp)
+     5ba:	e0da                	sd	s6,64(sp)
+     5bc:	0100                	addi	s0,sp,128
+  uint64 addrs[] = { 0LL, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+     5be:	00007797          	auipc	a5,0x7
+     5c2:	12a78793          	addi	a5,a5,298 # 76e8 <malloc+0x2580>
+     5c6:	7788                	ld	a0,40(a5)
+     5c8:	7b8c                	ld	a1,48(a5)
+     5ca:	7f90                	ld	a2,56(a5)
+     5cc:	63b4                	ld	a3,64(a5)
+     5ce:	67b8                	ld	a4,72(a5)
+     5d0:	6bbc                	ld	a5,80(a5)
+     5d2:	f8a43823          	sd	a0,-112(s0)
+     5d6:	f8b43c23          	sd	a1,-104(s0)
+     5da:	fac43023          	sd	a2,-96(s0)
+     5de:	fad43423          	sd	a3,-88(s0)
+     5e2:	fae43823          	sd	a4,-80(s0)
+     5e6:	faf43c23          	sd	a5,-72(s0)
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+     5ea:	f9040913          	addi	s2,s0,-112
+     5ee:	fc040b13          	addi	s6,s0,-64
+    int fd = open("README", 0);
+     5f2:	00005a17          	auipc	s4,0x5
+     5f6:	e7ea0a13          	addi	s4,s4,-386 # 5470 <malloc+0x308>
+    n = write(fds[1], "x", 1);
+     5fa:	00005a97          	auipc	s5,0x5
+     5fe:	d0ea8a93          	addi	s5,s5,-754 # 5308 <malloc+0x1a0>
+    uint64 addr = addrs[ai];
+     602:	00093983          	ld	s3,0(s2)
+    int fd = open("README", 0);
+     606:	4581                	li	a1,0
+     608:	8552                	mv	a0,s4
+     60a:	6ba040ef          	jal	4cc4 <open>
+     60e:	84aa                	mv	s1,a0
+    if(fd < 0){
+     610:	06054763          	bltz	a0,67e <copyout+0xd4>
+    int n = read(fd, (void*)addr, 8192);
+     614:	6609                	lui	a2,0x2
+     616:	85ce                	mv	a1,s3
+     618:	684040ef          	jal	4c9c <read>
+    if(n > 0){
+     61c:	06a04a63          	bgtz	a0,690 <copyout+0xe6>
+    close(fd);
+     620:	8526                	mv	a0,s1
+     622:	68a040ef          	jal	4cac <close>
+    if(pipe(fds) < 0){
+     626:	f8840513          	addi	a0,s0,-120
+     62a:	66a040ef          	jal	4c94 <pipe>
+     62e:	06054c63          	bltz	a0,6a6 <copyout+0xfc>
+    n = write(fds[1], "x", 1);
+     632:	4605                	li	a2,1
+     634:	85d6                	mv	a1,s5
+     636:	f8c42503          	lw	a0,-116(s0)
+     63a:	66a040ef          	jal	4ca4 <write>
+    if(n != 1){
+     63e:	4785                	li	a5,1
+     640:	06f51c63          	bne	a0,a5,6b8 <copyout+0x10e>
+    n = read(fds[0], (void*)addr, 8192);
+     644:	6609                	lui	a2,0x2
+     646:	85ce                	mv	a1,s3
+     648:	f8842503          	lw	a0,-120(s0)
+     64c:	650040ef          	jal	4c9c <read>
+    if(n > 0){
+     650:	06a04d63          	bgtz	a0,6ca <copyout+0x120>
+    close(fds[0]);
+     654:	f8842503          	lw	a0,-120(s0)
+     658:	654040ef          	jal	4cac <close>
+    close(fds[1]);
+     65c:	f8c42503          	lw	a0,-116(s0)
+     660:	64c040ef          	jal	4cac <close>
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+     664:	0921                	addi	s2,s2,8
+     666:	f9691ee3          	bne	s2,s6,602 <copyout+0x58>
+}
+     66a:	70e6                	ld	ra,120(sp)
+     66c:	7446                	ld	s0,112(sp)
+     66e:	74a6                	ld	s1,104(sp)
+     670:	7906                	ld	s2,96(sp)
+     672:	69e6                	ld	s3,88(sp)
+     674:	6a46                	ld	s4,80(sp)
+     676:	6aa6                	ld	s5,72(sp)
+     678:	6b06                	ld	s6,64(sp)
+     67a:	6109                	addi	sp,sp,128
+     67c:	8082                	ret
+      printf("open(README) failed\n");
+     67e:	00005517          	auipc	a0,0x5
+     682:	dfa50513          	addi	a0,a0,-518 # 5478 <malloc+0x310>
+     686:	22f040ef          	jal	50b4 <printf>
+      exit(1);
+     68a:	4505                	li	a0,1
+     68c:	5f8040ef          	jal	4c84 <exit>
+      printf("read(fd, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+     690:	862a                	mv	a2,a0
+     692:	85ce                	mv	a1,s3
+     694:	00005517          	auipc	a0,0x5
+     698:	dfc50513          	addi	a0,a0,-516 # 5490 <malloc+0x328>
+     69c:	219040ef          	jal	50b4 <printf>
+      exit(1);
+     6a0:	4505                	li	a0,1
+     6a2:	5e2040ef          	jal	4c84 <exit>
+      printf("pipe() failed\n");
+     6a6:	00005517          	auipc	a0,0x5
+     6aa:	d8a50513          	addi	a0,a0,-630 # 5430 <malloc+0x2c8>
+     6ae:	207040ef          	jal	50b4 <printf>
+      exit(1);
+     6b2:	4505                	li	a0,1
+     6b4:	5d0040ef          	jal	4c84 <exit>
+      printf("pipe write failed\n");
+     6b8:	00005517          	auipc	a0,0x5
+     6bc:	e0850513          	addi	a0,a0,-504 # 54c0 <malloc+0x358>
+     6c0:	1f5040ef          	jal	50b4 <printf>
+      exit(1);
+     6c4:	4505                	li	a0,1
+     6c6:	5be040ef          	jal	4c84 <exit>
+      printf("read(pipe, %p, 8192) returned %d, not -1 or 0\n", (void*)addr, n);
+     6ca:	862a                	mv	a2,a0
+     6cc:	85ce                	mv	a1,s3
+     6ce:	00005517          	auipc	a0,0x5
+     6d2:	e0a50513          	addi	a0,a0,-502 # 54d8 <malloc+0x370>
+     6d6:	1df040ef          	jal	50b4 <printf>
+      exit(1);
+     6da:	4505                	li	a0,1
+     6dc:	5a8040ef          	jal	4c84 <exit>
+
+00000000000006e0 <truncate1>:
+{
+     6e0:	711d                	addi	sp,sp,-96
+     6e2:	ec86                	sd	ra,88(sp)
+     6e4:	e8a2                	sd	s0,80(sp)
+     6e6:	e4a6                	sd	s1,72(sp)
+     6e8:	e0ca                	sd	s2,64(sp)
+     6ea:	fc4e                	sd	s3,56(sp)
+     6ec:	f852                	sd	s4,48(sp)
+     6ee:	f456                	sd	s5,40(sp)
+     6f0:	1080                	addi	s0,sp,96
+     6f2:	8aaa                	mv	s5,a0
+  unlink("truncfile");
+     6f4:	00005517          	auipc	a0,0x5
+     6f8:	bfc50513          	addi	a0,a0,-1028 # 52f0 <malloc+0x188>
+     6fc:	5d8040ef          	jal	4cd4 <unlink>
+  int fd1 = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+     700:	60100593          	li	a1,1537
+     704:	00005517          	auipc	a0,0x5
+     708:	bec50513          	addi	a0,a0,-1044 # 52f0 <malloc+0x188>
+     70c:	5b8040ef          	jal	4cc4 <open>
+     710:	84aa                	mv	s1,a0
+  write(fd1, "abcd", 4);
+     712:	4611                	li	a2,4
+     714:	00005597          	auipc	a1,0x5
+     718:	bec58593          	addi	a1,a1,-1044 # 5300 <malloc+0x198>
+     71c:	588040ef          	jal	4ca4 <write>
+  close(fd1);
+     720:	8526                	mv	a0,s1
+     722:	58a040ef          	jal	4cac <close>
+  int fd2 = open("truncfile", O_RDONLY);
+     726:	4581                	li	a1,0
+     728:	00005517          	auipc	a0,0x5
+     72c:	bc850513          	addi	a0,a0,-1080 # 52f0 <malloc+0x188>
+     730:	594040ef          	jal	4cc4 <open>
+     734:	84aa                	mv	s1,a0
+  int n = read(fd2, buf, sizeof(buf));
+     736:	02000613          	li	a2,32
+     73a:	fa040593          	addi	a1,s0,-96
+     73e:	55e040ef          	jal	4c9c <read>
+  if(n != 4){
+     742:	4791                	li	a5,4
+     744:	0af51863          	bne	a0,a5,7f4 <truncate1+0x114>
+  fd1 = open("truncfile", O_WRONLY|O_TRUNC);
+     748:	40100593          	li	a1,1025
+     74c:	00005517          	auipc	a0,0x5
+     750:	ba450513          	addi	a0,a0,-1116 # 52f0 <malloc+0x188>
+     754:	570040ef          	jal	4cc4 <open>
+     758:	89aa                	mv	s3,a0
+  int fd3 = open("truncfile", O_RDONLY);
+     75a:	4581                	li	a1,0
+     75c:	00005517          	auipc	a0,0x5
+     760:	b9450513          	addi	a0,a0,-1132 # 52f0 <malloc+0x188>
+     764:	560040ef          	jal	4cc4 <open>
+     768:	892a                	mv	s2,a0
+  n = read(fd3, buf, sizeof(buf));
+     76a:	02000613          	li	a2,32
+     76e:	fa040593          	addi	a1,s0,-96
+     772:	52a040ef          	jal	4c9c <read>
+     776:	8a2a                	mv	s4,a0
+  if(n != 0){
+     778:	e949                	bnez	a0,80a <truncate1+0x12a>
+  n = read(fd2, buf, sizeof(buf));
+     77a:	02000613          	li	a2,32
+     77e:	fa040593          	addi	a1,s0,-96
+     782:	8526                	mv	a0,s1
+     784:	518040ef          	jal	4c9c <read>
+     788:	8a2a                	mv	s4,a0
+  if(n != 0){
+     78a:	e155                	bnez	a0,82e <truncate1+0x14e>
+  write(fd1, "abcdef", 6);
+     78c:	4619                	li	a2,6
+     78e:	00005597          	auipc	a1,0x5
+     792:	dda58593          	addi	a1,a1,-550 # 5568 <malloc+0x400>
+     796:	854e                	mv	a0,s3
+     798:	50c040ef          	jal	4ca4 <write>
+  n = read(fd3, buf, sizeof(buf));
+     79c:	02000613          	li	a2,32
+     7a0:	fa040593          	addi	a1,s0,-96
+     7a4:	854a                	mv	a0,s2
+     7a6:	4f6040ef          	jal	4c9c <read>
+  if(n != 6){
+     7aa:	4799                	li	a5,6
+     7ac:	0af51363          	bne	a0,a5,852 <truncate1+0x172>
+  n = read(fd2, buf, sizeof(buf));
+     7b0:	02000613          	li	a2,32
+     7b4:	fa040593          	addi	a1,s0,-96
+     7b8:	8526                	mv	a0,s1
+     7ba:	4e2040ef          	jal	4c9c <read>
+  if(n != 2){
+     7be:	4789                	li	a5,2
+     7c0:	0af51463          	bne	a0,a5,868 <truncate1+0x188>
+  unlink("truncfile");
+     7c4:	00005517          	auipc	a0,0x5
+     7c8:	b2c50513          	addi	a0,a0,-1236 # 52f0 <malloc+0x188>
+     7cc:	508040ef          	jal	4cd4 <unlink>
+  close(fd1);
+     7d0:	854e                	mv	a0,s3
+     7d2:	4da040ef          	jal	4cac <close>
+  close(fd2);
+     7d6:	8526                	mv	a0,s1
+     7d8:	4d4040ef          	jal	4cac <close>
+  close(fd3);
+     7dc:	854a                	mv	a0,s2
+     7de:	4ce040ef          	jal	4cac <close>
+}
+     7e2:	60e6                	ld	ra,88(sp)
+     7e4:	6446                	ld	s0,80(sp)
+     7e6:	64a6                	ld	s1,72(sp)
+     7e8:	6906                	ld	s2,64(sp)
+     7ea:	79e2                	ld	s3,56(sp)
+     7ec:	7a42                	ld	s4,48(sp)
+     7ee:	7aa2                	ld	s5,40(sp)
+     7f0:	6125                	addi	sp,sp,96
+     7f2:	8082                	ret
+    printf("%s: read %d bytes, wanted 4\n", s, n);
+     7f4:	862a                	mv	a2,a0
+     7f6:	85d6                	mv	a1,s5
+     7f8:	00005517          	auipc	a0,0x5
+     7fc:	d1050513          	addi	a0,a0,-752 # 5508 <malloc+0x3a0>
+     800:	0b5040ef          	jal	50b4 <printf>
+    exit(1);
+     804:	4505                	li	a0,1
+     806:	47e040ef          	jal	4c84 <exit>
+    printf("aaa fd3=%d\n", fd3);
+     80a:	85ca                	mv	a1,s2
+     80c:	00005517          	auipc	a0,0x5
+     810:	d1c50513          	addi	a0,a0,-740 # 5528 <malloc+0x3c0>
+     814:	0a1040ef          	jal	50b4 <printf>
+    printf("%s: read %d bytes, wanted 0\n", s, n);
+     818:	8652                	mv	a2,s4
+     81a:	85d6                	mv	a1,s5
+     81c:	00005517          	auipc	a0,0x5
+     820:	d1c50513          	addi	a0,a0,-740 # 5538 <malloc+0x3d0>
+     824:	091040ef          	jal	50b4 <printf>
+    exit(1);
+     828:	4505                	li	a0,1
+     82a:	45a040ef          	jal	4c84 <exit>
+    printf("bbb fd2=%d\n", fd2);
+     82e:	85a6                	mv	a1,s1
+     830:	00005517          	auipc	a0,0x5
+     834:	d2850513          	addi	a0,a0,-728 # 5558 <malloc+0x3f0>
+     838:	07d040ef          	jal	50b4 <printf>
+    printf("%s: read %d bytes, wanted 0\n", s, n);
+     83c:	8652                	mv	a2,s4
+     83e:	85d6                	mv	a1,s5
+     840:	00005517          	auipc	a0,0x5
+     844:	cf850513          	addi	a0,a0,-776 # 5538 <malloc+0x3d0>
+     848:	06d040ef          	jal	50b4 <printf>
+    exit(1);
+     84c:	4505                	li	a0,1
+     84e:	436040ef          	jal	4c84 <exit>
+    printf("%s: read %d bytes, wanted 6\n", s, n);
+     852:	862a                	mv	a2,a0
+     854:	85d6                	mv	a1,s5
+     856:	00005517          	auipc	a0,0x5
+     85a:	d1a50513          	addi	a0,a0,-742 # 5570 <malloc+0x408>
+     85e:	057040ef          	jal	50b4 <printf>
+    exit(1);
+     862:	4505                	li	a0,1
+     864:	420040ef          	jal	4c84 <exit>
+    printf("%s: read %d bytes, wanted 2\n", s, n);
+     868:	862a                	mv	a2,a0
+     86a:	85d6                	mv	a1,s5
+     86c:	00005517          	auipc	a0,0x5
+     870:	d2450513          	addi	a0,a0,-732 # 5590 <malloc+0x428>
+     874:	041040ef          	jal	50b4 <printf>
+    exit(1);
+     878:	4505                	li	a0,1
+     87a:	40a040ef          	jal	4c84 <exit>
+
+000000000000087e <writetest>:
+{
+     87e:	7139                	addi	sp,sp,-64
+     880:	fc06                	sd	ra,56(sp)
+     882:	f822                	sd	s0,48(sp)
+     884:	f426                	sd	s1,40(sp)
+     886:	f04a                	sd	s2,32(sp)
+     888:	ec4e                	sd	s3,24(sp)
+     88a:	e852                	sd	s4,16(sp)
+     88c:	e456                	sd	s5,8(sp)
+     88e:	e05a                	sd	s6,0(sp)
+     890:	0080                	addi	s0,sp,64
+     892:	8b2a                	mv	s6,a0
+  fd = open("small", O_CREATE|O_RDWR);
+     894:	20200593          	li	a1,514
+     898:	00005517          	auipc	a0,0x5
+     89c:	d1850513          	addi	a0,a0,-744 # 55b0 <malloc+0x448>
+     8a0:	424040ef          	jal	4cc4 <open>
+  if(fd < 0){
+     8a4:	08054f63          	bltz	a0,942 <writetest+0xc4>
+     8a8:	892a                	mv	s2,a0
+     8aa:	4481                	li	s1,0
+    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
+     8ac:	00005997          	auipc	s3,0x5
+     8b0:	d2c98993          	addi	s3,s3,-724 # 55d8 <malloc+0x470>
+    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
+     8b4:	00005a97          	auipc	s5,0x5
+     8b8:	d5ca8a93          	addi	s5,s5,-676 # 5610 <malloc+0x4a8>
+  for(i = 0; i < N; i++){
+     8bc:	06400a13          	li	s4,100
+    if(write(fd, "aaaaaaaaaa", SZ) != SZ){
+     8c0:	4629                	li	a2,10
+     8c2:	85ce                	mv	a1,s3
+     8c4:	854a                	mv	a0,s2
+     8c6:	3de040ef          	jal	4ca4 <write>
+     8ca:	47a9                	li	a5,10
+     8cc:	08f51563          	bne	a0,a5,956 <writetest+0xd8>
+    if(write(fd, "bbbbbbbbbb", SZ) != SZ){
+     8d0:	4629                	li	a2,10
+     8d2:	85d6                	mv	a1,s5
+     8d4:	854a                	mv	a0,s2
+     8d6:	3ce040ef          	jal	4ca4 <write>
+     8da:	47a9                	li	a5,10
+     8dc:	08f51863          	bne	a0,a5,96c <writetest+0xee>
+  for(i = 0; i < N; i++){
+     8e0:	2485                	addiw	s1,s1,1
+     8e2:	fd449fe3          	bne	s1,s4,8c0 <writetest+0x42>
+  close(fd);
+     8e6:	854a                	mv	a0,s2
+     8e8:	3c4040ef          	jal	4cac <close>
+  fd = open("small", O_RDONLY);
+     8ec:	4581                	li	a1,0
+     8ee:	00005517          	auipc	a0,0x5
+     8f2:	cc250513          	addi	a0,a0,-830 # 55b0 <malloc+0x448>
+     8f6:	3ce040ef          	jal	4cc4 <open>
+     8fa:	84aa                	mv	s1,a0
+  if(fd < 0){
+     8fc:	08054363          	bltz	a0,982 <writetest+0x104>
+  i = read(fd, buf, N*SZ*2);
+     900:	7d000613          	li	a2,2000
+     904:	0000c597          	auipc	a1,0xc
+     908:	3a458593          	addi	a1,a1,932 # cca8 <buf>
+     90c:	390040ef          	jal	4c9c <read>
+  if(i != N*SZ*2){
+     910:	7d000793          	li	a5,2000
+     914:	08f51163          	bne	a0,a5,996 <writetest+0x118>
+  close(fd);
+     918:	8526                	mv	a0,s1
+     91a:	392040ef          	jal	4cac <close>
+  if(unlink("small") < 0){
+     91e:	00005517          	auipc	a0,0x5
+     922:	c9250513          	addi	a0,a0,-878 # 55b0 <malloc+0x448>
+     926:	3ae040ef          	jal	4cd4 <unlink>
+     92a:	08054063          	bltz	a0,9aa <writetest+0x12c>
+}
+     92e:	70e2                	ld	ra,56(sp)
+     930:	7442                	ld	s0,48(sp)
+     932:	74a2                	ld	s1,40(sp)
+     934:	7902                	ld	s2,32(sp)
+     936:	69e2                	ld	s3,24(sp)
+     938:	6a42                	ld	s4,16(sp)
+     93a:	6aa2                	ld	s5,8(sp)
+     93c:	6b02                	ld	s6,0(sp)
+     93e:	6121                	addi	sp,sp,64
+     940:	8082                	ret
+    printf("%s: error: creat small failed!\n", s);
+     942:	85da                	mv	a1,s6
+     944:	00005517          	auipc	a0,0x5
+     948:	c7450513          	addi	a0,a0,-908 # 55b8 <malloc+0x450>
+     94c:	768040ef          	jal	50b4 <printf>
+    exit(1);
+     950:	4505                	li	a0,1
+     952:	332040ef          	jal	4c84 <exit>
+      printf("%s: error: write aa %d new file failed\n", s, i);
+     956:	8626                	mv	a2,s1
+     958:	85da                	mv	a1,s6
+     95a:	00005517          	auipc	a0,0x5
+     95e:	c8e50513          	addi	a0,a0,-882 # 55e8 <malloc+0x480>
+     962:	752040ef          	jal	50b4 <printf>
+      exit(1);
+     966:	4505                	li	a0,1
+     968:	31c040ef          	jal	4c84 <exit>
+      printf("%s: error: write bb %d new file failed\n", s, i);
+     96c:	8626                	mv	a2,s1
+     96e:	85da                	mv	a1,s6
+     970:	00005517          	auipc	a0,0x5
+     974:	cb050513          	addi	a0,a0,-848 # 5620 <malloc+0x4b8>
+     978:	73c040ef          	jal	50b4 <printf>
+      exit(1);
+     97c:	4505                	li	a0,1
+     97e:	306040ef          	jal	4c84 <exit>
+    printf("%s: error: open small failed!\n", s);
+     982:	85da                	mv	a1,s6
+     984:	00005517          	auipc	a0,0x5
+     988:	cc450513          	addi	a0,a0,-828 # 5648 <malloc+0x4e0>
+     98c:	728040ef          	jal	50b4 <printf>
+    exit(1);
+     990:	4505                	li	a0,1
+     992:	2f2040ef          	jal	4c84 <exit>
+    printf("%s: read failed\n", s);
+     996:	85da                	mv	a1,s6
+     998:	00005517          	auipc	a0,0x5
+     99c:	cd050513          	addi	a0,a0,-816 # 5668 <malloc+0x500>
+     9a0:	714040ef          	jal	50b4 <printf>
+    exit(1);
+     9a4:	4505                	li	a0,1
+     9a6:	2de040ef          	jal	4c84 <exit>
+    printf("%s: unlink small failed\n", s);
+     9aa:	85da                	mv	a1,s6
+     9ac:	00005517          	auipc	a0,0x5
+     9b0:	cd450513          	addi	a0,a0,-812 # 5680 <malloc+0x518>
+     9b4:	700040ef          	jal	50b4 <printf>
+    exit(1);
+     9b8:	4505                	li	a0,1
+     9ba:	2ca040ef          	jal	4c84 <exit>
+
+00000000000009be <writebig>:
+{
+     9be:	7139                	addi	sp,sp,-64
+     9c0:	fc06                	sd	ra,56(sp)
+     9c2:	f822                	sd	s0,48(sp)
+     9c4:	f426                	sd	s1,40(sp)
+     9c6:	f04a                	sd	s2,32(sp)
+     9c8:	ec4e                	sd	s3,24(sp)
+     9ca:	e852                	sd	s4,16(sp)
+     9cc:	e456                	sd	s5,8(sp)
+     9ce:	0080                	addi	s0,sp,64
+     9d0:	8aaa                	mv	s5,a0
+  fd = open("big", O_CREATE|O_RDWR);
+     9d2:	20200593          	li	a1,514
+     9d6:	00005517          	auipc	a0,0x5
+     9da:	cca50513          	addi	a0,a0,-822 # 56a0 <malloc+0x538>
+     9de:	2e6040ef          	jal	4cc4 <open>
+     9e2:	89aa                	mv	s3,a0
+  for(i = 0; i < MAXFILE; i++){
+     9e4:	4481                	li	s1,0
+    ((int*)buf)[0] = i;
+     9e6:	0000c917          	auipc	s2,0xc
+     9ea:	2c290913          	addi	s2,s2,706 # cca8 <buf>
+  for(i = 0; i < MAXFILE; i++){
+     9ee:	10c00a13          	li	s4,268
+  if(fd < 0){
+     9f2:	06054463          	bltz	a0,a5a <writebig+0x9c>
+    ((int*)buf)[0] = i;
+     9f6:	00992023          	sw	s1,0(s2)
+    if(write(fd, buf, BSIZE) != BSIZE){
+     9fa:	40000613          	li	a2,1024
+     9fe:	85ca                	mv	a1,s2
+     a00:	854e                	mv	a0,s3
+     a02:	2a2040ef          	jal	4ca4 <write>
+     a06:	40000793          	li	a5,1024
+     a0a:	06f51263          	bne	a0,a5,a6e <writebig+0xb0>
+  for(i = 0; i < MAXFILE; i++){
+     a0e:	2485                	addiw	s1,s1,1
+     a10:	ff4493e3          	bne	s1,s4,9f6 <writebig+0x38>
+  close(fd);
+     a14:	854e                	mv	a0,s3
+     a16:	296040ef          	jal	4cac <close>
+  fd = open("big", O_RDONLY);
+     a1a:	4581                	li	a1,0
+     a1c:	00005517          	auipc	a0,0x5
+     a20:	c8450513          	addi	a0,a0,-892 # 56a0 <malloc+0x538>
+     a24:	2a0040ef          	jal	4cc4 <open>
+     a28:	89aa                	mv	s3,a0
+  n = 0;
+     a2a:	4481                	li	s1,0
+    i = read(fd, buf, BSIZE);
+     a2c:	0000c917          	auipc	s2,0xc
+     a30:	27c90913          	addi	s2,s2,636 # cca8 <buf>
+  if(fd < 0){
+     a34:	04054863          	bltz	a0,a84 <writebig+0xc6>
+    i = read(fd, buf, BSIZE);
+     a38:	40000613          	li	a2,1024
+     a3c:	85ca                	mv	a1,s2
+     a3e:	854e                	mv	a0,s3
+     a40:	25c040ef          	jal	4c9c <read>
+    if(i == 0){
+     a44:	c931                	beqz	a0,a98 <writebig+0xda>
+    } else if(i != BSIZE){
+     a46:	40000793          	li	a5,1024
+     a4a:	08f51a63          	bne	a0,a5,ade <writebig+0x120>
+    if(((int*)buf)[0] != n){
+     a4e:	00092683          	lw	a3,0(s2)
+     a52:	0a969163          	bne	a3,s1,af4 <writebig+0x136>
+    n++;
+     a56:	2485                	addiw	s1,s1,1
+    i = read(fd, buf, BSIZE);
+     a58:	b7c5                	j	a38 <writebig+0x7a>
+    printf("%s: error: creat big failed!\n", s);
+     a5a:	85d6                	mv	a1,s5
+     a5c:	00005517          	auipc	a0,0x5
+     a60:	c4c50513          	addi	a0,a0,-948 # 56a8 <malloc+0x540>
+     a64:	650040ef          	jal	50b4 <printf>
+    exit(1);
+     a68:	4505                	li	a0,1
+     a6a:	21a040ef          	jal	4c84 <exit>
+      printf("%s: error: write big file failed i=%d\n", s, i);
+     a6e:	8626                	mv	a2,s1
+     a70:	85d6                	mv	a1,s5
+     a72:	00005517          	auipc	a0,0x5
+     a76:	c5650513          	addi	a0,a0,-938 # 56c8 <malloc+0x560>
+     a7a:	63a040ef          	jal	50b4 <printf>
+      exit(1);
+     a7e:	4505                	li	a0,1
+     a80:	204040ef          	jal	4c84 <exit>
+    printf("%s: error: open big failed!\n", s);
+     a84:	85d6                	mv	a1,s5
+     a86:	00005517          	auipc	a0,0x5
+     a8a:	c6a50513          	addi	a0,a0,-918 # 56f0 <malloc+0x588>
+     a8e:	626040ef          	jal	50b4 <printf>
+    exit(1);
+     a92:	4505                	li	a0,1
+     a94:	1f0040ef          	jal	4c84 <exit>
+      if(n != MAXFILE){
+     a98:	10c00793          	li	a5,268
+     a9c:	02f49663          	bne	s1,a5,ac8 <writebig+0x10a>
+  close(fd);
+     aa0:	854e                	mv	a0,s3
+     aa2:	20a040ef          	jal	4cac <close>
+  if(unlink("big") < 0){
+     aa6:	00005517          	auipc	a0,0x5
+     aaa:	bfa50513          	addi	a0,a0,-1030 # 56a0 <malloc+0x538>
+     aae:	226040ef          	jal	4cd4 <unlink>
+     ab2:	04054c63          	bltz	a0,b0a <writebig+0x14c>
+}
+     ab6:	70e2                	ld	ra,56(sp)
+     ab8:	7442                	ld	s0,48(sp)
+     aba:	74a2                	ld	s1,40(sp)
+     abc:	7902                	ld	s2,32(sp)
+     abe:	69e2                	ld	s3,24(sp)
+     ac0:	6a42                	ld	s4,16(sp)
+     ac2:	6aa2                	ld	s5,8(sp)
+     ac4:	6121                	addi	sp,sp,64
+     ac6:	8082                	ret
+        printf("%s: read only %d blocks from big", s, n);
+     ac8:	8626                	mv	a2,s1
+     aca:	85d6                	mv	a1,s5
+     acc:	00005517          	auipc	a0,0x5
+     ad0:	c4450513          	addi	a0,a0,-956 # 5710 <malloc+0x5a8>
+     ad4:	5e0040ef          	jal	50b4 <printf>
+        exit(1);
+     ad8:	4505                	li	a0,1
+     ada:	1aa040ef          	jal	4c84 <exit>
+      printf("%s: read failed %d\n", s, i);
+     ade:	862a                	mv	a2,a0
+     ae0:	85d6                	mv	a1,s5
+     ae2:	00005517          	auipc	a0,0x5
+     ae6:	c5650513          	addi	a0,a0,-938 # 5738 <malloc+0x5d0>
+     aea:	5ca040ef          	jal	50b4 <printf>
+      exit(1);
+     aee:	4505                	li	a0,1
+     af0:	194040ef          	jal	4c84 <exit>
+      printf("%s: read content of block %d is %d\n", s,
+     af4:	8626                	mv	a2,s1
+     af6:	85d6                	mv	a1,s5
+     af8:	00005517          	auipc	a0,0x5
+     afc:	c5850513          	addi	a0,a0,-936 # 5750 <malloc+0x5e8>
+     b00:	5b4040ef          	jal	50b4 <printf>
+      exit(1);
+     b04:	4505                	li	a0,1
+     b06:	17e040ef          	jal	4c84 <exit>
+    printf("%s: unlink big failed\n", s);
+     b0a:	85d6                	mv	a1,s5
+     b0c:	00005517          	auipc	a0,0x5
+     b10:	c6c50513          	addi	a0,a0,-916 # 5778 <malloc+0x610>
+     b14:	5a0040ef          	jal	50b4 <printf>
+    exit(1);
+     b18:	4505                	li	a0,1
+     b1a:	16a040ef          	jal	4c84 <exit>
+
+0000000000000b1e <unlinkread>:
+{
+     b1e:	7179                	addi	sp,sp,-48
+     b20:	f406                	sd	ra,40(sp)
+     b22:	f022                	sd	s0,32(sp)
+     b24:	ec26                	sd	s1,24(sp)
+     b26:	e84a                	sd	s2,16(sp)
+     b28:	e44e                	sd	s3,8(sp)
+     b2a:	1800                	addi	s0,sp,48
+     b2c:	89aa                	mv	s3,a0
+  fd = open("unlinkread", O_CREATE | O_RDWR);
+     b2e:	20200593          	li	a1,514
+     b32:	00005517          	auipc	a0,0x5
+     b36:	c5e50513          	addi	a0,a0,-930 # 5790 <malloc+0x628>
+     b3a:	18a040ef          	jal	4cc4 <open>
+  if(fd < 0){
+     b3e:	0a054f63          	bltz	a0,bfc <unlinkread+0xde>
+     b42:	84aa                	mv	s1,a0
+  write(fd, "hello", SZ);
+     b44:	4615                	li	a2,5
+     b46:	00005597          	auipc	a1,0x5
+     b4a:	c7a58593          	addi	a1,a1,-902 # 57c0 <malloc+0x658>
+     b4e:	156040ef          	jal	4ca4 <write>
+  close(fd);
+     b52:	8526                	mv	a0,s1
+     b54:	158040ef          	jal	4cac <close>
+  fd = open("unlinkread", O_RDWR);
+     b58:	4589                	li	a1,2
+     b5a:	00005517          	auipc	a0,0x5
+     b5e:	c3650513          	addi	a0,a0,-970 # 5790 <malloc+0x628>
+     b62:	162040ef          	jal	4cc4 <open>
+     b66:	84aa                	mv	s1,a0
+  if(fd < 0){
+     b68:	0a054463          	bltz	a0,c10 <unlinkread+0xf2>
+  if(unlink("unlinkread") != 0){
+     b6c:	00005517          	auipc	a0,0x5
+     b70:	c2450513          	addi	a0,a0,-988 # 5790 <malloc+0x628>
+     b74:	160040ef          	jal	4cd4 <unlink>
+     b78:	e555                	bnez	a0,c24 <unlinkread+0x106>
+  fd1 = open("unlinkread", O_CREATE | O_RDWR);
+     b7a:	20200593          	li	a1,514
+     b7e:	00005517          	auipc	a0,0x5
+     b82:	c1250513          	addi	a0,a0,-1006 # 5790 <malloc+0x628>
+     b86:	13e040ef          	jal	4cc4 <open>
+     b8a:	892a                	mv	s2,a0
+  write(fd1, "yyy", 3);
+     b8c:	460d                	li	a2,3
+     b8e:	00005597          	auipc	a1,0x5
+     b92:	c7a58593          	addi	a1,a1,-902 # 5808 <malloc+0x6a0>
+     b96:	10e040ef          	jal	4ca4 <write>
+  close(fd1);
+     b9a:	854a                	mv	a0,s2
+     b9c:	110040ef          	jal	4cac <close>
+  if(read(fd, buf, sizeof(buf)) != SZ){
+     ba0:	660d                	lui	a2,0x3
+     ba2:	0000c597          	auipc	a1,0xc
+     ba6:	10658593          	addi	a1,a1,262 # cca8 <buf>
+     baa:	8526                	mv	a0,s1
+     bac:	0f0040ef          	jal	4c9c <read>
+     bb0:	4795                	li	a5,5
+     bb2:	08f51363          	bne	a0,a5,c38 <unlinkread+0x11a>
+  if(buf[0] != 'h'){
+     bb6:	0000c717          	auipc	a4,0xc
+     bba:	0f274703          	lbu	a4,242(a4) # cca8 <buf>
+     bbe:	06800793          	li	a5,104
+     bc2:	08f71563          	bne	a4,a5,c4c <unlinkread+0x12e>
+  if(write(fd, buf, 10) != 10){
+     bc6:	4629                	li	a2,10
+     bc8:	0000c597          	auipc	a1,0xc
+     bcc:	0e058593          	addi	a1,a1,224 # cca8 <buf>
+     bd0:	8526                	mv	a0,s1
+     bd2:	0d2040ef          	jal	4ca4 <write>
+     bd6:	47a9                	li	a5,10
+     bd8:	08f51463          	bne	a0,a5,c60 <unlinkread+0x142>
+  close(fd);
+     bdc:	8526                	mv	a0,s1
+     bde:	0ce040ef          	jal	4cac <close>
+  unlink("unlinkread");
+     be2:	00005517          	auipc	a0,0x5
+     be6:	bae50513          	addi	a0,a0,-1106 # 5790 <malloc+0x628>
+     bea:	0ea040ef          	jal	4cd4 <unlink>
+}
+     bee:	70a2                	ld	ra,40(sp)
+     bf0:	7402                	ld	s0,32(sp)
+     bf2:	64e2                	ld	s1,24(sp)
+     bf4:	6942                	ld	s2,16(sp)
+     bf6:	69a2                	ld	s3,8(sp)
+     bf8:	6145                	addi	sp,sp,48
+     bfa:	8082                	ret
+    printf("%s: create unlinkread failed\n", s);
+     bfc:	85ce                	mv	a1,s3
+     bfe:	00005517          	auipc	a0,0x5
+     c02:	ba250513          	addi	a0,a0,-1118 # 57a0 <malloc+0x638>
+     c06:	4ae040ef          	jal	50b4 <printf>
+    exit(1);
+     c0a:	4505                	li	a0,1
+     c0c:	078040ef          	jal	4c84 <exit>
+    printf("%s: open unlinkread failed\n", s);
+     c10:	85ce                	mv	a1,s3
+     c12:	00005517          	auipc	a0,0x5
+     c16:	bb650513          	addi	a0,a0,-1098 # 57c8 <malloc+0x660>
+     c1a:	49a040ef          	jal	50b4 <printf>
+    exit(1);
+     c1e:	4505                	li	a0,1
+     c20:	064040ef          	jal	4c84 <exit>
+    printf("%s: unlink unlinkread failed\n", s);
+     c24:	85ce                	mv	a1,s3
+     c26:	00005517          	auipc	a0,0x5
+     c2a:	bc250513          	addi	a0,a0,-1086 # 57e8 <malloc+0x680>
+     c2e:	486040ef          	jal	50b4 <printf>
+    exit(1);
+     c32:	4505                	li	a0,1
+     c34:	050040ef          	jal	4c84 <exit>
+    printf("%s: unlinkread read failed", s);
+     c38:	85ce                	mv	a1,s3
+     c3a:	00005517          	auipc	a0,0x5
+     c3e:	bd650513          	addi	a0,a0,-1066 # 5810 <malloc+0x6a8>
+     c42:	472040ef          	jal	50b4 <printf>
+    exit(1);
+     c46:	4505                	li	a0,1
+     c48:	03c040ef          	jal	4c84 <exit>
+    printf("%s: unlinkread wrong data\n", s);
+     c4c:	85ce                	mv	a1,s3
+     c4e:	00005517          	auipc	a0,0x5
+     c52:	be250513          	addi	a0,a0,-1054 # 5830 <malloc+0x6c8>
+     c56:	45e040ef          	jal	50b4 <printf>
+    exit(1);
+     c5a:	4505                	li	a0,1
+     c5c:	028040ef          	jal	4c84 <exit>
+    printf("%s: unlinkread write failed\n", s);
+     c60:	85ce                	mv	a1,s3
+     c62:	00005517          	auipc	a0,0x5
+     c66:	bee50513          	addi	a0,a0,-1042 # 5850 <malloc+0x6e8>
+     c6a:	44a040ef          	jal	50b4 <printf>
+    exit(1);
+     c6e:	4505                	li	a0,1
+     c70:	014040ef          	jal	4c84 <exit>
+
+0000000000000c74 <linktest>:
+{
+     c74:	1101                	addi	sp,sp,-32
+     c76:	ec06                	sd	ra,24(sp)
+     c78:	e822                	sd	s0,16(sp)
+     c7a:	e426                	sd	s1,8(sp)
+     c7c:	e04a                	sd	s2,0(sp)
+     c7e:	1000                	addi	s0,sp,32
+     c80:	892a                	mv	s2,a0
+  unlink("lf1");
+     c82:	00005517          	auipc	a0,0x5
+     c86:	bee50513          	addi	a0,a0,-1042 # 5870 <malloc+0x708>
+     c8a:	04a040ef          	jal	4cd4 <unlink>
+  unlink("lf2");
+     c8e:	00005517          	auipc	a0,0x5
+     c92:	bea50513          	addi	a0,a0,-1046 # 5878 <malloc+0x710>
+     c96:	03e040ef          	jal	4cd4 <unlink>
+  fd = open("lf1", O_CREATE|O_RDWR);
+     c9a:	20200593          	li	a1,514
+     c9e:	00005517          	auipc	a0,0x5
+     ca2:	bd250513          	addi	a0,a0,-1070 # 5870 <malloc+0x708>
+     ca6:	01e040ef          	jal	4cc4 <open>
+  if(fd < 0){
+     caa:	0c054f63          	bltz	a0,d88 <linktest+0x114>
+     cae:	84aa                	mv	s1,a0
+  if(write(fd, "hello", SZ) != SZ){
+     cb0:	4615                	li	a2,5
+     cb2:	00005597          	auipc	a1,0x5
+     cb6:	b0e58593          	addi	a1,a1,-1266 # 57c0 <malloc+0x658>
+     cba:	7eb030ef          	jal	4ca4 <write>
+     cbe:	4795                	li	a5,5
+     cc0:	0cf51e63          	bne	a0,a5,d9c <linktest+0x128>
+  close(fd);
+     cc4:	8526                	mv	a0,s1
+     cc6:	7e7030ef          	jal	4cac <close>
+  if(link("lf1", "lf2") < 0){
+     cca:	00005597          	auipc	a1,0x5
+     cce:	bae58593          	addi	a1,a1,-1106 # 5878 <malloc+0x710>
+     cd2:	00005517          	auipc	a0,0x5
+     cd6:	b9e50513          	addi	a0,a0,-1122 # 5870 <malloc+0x708>
+     cda:	00a040ef          	jal	4ce4 <link>
+     cde:	0c054963          	bltz	a0,db0 <linktest+0x13c>
+  unlink("lf1");
+     ce2:	00005517          	auipc	a0,0x5
+     ce6:	b8e50513          	addi	a0,a0,-1138 # 5870 <malloc+0x708>
+     cea:	7eb030ef          	jal	4cd4 <unlink>
+  if(open("lf1", 0) >= 0){
+     cee:	4581                	li	a1,0
+     cf0:	00005517          	auipc	a0,0x5
+     cf4:	b8050513          	addi	a0,a0,-1152 # 5870 <malloc+0x708>
+     cf8:	7cd030ef          	jal	4cc4 <open>
+     cfc:	0c055463          	bgez	a0,dc4 <linktest+0x150>
+  fd = open("lf2", 0);
+     d00:	4581                	li	a1,0
+     d02:	00005517          	auipc	a0,0x5
+     d06:	b7650513          	addi	a0,a0,-1162 # 5878 <malloc+0x710>
+     d0a:	7bb030ef          	jal	4cc4 <open>
+     d0e:	84aa                	mv	s1,a0
+  if(fd < 0){
+     d10:	0c054463          	bltz	a0,dd8 <linktest+0x164>
+  if(read(fd, buf, sizeof(buf)) != SZ){
+     d14:	660d                	lui	a2,0x3
+     d16:	0000c597          	auipc	a1,0xc
+     d1a:	f9258593          	addi	a1,a1,-110 # cca8 <buf>
+     d1e:	77f030ef          	jal	4c9c <read>
+     d22:	4795                	li	a5,5
+     d24:	0cf51463          	bne	a0,a5,dec <linktest+0x178>
+  close(fd);
+     d28:	8526                	mv	a0,s1
+     d2a:	783030ef          	jal	4cac <close>
+  if(link("lf2", "lf2") >= 0){
+     d2e:	00005597          	auipc	a1,0x5
+     d32:	b4a58593          	addi	a1,a1,-1206 # 5878 <malloc+0x710>
+     d36:	852e                	mv	a0,a1
+     d38:	7ad030ef          	jal	4ce4 <link>
+     d3c:	0c055263          	bgez	a0,e00 <linktest+0x18c>
+  unlink("lf2");
+     d40:	00005517          	auipc	a0,0x5
+     d44:	b3850513          	addi	a0,a0,-1224 # 5878 <malloc+0x710>
+     d48:	78d030ef          	jal	4cd4 <unlink>
+  if(link("lf2", "lf1") >= 0){
+     d4c:	00005597          	auipc	a1,0x5
+     d50:	b2458593          	addi	a1,a1,-1244 # 5870 <malloc+0x708>
+     d54:	00005517          	auipc	a0,0x5
+     d58:	b2450513          	addi	a0,a0,-1244 # 5878 <malloc+0x710>
+     d5c:	789030ef          	jal	4ce4 <link>
+     d60:	0a055a63          	bgez	a0,e14 <linktest+0x1a0>
+  if(link(".", "lf1") >= 0){
+     d64:	00005597          	auipc	a1,0x5
+     d68:	b0c58593          	addi	a1,a1,-1268 # 5870 <malloc+0x708>
+     d6c:	00005517          	auipc	a0,0x5
+     d70:	c1450513          	addi	a0,a0,-1004 # 5980 <malloc+0x818>
+     d74:	771030ef          	jal	4ce4 <link>
+     d78:	0a055863          	bgez	a0,e28 <linktest+0x1b4>
+}
+     d7c:	60e2                	ld	ra,24(sp)
+     d7e:	6442                	ld	s0,16(sp)
+     d80:	64a2                	ld	s1,8(sp)
+     d82:	6902                	ld	s2,0(sp)
+     d84:	6105                	addi	sp,sp,32
+     d86:	8082                	ret
+    printf("%s: create lf1 failed\n", s);
+     d88:	85ca                	mv	a1,s2
+     d8a:	00005517          	auipc	a0,0x5
+     d8e:	af650513          	addi	a0,a0,-1290 # 5880 <malloc+0x718>
+     d92:	322040ef          	jal	50b4 <printf>
+    exit(1);
+     d96:	4505                	li	a0,1
+     d98:	6ed030ef          	jal	4c84 <exit>
+    printf("%s: write lf1 failed\n", s);
+     d9c:	85ca                	mv	a1,s2
+     d9e:	00005517          	auipc	a0,0x5
+     da2:	afa50513          	addi	a0,a0,-1286 # 5898 <malloc+0x730>
+     da6:	30e040ef          	jal	50b4 <printf>
+    exit(1);
+     daa:	4505                	li	a0,1
+     dac:	6d9030ef          	jal	4c84 <exit>
+    printf("%s: link lf1 lf2 failed\n", s);
+     db0:	85ca                	mv	a1,s2
+     db2:	00005517          	auipc	a0,0x5
+     db6:	afe50513          	addi	a0,a0,-1282 # 58b0 <malloc+0x748>
+     dba:	2fa040ef          	jal	50b4 <printf>
+    exit(1);
+     dbe:	4505                	li	a0,1
+     dc0:	6c5030ef          	jal	4c84 <exit>
+    printf("%s: unlinked lf1 but it is still there!\n", s);
+     dc4:	85ca                	mv	a1,s2
+     dc6:	00005517          	auipc	a0,0x5
+     dca:	b0a50513          	addi	a0,a0,-1270 # 58d0 <malloc+0x768>
+     dce:	2e6040ef          	jal	50b4 <printf>
+    exit(1);
+     dd2:	4505                	li	a0,1
+     dd4:	6b1030ef          	jal	4c84 <exit>
+    printf("%s: open lf2 failed\n", s);
+     dd8:	85ca                	mv	a1,s2
+     dda:	00005517          	auipc	a0,0x5
+     dde:	b2650513          	addi	a0,a0,-1242 # 5900 <malloc+0x798>
+     de2:	2d2040ef          	jal	50b4 <printf>
+    exit(1);
+     de6:	4505                	li	a0,1
+     de8:	69d030ef          	jal	4c84 <exit>
+    printf("%s: read lf2 failed\n", s);
+     dec:	85ca                	mv	a1,s2
+     dee:	00005517          	auipc	a0,0x5
+     df2:	b2a50513          	addi	a0,a0,-1238 # 5918 <malloc+0x7b0>
+     df6:	2be040ef          	jal	50b4 <printf>
+    exit(1);
+     dfa:	4505                	li	a0,1
+     dfc:	689030ef          	jal	4c84 <exit>
+    printf("%s: link lf2 lf2 succeeded! oops\n", s);
+     e00:	85ca                	mv	a1,s2
+     e02:	00005517          	auipc	a0,0x5
+     e06:	b2e50513          	addi	a0,a0,-1234 # 5930 <malloc+0x7c8>
+     e0a:	2aa040ef          	jal	50b4 <printf>
+    exit(1);
+     e0e:	4505                	li	a0,1
+     e10:	675030ef          	jal	4c84 <exit>
+    printf("%s: link non-existent succeeded! oops\n", s);
+     e14:	85ca                	mv	a1,s2
+     e16:	00005517          	auipc	a0,0x5
+     e1a:	b4250513          	addi	a0,a0,-1214 # 5958 <malloc+0x7f0>
+     e1e:	296040ef          	jal	50b4 <printf>
+    exit(1);
+     e22:	4505                	li	a0,1
+     e24:	661030ef          	jal	4c84 <exit>
+    printf("%s: link . lf1 succeeded! oops\n", s);
+     e28:	85ca                	mv	a1,s2
+     e2a:	00005517          	auipc	a0,0x5
+     e2e:	b5e50513          	addi	a0,a0,-1186 # 5988 <malloc+0x820>
+     e32:	282040ef          	jal	50b4 <printf>
+    exit(1);
+     e36:	4505                	li	a0,1
+     e38:	64d030ef          	jal	4c84 <exit>
+
+0000000000000e3c <validatetest>:
+{
+     e3c:	7139                	addi	sp,sp,-64
+     e3e:	fc06                	sd	ra,56(sp)
+     e40:	f822                	sd	s0,48(sp)
+     e42:	f426                	sd	s1,40(sp)
+     e44:	f04a                	sd	s2,32(sp)
+     e46:	ec4e                	sd	s3,24(sp)
+     e48:	e852                	sd	s4,16(sp)
+     e4a:	e456                	sd	s5,8(sp)
+     e4c:	e05a                	sd	s6,0(sp)
+     e4e:	0080                	addi	s0,sp,64
+     e50:	8b2a                	mv	s6,a0
+  for(p = 0; p <= (uint)hi; p += PGSIZE){
+     e52:	4481                	li	s1,0
+    if(link("nosuchfile", (char*)p) != -1){
+     e54:	00005997          	auipc	s3,0x5
+     e58:	b5498993          	addi	s3,s3,-1196 # 59a8 <malloc+0x840>
+     e5c:	597d                	li	s2,-1
+  for(p = 0; p <= (uint)hi; p += PGSIZE){
+     e5e:	6a85                	lui	s5,0x1
+     e60:	00114a37          	lui	s4,0x114
+    if(link("nosuchfile", (char*)p) != -1){
+     e64:	85a6                	mv	a1,s1
+     e66:	854e                	mv	a0,s3
+     e68:	67d030ef          	jal	4ce4 <link>
+     e6c:	01251f63          	bne	a0,s2,e8a <validatetest+0x4e>
+  for(p = 0; p <= (uint)hi; p += PGSIZE){
+     e70:	94d6                	add	s1,s1,s5
+     e72:	ff4499e3          	bne	s1,s4,e64 <validatetest+0x28>
+}
+     e76:	70e2                	ld	ra,56(sp)
+     e78:	7442                	ld	s0,48(sp)
+     e7a:	74a2                	ld	s1,40(sp)
+     e7c:	7902                	ld	s2,32(sp)
+     e7e:	69e2                	ld	s3,24(sp)
+     e80:	6a42                	ld	s4,16(sp)
+     e82:	6aa2                	ld	s5,8(sp)
+     e84:	6b02                	ld	s6,0(sp)
+     e86:	6121                	addi	sp,sp,64
+     e88:	8082                	ret
+      printf("%s: link should not succeed\n", s);
+     e8a:	85da                	mv	a1,s6
+     e8c:	00005517          	auipc	a0,0x5
+     e90:	b2c50513          	addi	a0,a0,-1236 # 59b8 <malloc+0x850>
+     e94:	220040ef          	jal	50b4 <printf>
+      exit(1);
+     e98:	4505                	li	a0,1
+     e9a:	5eb030ef          	jal	4c84 <exit>
+
+0000000000000e9e <bigdir>:
+{
+     e9e:	715d                	addi	sp,sp,-80
+     ea0:	e486                	sd	ra,72(sp)
+     ea2:	e0a2                	sd	s0,64(sp)
+     ea4:	fc26                	sd	s1,56(sp)
+     ea6:	f84a                	sd	s2,48(sp)
+     ea8:	f44e                	sd	s3,40(sp)
+     eaa:	f052                	sd	s4,32(sp)
+     eac:	ec56                	sd	s5,24(sp)
+     eae:	e85a                	sd	s6,16(sp)
+     eb0:	0880                	addi	s0,sp,80
+     eb2:	89aa                	mv	s3,a0
+  unlink("bd");
+     eb4:	00005517          	auipc	a0,0x5
+     eb8:	b2450513          	addi	a0,a0,-1244 # 59d8 <malloc+0x870>
+     ebc:	619030ef          	jal	4cd4 <unlink>
+  fd = open("bd", O_CREATE);
+     ec0:	20000593          	li	a1,512
+     ec4:	00005517          	auipc	a0,0x5
+     ec8:	b1450513          	addi	a0,a0,-1260 # 59d8 <malloc+0x870>
+     ecc:	5f9030ef          	jal	4cc4 <open>
+  if(fd < 0){
+     ed0:	0c054163          	bltz	a0,f92 <bigdir+0xf4>
+  close(fd);
+     ed4:	5d9030ef          	jal	4cac <close>
+  for(i = 0; i < N; i++){
+     ed8:	4901                	li	s2,0
+    name[0] = 'x';
+     eda:	07800a93          	li	s5,120
+    if(link("bd", name) != 0){
+     ede:	00005a17          	auipc	s4,0x5
+     ee2:	afaa0a13          	addi	s4,s4,-1286 # 59d8 <malloc+0x870>
+  for(i = 0; i < N; i++){
+     ee6:	1f400b13          	li	s6,500
+    name[0] = 'x';
+     eea:	fb540823          	sb	s5,-80(s0)
+    name[1] = '0' + (i / 64);
+     eee:	41f9571b          	sraiw	a4,s2,0x1f
+     ef2:	01a7571b          	srliw	a4,a4,0x1a
+     ef6:	012707bb          	addw	a5,a4,s2
+     efa:	4067d69b          	sraiw	a3,a5,0x6
+     efe:	0306869b          	addiw	a3,a3,48
+     f02:	fad408a3          	sb	a3,-79(s0)
+    name[2] = '0' + (i % 64);
+     f06:	03f7f793          	andi	a5,a5,63
+     f0a:	9f99                	subw	a5,a5,a4
+     f0c:	0307879b          	addiw	a5,a5,48
+     f10:	faf40923          	sb	a5,-78(s0)
+    name[3] = '\0';
+     f14:	fa0409a3          	sb	zero,-77(s0)
+    if(link("bd", name) != 0){
+     f18:	fb040593          	addi	a1,s0,-80
+     f1c:	8552                	mv	a0,s4
+     f1e:	5c7030ef          	jal	4ce4 <link>
+     f22:	84aa                	mv	s1,a0
+     f24:	e149                	bnez	a0,fa6 <bigdir+0x108>
+  for(i = 0; i < N; i++){
+     f26:	2905                	addiw	s2,s2,1
+     f28:	fd6911e3          	bne	s2,s6,eea <bigdir+0x4c>
+  unlink("bd");
+     f2c:	00005517          	auipc	a0,0x5
+     f30:	aac50513          	addi	a0,a0,-1364 # 59d8 <malloc+0x870>
+     f34:	5a1030ef          	jal	4cd4 <unlink>
+    name[0] = 'x';
+     f38:	07800913          	li	s2,120
+  for(i = 0; i < N; i++){
+     f3c:	1f400a13          	li	s4,500
+    name[0] = 'x';
+     f40:	fb240823          	sb	s2,-80(s0)
+    name[1] = '0' + (i / 64);
+     f44:	41f4d71b          	sraiw	a4,s1,0x1f
+     f48:	01a7571b          	srliw	a4,a4,0x1a
+     f4c:	009707bb          	addw	a5,a4,s1
+     f50:	4067d69b          	sraiw	a3,a5,0x6
+     f54:	0306869b          	addiw	a3,a3,48
+     f58:	fad408a3          	sb	a3,-79(s0)
+    name[2] = '0' + (i % 64);
+     f5c:	03f7f793          	andi	a5,a5,63
+     f60:	9f99                	subw	a5,a5,a4
+     f62:	0307879b          	addiw	a5,a5,48
+     f66:	faf40923          	sb	a5,-78(s0)
+    name[3] = '\0';
+     f6a:	fa0409a3          	sb	zero,-77(s0)
+    if(unlink(name) != 0){
+     f6e:	fb040513          	addi	a0,s0,-80
+     f72:	563030ef          	jal	4cd4 <unlink>
+     f76:	e529                	bnez	a0,fc0 <bigdir+0x122>
+  for(i = 0; i < N; i++){
+     f78:	2485                	addiw	s1,s1,1
+     f7a:	fd4493e3          	bne	s1,s4,f40 <bigdir+0xa2>
+}
+     f7e:	60a6                	ld	ra,72(sp)
+     f80:	6406                	ld	s0,64(sp)
+     f82:	74e2                	ld	s1,56(sp)
+     f84:	7942                	ld	s2,48(sp)
+     f86:	79a2                	ld	s3,40(sp)
+     f88:	7a02                	ld	s4,32(sp)
+     f8a:	6ae2                	ld	s5,24(sp)
+     f8c:	6b42                	ld	s6,16(sp)
+     f8e:	6161                	addi	sp,sp,80
+     f90:	8082                	ret
+    printf("%s: bigdir create failed\n", s);
+     f92:	85ce                	mv	a1,s3
+     f94:	00005517          	auipc	a0,0x5
+     f98:	a4c50513          	addi	a0,a0,-1460 # 59e0 <malloc+0x878>
+     f9c:	118040ef          	jal	50b4 <printf>
+    exit(1);
+     fa0:	4505                	li	a0,1
+     fa2:	4e3030ef          	jal	4c84 <exit>
+      printf("%s: bigdir i=%d link(bd, %s) failed\n", s, i, name);
+     fa6:	fb040693          	addi	a3,s0,-80
+     faa:	864a                	mv	a2,s2
+     fac:	85ce                	mv	a1,s3
+     fae:	00005517          	auipc	a0,0x5
+     fb2:	a5250513          	addi	a0,a0,-1454 # 5a00 <malloc+0x898>
+     fb6:	0fe040ef          	jal	50b4 <printf>
+      exit(1);
+     fba:	4505                	li	a0,1
+     fbc:	4c9030ef          	jal	4c84 <exit>
+      printf("%s: bigdir unlink failed", s);
+     fc0:	85ce                	mv	a1,s3
+     fc2:	00005517          	auipc	a0,0x5
+     fc6:	a6650513          	addi	a0,a0,-1434 # 5a28 <malloc+0x8c0>
+     fca:	0ea040ef          	jal	50b4 <printf>
+      exit(1);
+     fce:	4505                	li	a0,1
+     fd0:	4b5030ef          	jal	4c84 <exit>
+
+0000000000000fd4 <pgbug>:
+{
+     fd4:	7179                	addi	sp,sp,-48
+     fd6:	f406                	sd	ra,40(sp)
+     fd8:	f022                	sd	s0,32(sp)
+     fda:	ec26                	sd	s1,24(sp)
+     fdc:	1800                	addi	s0,sp,48
+  argv[0] = 0;
+     fde:	fc043c23          	sd	zero,-40(s0)
+  exec(big, argv);
+     fe2:	00008497          	auipc	s1,0x8
+     fe6:	01e48493          	addi	s1,s1,30 # 9000 <big>
+     fea:	fd840593          	addi	a1,s0,-40
+     fee:	6088                	ld	a0,0(s1)
+     ff0:	4cd030ef          	jal	4cbc <exec>
+  pipe(big);
+     ff4:	6088                	ld	a0,0(s1)
+     ff6:	49f030ef          	jal	4c94 <pipe>
+  exit(0);
+     ffa:	4501                	li	a0,0
+     ffc:	489030ef          	jal	4c84 <exit>
+
+0000000000001000 <badarg>:
+{
+    1000:	7139                	addi	sp,sp,-64
+    1002:	fc06                	sd	ra,56(sp)
+    1004:	f822                	sd	s0,48(sp)
+    1006:	f426                	sd	s1,40(sp)
+    1008:	f04a                	sd	s2,32(sp)
+    100a:	ec4e                	sd	s3,24(sp)
+    100c:	0080                	addi	s0,sp,64
+    100e:	64b1                	lui	s1,0xc
+    1010:	35048493          	addi	s1,s1,848 # c350 <uninit+0x1db8>
+    argv[0] = (char*)0xffffffff;
+    1014:	597d                	li	s2,-1
+    1016:	02095913          	srli	s2,s2,0x20
+    exec("echo", argv);
+    101a:	00004997          	auipc	s3,0x4
+    101e:	27e98993          	addi	s3,s3,638 # 5298 <malloc+0x130>
+    argv[0] = (char*)0xffffffff;
+    1022:	fd243023          	sd	s2,-64(s0)
+    argv[1] = 0;
+    1026:	fc043423          	sd	zero,-56(s0)
+    exec("echo", argv);
+    102a:	fc040593          	addi	a1,s0,-64
+    102e:	854e                	mv	a0,s3
+    1030:	48d030ef          	jal	4cbc <exec>
+  for(int i = 0; i < 50000; i++){
+    1034:	34fd                	addiw	s1,s1,-1
+    1036:	f4f5                	bnez	s1,1022 <badarg+0x22>
+  exit(0);
+    1038:	4501                	li	a0,0
+    103a:	44b030ef          	jal	4c84 <exit>
+
+000000000000103e <copyinstr2>:
+{
+    103e:	7155                	addi	sp,sp,-208
+    1040:	e586                	sd	ra,200(sp)
+    1042:	e1a2                	sd	s0,192(sp)
+    1044:	0980                	addi	s0,sp,208
+  for(int i = 0; i < MAXPATH; i++)
+    1046:	f6840793          	addi	a5,s0,-152
+    104a:	fe840693          	addi	a3,s0,-24
+    b[i] = 'x';
+    104e:	07800713          	li	a4,120
+    1052:	00e78023          	sb	a4,0(a5)
+  for(int i = 0; i < MAXPATH; i++)
+    1056:	0785                	addi	a5,a5,1
+    1058:	fed79de3          	bne	a5,a3,1052 <copyinstr2+0x14>
+  b[MAXPATH] = '\0';
+    105c:	fe040423          	sb	zero,-24(s0)
+  int ret = unlink(b);
+    1060:	f6840513          	addi	a0,s0,-152
+    1064:	471030ef          	jal	4cd4 <unlink>
+  if(ret != -1){
+    1068:	57fd                	li	a5,-1
+    106a:	0cf51263          	bne	a0,a5,112e <copyinstr2+0xf0>
+  int fd = open(b, O_CREATE | O_WRONLY);
+    106e:	20100593          	li	a1,513
+    1072:	f6840513          	addi	a0,s0,-152
+    1076:	44f030ef          	jal	4cc4 <open>
+  if(fd != -1){
+    107a:	57fd                	li	a5,-1
+    107c:	0cf51563          	bne	a0,a5,1146 <copyinstr2+0x108>
+  ret = link(b, b);
+    1080:	f6840593          	addi	a1,s0,-152
+    1084:	852e                	mv	a0,a1
+    1086:	45f030ef          	jal	4ce4 <link>
+  if(ret != -1){
+    108a:	57fd                	li	a5,-1
+    108c:	0cf51963          	bne	a0,a5,115e <copyinstr2+0x120>
+  char *args[] = { "xx", 0 };
+    1090:	00006797          	auipc	a5,0x6
+    1094:	ae878793          	addi	a5,a5,-1304 # 6b78 <malloc+0x1a10>
+    1098:	f4f43c23          	sd	a5,-168(s0)
+    109c:	f6043023          	sd	zero,-160(s0)
+  ret = exec(b, args);
+    10a0:	f5840593          	addi	a1,s0,-168
+    10a4:	f6840513          	addi	a0,s0,-152
+    10a8:	415030ef          	jal	4cbc <exec>
+  if(ret != -1){
+    10ac:	57fd                	li	a5,-1
+    10ae:	0cf51563          	bne	a0,a5,1178 <copyinstr2+0x13a>
+  int pid = fork();
+    10b2:	3cb030ef          	jal	4c7c <fork>
+  if(pid < 0){
+    10b6:	0c054d63          	bltz	a0,1190 <copyinstr2+0x152>
+  if(pid == 0){
+    10ba:	0e051863          	bnez	a0,11aa <copyinstr2+0x16c>
+    10be:	00008797          	auipc	a5,0x8
+    10c2:	4d278793          	addi	a5,a5,1234 # 9590 <big.0>
+    10c6:	00009697          	auipc	a3,0x9
+    10ca:	4ca68693          	addi	a3,a3,1226 # a590 <big.0+0x1000>
+      big[i] = 'x';
+    10ce:	07800713          	li	a4,120
+    10d2:	00e78023          	sb	a4,0(a5)
+    for(int i = 0; i < PGSIZE; i++)
+    10d6:	0785                	addi	a5,a5,1
+    10d8:	fed79de3          	bne	a5,a3,10d2 <copyinstr2+0x94>
+    big[PGSIZE] = '\0';
+    10dc:	00009797          	auipc	a5,0x9
+    10e0:	4a078a23          	sb	zero,1204(a5) # a590 <big.0+0x1000>
+    char *args2[] = { big, big, big, 0 };
+    10e4:	00006797          	auipc	a5,0x6
+    10e8:	60478793          	addi	a5,a5,1540 # 76e8 <malloc+0x2580>
+    10ec:	6fb0                	ld	a2,88(a5)
+    10ee:	73b4                	ld	a3,96(a5)
+    10f0:	77b8                	ld	a4,104(a5)
+    10f2:	7bbc                	ld	a5,112(a5)
+    10f4:	f2c43823          	sd	a2,-208(s0)
+    10f8:	f2d43c23          	sd	a3,-200(s0)
+    10fc:	f4e43023          	sd	a4,-192(s0)
+    1100:	f4f43423          	sd	a5,-184(s0)
+    ret = exec("echo", args2);
+    1104:	f3040593          	addi	a1,s0,-208
+    1108:	00004517          	auipc	a0,0x4
+    110c:	19050513          	addi	a0,a0,400 # 5298 <malloc+0x130>
+    1110:	3ad030ef          	jal	4cbc <exec>
+    if(ret != -1){
+    1114:	57fd                	li	a5,-1
+    1116:	08f50663          	beq	a0,a5,11a2 <copyinstr2+0x164>
+      printf("exec(echo, BIG) returned %d, not -1\n", fd);
+    111a:	55fd                	li	a1,-1
+    111c:	00005517          	auipc	a0,0x5
+    1120:	9b450513          	addi	a0,a0,-1612 # 5ad0 <malloc+0x968>
+    1124:	791030ef          	jal	50b4 <printf>
+      exit(1);
+    1128:	4505                	li	a0,1
+    112a:	35b030ef          	jal	4c84 <exit>
+    printf("unlink(%s) returned %d, not -1\n", b, ret);
+    112e:	862a                	mv	a2,a0
+    1130:	f6840593          	addi	a1,s0,-152
+    1134:	00005517          	auipc	a0,0x5
+    1138:	91450513          	addi	a0,a0,-1772 # 5a48 <malloc+0x8e0>
+    113c:	779030ef          	jal	50b4 <printf>
+    exit(1);
+    1140:	4505                	li	a0,1
+    1142:	343030ef          	jal	4c84 <exit>
+    printf("open(%s) returned %d, not -1\n", b, fd);
+    1146:	862a                	mv	a2,a0
+    1148:	f6840593          	addi	a1,s0,-152
+    114c:	00005517          	auipc	a0,0x5
+    1150:	91c50513          	addi	a0,a0,-1764 # 5a68 <malloc+0x900>
+    1154:	761030ef          	jal	50b4 <printf>
+    exit(1);
+    1158:	4505                	li	a0,1
+    115a:	32b030ef          	jal	4c84 <exit>
+    printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+    115e:	86aa                	mv	a3,a0
+    1160:	f6840613          	addi	a2,s0,-152
+    1164:	85b2                	mv	a1,a2
+    1166:	00005517          	auipc	a0,0x5
+    116a:	92250513          	addi	a0,a0,-1758 # 5a88 <malloc+0x920>
+    116e:	747030ef          	jal	50b4 <printf>
+    exit(1);
+    1172:	4505                	li	a0,1
+    1174:	311030ef          	jal	4c84 <exit>
+    printf("exec(%s) returned %d, not -1\n", b, fd);
+    1178:	567d                	li	a2,-1
+    117a:	f6840593          	addi	a1,s0,-152
+    117e:	00005517          	auipc	a0,0x5
+    1182:	93250513          	addi	a0,a0,-1742 # 5ab0 <malloc+0x948>
+    1186:	72f030ef          	jal	50b4 <printf>
+    exit(1);
+    118a:	4505                	li	a0,1
+    118c:	2f9030ef          	jal	4c84 <exit>
+    printf("fork failed\n");
+    1190:	00006517          	auipc	a0,0x6
+    1194:	f4050513          	addi	a0,a0,-192 # 70d0 <malloc+0x1f68>
+    1198:	71d030ef          	jal	50b4 <printf>
+    exit(1);
+    119c:	4505                	li	a0,1
+    119e:	2e7030ef          	jal	4c84 <exit>
+    exit(747); // OK
+    11a2:	2eb00513          	li	a0,747
+    11a6:	2df030ef          	jal	4c84 <exit>
+  int st = 0;
+    11aa:	f4042a23          	sw	zero,-172(s0)
+  wait(&st);
+    11ae:	f5440513          	addi	a0,s0,-172
+    11b2:	2db030ef          	jal	4c8c <wait>
+  if(st != 747){
+    11b6:	f5442703          	lw	a4,-172(s0)
+    11ba:	2eb00793          	li	a5,747
+    11be:	00f71663          	bne	a4,a5,11ca <copyinstr2+0x18c>
+}
+    11c2:	60ae                	ld	ra,200(sp)
+    11c4:	640e                	ld	s0,192(sp)
+    11c6:	6169                	addi	sp,sp,208
+    11c8:	8082                	ret
+    printf("exec(echo, BIG) succeeded, should have failed\n");
+    11ca:	00005517          	auipc	a0,0x5
+    11ce:	92e50513          	addi	a0,a0,-1746 # 5af8 <malloc+0x990>
+    11d2:	6e3030ef          	jal	50b4 <printf>
+    exit(1);
+    11d6:	4505                	li	a0,1
+    11d8:	2ad030ef          	jal	4c84 <exit>
+
+00000000000011dc <truncate3>:
+{
+    11dc:	7159                	addi	sp,sp,-112
+    11de:	f486                	sd	ra,104(sp)
+    11e0:	f0a2                	sd	s0,96(sp)
+    11e2:	e8ca                	sd	s2,80(sp)
+    11e4:	1880                	addi	s0,sp,112
+    11e6:	892a                	mv	s2,a0
+  close(open("truncfile", O_CREATE|O_TRUNC|O_WRONLY));
+    11e8:	60100593          	li	a1,1537
+    11ec:	00004517          	auipc	a0,0x4
+    11f0:	10450513          	addi	a0,a0,260 # 52f0 <malloc+0x188>
+    11f4:	2d1030ef          	jal	4cc4 <open>
+    11f8:	2b5030ef          	jal	4cac <close>
+  pid = fork();
+    11fc:	281030ef          	jal	4c7c <fork>
+  if(pid < 0){
+    1200:	06054663          	bltz	a0,126c <truncate3+0x90>
+  if(pid == 0){
+    1204:	e55d                	bnez	a0,12b2 <truncate3+0xd6>
+    1206:	eca6                	sd	s1,88(sp)
+    1208:	e4ce                	sd	s3,72(sp)
+    120a:	e0d2                	sd	s4,64(sp)
+    120c:	fc56                	sd	s5,56(sp)
+    120e:	06400993          	li	s3,100
+      int fd = open("truncfile", O_WRONLY);
+    1212:	00004a17          	auipc	s4,0x4
+    1216:	0dea0a13          	addi	s4,s4,222 # 52f0 <malloc+0x188>
+      int n = write(fd, "1234567890", 10);
+    121a:	00005a97          	auipc	s5,0x5
+    121e:	93ea8a93          	addi	s5,s5,-1730 # 5b58 <malloc+0x9f0>
+      int fd = open("truncfile", O_WRONLY);
+    1222:	4585                	li	a1,1
+    1224:	8552                	mv	a0,s4
+    1226:	29f030ef          	jal	4cc4 <open>
+    122a:	84aa                	mv	s1,a0
+      if(fd < 0){
+    122c:	04054e63          	bltz	a0,1288 <truncate3+0xac>
+      int n = write(fd, "1234567890", 10);
+    1230:	4629                	li	a2,10
+    1232:	85d6                	mv	a1,s5
+    1234:	271030ef          	jal	4ca4 <write>
+      if(n != 10){
+    1238:	47a9                	li	a5,10
+    123a:	06f51163          	bne	a0,a5,129c <truncate3+0xc0>
+      close(fd);
+    123e:	8526                	mv	a0,s1
+    1240:	26d030ef          	jal	4cac <close>
+      fd = open("truncfile", O_RDONLY);
+    1244:	4581                	li	a1,0
+    1246:	8552                	mv	a0,s4
+    1248:	27d030ef          	jal	4cc4 <open>
+    124c:	84aa                	mv	s1,a0
+      read(fd, buf, sizeof(buf));
+    124e:	02000613          	li	a2,32
+    1252:	f9840593          	addi	a1,s0,-104
+    1256:	247030ef          	jal	4c9c <read>
+      close(fd);
+    125a:	8526                	mv	a0,s1
+    125c:	251030ef          	jal	4cac <close>
+    for(int i = 0; i < 100; i++){
+    1260:	39fd                	addiw	s3,s3,-1
+    1262:	fc0990e3          	bnez	s3,1222 <truncate3+0x46>
+    exit(0);
+    1266:	4501                	li	a0,0
+    1268:	21d030ef          	jal	4c84 <exit>
+    126c:	eca6                	sd	s1,88(sp)
+    126e:	e4ce                	sd	s3,72(sp)
+    1270:	e0d2                	sd	s4,64(sp)
+    1272:	fc56                	sd	s5,56(sp)
+    printf("%s: fork failed\n", s);
+    1274:	85ca                	mv	a1,s2
+    1276:	00005517          	auipc	a0,0x5
+    127a:	8b250513          	addi	a0,a0,-1870 # 5b28 <malloc+0x9c0>
+    127e:	637030ef          	jal	50b4 <printf>
+    exit(1);
+    1282:	4505                	li	a0,1
+    1284:	201030ef          	jal	4c84 <exit>
+        printf("%s: open failed\n", s);
+    1288:	85ca                	mv	a1,s2
+    128a:	00005517          	auipc	a0,0x5
+    128e:	8b650513          	addi	a0,a0,-1866 # 5b40 <malloc+0x9d8>
+    1292:	623030ef          	jal	50b4 <printf>
+        exit(1);
+    1296:	4505                	li	a0,1
+    1298:	1ed030ef          	jal	4c84 <exit>
+        printf("%s: write got %d, expected 10\n", s, n);
+    129c:	862a                	mv	a2,a0
+    129e:	85ca                	mv	a1,s2
+    12a0:	00005517          	auipc	a0,0x5
+    12a4:	8c850513          	addi	a0,a0,-1848 # 5b68 <malloc+0xa00>
+    12a8:	60d030ef          	jal	50b4 <printf>
+        exit(1);
+    12ac:	4505                	li	a0,1
+    12ae:	1d7030ef          	jal	4c84 <exit>
+    12b2:	eca6                	sd	s1,88(sp)
+    12b4:	e4ce                	sd	s3,72(sp)
+    12b6:	e0d2                	sd	s4,64(sp)
+    12b8:	fc56                	sd	s5,56(sp)
+    12ba:	09600993          	li	s3,150
+    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+    12be:	00004a17          	auipc	s4,0x4
+    12c2:	032a0a13          	addi	s4,s4,50 # 52f0 <malloc+0x188>
+    int n = write(fd, "xxx", 3);
+    12c6:	00005a97          	auipc	s5,0x5
+    12ca:	8c2a8a93          	addi	s5,s5,-1854 # 5b88 <malloc+0xa20>
+    int fd = open("truncfile", O_CREATE|O_WRONLY|O_TRUNC);
+    12ce:	60100593          	li	a1,1537
+    12d2:	8552                	mv	a0,s4
+    12d4:	1f1030ef          	jal	4cc4 <open>
+    12d8:	84aa                	mv	s1,a0
+    if(fd < 0){
+    12da:	02054d63          	bltz	a0,1314 <truncate3+0x138>
+    int n = write(fd, "xxx", 3);
+    12de:	460d                	li	a2,3
+    12e0:	85d6                	mv	a1,s5
+    12e2:	1c3030ef          	jal	4ca4 <write>
+    if(n != 3){
+    12e6:	478d                	li	a5,3
+    12e8:	04f51063          	bne	a0,a5,1328 <truncate3+0x14c>
+    close(fd);
+    12ec:	8526                	mv	a0,s1
+    12ee:	1bf030ef          	jal	4cac <close>
+  for(int i = 0; i < 150; i++){
+    12f2:	39fd                	addiw	s3,s3,-1
+    12f4:	fc099de3          	bnez	s3,12ce <truncate3+0xf2>
+  wait(&xstatus);
+    12f8:	fbc40513          	addi	a0,s0,-68
+    12fc:	191030ef          	jal	4c8c <wait>
+  unlink("truncfile");
+    1300:	00004517          	auipc	a0,0x4
+    1304:	ff050513          	addi	a0,a0,-16 # 52f0 <malloc+0x188>
+    1308:	1cd030ef          	jal	4cd4 <unlink>
+  exit(xstatus);
+    130c:	fbc42503          	lw	a0,-68(s0)
+    1310:	175030ef          	jal	4c84 <exit>
+      printf("%s: open failed\n", s);
+    1314:	85ca                	mv	a1,s2
+    1316:	00005517          	auipc	a0,0x5
+    131a:	82a50513          	addi	a0,a0,-2006 # 5b40 <malloc+0x9d8>
+    131e:	597030ef          	jal	50b4 <printf>
+      exit(1);
+    1322:	4505                	li	a0,1
+    1324:	161030ef          	jal	4c84 <exit>
+      printf("%s: write got %d, expected 3\n", s, n);
+    1328:	862a                	mv	a2,a0
+    132a:	85ca                	mv	a1,s2
+    132c:	00005517          	auipc	a0,0x5
+    1330:	86450513          	addi	a0,a0,-1948 # 5b90 <malloc+0xa28>
+    1334:	581030ef          	jal	50b4 <printf>
+      exit(1);
+    1338:	4505                	li	a0,1
+    133a:	14b030ef          	jal	4c84 <exit>
+
+000000000000133e <exectest>:
+{
+    133e:	715d                	addi	sp,sp,-80
+    1340:	e486                	sd	ra,72(sp)
+    1342:	e0a2                	sd	s0,64(sp)
+    1344:	f84a                	sd	s2,48(sp)
+    1346:	0880                	addi	s0,sp,80
+    1348:	892a                	mv	s2,a0
+  char *echoargv[] = { "echo", "OK", 0 };
+    134a:	00004797          	auipc	a5,0x4
+    134e:	f4e78793          	addi	a5,a5,-178 # 5298 <malloc+0x130>
+    1352:	fcf43023          	sd	a5,-64(s0)
+    1356:	00005797          	auipc	a5,0x5
+    135a:	85a78793          	addi	a5,a5,-1958 # 5bb0 <malloc+0xa48>
+    135e:	fcf43423          	sd	a5,-56(s0)
+    1362:	fc043823          	sd	zero,-48(s0)
+  unlink("echo-ok");
+    1366:	00005517          	auipc	a0,0x5
+    136a:	85250513          	addi	a0,a0,-1966 # 5bb8 <malloc+0xa50>
+    136e:	167030ef          	jal	4cd4 <unlink>
+  pid = fork();
+    1372:	10b030ef          	jal	4c7c <fork>
+  if(pid < 0) {
+    1376:	02054f63          	bltz	a0,13b4 <exectest+0x76>
+    137a:	fc26                	sd	s1,56(sp)
+    137c:	84aa                	mv	s1,a0
+  if(pid == 0) {
+    137e:	e935                	bnez	a0,13f2 <exectest+0xb4>
+    close(1);
+    1380:	4505                	li	a0,1
+    1382:	12b030ef          	jal	4cac <close>
+    fd = open("echo-ok", O_CREATE|O_WRONLY);
+    1386:	20100593          	li	a1,513
+    138a:	00005517          	auipc	a0,0x5
+    138e:	82e50513          	addi	a0,a0,-2002 # 5bb8 <malloc+0xa50>
+    1392:	133030ef          	jal	4cc4 <open>
+    if(fd < 0) {
+    1396:	02054a63          	bltz	a0,13ca <exectest+0x8c>
+    if(fd != 1) {
+    139a:	4785                	li	a5,1
+    139c:	04f50163          	beq	a0,a5,13de <exectest+0xa0>
+      printf("%s: wrong fd\n", s);
+    13a0:	85ca                	mv	a1,s2
+    13a2:	00005517          	auipc	a0,0x5
+    13a6:	83650513          	addi	a0,a0,-1994 # 5bd8 <malloc+0xa70>
+    13aa:	50b030ef          	jal	50b4 <printf>
+      exit(1);
+    13ae:	4505                	li	a0,1
+    13b0:	0d5030ef          	jal	4c84 <exit>
+    13b4:	fc26                	sd	s1,56(sp)
+     printf("%s: fork failed\n", s);
+    13b6:	85ca                	mv	a1,s2
+    13b8:	00004517          	auipc	a0,0x4
+    13bc:	77050513          	addi	a0,a0,1904 # 5b28 <malloc+0x9c0>
+    13c0:	4f5030ef          	jal	50b4 <printf>
+     exit(1);
+    13c4:	4505                	li	a0,1
+    13c6:	0bf030ef          	jal	4c84 <exit>
+      printf("%s: create failed\n", s);
+    13ca:	85ca                	mv	a1,s2
+    13cc:	00004517          	auipc	a0,0x4
+    13d0:	7f450513          	addi	a0,a0,2036 # 5bc0 <malloc+0xa58>
+    13d4:	4e1030ef          	jal	50b4 <printf>
+      exit(1);
+    13d8:	4505                	li	a0,1
+    13da:	0ab030ef          	jal	4c84 <exit>
+    if(exec("echo", echoargv) < 0){
+    13de:	fc040593          	addi	a1,s0,-64
+    13e2:	00004517          	auipc	a0,0x4
+    13e6:	eb650513          	addi	a0,a0,-330 # 5298 <malloc+0x130>
+    13ea:	0d3030ef          	jal	4cbc <exec>
+    13ee:	00054d63          	bltz	a0,1408 <exectest+0xca>
+  if (wait(&xstatus) != pid) {
+    13f2:	fdc40513          	addi	a0,s0,-36
+    13f6:	097030ef          	jal	4c8c <wait>
+    13fa:	02951163          	bne	a0,s1,141c <exectest+0xde>
+  if(xstatus != 0)
+    13fe:	fdc42503          	lw	a0,-36(s0)
+    1402:	c50d                	beqz	a0,142c <exectest+0xee>
+    exit(xstatus);
+    1404:	081030ef          	jal	4c84 <exit>
+      printf("%s: exec echo failed\n", s);
+    1408:	85ca                	mv	a1,s2
+    140a:	00004517          	auipc	a0,0x4
+    140e:	7de50513          	addi	a0,a0,2014 # 5be8 <malloc+0xa80>
+    1412:	4a3030ef          	jal	50b4 <printf>
+      exit(1);
+    1416:	4505                	li	a0,1
+    1418:	06d030ef          	jal	4c84 <exit>
+    printf("%s: wait failed!\n", s);
+    141c:	85ca                	mv	a1,s2
+    141e:	00004517          	auipc	a0,0x4
+    1422:	7e250513          	addi	a0,a0,2018 # 5c00 <malloc+0xa98>
+    1426:	48f030ef          	jal	50b4 <printf>
+    142a:	bfd1                	j	13fe <exectest+0xc0>
+  fd = open("echo-ok", O_RDONLY);
+    142c:	4581                	li	a1,0
+    142e:	00004517          	auipc	a0,0x4
+    1432:	78a50513          	addi	a0,a0,1930 # 5bb8 <malloc+0xa50>
+    1436:	08f030ef          	jal	4cc4 <open>
+  if(fd < 0) {
+    143a:	02054463          	bltz	a0,1462 <exectest+0x124>
+  if (read(fd, buf, 2) != 2) {
+    143e:	4609                	li	a2,2
+    1440:	fb840593          	addi	a1,s0,-72
+    1444:	059030ef          	jal	4c9c <read>
+    1448:	4789                	li	a5,2
+    144a:	02f50663          	beq	a0,a5,1476 <exectest+0x138>
+    printf("%s: read failed\n", s);
+    144e:	85ca                	mv	a1,s2
+    1450:	00004517          	auipc	a0,0x4
+    1454:	21850513          	addi	a0,a0,536 # 5668 <malloc+0x500>
+    1458:	45d030ef          	jal	50b4 <printf>
+    exit(1);
+    145c:	4505                	li	a0,1
+    145e:	027030ef          	jal	4c84 <exit>
+    printf("%s: open failed\n", s);
+    1462:	85ca                	mv	a1,s2
+    1464:	00004517          	auipc	a0,0x4
+    1468:	6dc50513          	addi	a0,a0,1756 # 5b40 <malloc+0x9d8>
+    146c:	449030ef          	jal	50b4 <printf>
+    exit(1);
+    1470:	4505                	li	a0,1
+    1472:	013030ef          	jal	4c84 <exit>
+  unlink("echo-ok");
+    1476:	00004517          	auipc	a0,0x4
+    147a:	74250513          	addi	a0,a0,1858 # 5bb8 <malloc+0xa50>
+    147e:	057030ef          	jal	4cd4 <unlink>
+  if(buf[0] == 'O' && buf[1] == 'K')
+    1482:	fb844703          	lbu	a4,-72(s0)
+    1486:	04f00793          	li	a5,79
+    148a:	00f71863          	bne	a4,a5,149a <exectest+0x15c>
+    148e:	fb944703          	lbu	a4,-71(s0)
+    1492:	04b00793          	li	a5,75
+    1496:	00f70c63          	beq	a4,a5,14ae <exectest+0x170>
+    printf("%s: wrong output\n", s);
+    149a:	85ca                	mv	a1,s2
+    149c:	00004517          	auipc	a0,0x4
+    14a0:	77c50513          	addi	a0,a0,1916 # 5c18 <malloc+0xab0>
+    14a4:	411030ef          	jal	50b4 <printf>
+    exit(1);
+    14a8:	4505                	li	a0,1
+    14aa:	7da030ef          	jal	4c84 <exit>
+    exit(0);
+    14ae:	4501                	li	a0,0
+    14b0:	7d4030ef          	jal	4c84 <exit>
+
+00000000000014b4 <pipe1>:
+{
+    14b4:	711d                	addi	sp,sp,-96
+    14b6:	ec86                	sd	ra,88(sp)
+    14b8:	e8a2                	sd	s0,80(sp)
+    14ba:	fc4e                	sd	s3,56(sp)
+    14bc:	1080                	addi	s0,sp,96
+    14be:	89aa                	mv	s3,a0
+  if(pipe(fds) != 0){
+    14c0:	fa840513          	addi	a0,s0,-88
+    14c4:	7d0030ef          	jal	4c94 <pipe>
+    14c8:	e92d                	bnez	a0,153a <pipe1+0x86>
+    14ca:	e4a6                	sd	s1,72(sp)
+    14cc:	f852                	sd	s4,48(sp)
+    14ce:	84aa                	mv	s1,a0
+  pid = fork();
+    14d0:	7ac030ef          	jal	4c7c <fork>
+    14d4:	8a2a                	mv	s4,a0
+  if(pid == 0){
+    14d6:	c151                	beqz	a0,155a <pipe1+0xa6>
+  } else if(pid > 0){
+    14d8:	14a05e63          	blez	a0,1634 <pipe1+0x180>
+    14dc:	e0ca                	sd	s2,64(sp)
+    14de:	f456                	sd	s5,40(sp)
+    close(fds[1]);
+    14e0:	fac42503          	lw	a0,-84(s0)
+    14e4:	7c8030ef          	jal	4cac <close>
+    total = 0;
+    14e8:	8a26                	mv	s4,s1
+    cc = 1;
+    14ea:	4905                	li	s2,1
+    while((n = read(fds[0], buf, cc)) > 0){
+    14ec:	0000ba97          	auipc	s5,0xb
+    14f0:	7bca8a93          	addi	s5,s5,1980 # cca8 <buf>
+    14f4:	864a                	mv	a2,s2
+    14f6:	85d6                	mv	a1,s5
+    14f8:	fa842503          	lw	a0,-88(s0)
+    14fc:	7a0030ef          	jal	4c9c <read>
+    1500:	0ea05a63          	blez	a0,15f4 <pipe1+0x140>
+      for(i = 0; i < n; i++){
+    1504:	0000b717          	auipc	a4,0xb
+    1508:	7a470713          	addi	a4,a4,1956 # cca8 <buf>
+    150c:	00a4863b          	addw	a2,s1,a0
+        if((buf[i] & 0xff) != (seq++ & 0xff)){
+    1510:	00074683          	lbu	a3,0(a4)
+    1514:	0ff4f793          	zext.b	a5,s1
+    1518:	2485                	addiw	s1,s1,1
+    151a:	0af69d63          	bne	a3,a5,15d4 <pipe1+0x120>
+      for(i = 0; i < n; i++){
+    151e:	0705                	addi	a4,a4,1
+    1520:	fec498e3          	bne	s1,a2,1510 <pipe1+0x5c>
+      total += n;
+    1524:	00aa0a3b          	addw	s4,s4,a0
+      cc = cc * 2;
+    1528:	0019179b          	slliw	a5,s2,0x1
+    152c:	0007891b          	sext.w	s2,a5
+      if(cc > sizeof(buf))
+    1530:	670d                	lui	a4,0x3
+    1532:	fd2771e3          	bgeu	a4,s2,14f4 <pipe1+0x40>
+        cc = sizeof(buf);
+    1536:	690d                	lui	s2,0x3
+    1538:	bf75                	j	14f4 <pipe1+0x40>
+    153a:	e4a6                	sd	s1,72(sp)
+    153c:	e0ca                	sd	s2,64(sp)
+    153e:	f852                	sd	s4,48(sp)
+    1540:	f456                	sd	s5,40(sp)
+    1542:	f05a                	sd	s6,32(sp)
+    1544:	ec5e                	sd	s7,24(sp)
+    printf("%s: pipe() failed\n", s);
+    1546:	85ce                	mv	a1,s3
+    1548:	00004517          	auipc	a0,0x4
+    154c:	6e850513          	addi	a0,a0,1768 # 5c30 <malloc+0xac8>
+    1550:	365030ef          	jal	50b4 <printf>
+    exit(1);
+    1554:	4505                	li	a0,1
+    1556:	72e030ef          	jal	4c84 <exit>
+    155a:	e0ca                	sd	s2,64(sp)
+    155c:	f456                	sd	s5,40(sp)
+    155e:	f05a                	sd	s6,32(sp)
+    1560:	ec5e                	sd	s7,24(sp)
+    close(fds[0]);
+    1562:	fa842503          	lw	a0,-88(s0)
+    1566:	746030ef          	jal	4cac <close>
+    for(n = 0; n < N; n++){
+    156a:	0000bb17          	auipc	s6,0xb
+    156e:	73eb0b13          	addi	s6,s6,1854 # cca8 <buf>
+    1572:	416004bb          	negw	s1,s6
+    1576:	0ff4f493          	zext.b	s1,s1
+    157a:	409b0913          	addi	s2,s6,1033
+      if(write(fds[1], buf, SZ) != SZ){
+    157e:	8bda                	mv	s7,s6
+    for(n = 0; n < N; n++){
+    1580:	6a85                	lui	s5,0x1
+    1582:	42da8a93          	addi	s5,s5,1069 # 142d <exectest+0xef>
+{
+    1586:	87da                	mv	a5,s6
+        buf[i] = seq++;
+    1588:	0097873b          	addw	a4,a5,s1
+    158c:	00e78023          	sb	a4,0(a5)
+      for(i = 0; i < SZ; i++)
+    1590:	0785                	addi	a5,a5,1
+    1592:	ff279be3          	bne	a5,s2,1588 <pipe1+0xd4>
+    1596:	409a0a1b          	addiw	s4,s4,1033
+      if(write(fds[1], buf, SZ) != SZ){
+    159a:	40900613          	li	a2,1033
+    159e:	85de                	mv	a1,s7
+    15a0:	fac42503          	lw	a0,-84(s0)
+    15a4:	700030ef          	jal	4ca4 <write>
+    15a8:	40900793          	li	a5,1033
+    15ac:	00f51a63          	bne	a0,a5,15c0 <pipe1+0x10c>
+    for(n = 0; n < N; n++){
+    15b0:	24a5                	addiw	s1,s1,9
+    15b2:	0ff4f493          	zext.b	s1,s1
+    15b6:	fd5a18e3          	bne	s4,s5,1586 <pipe1+0xd2>
+    exit(0);
+    15ba:	4501                	li	a0,0
+    15bc:	6c8030ef          	jal	4c84 <exit>
+        printf("%s: pipe1 oops 1\n", s);
+    15c0:	85ce                	mv	a1,s3
+    15c2:	00004517          	auipc	a0,0x4
+    15c6:	68650513          	addi	a0,a0,1670 # 5c48 <malloc+0xae0>
+    15ca:	2eb030ef          	jal	50b4 <printf>
+        exit(1);
+    15ce:	4505                	li	a0,1
+    15d0:	6b4030ef          	jal	4c84 <exit>
+          printf("%s: pipe1 oops 2\n", s);
+    15d4:	85ce                	mv	a1,s3
+    15d6:	00004517          	auipc	a0,0x4
+    15da:	68a50513          	addi	a0,a0,1674 # 5c60 <malloc+0xaf8>
+    15de:	2d7030ef          	jal	50b4 <printf>
+          return;
+    15e2:	64a6                	ld	s1,72(sp)
+    15e4:	6906                	ld	s2,64(sp)
+    15e6:	7a42                	ld	s4,48(sp)
+    15e8:	7aa2                	ld	s5,40(sp)
+}
+    15ea:	60e6                	ld	ra,88(sp)
+    15ec:	6446                	ld	s0,80(sp)
+    15ee:	79e2                	ld	s3,56(sp)
+    15f0:	6125                	addi	sp,sp,96
+    15f2:	8082                	ret
+    if(total != N * SZ){
+    15f4:	6785                	lui	a5,0x1
+    15f6:	42d78793          	addi	a5,a5,1069 # 142d <exectest+0xef>
+    15fa:	00fa0f63          	beq	s4,a5,1618 <pipe1+0x164>
+    15fe:	f05a                	sd	s6,32(sp)
+    1600:	ec5e                	sd	s7,24(sp)
+      printf("%s: pipe1 oops 3 total %d\n", s, total);
+    1602:	8652                	mv	a2,s4
+    1604:	85ce                	mv	a1,s3
+    1606:	00004517          	auipc	a0,0x4
+    160a:	67250513          	addi	a0,a0,1650 # 5c78 <malloc+0xb10>
+    160e:	2a7030ef          	jal	50b4 <printf>
+      exit(1);
+    1612:	4505                	li	a0,1
+    1614:	670030ef          	jal	4c84 <exit>
+    1618:	f05a                	sd	s6,32(sp)
+    161a:	ec5e                	sd	s7,24(sp)
+    close(fds[0]);
+    161c:	fa842503          	lw	a0,-88(s0)
+    1620:	68c030ef          	jal	4cac <close>
+    wait(&xstatus);
+    1624:	fa440513          	addi	a0,s0,-92
+    1628:	664030ef          	jal	4c8c <wait>
+    exit(xstatus);
+    162c:	fa442503          	lw	a0,-92(s0)
+    1630:	654030ef          	jal	4c84 <exit>
+    1634:	e0ca                	sd	s2,64(sp)
+    1636:	f456                	sd	s5,40(sp)
+    1638:	f05a                	sd	s6,32(sp)
+    163a:	ec5e                	sd	s7,24(sp)
+    printf("%s: fork() failed\n", s);
+    163c:	85ce                	mv	a1,s3
+    163e:	00004517          	auipc	a0,0x4
+    1642:	65a50513          	addi	a0,a0,1626 # 5c98 <malloc+0xb30>
+    1646:	26f030ef          	jal	50b4 <printf>
+    exit(1);
+    164a:	4505                	li	a0,1
+    164c:	638030ef          	jal	4c84 <exit>
+
+0000000000001650 <exitwait>:
+{
+    1650:	7139                	addi	sp,sp,-64
+    1652:	fc06                	sd	ra,56(sp)
+    1654:	f822                	sd	s0,48(sp)
+    1656:	f426                	sd	s1,40(sp)
+    1658:	f04a                	sd	s2,32(sp)
+    165a:	ec4e                	sd	s3,24(sp)
+    165c:	e852                	sd	s4,16(sp)
+    165e:	0080                	addi	s0,sp,64
+    1660:	8a2a                	mv	s4,a0
+  for(i = 0; i < 100; i++){
+    1662:	4901                	li	s2,0
+    1664:	06400993          	li	s3,100
+    pid = fork();
+    1668:	614030ef          	jal	4c7c <fork>
+    166c:	84aa                	mv	s1,a0
+    if(pid < 0){
+    166e:	02054863          	bltz	a0,169e <exitwait+0x4e>
+    if(pid){
+    1672:	c525                	beqz	a0,16da <exitwait+0x8a>
+      if(wait(&xstate) != pid){
+    1674:	fcc40513          	addi	a0,s0,-52
+    1678:	614030ef          	jal	4c8c <wait>
+    167c:	02951b63          	bne	a0,s1,16b2 <exitwait+0x62>
+      if(i != xstate) {
+    1680:	fcc42783          	lw	a5,-52(s0)
+    1684:	05279163          	bne	a5,s2,16c6 <exitwait+0x76>
+  for(i = 0; i < 100; i++){
+    1688:	2905                	addiw	s2,s2,1 # 3001 <subdir+0x43f>
+    168a:	fd391fe3          	bne	s2,s3,1668 <exitwait+0x18>
+}
+    168e:	70e2                	ld	ra,56(sp)
+    1690:	7442                	ld	s0,48(sp)
+    1692:	74a2                	ld	s1,40(sp)
+    1694:	7902                	ld	s2,32(sp)
+    1696:	69e2                	ld	s3,24(sp)
+    1698:	6a42                	ld	s4,16(sp)
+    169a:	6121                	addi	sp,sp,64
+    169c:	8082                	ret
+      printf("%s: fork failed\n", s);
+    169e:	85d2                	mv	a1,s4
+    16a0:	00004517          	auipc	a0,0x4
+    16a4:	48850513          	addi	a0,a0,1160 # 5b28 <malloc+0x9c0>
+    16a8:	20d030ef          	jal	50b4 <printf>
+      exit(1);
+    16ac:	4505                	li	a0,1
+    16ae:	5d6030ef          	jal	4c84 <exit>
+        printf("%s: wait wrong pid\n", s);
+    16b2:	85d2                	mv	a1,s4
+    16b4:	00004517          	auipc	a0,0x4
+    16b8:	5fc50513          	addi	a0,a0,1532 # 5cb0 <malloc+0xb48>
+    16bc:	1f9030ef          	jal	50b4 <printf>
+        exit(1);
+    16c0:	4505                	li	a0,1
+    16c2:	5c2030ef          	jal	4c84 <exit>
+        printf("%s: wait wrong exit status\n", s);
+    16c6:	85d2                	mv	a1,s4
+    16c8:	00004517          	auipc	a0,0x4
+    16cc:	60050513          	addi	a0,a0,1536 # 5cc8 <malloc+0xb60>
+    16d0:	1e5030ef          	jal	50b4 <printf>
+        exit(1);
+    16d4:	4505                	li	a0,1
+    16d6:	5ae030ef          	jal	4c84 <exit>
+      exit(i);
+    16da:	854a                	mv	a0,s2
+    16dc:	5a8030ef          	jal	4c84 <exit>
+
+00000000000016e0 <twochildren>:
+{
+    16e0:	1101                	addi	sp,sp,-32
+    16e2:	ec06                	sd	ra,24(sp)
+    16e4:	e822                	sd	s0,16(sp)
+    16e6:	e426                	sd	s1,8(sp)
+    16e8:	e04a                	sd	s2,0(sp)
+    16ea:	1000                	addi	s0,sp,32
+    16ec:	892a                	mv	s2,a0
+    16ee:	3e800493          	li	s1,1000
+    int pid1 = fork();
+    16f2:	58a030ef          	jal	4c7c <fork>
+    if(pid1 < 0){
+    16f6:	02054663          	bltz	a0,1722 <twochildren+0x42>
+    if(pid1 == 0){
+    16fa:	cd15                	beqz	a0,1736 <twochildren+0x56>
+      int pid2 = fork();
+    16fc:	580030ef          	jal	4c7c <fork>
+      if(pid2 < 0){
+    1700:	02054d63          	bltz	a0,173a <twochildren+0x5a>
+      if(pid2 == 0){
+    1704:	c529                	beqz	a0,174e <twochildren+0x6e>
+        wait(0);
+    1706:	4501                	li	a0,0
+    1708:	584030ef          	jal	4c8c <wait>
+        wait(0);
+    170c:	4501                	li	a0,0
+    170e:	57e030ef          	jal	4c8c <wait>
+  for(int i = 0; i < 1000; i++){
+    1712:	34fd                	addiw	s1,s1,-1
+    1714:	fcf9                	bnez	s1,16f2 <twochildren+0x12>
+}
+    1716:	60e2                	ld	ra,24(sp)
+    1718:	6442                	ld	s0,16(sp)
+    171a:	64a2                	ld	s1,8(sp)
+    171c:	6902                	ld	s2,0(sp)
+    171e:	6105                	addi	sp,sp,32
+    1720:	8082                	ret
+      printf("%s: fork failed\n", s);
+    1722:	85ca                	mv	a1,s2
+    1724:	00004517          	auipc	a0,0x4
+    1728:	40450513          	addi	a0,a0,1028 # 5b28 <malloc+0x9c0>
+    172c:	189030ef          	jal	50b4 <printf>
+      exit(1);
+    1730:	4505                	li	a0,1
+    1732:	552030ef          	jal	4c84 <exit>
+      exit(0);
+    1736:	54e030ef          	jal	4c84 <exit>
+        printf("%s: fork failed\n", s);
+    173a:	85ca                	mv	a1,s2
+    173c:	00004517          	auipc	a0,0x4
+    1740:	3ec50513          	addi	a0,a0,1004 # 5b28 <malloc+0x9c0>
+    1744:	171030ef          	jal	50b4 <printf>
+        exit(1);
+    1748:	4505                	li	a0,1
+    174a:	53a030ef          	jal	4c84 <exit>
+        exit(0);
+    174e:	536030ef          	jal	4c84 <exit>
+
+0000000000001752 <forkfork>:
+{
+    1752:	7179                	addi	sp,sp,-48
+    1754:	f406                	sd	ra,40(sp)
+    1756:	f022                	sd	s0,32(sp)
+    1758:	ec26                	sd	s1,24(sp)
+    175a:	1800                	addi	s0,sp,48
+    175c:	84aa                	mv	s1,a0
+    int pid = fork();
+    175e:	51e030ef          	jal	4c7c <fork>
+    if(pid < 0){
+    1762:	02054b63          	bltz	a0,1798 <forkfork+0x46>
+    if(pid == 0){
+    1766:	c139                	beqz	a0,17ac <forkfork+0x5a>
+    int pid = fork();
+    1768:	514030ef          	jal	4c7c <fork>
+    if(pid < 0){
+    176c:	02054663          	bltz	a0,1798 <forkfork+0x46>
+    if(pid == 0){
+    1770:	cd15                	beqz	a0,17ac <forkfork+0x5a>
+    wait(&xstatus);
+    1772:	fdc40513          	addi	a0,s0,-36
+    1776:	516030ef          	jal	4c8c <wait>
+    if(xstatus != 0) {
+    177a:	fdc42783          	lw	a5,-36(s0)
+    177e:	ebb9                	bnez	a5,17d4 <forkfork+0x82>
+    wait(&xstatus);
+    1780:	fdc40513          	addi	a0,s0,-36
+    1784:	508030ef          	jal	4c8c <wait>
+    if(xstatus != 0) {
+    1788:	fdc42783          	lw	a5,-36(s0)
+    178c:	e7a1                	bnez	a5,17d4 <forkfork+0x82>
+}
+    178e:	70a2                	ld	ra,40(sp)
+    1790:	7402                	ld	s0,32(sp)
+    1792:	64e2                	ld	s1,24(sp)
+    1794:	6145                	addi	sp,sp,48
+    1796:	8082                	ret
+      printf("%s: fork failed", s);
+    1798:	85a6                	mv	a1,s1
+    179a:	00004517          	auipc	a0,0x4
+    179e:	54e50513          	addi	a0,a0,1358 # 5ce8 <malloc+0xb80>
+    17a2:	113030ef          	jal	50b4 <printf>
+      exit(1);
+    17a6:	4505                	li	a0,1
+    17a8:	4dc030ef          	jal	4c84 <exit>
+{
+    17ac:	0c800493          	li	s1,200
+        int pid1 = fork();
+    17b0:	4cc030ef          	jal	4c7c <fork>
+        if(pid1 < 0){
+    17b4:	00054b63          	bltz	a0,17ca <forkfork+0x78>
+        if(pid1 == 0){
+    17b8:	cd01                	beqz	a0,17d0 <forkfork+0x7e>
+        wait(0);
+    17ba:	4501                	li	a0,0
+    17bc:	4d0030ef          	jal	4c8c <wait>
+      for(int j = 0; j < 200; j++){
+    17c0:	34fd                	addiw	s1,s1,-1
+    17c2:	f4fd                	bnez	s1,17b0 <forkfork+0x5e>
+      exit(0);
+    17c4:	4501                	li	a0,0
+    17c6:	4be030ef          	jal	4c84 <exit>
+          exit(1);
+    17ca:	4505                	li	a0,1
+    17cc:	4b8030ef          	jal	4c84 <exit>
+          exit(0);
+    17d0:	4b4030ef          	jal	4c84 <exit>
+      printf("%s: fork in child failed", s);
+    17d4:	85a6                	mv	a1,s1
+    17d6:	00004517          	auipc	a0,0x4
+    17da:	52250513          	addi	a0,a0,1314 # 5cf8 <malloc+0xb90>
+    17de:	0d7030ef          	jal	50b4 <printf>
+      exit(1);
+    17e2:	4505                	li	a0,1
+    17e4:	4a0030ef          	jal	4c84 <exit>
+
+00000000000017e8 <reparent2>:
+{
+    17e8:	1101                	addi	sp,sp,-32
+    17ea:	ec06                	sd	ra,24(sp)
+    17ec:	e822                	sd	s0,16(sp)
+    17ee:	e426                	sd	s1,8(sp)
+    17f0:	1000                	addi	s0,sp,32
+    17f2:	32000493          	li	s1,800
+    int pid1 = fork();
+    17f6:	486030ef          	jal	4c7c <fork>
+    if(pid1 < 0){
+    17fa:	00054b63          	bltz	a0,1810 <reparent2+0x28>
+    if(pid1 == 0){
+    17fe:	c115                	beqz	a0,1822 <reparent2+0x3a>
+    wait(0);
+    1800:	4501                	li	a0,0
+    1802:	48a030ef          	jal	4c8c <wait>
+  for(int i = 0; i < 800; i++){
+    1806:	34fd                	addiw	s1,s1,-1
+    1808:	f4fd                	bnez	s1,17f6 <reparent2+0xe>
+  exit(0);
+    180a:	4501                	li	a0,0
+    180c:	478030ef          	jal	4c84 <exit>
+      printf("fork failed\n");
+    1810:	00006517          	auipc	a0,0x6
+    1814:	8c050513          	addi	a0,a0,-1856 # 70d0 <malloc+0x1f68>
+    1818:	09d030ef          	jal	50b4 <printf>
+      exit(1);
+    181c:	4505                	li	a0,1
+    181e:	466030ef          	jal	4c84 <exit>
+      fork();
+    1822:	45a030ef          	jal	4c7c <fork>
+      fork();
+    1826:	456030ef          	jal	4c7c <fork>
+      exit(0);
+    182a:	4501                	li	a0,0
+    182c:	458030ef          	jal	4c84 <exit>
+
+0000000000001830 <createdelete>:
+{
+    1830:	7175                	addi	sp,sp,-144
+    1832:	e506                	sd	ra,136(sp)
+    1834:	e122                	sd	s0,128(sp)
+    1836:	fca6                	sd	s1,120(sp)
+    1838:	f8ca                	sd	s2,112(sp)
+    183a:	f4ce                	sd	s3,104(sp)
+    183c:	f0d2                	sd	s4,96(sp)
+    183e:	ecd6                	sd	s5,88(sp)
+    1840:	e8da                	sd	s6,80(sp)
+    1842:	e4de                	sd	s7,72(sp)
+    1844:	e0e2                	sd	s8,64(sp)
+    1846:	fc66                	sd	s9,56(sp)
+    1848:	0900                	addi	s0,sp,144
+    184a:	8caa                	mv	s9,a0
+  for(pi = 0; pi < NCHILD; pi++){
+    184c:	4901                	li	s2,0
+    184e:	4991                	li	s3,4
+    pid = fork();
+    1850:	42c030ef          	jal	4c7c <fork>
+    1854:	84aa                	mv	s1,a0
+    if(pid < 0){
+    1856:	02054d63          	bltz	a0,1890 <createdelete+0x60>
+    if(pid == 0){
+    185a:	c529                	beqz	a0,18a4 <createdelete+0x74>
+  for(pi = 0; pi < NCHILD; pi++){
+    185c:	2905                	addiw	s2,s2,1
+    185e:	ff3919e3          	bne	s2,s3,1850 <createdelete+0x20>
+    1862:	4491                	li	s1,4
+    wait(&xstatus);
+    1864:	f7c40513          	addi	a0,s0,-132
+    1868:	424030ef          	jal	4c8c <wait>
+    if(xstatus != 0)
+    186c:	f7c42903          	lw	s2,-132(s0)
+    1870:	0a091e63          	bnez	s2,192c <createdelete+0xfc>
+  for(pi = 0; pi < NCHILD; pi++){
+    1874:	34fd                	addiw	s1,s1,-1
+    1876:	f4fd                	bnez	s1,1864 <createdelete+0x34>
+  name[0] = name[1] = name[2] = 0;
+    1878:	f8040123          	sb	zero,-126(s0)
+    187c:	03000993          	li	s3,48
+    1880:	5a7d                	li	s4,-1
+    1882:	07000c13          	li	s8,112
+      if((i == 0 || i >= N/2) && fd < 0){
+    1886:	4b25                	li	s6,9
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    1888:	4ba1                	li	s7,8
+    for(pi = 0; pi < NCHILD; pi++){
+    188a:	07400a93          	li	s5,116
+    188e:	aa39                	j	19ac <createdelete+0x17c>
+      printf("%s: fork failed\n", s);
+    1890:	85e6                	mv	a1,s9
+    1892:	00004517          	auipc	a0,0x4
+    1896:	29650513          	addi	a0,a0,662 # 5b28 <malloc+0x9c0>
+    189a:	01b030ef          	jal	50b4 <printf>
+      exit(1);
+    189e:	4505                	li	a0,1
+    18a0:	3e4030ef          	jal	4c84 <exit>
+      name[0] = 'p' + pi;
+    18a4:	0709091b          	addiw	s2,s2,112
+    18a8:	f9240023          	sb	s2,-128(s0)
+      name[2] = '\0';
+    18ac:	f8040123          	sb	zero,-126(s0)
+      for(i = 0; i < N; i++){
+    18b0:	4951                	li	s2,20
+    18b2:	a831                	j	18ce <createdelete+0x9e>
+          printf("%s: create failed\n", s);
+    18b4:	85e6                	mv	a1,s9
+    18b6:	00004517          	auipc	a0,0x4
+    18ba:	30a50513          	addi	a0,a0,778 # 5bc0 <malloc+0xa58>
+    18be:	7f6030ef          	jal	50b4 <printf>
+          exit(1);
+    18c2:	4505                	li	a0,1
+    18c4:	3c0030ef          	jal	4c84 <exit>
+      for(i = 0; i < N; i++){
+    18c8:	2485                	addiw	s1,s1,1
+    18ca:	05248e63          	beq	s1,s2,1926 <createdelete+0xf6>
+        name[1] = '0' + i;
+    18ce:	0304879b          	addiw	a5,s1,48
+    18d2:	f8f400a3          	sb	a5,-127(s0)
+        fd = open(name, O_CREATE | O_RDWR);
+    18d6:	20200593          	li	a1,514
+    18da:	f8040513          	addi	a0,s0,-128
+    18de:	3e6030ef          	jal	4cc4 <open>
+        if(fd < 0){
+    18e2:	fc0549e3          	bltz	a0,18b4 <createdelete+0x84>
+        close(fd);
+    18e6:	3c6030ef          	jal	4cac <close>
+        if(i > 0 && (i % 2 ) == 0){
+    18ea:	10905063          	blez	s1,19ea <createdelete+0x1ba>
+    18ee:	0014f793          	andi	a5,s1,1
+    18f2:	fbf9                	bnez	a5,18c8 <createdelete+0x98>
+          name[1] = '0' + (i / 2);
+    18f4:	01f4d79b          	srliw	a5,s1,0x1f
+    18f8:	9fa5                	addw	a5,a5,s1
+    18fa:	4017d79b          	sraiw	a5,a5,0x1
+    18fe:	0307879b          	addiw	a5,a5,48
+    1902:	f8f400a3          	sb	a5,-127(s0)
+          if(unlink(name) < 0){
+    1906:	f8040513          	addi	a0,s0,-128
+    190a:	3ca030ef          	jal	4cd4 <unlink>
+    190e:	fa055de3          	bgez	a0,18c8 <createdelete+0x98>
+            printf("%s: unlink failed\n", s);
+    1912:	85e6                	mv	a1,s9
+    1914:	00004517          	auipc	a0,0x4
+    1918:	40450513          	addi	a0,a0,1028 # 5d18 <malloc+0xbb0>
+    191c:	798030ef          	jal	50b4 <printf>
+            exit(1);
+    1920:	4505                	li	a0,1
+    1922:	362030ef          	jal	4c84 <exit>
+      exit(0);
+    1926:	4501                	li	a0,0
+    1928:	35c030ef          	jal	4c84 <exit>
+      exit(1);
+    192c:	4505                	li	a0,1
+    192e:	356030ef          	jal	4c84 <exit>
+        printf("%s: oops createdelete %s didn't exist\n", s, name);
+    1932:	f8040613          	addi	a2,s0,-128
+    1936:	85e6                	mv	a1,s9
+    1938:	00004517          	auipc	a0,0x4
+    193c:	3f850513          	addi	a0,a0,1016 # 5d30 <malloc+0xbc8>
+    1940:	774030ef          	jal	50b4 <printf>
+        exit(1);
+    1944:	4505                	li	a0,1
+    1946:	33e030ef          	jal	4c84 <exit>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    194a:	034bfb63          	bgeu	s7,s4,1980 <createdelete+0x150>
+      if(fd >= 0)
+    194e:	02055663          	bgez	a0,197a <createdelete+0x14a>
+    for(pi = 0; pi < NCHILD; pi++){
+    1952:	2485                	addiw	s1,s1,1
+    1954:	0ff4f493          	zext.b	s1,s1
+    1958:	05548263          	beq	s1,s5,199c <createdelete+0x16c>
+      name[0] = 'p' + pi;
+    195c:	f8940023          	sb	s1,-128(s0)
+      name[1] = '0' + i;
+    1960:	f93400a3          	sb	s3,-127(s0)
+      fd = open(name, 0);
+    1964:	4581                	li	a1,0
+    1966:	f8040513          	addi	a0,s0,-128
+    196a:	35a030ef          	jal	4cc4 <open>
+      if((i == 0 || i >= N/2) && fd < 0){
+    196e:	00090463          	beqz	s2,1976 <createdelete+0x146>
+    1972:	fd2b5ce3          	bge	s6,s2,194a <createdelete+0x11a>
+    1976:	fa054ee3          	bltz	a0,1932 <createdelete+0x102>
+        close(fd);
+    197a:	332030ef          	jal	4cac <close>
+    197e:	bfd1                	j	1952 <createdelete+0x122>
+      } else if((i >= 1 && i < N/2) && fd >= 0){
+    1980:	fc0549e3          	bltz	a0,1952 <createdelete+0x122>
+        printf("%s: oops createdelete %s did exist\n", s, name);
+    1984:	f8040613          	addi	a2,s0,-128
+    1988:	85e6                	mv	a1,s9
+    198a:	00004517          	auipc	a0,0x4
+    198e:	3ce50513          	addi	a0,a0,974 # 5d58 <malloc+0xbf0>
+    1992:	722030ef          	jal	50b4 <printf>
+        exit(1);
+    1996:	4505                	li	a0,1
+    1998:	2ec030ef          	jal	4c84 <exit>
+  for(i = 0; i < N; i++){
+    199c:	2905                	addiw	s2,s2,1
+    199e:	2a05                	addiw	s4,s4,1
+    19a0:	2985                	addiw	s3,s3,1
+    19a2:	0ff9f993          	zext.b	s3,s3
+    19a6:	47d1                	li	a5,20
+    19a8:	02f90863          	beq	s2,a5,19d8 <createdelete+0x1a8>
+    for(pi = 0; pi < NCHILD; pi++){
+    19ac:	84e2                	mv	s1,s8
+    19ae:	b77d                	j	195c <createdelete+0x12c>
+  for(i = 0; i < N; i++){
+    19b0:	2905                	addiw	s2,s2,1
+    19b2:	0ff97913          	zext.b	s2,s2
+    19b6:	03490c63          	beq	s2,s4,19ee <createdelete+0x1be>
+  name[0] = name[1] = name[2] = 0;
+    19ba:	84d6                	mv	s1,s5
+      name[0] = 'p' + pi;
+    19bc:	f8940023          	sb	s1,-128(s0)
+      name[1] = '0' + i;
+    19c0:	f92400a3          	sb	s2,-127(s0)
+      unlink(name);
+    19c4:	f8040513          	addi	a0,s0,-128
+    19c8:	30c030ef          	jal	4cd4 <unlink>
+    for(pi = 0; pi < NCHILD; pi++){
+    19cc:	2485                	addiw	s1,s1,1
+    19ce:	0ff4f493          	zext.b	s1,s1
+    19d2:	ff3495e3          	bne	s1,s3,19bc <createdelete+0x18c>
+    19d6:	bfe9                	j	19b0 <createdelete+0x180>
+    19d8:	03000913          	li	s2,48
+  name[0] = name[1] = name[2] = 0;
+    19dc:	07000a93          	li	s5,112
+    for(pi = 0; pi < NCHILD; pi++){
+    19e0:	07400993          	li	s3,116
+  for(i = 0; i < N; i++){
+    19e4:	04400a13          	li	s4,68
+    19e8:	bfc9                	j	19ba <createdelete+0x18a>
+      for(i = 0; i < N; i++){
+    19ea:	2485                	addiw	s1,s1,1
+    19ec:	b5cd                	j	18ce <createdelete+0x9e>
+}
+    19ee:	60aa                	ld	ra,136(sp)
+    19f0:	640a                	ld	s0,128(sp)
+    19f2:	74e6                	ld	s1,120(sp)
+    19f4:	7946                	ld	s2,112(sp)
+    19f6:	79a6                	ld	s3,104(sp)
+    19f8:	7a06                	ld	s4,96(sp)
+    19fa:	6ae6                	ld	s5,88(sp)
+    19fc:	6b46                	ld	s6,80(sp)
+    19fe:	6ba6                	ld	s7,72(sp)
+    1a00:	6c06                	ld	s8,64(sp)
+    1a02:	7ce2                	ld	s9,56(sp)
+    1a04:	6149                	addi	sp,sp,144
+    1a06:	8082                	ret
+
+0000000000001a08 <linkunlink>:
+{
+    1a08:	711d                	addi	sp,sp,-96
+    1a0a:	ec86                	sd	ra,88(sp)
+    1a0c:	e8a2                	sd	s0,80(sp)
+    1a0e:	e4a6                	sd	s1,72(sp)
+    1a10:	e0ca                	sd	s2,64(sp)
+    1a12:	fc4e                	sd	s3,56(sp)
+    1a14:	f852                	sd	s4,48(sp)
+    1a16:	f456                	sd	s5,40(sp)
+    1a18:	f05a                	sd	s6,32(sp)
+    1a1a:	ec5e                	sd	s7,24(sp)
+    1a1c:	e862                	sd	s8,16(sp)
+    1a1e:	e466                	sd	s9,8(sp)
+    1a20:	1080                	addi	s0,sp,96
+    1a22:	84aa                	mv	s1,a0
+  unlink("x");
+    1a24:	00004517          	auipc	a0,0x4
+    1a28:	8e450513          	addi	a0,a0,-1820 # 5308 <malloc+0x1a0>
+    1a2c:	2a8030ef          	jal	4cd4 <unlink>
+  pid = fork();
+    1a30:	24c030ef          	jal	4c7c <fork>
+  if(pid < 0){
+    1a34:	02054b63          	bltz	a0,1a6a <linkunlink+0x62>
+    1a38:	8caa                	mv	s9,a0
+  unsigned int x = (pid ? 1 : 97);
+    1a3a:	06100913          	li	s2,97
+    1a3e:	c111                	beqz	a0,1a42 <linkunlink+0x3a>
+    1a40:	4905                	li	s2,1
+    1a42:	06400493          	li	s1,100
+    x = x * 1103515245 + 12345;
+    1a46:	41c65a37          	lui	s4,0x41c65
+    1a4a:	e6da0a1b          	addiw	s4,s4,-403 # 41c64e6d <base+0x41c551c5>
+    1a4e:	698d                	lui	s3,0x3
+    1a50:	0399899b          	addiw	s3,s3,57 # 3039 <subdir+0x477>
+    if((x % 3) == 0){
+    1a54:	4a8d                	li	s5,3
+    } else if((x % 3) == 1){
+    1a56:	4b85                	li	s7,1
+      unlink("x");
+    1a58:	00004b17          	auipc	s6,0x4
+    1a5c:	8b0b0b13          	addi	s6,s6,-1872 # 5308 <malloc+0x1a0>
+      link("cat", "x");
+    1a60:	00004c17          	auipc	s8,0x4
+    1a64:	320c0c13          	addi	s8,s8,800 # 5d80 <malloc+0xc18>
+    1a68:	a025                	j	1a90 <linkunlink+0x88>
+    printf("%s: fork failed\n", s);
+    1a6a:	85a6                	mv	a1,s1
+    1a6c:	00004517          	auipc	a0,0x4
+    1a70:	0bc50513          	addi	a0,a0,188 # 5b28 <malloc+0x9c0>
+    1a74:	640030ef          	jal	50b4 <printf>
+    exit(1);
+    1a78:	4505                	li	a0,1
+    1a7a:	20a030ef          	jal	4c84 <exit>
+      close(open("x", O_RDWR | O_CREATE));
+    1a7e:	20200593          	li	a1,514
+    1a82:	855a                	mv	a0,s6
+    1a84:	240030ef          	jal	4cc4 <open>
+    1a88:	224030ef          	jal	4cac <close>
+  for(i = 0; i < 100; i++){
+    1a8c:	34fd                	addiw	s1,s1,-1
+    1a8e:	c495                	beqz	s1,1aba <linkunlink+0xb2>
+    x = x * 1103515245 + 12345;
+    1a90:	034907bb          	mulw	a5,s2,s4
+    1a94:	013787bb          	addw	a5,a5,s3
+    1a98:	0007891b          	sext.w	s2,a5
+    if((x % 3) == 0){
+    1a9c:	0357f7bb          	remuw	a5,a5,s5
+    1aa0:	2781                	sext.w	a5,a5
+    1aa2:	dff1                	beqz	a5,1a7e <linkunlink+0x76>
+    } else if((x % 3) == 1){
+    1aa4:	01778663          	beq	a5,s7,1ab0 <linkunlink+0xa8>
+      unlink("x");
+    1aa8:	855a                	mv	a0,s6
+    1aaa:	22a030ef          	jal	4cd4 <unlink>
+    1aae:	bff9                	j	1a8c <linkunlink+0x84>
+      link("cat", "x");
+    1ab0:	85da                	mv	a1,s6
+    1ab2:	8562                	mv	a0,s8
+    1ab4:	230030ef          	jal	4ce4 <link>
+    1ab8:	bfd1                	j	1a8c <linkunlink+0x84>
+  if(pid)
+    1aba:	020c8263          	beqz	s9,1ade <linkunlink+0xd6>
+    wait(0);
+    1abe:	4501                	li	a0,0
+    1ac0:	1cc030ef          	jal	4c8c <wait>
+}
+    1ac4:	60e6                	ld	ra,88(sp)
+    1ac6:	6446                	ld	s0,80(sp)
+    1ac8:	64a6                	ld	s1,72(sp)
+    1aca:	6906                	ld	s2,64(sp)
+    1acc:	79e2                	ld	s3,56(sp)
+    1ace:	7a42                	ld	s4,48(sp)
+    1ad0:	7aa2                	ld	s5,40(sp)
+    1ad2:	7b02                	ld	s6,32(sp)
+    1ad4:	6be2                	ld	s7,24(sp)
+    1ad6:	6c42                	ld	s8,16(sp)
+    1ad8:	6ca2                	ld	s9,8(sp)
+    1ada:	6125                	addi	sp,sp,96
+    1adc:	8082                	ret
+    exit(0);
+    1ade:	4501                	li	a0,0
+    1ae0:	1a4030ef          	jal	4c84 <exit>
+
+0000000000001ae4 <forktest>:
+{
+    1ae4:	7179                	addi	sp,sp,-48
+    1ae6:	f406                	sd	ra,40(sp)
+    1ae8:	f022                	sd	s0,32(sp)
+    1aea:	ec26                	sd	s1,24(sp)
+    1aec:	e84a                	sd	s2,16(sp)
+    1aee:	e44e                	sd	s3,8(sp)
+    1af0:	1800                	addi	s0,sp,48
+    1af2:	89aa                	mv	s3,a0
+  for(n=0; n<N; n++){
+    1af4:	4481                	li	s1,0
+    1af6:	3e800913          	li	s2,1000
+    pid = fork();
+    1afa:	182030ef          	jal	4c7c <fork>
+    if(pid < 0)
+    1afe:	06054063          	bltz	a0,1b5e <forktest+0x7a>
+    if(pid == 0)
+    1b02:	cd11                	beqz	a0,1b1e <forktest+0x3a>
+  for(n=0; n<N; n++){
+    1b04:	2485                	addiw	s1,s1,1
+    1b06:	ff249ae3          	bne	s1,s2,1afa <forktest+0x16>
+    printf("%s: fork claimed to work 1000 times!\n", s);
+    1b0a:	85ce                	mv	a1,s3
+    1b0c:	00004517          	auipc	a0,0x4
+    1b10:	2c450513          	addi	a0,a0,708 # 5dd0 <malloc+0xc68>
+    1b14:	5a0030ef          	jal	50b4 <printf>
+    exit(1);
+    1b18:	4505                	li	a0,1
+    1b1a:	16a030ef          	jal	4c84 <exit>
+      exit(0);
+    1b1e:	166030ef          	jal	4c84 <exit>
+    printf("%s: no fork at all!\n", s);
+    1b22:	85ce                	mv	a1,s3
+    1b24:	00004517          	auipc	a0,0x4
+    1b28:	26450513          	addi	a0,a0,612 # 5d88 <malloc+0xc20>
+    1b2c:	588030ef          	jal	50b4 <printf>
+    exit(1);
+    1b30:	4505                	li	a0,1
+    1b32:	152030ef          	jal	4c84 <exit>
+      printf("%s: wait stopped early\n", s);
+    1b36:	85ce                	mv	a1,s3
+    1b38:	00004517          	auipc	a0,0x4
+    1b3c:	26850513          	addi	a0,a0,616 # 5da0 <malloc+0xc38>
+    1b40:	574030ef          	jal	50b4 <printf>
+      exit(1);
+    1b44:	4505                	li	a0,1
+    1b46:	13e030ef          	jal	4c84 <exit>
+    printf("%s: wait got too many\n", s);
+    1b4a:	85ce                	mv	a1,s3
+    1b4c:	00004517          	auipc	a0,0x4
+    1b50:	26c50513          	addi	a0,a0,620 # 5db8 <malloc+0xc50>
+    1b54:	560030ef          	jal	50b4 <printf>
+    exit(1);
+    1b58:	4505                	li	a0,1
+    1b5a:	12a030ef          	jal	4c84 <exit>
+  if (n == 0) {
+    1b5e:	d0f1                	beqz	s1,1b22 <forktest+0x3e>
+  for(; n > 0; n--){
+    1b60:	00905963          	blez	s1,1b72 <forktest+0x8e>
+    if(wait(0) < 0){
+    1b64:	4501                	li	a0,0
+    1b66:	126030ef          	jal	4c8c <wait>
+    1b6a:	fc0546e3          	bltz	a0,1b36 <forktest+0x52>
+  for(; n > 0; n--){
+    1b6e:	34fd                	addiw	s1,s1,-1
+    1b70:	f8f5                	bnez	s1,1b64 <forktest+0x80>
+  if(wait(0) != -1){
+    1b72:	4501                	li	a0,0
+    1b74:	118030ef          	jal	4c8c <wait>
+    1b78:	57fd                	li	a5,-1
+    1b7a:	fcf518e3          	bne	a0,a5,1b4a <forktest+0x66>
+}
+    1b7e:	70a2                	ld	ra,40(sp)
+    1b80:	7402                	ld	s0,32(sp)
+    1b82:	64e2                	ld	s1,24(sp)
+    1b84:	6942                	ld	s2,16(sp)
+    1b86:	69a2                	ld	s3,8(sp)
+    1b88:	6145                	addi	sp,sp,48
+    1b8a:	8082                	ret
+
+0000000000001b8c <kernmem>:
+{
+    1b8c:	715d                	addi	sp,sp,-80
+    1b8e:	e486                	sd	ra,72(sp)
+    1b90:	e0a2                	sd	s0,64(sp)
+    1b92:	fc26                	sd	s1,56(sp)
+    1b94:	f84a                	sd	s2,48(sp)
+    1b96:	f44e                	sd	s3,40(sp)
+    1b98:	f052                	sd	s4,32(sp)
+    1b9a:	ec56                	sd	s5,24(sp)
+    1b9c:	0880                	addi	s0,sp,80
+    1b9e:	8aaa                	mv	s5,a0
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    1ba0:	4485                	li	s1,1
+    1ba2:	04fe                	slli	s1,s1,0x1f
+    if(xstatus != -1)  // did kernel kill child?
+    1ba4:	5a7d                	li	s4,-1
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    1ba6:	69b1                	lui	s3,0xc
+    1ba8:	35098993          	addi	s3,s3,848 # c350 <uninit+0x1db8>
+    1bac:	1003d937          	lui	s2,0x1003d
+    1bb0:	090e                	slli	s2,s2,0x3
+    1bb2:	48090913          	addi	s2,s2,1152 # 1003d480 <base+0x1002d7d8>
+    pid = fork();
+    1bb6:	0c6030ef          	jal	4c7c <fork>
+    if(pid < 0){
+    1bba:	02054763          	bltz	a0,1be8 <kernmem+0x5c>
+    if(pid == 0){
+    1bbe:	cd1d                	beqz	a0,1bfc <kernmem+0x70>
+    wait(&xstatus);
+    1bc0:	fbc40513          	addi	a0,s0,-68
+    1bc4:	0c8030ef          	jal	4c8c <wait>
+    if(xstatus != -1)  // did kernel kill child?
+    1bc8:	fbc42783          	lw	a5,-68(s0)
+    1bcc:	05479563          	bne	a5,s4,1c16 <kernmem+0x8a>
+  for(a = (char*)(KERNBASE); a < (char*) (KERNBASE+2000000); a += 50000){
+    1bd0:	94ce                	add	s1,s1,s3
+    1bd2:	ff2492e3          	bne	s1,s2,1bb6 <kernmem+0x2a>
+}
+    1bd6:	60a6                	ld	ra,72(sp)
+    1bd8:	6406                	ld	s0,64(sp)
+    1bda:	74e2                	ld	s1,56(sp)
+    1bdc:	7942                	ld	s2,48(sp)
+    1bde:	79a2                	ld	s3,40(sp)
+    1be0:	7a02                	ld	s4,32(sp)
+    1be2:	6ae2                	ld	s5,24(sp)
+    1be4:	6161                	addi	sp,sp,80
+    1be6:	8082                	ret
+      printf("%s: fork failed\n", s);
+    1be8:	85d6                	mv	a1,s5
+    1bea:	00004517          	auipc	a0,0x4
+    1bee:	f3e50513          	addi	a0,a0,-194 # 5b28 <malloc+0x9c0>
+    1bf2:	4c2030ef          	jal	50b4 <printf>
+      exit(1);
+    1bf6:	4505                	li	a0,1
+    1bf8:	08c030ef          	jal	4c84 <exit>
+      printf("%s: oops could read %p = %x\n", s, a, *a);
+    1bfc:	0004c683          	lbu	a3,0(s1)
+    1c00:	8626                	mv	a2,s1
+    1c02:	85d6                	mv	a1,s5
+    1c04:	00004517          	auipc	a0,0x4
+    1c08:	1f450513          	addi	a0,a0,500 # 5df8 <malloc+0xc90>
+    1c0c:	4a8030ef          	jal	50b4 <printf>
+      exit(1);
+    1c10:	4505                	li	a0,1
+    1c12:	072030ef          	jal	4c84 <exit>
+      exit(1);
+    1c16:	4505                	li	a0,1
+    1c18:	06c030ef          	jal	4c84 <exit>
+
+0000000000001c1c <MAXVAplus>:
+{
+    1c1c:	7179                	addi	sp,sp,-48
+    1c1e:	f406                	sd	ra,40(sp)
+    1c20:	f022                	sd	s0,32(sp)
+    1c22:	1800                	addi	s0,sp,48
+  volatile uint64 a = MAXVA;
+    1c24:	4785                	li	a5,1
+    1c26:	179a                	slli	a5,a5,0x26
+    1c28:	fcf43c23          	sd	a5,-40(s0)
+  for( ; a != 0; a <<= 1){
+    1c2c:	fd843783          	ld	a5,-40(s0)
+    1c30:	cf85                	beqz	a5,1c68 <MAXVAplus+0x4c>
+    1c32:	ec26                	sd	s1,24(sp)
+    1c34:	e84a                	sd	s2,16(sp)
+    1c36:	892a                	mv	s2,a0
+    if(xstatus != -1)  // did kernel kill child?
+    1c38:	54fd                	li	s1,-1
+    pid = fork();
+    1c3a:	042030ef          	jal	4c7c <fork>
+    if(pid < 0){
+    1c3e:	02054963          	bltz	a0,1c70 <MAXVAplus+0x54>
+    if(pid == 0){
+    1c42:	c129                	beqz	a0,1c84 <MAXVAplus+0x68>
+    wait(&xstatus);
+    1c44:	fd440513          	addi	a0,s0,-44
+    1c48:	044030ef          	jal	4c8c <wait>
+    if(xstatus != -1)  // did kernel kill child?
+    1c4c:	fd442783          	lw	a5,-44(s0)
+    1c50:	04979c63          	bne	a5,s1,1ca8 <MAXVAplus+0x8c>
+  for( ; a != 0; a <<= 1){
+    1c54:	fd843783          	ld	a5,-40(s0)
+    1c58:	0786                	slli	a5,a5,0x1
+    1c5a:	fcf43c23          	sd	a5,-40(s0)
+    1c5e:	fd843783          	ld	a5,-40(s0)
+    1c62:	ffe1                	bnez	a5,1c3a <MAXVAplus+0x1e>
+    1c64:	64e2                	ld	s1,24(sp)
+    1c66:	6942                	ld	s2,16(sp)
+}
+    1c68:	70a2                	ld	ra,40(sp)
+    1c6a:	7402                	ld	s0,32(sp)
+    1c6c:	6145                	addi	sp,sp,48
+    1c6e:	8082                	ret
+      printf("%s: fork failed\n", s);
+    1c70:	85ca                	mv	a1,s2
+    1c72:	00004517          	auipc	a0,0x4
+    1c76:	eb650513          	addi	a0,a0,-330 # 5b28 <malloc+0x9c0>
+    1c7a:	43a030ef          	jal	50b4 <printf>
+      exit(1);
+    1c7e:	4505                	li	a0,1
+    1c80:	004030ef          	jal	4c84 <exit>
+      *(char*)a = 99;
+    1c84:	fd843783          	ld	a5,-40(s0)
+    1c88:	06300713          	li	a4,99
+    1c8c:	00e78023          	sb	a4,0(a5)
+      printf("%s: oops wrote %p\n", s, (void*)a);
+    1c90:	fd843603          	ld	a2,-40(s0)
+    1c94:	85ca                	mv	a1,s2
+    1c96:	00004517          	auipc	a0,0x4
+    1c9a:	18250513          	addi	a0,a0,386 # 5e18 <malloc+0xcb0>
+    1c9e:	416030ef          	jal	50b4 <printf>
+      exit(1);
+    1ca2:	4505                	li	a0,1
+    1ca4:	7e1020ef          	jal	4c84 <exit>
+      exit(1);
+    1ca8:	4505                	li	a0,1
+    1caa:	7db020ef          	jal	4c84 <exit>
+
+0000000000001cae <stacktest>:
+{
+    1cae:	7179                	addi	sp,sp,-48
+    1cb0:	f406                	sd	ra,40(sp)
+    1cb2:	f022                	sd	s0,32(sp)
+    1cb4:	ec26                	sd	s1,24(sp)
+    1cb6:	1800                	addi	s0,sp,48
+    1cb8:	84aa                	mv	s1,a0
+  pid = fork();
+    1cba:	7c3020ef          	jal	4c7c <fork>
+  if(pid == 0) {
+    1cbe:	cd11                	beqz	a0,1cda <stacktest+0x2c>
+  } else if(pid < 0){
+    1cc0:	02054c63          	bltz	a0,1cf8 <stacktest+0x4a>
+  wait(&xstatus);
+    1cc4:	fdc40513          	addi	a0,s0,-36
+    1cc8:	7c5020ef          	jal	4c8c <wait>
+  if(xstatus == -1)  // kernel killed child?
+    1ccc:	fdc42503          	lw	a0,-36(s0)
+    1cd0:	57fd                	li	a5,-1
+    1cd2:	02f50d63          	beq	a0,a5,1d0c <stacktest+0x5e>
+    exit(xstatus);
+    1cd6:	7af020ef          	jal	4c84 <exit>
+
+static inline uint64
+r_sp()
+{
+  uint64 x;
+  asm volatile("mv %0, sp" : "=r" (x) );
+    1cda:	870a                	mv	a4,sp
+    printf("%s: stacktest: read below stack %d\n", s, *sp);
+    1cdc:	77fd                	lui	a5,0xfffff
+    1cde:	97ba                	add	a5,a5,a4
+    1ce0:	0007c603          	lbu	a2,0(a5) # fffffffffffff000 <base+0xfffffffffffef358>
+    1ce4:	85a6                	mv	a1,s1
+    1ce6:	00004517          	auipc	a0,0x4
+    1cea:	14a50513          	addi	a0,a0,330 # 5e30 <malloc+0xcc8>
+    1cee:	3c6030ef          	jal	50b4 <printf>
+    exit(1);
+    1cf2:	4505                	li	a0,1
+    1cf4:	791020ef          	jal	4c84 <exit>
+    printf("%s: fork failed\n", s);
+    1cf8:	85a6                	mv	a1,s1
+    1cfa:	00004517          	auipc	a0,0x4
+    1cfe:	e2e50513          	addi	a0,a0,-466 # 5b28 <malloc+0x9c0>
+    1d02:	3b2030ef          	jal	50b4 <printf>
+    exit(1);
+    1d06:	4505                	li	a0,1
+    1d08:	77d020ef          	jal	4c84 <exit>
+    exit(0);
+    1d0c:	4501                	li	a0,0
+    1d0e:	777020ef          	jal	4c84 <exit>
+
+0000000000001d12 <nowrite>:
+{
+    1d12:	7159                	addi	sp,sp,-112
+    1d14:	f486                	sd	ra,104(sp)
+    1d16:	f0a2                	sd	s0,96(sp)
+    1d18:	eca6                	sd	s1,88(sp)
+    1d1a:	e8ca                	sd	s2,80(sp)
+    1d1c:	e4ce                	sd	s3,72(sp)
+    1d1e:	1880                	addi	s0,sp,112
+    1d20:	89aa                	mv	s3,a0
+  uint64 addrs[] = { 0, 0x80000000LL, 0x3fffffe000, 0x3ffffff000, 0x4000000000,
+    1d22:	00006797          	auipc	a5,0x6
+    1d26:	9c678793          	addi	a5,a5,-1594 # 76e8 <malloc+0x2580>
+    1d2a:	7788                	ld	a0,40(a5)
+    1d2c:	7b8c                	ld	a1,48(a5)
+    1d2e:	7f90                	ld	a2,56(a5)
+    1d30:	63b4                	ld	a3,64(a5)
+    1d32:	67b8                	ld	a4,72(a5)
+    1d34:	6bbc                	ld	a5,80(a5)
+    1d36:	f8a43c23          	sd	a0,-104(s0)
+    1d3a:	fab43023          	sd	a1,-96(s0)
+    1d3e:	fac43423          	sd	a2,-88(s0)
+    1d42:	fad43823          	sd	a3,-80(s0)
+    1d46:	fae43c23          	sd	a4,-72(s0)
+    1d4a:	fcf43023          	sd	a5,-64(s0)
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+    1d4e:	4481                	li	s1,0
+    1d50:	4919                	li	s2,6
+    pid = fork();
+    1d52:	72b020ef          	jal	4c7c <fork>
+    if(pid == 0) {
+    1d56:	c105                	beqz	a0,1d76 <nowrite+0x64>
+    } else if(pid < 0){
+    1d58:	04054263          	bltz	a0,1d9c <nowrite+0x8a>
+    wait(&xstatus);
+    1d5c:	fcc40513          	addi	a0,s0,-52
+    1d60:	72d020ef          	jal	4c8c <wait>
+    if(xstatus == 0){
+    1d64:	fcc42783          	lw	a5,-52(s0)
+    1d68:	c7a1                	beqz	a5,1db0 <nowrite+0x9e>
+  for(int ai = 0; ai < sizeof(addrs)/sizeof(addrs[0]); ai++){
+    1d6a:	2485                	addiw	s1,s1,1
+    1d6c:	ff2493e3          	bne	s1,s2,1d52 <nowrite+0x40>
+  exit(0);
+    1d70:	4501                	li	a0,0
+    1d72:	713020ef          	jal	4c84 <exit>
+      volatile int *addr = (int *) addrs[ai];
+    1d76:	048e                	slli	s1,s1,0x3
+    1d78:	fd048793          	addi	a5,s1,-48
+    1d7c:	008784b3          	add	s1,a5,s0
+    1d80:	fc84b603          	ld	a2,-56(s1)
+      *addr = 10;
+    1d84:	47a9                	li	a5,10
+    1d86:	c21c                	sw	a5,0(a2)
+      printf("%s: write to %p did not fail!\n", s, addr);
+    1d88:	85ce                	mv	a1,s3
+    1d8a:	00004517          	auipc	a0,0x4
+    1d8e:	0ce50513          	addi	a0,a0,206 # 5e58 <malloc+0xcf0>
+    1d92:	322030ef          	jal	50b4 <printf>
+      exit(0);
+    1d96:	4501                	li	a0,0
+    1d98:	6ed020ef          	jal	4c84 <exit>
+      printf("%s: fork failed\n", s);
+    1d9c:	85ce                	mv	a1,s3
+    1d9e:	00004517          	auipc	a0,0x4
+    1da2:	d8a50513          	addi	a0,a0,-630 # 5b28 <malloc+0x9c0>
+    1da6:	30e030ef          	jal	50b4 <printf>
+      exit(1);
+    1daa:	4505                	li	a0,1
+    1dac:	6d9020ef          	jal	4c84 <exit>
+      exit(1);
+    1db0:	4505                	li	a0,1
+    1db2:	6d3020ef          	jal	4c84 <exit>
+
+0000000000001db6 <manywrites>:
+{
+    1db6:	711d                	addi	sp,sp,-96
+    1db8:	ec86                	sd	ra,88(sp)
+    1dba:	e8a2                	sd	s0,80(sp)
+    1dbc:	e4a6                	sd	s1,72(sp)
+    1dbe:	e0ca                	sd	s2,64(sp)
+    1dc0:	fc4e                	sd	s3,56(sp)
+    1dc2:	f456                	sd	s5,40(sp)
+    1dc4:	1080                	addi	s0,sp,96
+    1dc6:	8aaa                	mv	s5,a0
+  for(int ci = 0; ci < nchildren; ci++){
+    1dc8:	4981                	li	s3,0
+    1dca:	4911                	li	s2,4
+    int pid = fork();
+    1dcc:	6b1020ef          	jal	4c7c <fork>
+    1dd0:	84aa                	mv	s1,a0
+    if(pid < 0){
+    1dd2:	02054963          	bltz	a0,1e04 <manywrites+0x4e>
+    if(pid == 0){
+    1dd6:	c139                	beqz	a0,1e1c <manywrites+0x66>
+  for(int ci = 0; ci < nchildren; ci++){
+    1dd8:	2985                	addiw	s3,s3,1
+    1dda:	ff2999e3          	bne	s3,s2,1dcc <manywrites+0x16>
+    1dde:	f852                	sd	s4,48(sp)
+    1de0:	f05a                	sd	s6,32(sp)
+    1de2:	ec5e                	sd	s7,24(sp)
+    1de4:	4491                	li	s1,4
+    int st = 0;
+    1de6:	fa042423          	sw	zero,-88(s0)
+    wait(&st);
+    1dea:	fa840513          	addi	a0,s0,-88
+    1dee:	69f020ef          	jal	4c8c <wait>
+    if(st != 0)
+    1df2:	fa842503          	lw	a0,-88(s0)
+    1df6:	0c051863          	bnez	a0,1ec6 <manywrites+0x110>
+  for(int ci = 0; ci < nchildren; ci++){
+    1dfa:	34fd                	addiw	s1,s1,-1
+    1dfc:	f4ed                	bnez	s1,1de6 <manywrites+0x30>
+  exit(0);
+    1dfe:	4501                	li	a0,0
+    1e00:	685020ef          	jal	4c84 <exit>
+    1e04:	f852                	sd	s4,48(sp)
+    1e06:	f05a                	sd	s6,32(sp)
+    1e08:	ec5e                	sd	s7,24(sp)
+      printf("fork failed\n");
+    1e0a:	00005517          	auipc	a0,0x5
+    1e0e:	2c650513          	addi	a0,a0,710 # 70d0 <malloc+0x1f68>
+    1e12:	2a2030ef          	jal	50b4 <printf>
+      exit(1);
+    1e16:	4505                	li	a0,1
+    1e18:	66d020ef          	jal	4c84 <exit>
+    1e1c:	f852                	sd	s4,48(sp)
+    1e1e:	f05a                	sd	s6,32(sp)
+    1e20:	ec5e                	sd	s7,24(sp)
+      name[0] = 'b';
+    1e22:	06200793          	li	a5,98
+    1e26:	faf40423          	sb	a5,-88(s0)
+      name[1] = 'a' + ci;
+    1e2a:	0619879b          	addiw	a5,s3,97
+    1e2e:	faf404a3          	sb	a5,-87(s0)
+      name[2] = '\0';
+    1e32:	fa040523          	sb	zero,-86(s0)
+      unlink(name);
+    1e36:	fa840513          	addi	a0,s0,-88
+    1e3a:	69b020ef          	jal	4cd4 <unlink>
+    1e3e:	4bf9                	li	s7,30
+          int cc = write(fd, buf, sz);
+    1e40:	0000bb17          	auipc	s6,0xb
+    1e44:	e68b0b13          	addi	s6,s6,-408 # cca8 <buf>
+        for(int i = 0; i < ci+1; i++){
+    1e48:	8a26                	mv	s4,s1
+    1e4a:	0209c863          	bltz	s3,1e7a <manywrites+0xc4>
+          int fd = open(name, O_CREATE | O_RDWR);
+    1e4e:	20200593          	li	a1,514
+    1e52:	fa840513          	addi	a0,s0,-88
+    1e56:	66f020ef          	jal	4cc4 <open>
+    1e5a:	892a                	mv	s2,a0
+          if(fd < 0){
+    1e5c:	02054d63          	bltz	a0,1e96 <manywrites+0xe0>
+          int cc = write(fd, buf, sz);
+    1e60:	660d                	lui	a2,0x3
+    1e62:	85da                	mv	a1,s6
+    1e64:	641020ef          	jal	4ca4 <write>
+          if(cc != sz){
+    1e68:	678d                	lui	a5,0x3
+    1e6a:	04f51263          	bne	a0,a5,1eae <manywrites+0xf8>
+          close(fd);
+    1e6e:	854a                	mv	a0,s2
+    1e70:	63d020ef          	jal	4cac <close>
+        for(int i = 0; i < ci+1; i++){
+    1e74:	2a05                	addiw	s4,s4,1
+    1e76:	fd49dce3          	bge	s3,s4,1e4e <manywrites+0x98>
+        unlink(name);
+    1e7a:	fa840513          	addi	a0,s0,-88
+    1e7e:	657020ef          	jal	4cd4 <unlink>
+      for(int iters = 0; iters < howmany; iters++){
+    1e82:	3bfd                	addiw	s7,s7,-1
+    1e84:	fc0b92e3          	bnez	s7,1e48 <manywrites+0x92>
+      unlink(name);
+    1e88:	fa840513          	addi	a0,s0,-88
+    1e8c:	649020ef          	jal	4cd4 <unlink>
+      exit(0);
+    1e90:	4501                	li	a0,0
+    1e92:	5f3020ef          	jal	4c84 <exit>
+            printf("%s: cannot create %s\n", s, name);
+    1e96:	fa840613          	addi	a2,s0,-88
+    1e9a:	85d6                	mv	a1,s5
+    1e9c:	00004517          	auipc	a0,0x4
+    1ea0:	fdc50513          	addi	a0,a0,-36 # 5e78 <malloc+0xd10>
+    1ea4:	210030ef          	jal	50b4 <printf>
+            exit(1);
+    1ea8:	4505                	li	a0,1
+    1eaa:	5db020ef          	jal	4c84 <exit>
+            printf("%s: write(%d) ret %d\n", s, sz, cc);
+    1eae:	86aa                	mv	a3,a0
+    1eb0:	660d                	lui	a2,0x3
+    1eb2:	85d6                	mv	a1,s5
+    1eb4:	00003517          	auipc	a0,0x3
+    1eb8:	4b450513          	addi	a0,a0,1204 # 5368 <malloc+0x200>
+    1ebc:	1f8030ef          	jal	50b4 <printf>
+            exit(1);
+    1ec0:	4505                	li	a0,1
+    1ec2:	5c3020ef          	jal	4c84 <exit>
+      exit(st);
+    1ec6:	5bf020ef          	jal	4c84 <exit>
+
+0000000000001eca <copyinstr3>:
+{
+    1eca:	7179                	addi	sp,sp,-48
+    1ecc:	f406                	sd	ra,40(sp)
+    1ece:	f022                	sd	s0,32(sp)
+    1ed0:	ec26                	sd	s1,24(sp)
+    1ed2:	1800                	addi	s0,sp,48
+  sbrk(8192);
+    1ed4:	6509                	lui	a0,0x2
+    1ed6:	57b020ef          	jal	4c50 <sbrk>
+  uint64 top = (uint64) sbrk(0);
+    1eda:	4501                	li	a0,0
+    1edc:	575020ef          	jal	4c50 <sbrk>
+  if((top % PGSIZE) != 0){
+    1ee0:	03451793          	slli	a5,a0,0x34
+    1ee4:	e7bd                	bnez	a5,1f52 <copyinstr3+0x88>
+  top = (uint64) sbrk(0);
+    1ee6:	4501                	li	a0,0
+    1ee8:	569020ef          	jal	4c50 <sbrk>
+  if(top % PGSIZE){
+    1eec:	03451793          	slli	a5,a0,0x34
+    1ef0:	ebad                	bnez	a5,1f62 <copyinstr3+0x98>
+  char *b = (char *) (top - 1);
+    1ef2:	fff50493          	addi	s1,a0,-1 # 1fff <rwsbrk+0x31>
+  *b = 'x';
+    1ef6:	07800793          	li	a5,120
+    1efa:	fef50fa3          	sb	a5,-1(a0)
+  int ret = unlink(b);
+    1efe:	8526                	mv	a0,s1
+    1f00:	5d5020ef          	jal	4cd4 <unlink>
+  if(ret != -1){
+    1f04:	57fd                	li	a5,-1
+    1f06:	06f51763          	bne	a0,a5,1f74 <copyinstr3+0xaa>
+  int fd = open(b, O_CREATE | O_WRONLY);
+    1f0a:	20100593          	li	a1,513
+    1f0e:	8526                	mv	a0,s1
+    1f10:	5b5020ef          	jal	4cc4 <open>
+  if(fd != -1){
+    1f14:	57fd                	li	a5,-1
+    1f16:	06f51a63          	bne	a0,a5,1f8a <copyinstr3+0xc0>
+  ret = link(b, b);
+    1f1a:	85a6                	mv	a1,s1
+    1f1c:	8526                	mv	a0,s1
+    1f1e:	5c7020ef          	jal	4ce4 <link>
+  if(ret != -1){
+    1f22:	57fd                	li	a5,-1
+    1f24:	06f51e63          	bne	a0,a5,1fa0 <copyinstr3+0xd6>
+  char *args[] = { "xx", 0 };
+    1f28:	00005797          	auipc	a5,0x5
+    1f2c:	c5078793          	addi	a5,a5,-944 # 6b78 <malloc+0x1a10>
+    1f30:	fcf43823          	sd	a5,-48(s0)
+    1f34:	fc043c23          	sd	zero,-40(s0)
+  ret = exec(b, args);
+    1f38:	fd040593          	addi	a1,s0,-48
+    1f3c:	8526                	mv	a0,s1
+    1f3e:	57f020ef          	jal	4cbc <exec>
+  if(ret != -1){
+    1f42:	57fd                	li	a5,-1
+    1f44:	06f51a63          	bne	a0,a5,1fb8 <copyinstr3+0xee>
+}
+    1f48:	70a2                	ld	ra,40(sp)
+    1f4a:	7402                	ld	s0,32(sp)
+    1f4c:	64e2                	ld	s1,24(sp)
+    1f4e:	6145                	addi	sp,sp,48
+    1f50:	8082                	ret
+    sbrk(PGSIZE - (top % PGSIZE));
+    1f52:	0347d513          	srli	a0,a5,0x34
+    1f56:	6785                	lui	a5,0x1
+    1f58:	40a7853b          	subw	a0,a5,a0
+    1f5c:	4f5020ef          	jal	4c50 <sbrk>
+    1f60:	b759                	j	1ee6 <copyinstr3+0x1c>
+    printf("oops\n");
+    1f62:	00004517          	auipc	a0,0x4
+    1f66:	f2e50513          	addi	a0,a0,-210 # 5e90 <malloc+0xd28>
+    1f6a:	14a030ef          	jal	50b4 <printf>
+    exit(1);
+    1f6e:	4505                	li	a0,1
+    1f70:	515020ef          	jal	4c84 <exit>
+    printf("unlink(%s) returned %d, not -1\n", b, ret);
+    1f74:	862a                	mv	a2,a0
+    1f76:	85a6                	mv	a1,s1
+    1f78:	00004517          	auipc	a0,0x4
+    1f7c:	ad050513          	addi	a0,a0,-1328 # 5a48 <malloc+0x8e0>
+    1f80:	134030ef          	jal	50b4 <printf>
+    exit(1);
+    1f84:	4505                	li	a0,1
+    1f86:	4ff020ef          	jal	4c84 <exit>
+    printf("open(%s) returned %d, not -1\n", b, fd);
+    1f8a:	862a                	mv	a2,a0
+    1f8c:	85a6                	mv	a1,s1
+    1f8e:	00004517          	auipc	a0,0x4
+    1f92:	ada50513          	addi	a0,a0,-1318 # 5a68 <malloc+0x900>
+    1f96:	11e030ef          	jal	50b4 <printf>
+    exit(1);
+    1f9a:	4505                	li	a0,1
+    1f9c:	4e9020ef          	jal	4c84 <exit>
+    printf("link(%s, %s) returned %d, not -1\n", b, b, ret);
+    1fa0:	86aa                	mv	a3,a0
+    1fa2:	8626                	mv	a2,s1
+    1fa4:	85a6                	mv	a1,s1
+    1fa6:	00004517          	auipc	a0,0x4
+    1faa:	ae250513          	addi	a0,a0,-1310 # 5a88 <malloc+0x920>
+    1fae:	106030ef          	jal	50b4 <printf>
+    exit(1);
+    1fb2:	4505                	li	a0,1
+    1fb4:	4d1020ef          	jal	4c84 <exit>
+    printf("exec(%s) returned %d, not -1\n", b, fd);
+    1fb8:	567d                	li	a2,-1
+    1fba:	85a6                	mv	a1,s1
+    1fbc:	00004517          	auipc	a0,0x4
+    1fc0:	af450513          	addi	a0,a0,-1292 # 5ab0 <malloc+0x948>
+    1fc4:	0f0030ef          	jal	50b4 <printf>
+    exit(1);
+    1fc8:	4505                	li	a0,1
+    1fca:	4bb020ef          	jal	4c84 <exit>
+
+0000000000001fce <rwsbrk>:
+{
+    1fce:	1101                	addi	sp,sp,-32
+    1fd0:	ec06                	sd	ra,24(sp)
+    1fd2:	e822                	sd	s0,16(sp)
+    1fd4:	1000                	addi	s0,sp,32
+  uint64 a = (uint64) sbrk(8192);
+    1fd6:	6509                	lui	a0,0x2
+    1fd8:	479020ef          	jal	4c50 <sbrk>
+  if(a == (uint64) SBRK_ERROR) {
+    1fdc:	57fd                	li	a5,-1
+    1fde:	04f50a63          	beq	a0,a5,2032 <rwsbrk+0x64>
+    1fe2:	e426                	sd	s1,8(sp)
+    1fe4:	84aa                	mv	s1,a0
+  if (sbrk(-8192) == SBRK_ERROR) {
+    1fe6:	7579                	lui	a0,0xffffe
+    1fe8:	469020ef          	jal	4c50 <sbrk>
+    1fec:	57fd                	li	a5,-1
+    1fee:	04f50d63          	beq	a0,a5,2048 <rwsbrk+0x7a>
+    1ff2:	e04a                	sd	s2,0(sp)
+  fd = open("rwsbrk", O_CREATE|O_WRONLY);
+    1ff4:	20100593          	li	a1,513
+    1ff8:	00004517          	auipc	a0,0x4
+    1ffc:	ed850513          	addi	a0,a0,-296 # 5ed0 <malloc+0xd68>
+    2000:	4c5020ef          	jal	4cc4 <open>
+    2004:	892a                	mv	s2,a0
+  if(fd < 0){
+    2006:	04054b63          	bltz	a0,205c <rwsbrk+0x8e>
+  n = write(fd, (void*)(a+PGSIZE), 1024);
+    200a:	6785                	lui	a5,0x1
+    200c:	94be                	add	s1,s1,a5
+    200e:	40000613          	li	a2,1024
+    2012:	85a6                	mv	a1,s1
+    2014:	491020ef          	jal	4ca4 <write>
+    2018:	862a                	mv	a2,a0
+  if(n >= 0){
+    201a:	04054a63          	bltz	a0,206e <rwsbrk+0xa0>
+    printf("write(fd, %p, 1024) returned %d, not -1\n", (void*)a+PGSIZE, n);
+    201e:	85a6                	mv	a1,s1
+    2020:	00004517          	auipc	a0,0x4
+    2024:	ed050513          	addi	a0,a0,-304 # 5ef0 <malloc+0xd88>
+    2028:	08c030ef          	jal	50b4 <printf>
+    exit(1);
+    202c:	4505                	li	a0,1
+    202e:	457020ef          	jal	4c84 <exit>
+    2032:	e426                	sd	s1,8(sp)
+    2034:	e04a                	sd	s2,0(sp)
+    printf("sbrk(rwsbrk) failed\n");
+    2036:	00004517          	auipc	a0,0x4
+    203a:	e6250513          	addi	a0,a0,-414 # 5e98 <malloc+0xd30>
+    203e:	076030ef          	jal	50b4 <printf>
+    exit(1);
+    2042:	4505                	li	a0,1
+    2044:	441020ef          	jal	4c84 <exit>
+    2048:	e04a                	sd	s2,0(sp)
+    printf("sbrk(rwsbrk) shrink failed\n");
+    204a:	00004517          	auipc	a0,0x4
+    204e:	e6650513          	addi	a0,a0,-410 # 5eb0 <malloc+0xd48>
+    2052:	062030ef          	jal	50b4 <printf>
+    exit(1);
+    2056:	4505                	li	a0,1
+    2058:	42d020ef          	jal	4c84 <exit>
+    printf("open(rwsbrk) failed\n");
+    205c:	00004517          	auipc	a0,0x4
+    2060:	e7c50513          	addi	a0,a0,-388 # 5ed8 <malloc+0xd70>
+    2064:	050030ef          	jal	50b4 <printf>
+    exit(1);
+    2068:	4505                	li	a0,1
+    206a:	41b020ef          	jal	4c84 <exit>
+  close(fd);
+    206e:	854a                	mv	a0,s2
+    2070:	43d020ef          	jal	4cac <close>
+  unlink("rwsbrk");
+    2074:	00004517          	auipc	a0,0x4
+    2078:	e5c50513          	addi	a0,a0,-420 # 5ed0 <malloc+0xd68>
+    207c:	459020ef          	jal	4cd4 <unlink>
+  fd = open("README", O_RDONLY);
+    2080:	4581                	li	a1,0
+    2082:	00003517          	auipc	a0,0x3
+    2086:	3ee50513          	addi	a0,a0,1006 # 5470 <malloc+0x308>
+    208a:	43b020ef          	jal	4cc4 <open>
+    208e:	892a                	mv	s2,a0
+  if(fd < 0){
+    2090:	02054363          	bltz	a0,20b6 <rwsbrk+0xe8>
+  n = read(fd, (void*)(a+PGSIZE), 10);
+    2094:	4629                	li	a2,10
+    2096:	85a6                	mv	a1,s1
+    2098:	405020ef          	jal	4c9c <read>
+    209c:	862a                	mv	a2,a0
+  if(n >= 0){
+    209e:	02054563          	bltz	a0,20c8 <rwsbrk+0xfa>
+    printf("read(fd, %p, 10) returned %d, not -1\n", (void*)a+PGSIZE, n);
+    20a2:	85a6                	mv	a1,s1
+    20a4:	00004517          	auipc	a0,0x4
+    20a8:	e7c50513          	addi	a0,a0,-388 # 5f20 <malloc+0xdb8>
+    20ac:	008030ef          	jal	50b4 <printf>
+    exit(1);
+    20b0:	4505                	li	a0,1
+    20b2:	3d3020ef          	jal	4c84 <exit>
+    printf("open(README) failed\n");
+    20b6:	00003517          	auipc	a0,0x3
+    20ba:	3c250513          	addi	a0,a0,962 # 5478 <malloc+0x310>
+    20be:	7f7020ef          	jal	50b4 <printf>
+    exit(1);
+    20c2:	4505                	li	a0,1
+    20c4:	3c1020ef          	jal	4c84 <exit>
+  close(fd);
+    20c8:	854a                	mv	a0,s2
+    20ca:	3e3020ef          	jal	4cac <close>
+  exit(0);
+    20ce:	4501                	li	a0,0
+    20d0:	3b5020ef          	jal	4c84 <exit>
+
+00000000000020d4 <sbrkbasic>:
+{
+    20d4:	7139                	addi	sp,sp,-64
+    20d6:	fc06                	sd	ra,56(sp)
+    20d8:	f822                	sd	s0,48(sp)
+    20da:	ec4e                	sd	s3,24(sp)
+    20dc:	0080                	addi	s0,sp,64
+    20de:	89aa                	mv	s3,a0
+  pid = fork();
+    20e0:	39d020ef          	jal	4c7c <fork>
+  if(pid < 0){
+    20e4:	02054b63          	bltz	a0,211a <sbrkbasic+0x46>
+  if(pid == 0){
+    20e8:	e939                	bnez	a0,213e <sbrkbasic+0x6a>
+    a = sbrk(TOOMUCH);
+    20ea:	40000537          	lui	a0,0x40000
+    20ee:	363020ef          	jal	4c50 <sbrk>
+    if(a == (char*)SBRK_ERROR){
+    20f2:	57fd                	li	a5,-1
+    20f4:	02f50f63          	beq	a0,a5,2132 <sbrkbasic+0x5e>
+    20f8:	f426                	sd	s1,40(sp)
+    20fa:	f04a                	sd	s2,32(sp)
+    20fc:	e852                	sd	s4,16(sp)
+    for(b = a; b < a+TOOMUCH; b += PGSIZE){
+    20fe:	400007b7          	lui	a5,0x40000
+    2102:	97aa                	add	a5,a5,a0
+      *b = 99;
+    2104:	06300693          	li	a3,99
+    for(b = a; b < a+TOOMUCH; b += PGSIZE){
+    2108:	6705                	lui	a4,0x1
+      *b = 99;
+    210a:	00d50023          	sb	a3,0(a0) # 40000000 <base+0x3fff0358>
+    for(b = a; b < a+TOOMUCH; b += PGSIZE){
+    210e:	953a                	add	a0,a0,a4
+    2110:	fef51de3          	bne	a0,a5,210a <sbrkbasic+0x36>
+    exit(1);
+    2114:	4505                	li	a0,1
+    2116:	36f020ef          	jal	4c84 <exit>
+    211a:	f426                	sd	s1,40(sp)
+    211c:	f04a                	sd	s2,32(sp)
+    211e:	e852                	sd	s4,16(sp)
+    printf("fork failed in sbrkbasic\n");
+    2120:	00004517          	auipc	a0,0x4
+    2124:	e2850513          	addi	a0,a0,-472 # 5f48 <malloc+0xde0>
+    2128:	78d020ef          	jal	50b4 <printf>
+    exit(1);
+    212c:	4505                	li	a0,1
+    212e:	357020ef          	jal	4c84 <exit>
+    2132:	f426                	sd	s1,40(sp)
+    2134:	f04a                	sd	s2,32(sp)
+    2136:	e852                	sd	s4,16(sp)
+      exit(0);
+    2138:	4501                	li	a0,0
+    213a:	34b020ef          	jal	4c84 <exit>
+  wait(&xstatus);
+    213e:	fcc40513          	addi	a0,s0,-52
+    2142:	34b020ef          	jal	4c8c <wait>
+  if(xstatus == 1){
+    2146:	fcc42703          	lw	a4,-52(s0)
+    214a:	4785                	li	a5,1
+    214c:	00f70e63          	beq	a4,a5,2168 <sbrkbasic+0x94>
+    2150:	f426                	sd	s1,40(sp)
+    2152:	f04a                	sd	s2,32(sp)
+    2154:	e852                	sd	s4,16(sp)
+  a = sbrk(0);
+    2156:	4501                	li	a0,0
+    2158:	2f9020ef          	jal	4c50 <sbrk>
+    215c:	84aa                	mv	s1,a0
+  for(i = 0; i < 5000; i++){
+    215e:	4901                	li	s2,0
+    2160:	6a05                	lui	s4,0x1
+    2162:	388a0a13          	addi	s4,s4,904 # 1388 <exectest+0x4a>
+    2166:	a839                	j	2184 <sbrkbasic+0xb0>
+    2168:	f426                	sd	s1,40(sp)
+    216a:	f04a                	sd	s2,32(sp)
+    216c:	e852                	sd	s4,16(sp)
+    printf("%s: too much memory allocated!\n", s);
+    216e:	85ce                	mv	a1,s3
+    2170:	00004517          	auipc	a0,0x4
+    2174:	df850513          	addi	a0,a0,-520 # 5f68 <malloc+0xe00>
+    2178:	73d020ef          	jal	50b4 <printf>
+    exit(1);
+    217c:	4505                	li	a0,1
+    217e:	307020ef          	jal	4c84 <exit>
+    2182:	84be                	mv	s1,a5
+    b = sbrk(1);
+    2184:	4505                	li	a0,1
+    2186:	2cb020ef          	jal	4c50 <sbrk>
+    if(b != a){
+    218a:	04951263          	bne	a0,s1,21ce <sbrkbasic+0xfa>
+    *b = 1;
+    218e:	4785                	li	a5,1
+    2190:	00f48023          	sb	a5,0(s1)
+    a = b + 1;
+    2194:	00148793          	addi	a5,s1,1
+  for(i = 0; i < 5000; i++){
+    2198:	2905                	addiw	s2,s2,1
+    219a:	ff4914e3          	bne	s2,s4,2182 <sbrkbasic+0xae>
+  pid = fork();
+    219e:	2df020ef          	jal	4c7c <fork>
+    21a2:	892a                	mv	s2,a0
+  if(pid < 0){
+    21a4:	04054263          	bltz	a0,21e8 <sbrkbasic+0x114>
+  c = sbrk(1);
+    21a8:	4505                	li	a0,1
+    21aa:	2a7020ef          	jal	4c50 <sbrk>
+  c = sbrk(1);
+    21ae:	4505                	li	a0,1
+    21b0:	2a1020ef          	jal	4c50 <sbrk>
+  if(c != a + 1){
+    21b4:	0489                	addi	s1,s1,2
+    21b6:	04a48363          	beq	s1,a0,21fc <sbrkbasic+0x128>
+    printf("%s: sbrk test failed post-fork\n", s);
+    21ba:	85ce                	mv	a1,s3
+    21bc:	00004517          	auipc	a0,0x4
+    21c0:	e0c50513          	addi	a0,a0,-500 # 5fc8 <malloc+0xe60>
+    21c4:	6f1020ef          	jal	50b4 <printf>
+    exit(1);
+    21c8:	4505                	li	a0,1
+    21ca:	2bb020ef          	jal	4c84 <exit>
+      printf("%s: sbrk test failed %d %p %p\n", s, i, a, b);
+    21ce:	872a                	mv	a4,a0
+    21d0:	86a6                	mv	a3,s1
+    21d2:	864a                	mv	a2,s2
+    21d4:	85ce                	mv	a1,s3
+    21d6:	00004517          	auipc	a0,0x4
+    21da:	db250513          	addi	a0,a0,-590 # 5f88 <malloc+0xe20>
+    21de:	6d7020ef          	jal	50b4 <printf>
+      exit(1);
+    21e2:	4505                	li	a0,1
+    21e4:	2a1020ef          	jal	4c84 <exit>
+    printf("%s: sbrk test fork failed\n", s);
+    21e8:	85ce                	mv	a1,s3
+    21ea:	00004517          	auipc	a0,0x4
+    21ee:	dbe50513          	addi	a0,a0,-578 # 5fa8 <malloc+0xe40>
+    21f2:	6c3020ef          	jal	50b4 <printf>
+    exit(1);
+    21f6:	4505                	li	a0,1
+    21f8:	28d020ef          	jal	4c84 <exit>
+  if(pid == 0)
+    21fc:	00091563          	bnez	s2,2206 <sbrkbasic+0x132>
+    exit(0);
+    2200:	4501                	li	a0,0
+    2202:	283020ef          	jal	4c84 <exit>
+  wait(&xstatus);
+    2206:	fcc40513          	addi	a0,s0,-52
+    220a:	283020ef          	jal	4c8c <wait>
+  exit(xstatus);
+    220e:	fcc42503          	lw	a0,-52(s0)
+    2212:	273020ef          	jal	4c84 <exit>
+
+0000000000002216 <sbrkmuch>:
+{
+    2216:	7179                	addi	sp,sp,-48
+    2218:	f406                	sd	ra,40(sp)
+    221a:	f022                	sd	s0,32(sp)
+    221c:	ec26                	sd	s1,24(sp)
+    221e:	e84a                	sd	s2,16(sp)
+    2220:	e44e                	sd	s3,8(sp)
+    2222:	e052                	sd	s4,0(sp)
+    2224:	1800                	addi	s0,sp,48
+    2226:	89aa                	mv	s3,a0
+  oldbrk = sbrk(0);
+    2228:	4501                	li	a0,0
+    222a:	227020ef          	jal	4c50 <sbrk>
+    222e:	892a                	mv	s2,a0
+  a = sbrk(0);
+    2230:	4501                	li	a0,0
+    2232:	21f020ef          	jal	4c50 <sbrk>
+    2236:	84aa                	mv	s1,a0
+  p = sbrk(amt);
+    2238:	06400537          	lui	a0,0x6400
+    223c:	9d05                	subw	a0,a0,s1
+    223e:	213020ef          	jal	4c50 <sbrk>
+  if (p != a) {
+    2242:	08a49763          	bne	s1,a0,22d0 <sbrkmuch+0xba>
+  *lastaddr = 99;
+    2246:	064007b7          	lui	a5,0x6400
+    224a:	06300713          	li	a4,99
+    224e:	fee78fa3          	sb	a4,-1(a5) # 63fffff <base+0x63f0357>
+  a = sbrk(0);
+    2252:	4501                	li	a0,0
+    2254:	1fd020ef          	jal	4c50 <sbrk>
+    2258:	84aa                	mv	s1,a0
+  c = sbrk(-PGSIZE);
+    225a:	757d                	lui	a0,0xfffff
+    225c:	1f5020ef          	jal	4c50 <sbrk>
+  if(c == (char*)SBRK_ERROR){
+    2260:	57fd                	li	a5,-1
+    2262:	08f50163          	beq	a0,a5,22e4 <sbrkmuch+0xce>
+  c = sbrk(0);
+    2266:	4501                	li	a0,0
+    2268:	1e9020ef          	jal	4c50 <sbrk>
+  if(c != a - PGSIZE){
+    226c:	77fd                	lui	a5,0xfffff
+    226e:	97a6                	add	a5,a5,s1
+    2270:	08f51463          	bne	a0,a5,22f8 <sbrkmuch+0xe2>
+  a = sbrk(0);
+    2274:	4501                	li	a0,0
+    2276:	1db020ef          	jal	4c50 <sbrk>
+    227a:	84aa                	mv	s1,a0
+  c = sbrk(PGSIZE);
+    227c:	6505                	lui	a0,0x1
+    227e:	1d3020ef          	jal	4c50 <sbrk>
+    2282:	8a2a                	mv	s4,a0
+  if(c != a || sbrk(0) != a + PGSIZE){
+    2284:	08a49663          	bne	s1,a0,2310 <sbrkmuch+0xfa>
+    2288:	4501                	li	a0,0
+    228a:	1c7020ef          	jal	4c50 <sbrk>
+    228e:	6785                	lui	a5,0x1
+    2290:	97a6                	add	a5,a5,s1
+    2292:	06f51f63          	bne	a0,a5,2310 <sbrkmuch+0xfa>
+  if(*lastaddr == 99){
+    2296:	064007b7          	lui	a5,0x6400
+    229a:	fff7c703          	lbu	a4,-1(a5) # 63fffff <base+0x63f0357>
+    229e:	06300793          	li	a5,99
+    22a2:	08f70363          	beq	a4,a5,2328 <sbrkmuch+0x112>
+  a = sbrk(0);
+    22a6:	4501                	li	a0,0
+    22a8:	1a9020ef          	jal	4c50 <sbrk>
+    22ac:	84aa                	mv	s1,a0
+  c = sbrk(-(sbrk(0) - oldbrk));
+    22ae:	4501                	li	a0,0
+    22b0:	1a1020ef          	jal	4c50 <sbrk>
+    22b4:	40a9053b          	subw	a0,s2,a0
+    22b8:	199020ef          	jal	4c50 <sbrk>
+  if(c != a){
+    22bc:	08a49063          	bne	s1,a0,233c <sbrkmuch+0x126>
+}
+    22c0:	70a2                	ld	ra,40(sp)
+    22c2:	7402                	ld	s0,32(sp)
+    22c4:	64e2                	ld	s1,24(sp)
+    22c6:	6942                	ld	s2,16(sp)
+    22c8:	69a2                	ld	s3,8(sp)
+    22ca:	6a02                	ld	s4,0(sp)
+    22cc:	6145                	addi	sp,sp,48
+    22ce:	8082                	ret
+    printf("%s: sbrk test failed to grow big address space; enough phys mem?\n", s);
+    22d0:	85ce                	mv	a1,s3
+    22d2:	00004517          	auipc	a0,0x4
+    22d6:	d1650513          	addi	a0,a0,-746 # 5fe8 <malloc+0xe80>
+    22da:	5db020ef          	jal	50b4 <printf>
+    exit(1);
+    22de:	4505                	li	a0,1
+    22e0:	1a5020ef          	jal	4c84 <exit>
+    printf("%s: sbrk could not deallocate\n", s);
+    22e4:	85ce                	mv	a1,s3
+    22e6:	00004517          	auipc	a0,0x4
+    22ea:	d4a50513          	addi	a0,a0,-694 # 6030 <malloc+0xec8>
+    22ee:	5c7020ef          	jal	50b4 <printf>
+    exit(1);
+    22f2:	4505                	li	a0,1
+    22f4:	191020ef          	jal	4c84 <exit>
+    printf("%s: sbrk deallocation produced wrong address, a %p c %p\n", s, a, c);
+    22f8:	86aa                	mv	a3,a0
+    22fa:	8626                	mv	a2,s1
+    22fc:	85ce                	mv	a1,s3
+    22fe:	00004517          	auipc	a0,0x4
+    2302:	d5250513          	addi	a0,a0,-686 # 6050 <malloc+0xee8>
+    2306:	5af020ef          	jal	50b4 <printf>
+    exit(1);
+    230a:	4505                	li	a0,1
+    230c:	179020ef          	jal	4c84 <exit>
+    printf("%s: sbrk re-allocation failed, a %p c %p\n", s, a, c);
+    2310:	86d2                	mv	a3,s4
+    2312:	8626                	mv	a2,s1
+    2314:	85ce                	mv	a1,s3
+    2316:	00004517          	auipc	a0,0x4
+    231a:	d7a50513          	addi	a0,a0,-646 # 6090 <malloc+0xf28>
+    231e:	597020ef          	jal	50b4 <printf>
+    exit(1);
+    2322:	4505                	li	a0,1
+    2324:	161020ef          	jal	4c84 <exit>
+    printf("%s: sbrk de-allocation didn't really deallocate\n", s);
+    2328:	85ce                	mv	a1,s3
+    232a:	00004517          	auipc	a0,0x4
+    232e:	d9650513          	addi	a0,a0,-618 # 60c0 <malloc+0xf58>
+    2332:	583020ef          	jal	50b4 <printf>
+    exit(1);
+    2336:	4505                	li	a0,1
+    2338:	14d020ef          	jal	4c84 <exit>
+    printf("%s: sbrk downsize failed, a %p c %p\n", s, a, c);
+    233c:	86aa                	mv	a3,a0
+    233e:	8626                	mv	a2,s1
+    2340:	85ce                	mv	a1,s3
+    2342:	00004517          	auipc	a0,0x4
+    2346:	db650513          	addi	a0,a0,-586 # 60f8 <malloc+0xf90>
+    234a:	56b020ef          	jal	50b4 <printf>
+    exit(1);
+    234e:	4505                	li	a0,1
+    2350:	135020ef          	jal	4c84 <exit>
+
+0000000000002354 <sbrkarg>:
+{
+    2354:	7179                	addi	sp,sp,-48
+    2356:	f406                	sd	ra,40(sp)
+    2358:	f022                	sd	s0,32(sp)
+    235a:	ec26                	sd	s1,24(sp)
+    235c:	e84a                	sd	s2,16(sp)
+    235e:	e44e                	sd	s3,8(sp)
+    2360:	1800                	addi	s0,sp,48
+    2362:	89aa                	mv	s3,a0
+  a = sbrk(PGSIZE);
+    2364:	6505                	lui	a0,0x1
+    2366:	0eb020ef          	jal	4c50 <sbrk>
+    236a:	892a                	mv	s2,a0
+  fd = open("sbrk", O_CREATE|O_WRONLY);
+    236c:	20100593          	li	a1,513
+    2370:	00004517          	auipc	a0,0x4
+    2374:	db050513          	addi	a0,a0,-592 # 6120 <malloc+0xfb8>
+    2378:	14d020ef          	jal	4cc4 <open>
+    237c:	84aa                	mv	s1,a0
+  unlink("sbrk");
+    237e:	00004517          	auipc	a0,0x4
+    2382:	da250513          	addi	a0,a0,-606 # 6120 <malloc+0xfb8>
+    2386:	14f020ef          	jal	4cd4 <unlink>
+  if(fd < 0)  {
+    238a:	0204c963          	bltz	s1,23bc <sbrkarg+0x68>
+  if ((n = write(fd, a, PGSIZE)) < 0) {
+    238e:	6605                	lui	a2,0x1
+    2390:	85ca                	mv	a1,s2
+    2392:	8526                	mv	a0,s1
+    2394:	111020ef          	jal	4ca4 <write>
+    2398:	02054c63          	bltz	a0,23d0 <sbrkarg+0x7c>
+  close(fd);
+    239c:	8526                	mv	a0,s1
+    239e:	10f020ef          	jal	4cac <close>
+  a = sbrk(PGSIZE);
+    23a2:	6505                	lui	a0,0x1
+    23a4:	0ad020ef          	jal	4c50 <sbrk>
+  if(pipe((int *) a) != 0){
+    23a8:	0ed020ef          	jal	4c94 <pipe>
+    23ac:	ed05                	bnez	a0,23e4 <sbrkarg+0x90>
+}
+    23ae:	70a2                	ld	ra,40(sp)
+    23b0:	7402                	ld	s0,32(sp)
+    23b2:	64e2                	ld	s1,24(sp)
+    23b4:	6942                	ld	s2,16(sp)
+    23b6:	69a2                	ld	s3,8(sp)
+    23b8:	6145                	addi	sp,sp,48
+    23ba:	8082                	ret
+    printf("%s: open sbrk failed\n", s);
+    23bc:	85ce                	mv	a1,s3
+    23be:	00004517          	auipc	a0,0x4
+    23c2:	d6a50513          	addi	a0,a0,-662 # 6128 <malloc+0xfc0>
+    23c6:	4ef020ef          	jal	50b4 <printf>
+    exit(1);
+    23ca:	4505                	li	a0,1
+    23cc:	0b9020ef          	jal	4c84 <exit>
+    printf("%s: write sbrk failed\n", s);
+    23d0:	85ce                	mv	a1,s3
+    23d2:	00004517          	auipc	a0,0x4
+    23d6:	d6e50513          	addi	a0,a0,-658 # 6140 <malloc+0xfd8>
+    23da:	4db020ef          	jal	50b4 <printf>
+    exit(1);
+    23de:	4505                	li	a0,1
+    23e0:	0a5020ef          	jal	4c84 <exit>
+    printf("%s: pipe() failed\n", s);
+    23e4:	85ce                	mv	a1,s3
+    23e6:	00004517          	auipc	a0,0x4
+    23ea:	84a50513          	addi	a0,a0,-1974 # 5c30 <malloc+0xac8>
+    23ee:	4c7020ef          	jal	50b4 <printf>
+    exit(1);
+    23f2:	4505                	li	a0,1
+    23f4:	091020ef          	jal	4c84 <exit>
+
+00000000000023f8 <argptest>:
+{
+    23f8:	1101                	addi	sp,sp,-32
+    23fa:	ec06                	sd	ra,24(sp)
+    23fc:	e822                	sd	s0,16(sp)
+    23fe:	e426                	sd	s1,8(sp)
+    2400:	e04a                	sd	s2,0(sp)
+    2402:	1000                	addi	s0,sp,32
+    2404:	892a                	mv	s2,a0
+  fd = open("init", O_RDONLY);
+    2406:	4581                	li	a1,0
+    2408:	00004517          	auipc	a0,0x4
+    240c:	d5050513          	addi	a0,a0,-688 # 6158 <malloc+0xff0>
+    2410:	0b5020ef          	jal	4cc4 <open>
+  if (fd < 0) {
+    2414:	02054563          	bltz	a0,243e <argptest+0x46>
+    2418:	84aa                	mv	s1,a0
+  read(fd, sbrk(0) - 1, -1);
+    241a:	4501                	li	a0,0
+    241c:	035020ef          	jal	4c50 <sbrk>
+    2420:	567d                	li	a2,-1
+    2422:	fff50593          	addi	a1,a0,-1
+    2426:	8526                	mv	a0,s1
+    2428:	075020ef          	jal	4c9c <read>
+  close(fd);
+    242c:	8526                	mv	a0,s1
+    242e:	07f020ef          	jal	4cac <close>
+}
+    2432:	60e2                	ld	ra,24(sp)
+    2434:	6442                	ld	s0,16(sp)
+    2436:	64a2                	ld	s1,8(sp)
+    2438:	6902                	ld	s2,0(sp)
+    243a:	6105                	addi	sp,sp,32
+    243c:	8082                	ret
+    printf("%s: open failed\n", s);
+    243e:	85ca                	mv	a1,s2
+    2440:	00003517          	auipc	a0,0x3
+    2444:	70050513          	addi	a0,a0,1792 # 5b40 <malloc+0x9d8>
+    2448:	46d020ef          	jal	50b4 <printf>
+    exit(1);
+    244c:	4505                	li	a0,1
+    244e:	037020ef          	jal	4c84 <exit>
+
+0000000000002452 <sbrkbugs>:
+{
+    2452:	1141                	addi	sp,sp,-16
+    2454:	e406                	sd	ra,8(sp)
+    2456:	e022                	sd	s0,0(sp)
+    2458:	0800                	addi	s0,sp,16
+  int pid = fork();
+    245a:	023020ef          	jal	4c7c <fork>
+  if(pid < 0){
+    245e:	00054c63          	bltz	a0,2476 <sbrkbugs+0x24>
+  if(pid == 0){
+    2462:	e11d                	bnez	a0,2488 <sbrkbugs+0x36>
+    int sz = (uint64) sbrk(0);
+    2464:	7ec020ef          	jal	4c50 <sbrk>
+    sbrk(-sz);
+    2468:	40a0053b          	negw	a0,a0
+    246c:	7e4020ef          	jal	4c50 <sbrk>
+    exit(0);
+    2470:	4501                	li	a0,0
+    2472:	013020ef          	jal	4c84 <exit>
+    printf("fork failed\n");
+    2476:	00005517          	auipc	a0,0x5
+    247a:	c5a50513          	addi	a0,a0,-934 # 70d0 <malloc+0x1f68>
+    247e:	437020ef          	jal	50b4 <printf>
+    exit(1);
+    2482:	4505                	li	a0,1
+    2484:	001020ef          	jal	4c84 <exit>
+  wait(0);
+    2488:	4501                	li	a0,0
+    248a:	003020ef          	jal	4c8c <wait>
+  pid = fork();
+    248e:	7ee020ef          	jal	4c7c <fork>
+  if(pid < 0){
+    2492:	00054f63          	bltz	a0,24b0 <sbrkbugs+0x5e>
+  if(pid == 0){
+    2496:	e515                	bnez	a0,24c2 <sbrkbugs+0x70>
+    int sz = (uint64) sbrk(0);
+    2498:	7b8020ef          	jal	4c50 <sbrk>
+    sbrk(-(sz - 3500));
+    249c:	6785                	lui	a5,0x1
+    249e:	dac7879b          	addiw	a5,a5,-596 # dac <linktest+0x138>
+    24a2:	40a7853b          	subw	a0,a5,a0
+    24a6:	7aa020ef          	jal	4c50 <sbrk>
+    exit(0);
+    24aa:	4501                	li	a0,0
+    24ac:	7d8020ef          	jal	4c84 <exit>
+    printf("fork failed\n");
+    24b0:	00005517          	auipc	a0,0x5
+    24b4:	c2050513          	addi	a0,a0,-992 # 70d0 <malloc+0x1f68>
+    24b8:	3fd020ef          	jal	50b4 <printf>
+    exit(1);
+    24bc:	4505                	li	a0,1
+    24be:	7c6020ef          	jal	4c84 <exit>
+  wait(0);
+    24c2:	4501                	li	a0,0
+    24c4:	7c8020ef          	jal	4c8c <wait>
+  pid = fork();
+    24c8:	7b4020ef          	jal	4c7c <fork>
+  if(pid < 0){
+    24cc:	02054263          	bltz	a0,24f0 <sbrkbugs+0x9e>
+  if(pid == 0){
+    24d0:	e90d                	bnez	a0,2502 <sbrkbugs+0xb0>
+    sbrk((10*PGSIZE + 2048) - (uint64)sbrk(0));
+    24d2:	77e020ef          	jal	4c50 <sbrk>
+    24d6:	67ad                	lui	a5,0xb
+    24d8:	8007879b          	addiw	a5,a5,-2048 # a800 <uninit+0x268>
+    24dc:	40a7853b          	subw	a0,a5,a0
+    24e0:	770020ef          	jal	4c50 <sbrk>
+    sbrk(-10);
+    24e4:	5559                	li	a0,-10
+    24e6:	76a020ef          	jal	4c50 <sbrk>
+    exit(0);
+    24ea:	4501                	li	a0,0
+    24ec:	798020ef          	jal	4c84 <exit>
+    printf("fork failed\n");
+    24f0:	00005517          	auipc	a0,0x5
+    24f4:	be050513          	addi	a0,a0,-1056 # 70d0 <malloc+0x1f68>
+    24f8:	3bd020ef          	jal	50b4 <printf>
+    exit(1);
+    24fc:	4505                	li	a0,1
+    24fe:	786020ef          	jal	4c84 <exit>
+  wait(0);
+    2502:	4501                	li	a0,0
+    2504:	788020ef          	jal	4c8c <wait>
+  exit(0);
+    2508:	4501                	li	a0,0
+    250a:	77a020ef          	jal	4c84 <exit>
+
+000000000000250e <sbrklast>:
+{
+    250e:	7179                	addi	sp,sp,-48
+    2510:	f406                	sd	ra,40(sp)
+    2512:	f022                	sd	s0,32(sp)
+    2514:	ec26                	sd	s1,24(sp)
+    2516:	e84a                	sd	s2,16(sp)
+    2518:	e44e                	sd	s3,8(sp)
+    251a:	e052                	sd	s4,0(sp)
+    251c:	1800                	addi	s0,sp,48
+  uint64 top = (uint64) sbrk(0);
+    251e:	4501                	li	a0,0
+    2520:	730020ef          	jal	4c50 <sbrk>
+  if((top % PGSIZE) != 0)
+    2524:	03451793          	slli	a5,a0,0x34
+    2528:	ebad                	bnez	a5,259a <sbrklast+0x8c>
+  sbrk(PGSIZE);
+    252a:	6505                	lui	a0,0x1
+    252c:	724020ef          	jal	4c50 <sbrk>
+  sbrk(10);
+    2530:	4529                	li	a0,10
+    2532:	71e020ef          	jal	4c50 <sbrk>
+  sbrk(-20);
+    2536:	5531                	li	a0,-20
+    2538:	718020ef          	jal	4c50 <sbrk>
+  top = (uint64) sbrk(0);
+    253c:	4501                	li	a0,0
+    253e:	712020ef          	jal	4c50 <sbrk>
+    2542:	84aa                	mv	s1,a0
+  char *p = (char *) (top - 64);
+    2544:	fc050913          	addi	s2,a0,-64 # fc0 <bigdir+0x122>
+  p[0] = 'x';
+    2548:	07800a13          	li	s4,120
+    254c:	fd450023          	sb	s4,-64(a0)
+  p[1] = '\0';
+    2550:	fc0500a3          	sb	zero,-63(a0)
+  int fd = open(p, O_RDWR|O_CREATE);
+    2554:	20200593          	li	a1,514
+    2558:	854a                	mv	a0,s2
+    255a:	76a020ef          	jal	4cc4 <open>
+    255e:	89aa                	mv	s3,a0
+  write(fd, p, 1);
+    2560:	4605                	li	a2,1
+    2562:	85ca                	mv	a1,s2
+    2564:	740020ef          	jal	4ca4 <write>
+  close(fd);
+    2568:	854e                	mv	a0,s3
+    256a:	742020ef          	jal	4cac <close>
+  fd = open(p, O_RDWR);
+    256e:	4589                	li	a1,2
+    2570:	854a                	mv	a0,s2
+    2572:	752020ef          	jal	4cc4 <open>
+  p[0] = '\0';
+    2576:	fc048023          	sb	zero,-64(s1)
+  read(fd, p, 1);
+    257a:	4605                	li	a2,1
+    257c:	85ca                	mv	a1,s2
+    257e:	71e020ef          	jal	4c9c <read>
+  if(p[0] != 'x')
+    2582:	fc04c783          	lbu	a5,-64(s1)
+    2586:	03479263          	bne	a5,s4,25aa <sbrklast+0x9c>
+}
+    258a:	70a2                	ld	ra,40(sp)
+    258c:	7402                	ld	s0,32(sp)
+    258e:	64e2                	ld	s1,24(sp)
+    2590:	6942                	ld	s2,16(sp)
+    2592:	69a2                	ld	s3,8(sp)
+    2594:	6a02                	ld	s4,0(sp)
+    2596:	6145                	addi	sp,sp,48
+    2598:	8082                	ret
+    sbrk(PGSIZE - (top % PGSIZE));
+    259a:	0347d513          	srli	a0,a5,0x34
+    259e:	6785                	lui	a5,0x1
+    25a0:	40a7853b          	subw	a0,a5,a0
+    25a4:	6ac020ef          	jal	4c50 <sbrk>
+    25a8:	b749                	j	252a <sbrklast+0x1c>
+    exit(1);
+    25aa:	4505                	li	a0,1
+    25ac:	6d8020ef          	jal	4c84 <exit>
+
+00000000000025b0 <sbrk8000>:
+{
+    25b0:	1141                	addi	sp,sp,-16
+    25b2:	e406                	sd	ra,8(sp)
+    25b4:	e022                	sd	s0,0(sp)
+    25b6:	0800                	addi	s0,sp,16
+  sbrk(0x80000004);
+    25b8:	80000537          	lui	a0,0x80000
+    25bc:	0511                	addi	a0,a0,4 # ffffffff80000004 <base+0xffffffff7fff035c>
+    25be:	692020ef          	jal	4c50 <sbrk>
+  volatile char *top = sbrk(0);
+    25c2:	4501                	li	a0,0
+    25c4:	68c020ef          	jal	4c50 <sbrk>
+  *(top-1) = *(top-1) + 1;
+    25c8:	fff54783          	lbu	a5,-1(a0)
+    25cc:	2785                	addiw	a5,a5,1 # 1001 <badarg+0x1>
+    25ce:	0ff7f793          	zext.b	a5,a5
+    25d2:	fef50fa3          	sb	a5,-1(a0)
+}
+    25d6:	60a2                	ld	ra,8(sp)
+    25d8:	6402                	ld	s0,0(sp)
+    25da:	0141                	addi	sp,sp,16
+    25dc:	8082                	ret
+
+00000000000025de <execout>:
+{
+    25de:	715d                	addi	sp,sp,-80
+    25e0:	e486                	sd	ra,72(sp)
+    25e2:	e0a2                	sd	s0,64(sp)
+    25e4:	fc26                	sd	s1,56(sp)
+    25e6:	f84a                	sd	s2,48(sp)
+    25e8:	f44e                	sd	s3,40(sp)
+    25ea:	f052                	sd	s4,32(sp)
+    25ec:	0880                	addi	s0,sp,80
+  for(int avail = 0; avail < 15; avail++){
+    25ee:	4901                	li	s2,0
+    25f0:	49bd                	li	s3,15
+    int pid = fork();
+    25f2:	68a020ef          	jal	4c7c <fork>
+    25f6:	84aa                	mv	s1,a0
+    if(pid < 0){
+    25f8:	00054c63          	bltz	a0,2610 <execout+0x32>
+    } else if(pid == 0){
+    25fc:	c11d                	beqz	a0,2622 <execout+0x44>
+      wait((int*)0);
+    25fe:	4501                	li	a0,0
+    2600:	68c020ef          	jal	4c8c <wait>
+  for(int avail = 0; avail < 15; avail++){
+    2604:	2905                	addiw	s2,s2,1
+    2606:	ff3916e3          	bne	s2,s3,25f2 <execout+0x14>
+  exit(0);
+    260a:	4501                	li	a0,0
+    260c:	678020ef          	jal	4c84 <exit>
+      printf("fork failed\n");
+    2610:	00005517          	auipc	a0,0x5
+    2614:	ac050513          	addi	a0,a0,-1344 # 70d0 <malloc+0x1f68>
+    2618:	29d020ef          	jal	50b4 <printf>
+      exit(1);
+    261c:	4505                	li	a0,1
+    261e:	666020ef          	jal	4c84 <exit>
+        if(a == SBRK_ERROR)
+    2622:	59fd                	li	s3,-1
+        *(a + PGSIZE - 1) = 1;
+    2624:	4a05                	li	s4,1
+        char *a = sbrk(PGSIZE);
+    2626:	6505                	lui	a0,0x1
+    2628:	628020ef          	jal	4c50 <sbrk>
+        if(a == SBRK_ERROR)
+    262c:	01350763          	beq	a0,s3,263a <execout+0x5c>
+        *(a + PGSIZE - 1) = 1;
+    2630:	6785                	lui	a5,0x1
+    2632:	953e                	add	a0,a0,a5
+    2634:	ff450fa3          	sb	s4,-1(a0) # fff <pgbug+0x2b>
+      while(1){
+    2638:	b7fd                	j	2626 <execout+0x48>
+      for(int i = 0; i < avail; i++)
+    263a:	01205863          	blez	s2,264a <execout+0x6c>
+        sbrk(-PGSIZE);
+    263e:	757d                	lui	a0,0xfffff
+    2640:	610020ef          	jal	4c50 <sbrk>
+      for(int i = 0; i < avail; i++)
+    2644:	2485                	addiw	s1,s1,1
+    2646:	ff249ce3          	bne	s1,s2,263e <execout+0x60>
+      close(1);
+    264a:	4505                	li	a0,1
+    264c:	660020ef          	jal	4cac <close>
+      char *args[] = { "echo", "x", 0 };
+    2650:	00003517          	auipc	a0,0x3
+    2654:	c4850513          	addi	a0,a0,-952 # 5298 <malloc+0x130>
+    2658:	faa43c23          	sd	a0,-72(s0)
+    265c:	00003797          	auipc	a5,0x3
+    2660:	cac78793          	addi	a5,a5,-852 # 5308 <malloc+0x1a0>
+    2664:	fcf43023          	sd	a5,-64(s0)
+    2668:	fc043423          	sd	zero,-56(s0)
+      exec("echo", args);
+    266c:	fb840593          	addi	a1,s0,-72
+    2670:	64c020ef          	jal	4cbc <exec>
+      exit(0);
+    2674:	4501                	li	a0,0
+    2676:	60e020ef          	jal	4c84 <exit>
+
+000000000000267a <fourteen>:
+{
+    267a:	1101                	addi	sp,sp,-32
+    267c:	ec06                	sd	ra,24(sp)
+    267e:	e822                	sd	s0,16(sp)
+    2680:	e426                	sd	s1,8(sp)
+    2682:	1000                	addi	s0,sp,32
+    2684:	84aa                	mv	s1,a0
+  if(mkdir("12345678901234") != 0){
+    2686:	00004517          	auipc	a0,0x4
+    268a:	caa50513          	addi	a0,a0,-854 # 6330 <malloc+0x11c8>
+    268e:	65e020ef          	jal	4cec <mkdir>
+    2692:	e555                	bnez	a0,273e <fourteen+0xc4>
+  if(mkdir("12345678901234/123456789012345") != 0){
+    2694:	00004517          	auipc	a0,0x4
+    2698:	af450513          	addi	a0,a0,-1292 # 6188 <malloc+0x1020>
+    269c:	650020ef          	jal	4cec <mkdir>
+    26a0:	e94d                	bnez	a0,2752 <fourteen+0xd8>
+  fd = open("123456789012345/123456789012345/123456789012345", O_CREATE);
+    26a2:	20000593          	li	a1,512
+    26a6:	00004517          	auipc	a0,0x4
+    26aa:	b3a50513          	addi	a0,a0,-1222 # 61e0 <malloc+0x1078>
+    26ae:	616020ef          	jal	4cc4 <open>
+  if(fd < 0){
+    26b2:	0a054a63          	bltz	a0,2766 <fourteen+0xec>
+  close(fd);
+    26b6:	5f6020ef          	jal	4cac <close>
+  fd = open("12345678901234/12345678901234/12345678901234", 0);
+    26ba:	4581                	li	a1,0
+    26bc:	00004517          	auipc	a0,0x4
+    26c0:	b9c50513          	addi	a0,a0,-1124 # 6258 <malloc+0x10f0>
+    26c4:	600020ef          	jal	4cc4 <open>
+  if(fd < 0){
+    26c8:	0a054963          	bltz	a0,277a <fourteen+0x100>
+  close(fd);
+    26cc:	5e0020ef          	jal	4cac <close>
+  if(mkdir("12345678901234/12345678901234") == 0){
+    26d0:	00004517          	auipc	a0,0x4
+    26d4:	bf850513          	addi	a0,a0,-1032 # 62c8 <malloc+0x1160>
+    26d8:	614020ef          	jal	4cec <mkdir>
+    26dc:	c94d                	beqz	a0,278e <fourteen+0x114>
+  if(mkdir("123456789012345/12345678901234") == 0){
+    26de:	00004517          	auipc	a0,0x4
+    26e2:	c4250513          	addi	a0,a0,-958 # 6320 <malloc+0x11b8>
+    26e6:	606020ef          	jal	4cec <mkdir>
+    26ea:	cd45                	beqz	a0,27a2 <fourteen+0x128>
+  unlink("123456789012345/12345678901234");
+    26ec:	00004517          	auipc	a0,0x4
+    26f0:	c3450513          	addi	a0,a0,-972 # 6320 <malloc+0x11b8>
+    26f4:	5e0020ef          	jal	4cd4 <unlink>
+  unlink("12345678901234/12345678901234");
+    26f8:	00004517          	auipc	a0,0x4
+    26fc:	bd050513          	addi	a0,a0,-1072 # 62c8 <malloc+0x1160>
+    2700:	5d4020ef          	jal	4cd4 <unlink>
+  unlink("12345678901234/12345678901234/12345678901234");
+    2704:	00004517          	auipc	a0,0x4
+    2708:	b5450513          	addi	a0,a0,-1196 # 6258 <malloc+0x10f0>
+    270c:	5c8020ef          	jal	4cd4 <unlink>
+  unlink("123456789012345/123456789012345/123456789012345");
+    2710:	00004517          	auipc	a0,0x4
+    2714:	ad050513          	addi	a0,a0,-1328 # 61e0 <malloc+0x1078>
+    2718:	5bc020ef          	jal	4cd4 <unlink>
+  unlink("12345678901234/123456789012345");
+    271c:	00004517          	auipc	a0,0x4
+    2720:	a6c50513          	addi	a0,a0,-1428 # 6188 <malloc+0x1020>
+    2724:	5b0020ef          	jal	4cd4 <unlink>
+  unlink("12345678901234");
+    2728:	00004517          	auipc	a0,0x4
+    272c:	c0850513          	addi	a0,a0,-1016 # 6330 <malloc+0x11c8>
+    2730:	5a4020ef          	jal	4cd4 <unlink>
+}
+    2734:	60e2                	ld	ra,24(sp)
+    2736:	6442                	ld	s0,16(sp)
+    2738:	64a2                	ld	s1,8(sp)
+    273a:	6105                	addi	sp,sp,32
+    273c:	8082                	ret
+    printf("%s: mkdir 12345678901234 failed\n", s);
+    273e:	85a6                	mv	a1,s1
+    2740:	00004517          	auipc	a0,0x4
+    2744:	a2050513          	addi	a0,a0,-1504 # 6160 <malloc+0xff8>
+    2748:	16d020ef          	jal	50b4 <printf>
+    exit(1);
+    274c:	4505                	li	a0,1
+    274e:	536020ef          	jal	4c84 <exit>
+    printf("%s: mkdir 12345678901234/123456789012345 failed\n", s);
+    2752:	85a6                	mv	a1,s1
+    2754:	00004517          	auipc	a0,0x4
+    2758:	a5450513          	addi	a0,a0,-1452 # 61a8 <malloc+0x1040>
+    275c:	159020ef          	jal	50b4 <printf>
+    exit(1);
+    2760:	4505                	li	a0,1
+    2762:	522020ef          	jal	4c84 <exit>
+    printf("%s: create 123456789012345/123456789012345/123456789012345 failed\n", s);
+    2766:	85a6                	mv	a1,s1
+    2768:	00004517          	auipc	a0,0x4
+    276c:	aa850513          	addi	a0,a0,-1368 # 6210 <malloc+0x10a8>
+    2770:	145020ef          	jal	50b4 <printf>
+    exit(1);
+    2774:	4505                	li	a0,1
+    2776:	50e020ef          	jal	4c84 <exit>
+    printf("%s: open 12345678901234/12345678901234/12345678901234 failed\n", s);
+    277a:	85a6                	mv	a1,s1
+    277c:	00004517          	auipc	a0,0x4
+    2780:	b0c50513          	addi	a0,a0,-1268 # 6288 <malloc+0x1120>
+    2784:	131020ef          	jal	50b4 <printf>
+    exit(1);
+    2788:	4505                	li	a0,1
+    278a:	4fa020ef          	jal	4c84 <exit>
+    printf("%s: mkdir 12345678901234/12345678901234 succeeded!\n", s);
+    278e:	85a6                	mv	a1,s1
+    2790:	00004517          	auipc	a0,0x4
+    2794:	b5850513          	addi	a0,a0,-1192 # 62e8 <malloc+0x1180>
+    2798:	11d020ef          	jal	50b4 <printf>
+    exit(1);
+    279c:	4505                	li	a0,1
+    279e:	4e6020ef          	jal	4c84 <exit>
+    printf("%s: mkdir 12345678901234/123456789012345 succeeded!\n", s);
+    27a2:	85a6                	mv	a1,s1
+    27a4:	00004517          	auipc	a0,0x4
+    27a8:	b9c50513          	addi	a0,a0,-1124 # 6340 <malloc+0x11d8>
+    27ac:	109020ef          	jal	50b4 <printf>
+    exit(1);
+    27b0:	4505                	li	a0,1
+    27b2:	4d2020ef          	jal	4c84 <exit>
+
+00000000000027b6 <diskfull>:
+{
+    27b6:	b8010113          	addi	sp,sp,-1152
+    27ba:	46113c23          	sd	ra,1144(sp)
+    27be:	46813823          	sd	s0,1136(sp)
+    27c2:	46913423          	sd	s1,1128(sp)
+    27c6:	47213023          	sd	s2,1120(sp)
+    27ca:	45313c23          	sd	s3,1112(sp)
+    27ce:	45413823          	sd	s4,1104(sp)
+    27d2:	45513423          	sd	s5,1096(sp)
+    27d6:	45613023          	sd	s6,1088(sp)
+    27da:	43713c23          	sd	s7,1080(sp)
+    27de:	43813823          	sd	s8,1072(sp)
+    27e2:	43913423          	sd	s9,1064(sp)
+    27e6:	48010413          	addi	s0,sp,1152
+    27ea:	8caa                	mv	s9,a0
+  unlink("diskfulldir");
+    27ec:	00004517          	auipc	a0,0x4
+    27f0:	b8c50513          	addi	a0,a0,-1140 # 6378 <malloc+0x1210>
+    27f4:	4e0020ef          	jal	4cd4 <unlink>
+    27f8:	03000993          	li	s3,48
+    name[0] = 'b';
+    27fc:	06200b13          	li	s6,98
+    name[1] = 'i';
+    2800:	06900a93          	li	s5,105
+    name[2] = 'g';
+    2804:	06700a13          	li	s4,103
+    2808:	10c00b93          	li	s7,268
+  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
+    280c:	07f00c13          	li	s8,127
+    2810:	aab9                	j	296e <diskfull+0x1b8>
+      printf("%s: could not create file %s\n", s, name);
+    2812:	b8040613          	addi	a2,s0,-1152
+    2816:	85e6                	mv	a1,s9
+    2818:	00004517          	auipc	a0,0x4
+    281c:	b7050513          	addi	a0,a0,-1168 # 6388 <malloc+0x1220>
+    2820:	095020ef          	jal	50b4 <printf>
+      break;
+    2824:	a039                	j	2832 <diskfull+0x7c>
+        close(fd);
+    2826:	854a                	mv	a0,s2
+    2828:	484020ef          	jal	4cac <close>
+    close(fd);
+    282c:	854a                	mv	a0,s2
+    282e:	47e020ef          	jal	4cac <close>
+  for(int i = 0; i < nzz; i++){
+    2832:	4481                	li	s1,0
+    name[0] = 'z';
+    2834:	07a00913          	li	s2,122
+  for(int i = 0; i < nzz; i++){
+    2838:	08000993          	li	s3,128
+    name[0] = 'z';
+    283c:	bb240023          	sb	s2,-1120(s0)
+    name[1] = 'z';
+    2840:	bb2400a3          	sb	s2,-1119(s0)
+    name[2] = '0' + (i / 32);
+    2844:	41f4d71b          	sraiw	a4,s1,0x1f
+    2848:	01b7571b          	srliw	a4,a4,0x1b
+    284c:	009707bb          	addw	a5,a4,s1
+    2850:	4057d69b          	sraiw	a3,a5,0x5
+    2854:	0306869b          	addiw	a3,a3,48
+    2858:	bad40123          	sb	a3,-1118(s0)
+    name[3] = '0' + (i % 32);
+    285c:	8bfd                	andi	a5,a5,31
+    285e:	9f99                	subw	a5,a5,a4
+    2860:	0307879b          	addiw	a5,a5,48
+    2864:	baf401a3          	sb	a5,-1117(s0)
+    name[4] = '\0';
+    2868:	ba040223          	sb	zero,-1116(s0)
+    unlink(name);
+    286c:	ba040513          	addi	a0,s0,-1120
+    2870:	464020ef          	jal	4cd4 <unlink>
+    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+    2874:	60200593          	li	a1,1538
+    2878:	ba040513          	addi	a0,s0,-1120
+    287c:	448020ef          	jal	4cc4 <open>
+    if(fd < 0)
+    2880:	00054763          	bltz	a0,288e <diskfull+0xd8>
+    close(fd);
+    2884:	428020ef          	jal	4cac <close>
+  for(int i = 0; i < nzz; i++){
+    2888:	2485                	addiw	s1,s1,1
+    288a:	fb3499e3          	bne	s1,s3,283c <diskfull+0x86>
+  if(mkdir("diskfulldir") == 0)
+    288e:	00004517          	auipc	a0,0x4
+    2892:	aea50513          	addi	a0,a0,-1302 # 6378 <malloc+0x1210>
+    2896:	456020ef          	jal	4cec <mkdir>
+    289a:	12050063          	beqz	a0,29ba <diskfull+0x204>
+  unlink("diskfulldir");
+    289e:	00004517          	auipc	a0,0x4
+    28a2:	ada50513          	addi	a0,a0,-1318 # 6378 <malloc+0x1210>
+    28a6:	42e020ef          	jal	4cd4 <unlink>
+  for(int i = 0; i < nzz; i++){
+    28aa:	4481                	li	s1,0
+    name[0] = 'z';
+    28ac:	07a00913          	li	s2,122
+  for(int i = 0; i < nzz; i++){
+    28b0:	08000993          	li	s3,128
+    name[0] = 'z';
+    28b4:	bb240023          	sb	s2,-1120(s0)
+    name[1] = 'z';
+    28b8:	bb2400a3          	sb	s2,-1119(s0)
+    name[2] = '0' + (i / 32);
+    28bc:	41f4d71b          	sraiw	a4,s1,0x1f
+    28c0:	01b7571b          	srliw	a4,a4,0x1b
+    28c4:	009707bb          	addw	a5,a4,s1
+    28c8:	4057d69b          	sraiw	a3,a5,0x5
+    28cc:	0306869b          	addiw	a3,a3,48
+    28d0:	bad40123          	sb	a3,-1118(s0)
+    name[3] = '0' + (i % 32);
+    28d4:	8bfd                	andi	a5,a5,31
+    28d6:	9f99                	subw	a5,a5,a4
+    28d8:	0307879b          	addiw	a5,a5,48
+    28dc:	baf401a3          	sb	a5,-1117(s0)
+    name[4] = '\0';
+    28e0:	ba040223          	sb	zero,-1116(s0)
+    unlink(name);
+    28e4:	ba040513          	addi	a0,s0,-1120
+    28e8:	3ec020ef          	jal	4cd4 <unlink>
+  for(int i = 0; i < nzz; i++){
+    28ec:	2485                	addiw	s1,s1,1
+    28ee:	fd3493e3          	bne	s1,s3,28b4 <diskfull+0xfe>
+    28f2:	03000493          	li	s1,48
+    name[0] = 'b';
+    28f6:	06200a93          	li	s5,98
+    name[1] = 'i';
+    28fa:	06900a13          	li	s4,105
+    name[2] = 'g';
+    28fe:	06700993          	li	s3,103
+  for(int i = 0; '0' + i < 0177; i++){
+    2902:	07f00913          	li	s2,127
+    name[0] = 'b';
+    2906:	bb540023          	sb	s5,-1120(s0)
+    name[1] = 'i';
+    290a:	bb4400a3          	sb	s4,-1119(s0)
+    name[2] = 'g';
+    290e:	bb340123          	sb	s3,-1118(s0)
+    name[3] = '0' + i;
+    2912:	ba9401a3          	sb	s1,-1117(s0)
+    name[4] = '\0';
+    2916:	ba040223          	sb	zero,-1116(s0)
+    unlink(name);
+    291a:	ba040513          	addi	a0,s0,-1120
+    291e:	3b6020ef          	jal	4cd4 <unlink>
+  for(int i = 0; '0' + i < 0177; i++){
+    2922:	2485                	addiw	s1,s1,1
+    2924:	0ff4f493          	zext.b	s1,s1
+    2928:	fd249fe3          	bne	s1,s2,2906 <diskfull+0x150>
+}
+    292c:	47813083          	ld	ra,1144(sp)
+    2930:	47013403          	ld	s0,1136(sp)
+    2934:	46813483          	ld	s1,1128(sp)
+    2938:	46013903          	ld	s2,1120(sp)
+    293c:	45813983          	ld	s3,1112(sp)
+    2940:	45013a03          	ld	s4,1104(sp)
+    2944:	44813a83          	ld	s5,1096(sp)
+    2948:	44013b03          	ld	s6,1088(sp)
+    294c:	43813b83          	ld	s7,1080(sp)
+    2950:	43013c03          	ld	s8,1072(sp)
+    2954:	42813c83          	ld	s9,1064(sp)
+    2958:	48010113          	addi	sp,sp,1152
+    295c:	8082                	ret
+    close(fd);
+    295e:	854a                	mv	a0,s2
+    2960:	34c020ef          	jal	4cac <close>
+  for(fi = 0; done == 0 && '0' + fi < 0177; fi++){
+    2964:	2985                	addiw	s3,s3,1
+    2966:	0ff9f993          	zext.b	s3,s3
+    296a:	ed8984e3          	beq	s3,s8,2832 <diskfull+0x7c>
+    name[0] = 'b';
+    296e:	b9640023          	sb	s6,-1152(s0)
+    name[1] = 'i';
+    2972:	b95400a3          	sb	s5,-1151(s0)
+    name[2] = 'g';
+    2976:	b9440123          	sb	s4,-1150(s0)
+    name[3] = '0' + fi;
+    297a:	b93401a3          	sb	s3,-1149(s0)
+    name[4] = '\0';
+    297e:	b8040223          	sb	zero,-1148(s0)
+    unlink(name);
+    2982:	b8040513          	addi	a0,s0,-1152
+    2986:	34e020ef          	jal	4cd4 <unlink>
+    int fd = open(name, O_CREATE|O_RDWR|O_TRUNC);
+    298a:	60200593          	li	a1,1538
+    298e:	b8040513          	addi	a0,s0,-1152
+    2992:	332020ef          	jal	4cc4 <open>
+    2996:	892a                	mv	s2,a0
+    if(fd < 0){
+    2998:	e6054de3          	bltz	a0,2812 <diskfull+0x5c>
+    299c:	84de                	mv	s1,s7
+      if(write(fd, buf, BSIZE) != BSIZE){
+    299e:	40000613          	li	a2,1024
+    29a2:	ba040593          	addi	a1,s0,-1120
+    29a6:	854a                	mv	a0,s2
+    29a8:	2fc020ef          	jal	4ca4 <write>
+    29ac:	40000793          	li	a5,1024
+    29b0:	e6f51be3          	bne	a0,a5,2826 <diskfull+0x70>
+    for(int i = 0; i < MAXFILE; i++){
+    29b4:	34fd                	addiw	s1,s1,-1
+    29b6:	f4e5                	bnez	s1,299e <diskfull+0x1e8>
+    29b8:	b75d                	j	295e <diskfull+0x1a8>
+    printf("%s: mkdir(diskfulldir) unexpectedly succeeded!\n", s);
+    29ba:	85e6                	mv	a1,s9
+    29bc:	00004517          	auipc	a0,0x4
+    29c0:	9ec50513          	addi	a0,a0,-1556 # 63a8 <malloc+0x1240>
+    29c4:	6f0020ef          	jal	50b4 <printf>
+    29c8:	bdd9                	j	289e <diskfull+0xe8>
+
+00000000000029ca <iputtest>:
+{
+    29ca:	1101                	addi	sp,sp,-32
+    29cc:	ec06                	sd	ra,24(sp)
+    29ce:	e822                	sd	s0,16(sp)
+    29d0:	e426                	sd	s1,8(sp)
+    29d2:	1000                	addi	s0,sp,32
+    29d4:	84aa                	mv	s1,a0
+  if(mkdir("iputdir") < 0){
+    29d6:	00004517          	auipc	a0,0x4
+    29da:	a0250513          	addi	a0,a0,-1534 # 63d8 <malloc+0x1270>
+    29de:	30e020ef          	jal	4cec <mkdir>
+    29e2:	02054f63          	bltz	a0,2a20 <iputtest+0x56>
+  if(chdir("iputdir") < 0){
+    29e6:	00004517          	auipc	a0,0x4
+    29ea:	9f250513          	addi	a0,a0,-1550 # 63d8 <malloc+0x1270>
+    29ee:	306020ef          	jal	4cf4 <chdir>
+    29f2:	04054163          	bltz	a0,2a34 <iputtest+0x6a>
+  if(unlink("../iputdir") < 0){
+    29f6:	00004517          	auipc	a0,0x4
+    29fa:	a2250513          	addi	a0,a0,-1502 # 6418 <malloc+0x12b0>
+    29fe:	2d6020ef          	jal	4cd4 <unlink>
+    2a02:	04054363          	bltz	a0,2a48 <iputtest+0x7e>
+  if(chdir("/") < 0){
+    2a06:	00004517          	auipc	a0,0x4
+    2a0a:	a4250513          	addi	a0,a0,-1470 # 6448 <malloc+0x12e0>
+    2a0e:	2e6020ef          	jal	4cf4 <chdir>
+    2a12:	04054563          	bltz	a0,2a5c <iputtest+0x92>
+}
+    2a16:	60e2                	ld	ra,24(sp)
+    2a18:	6442                	ld	s0,16(sp)
+    2a1a:	64a2                	ld	s1,8(sp)
+    2a1c:	6105                	addi	sp,sp,32
+    2a1e:	8082                	ret
+    printf("%s: mkdir failed\n", s);
+    2a20:	85a6                	mv	a1,s1
+    2a22:	00004517          	auipc	a0,0x4
+    2a26:	9be50513          	addi	a0,a0,-1602 # 63e0 <malloc+0x1278>
+    2a2a:	68a020ef          	jal	50b4 <printf>
+    exit(1);
+    2a2e:	4505                	li	a0,1
+    2a30:	254020ef          	jal	4c84 <exit>
+    printf("%s: chdir iputdir failed\n", s);
+    2a34:	85a6                	mv	a1,s1
+    2a36:	00004517          	auipc	a0,0x4
+    2a3a:	9c250513          	addi	a0,a0,-1598 # 63f8 <malloc+0x1290>
+    2a3e:	676020ef          	jal	50b4 <printf>
+    exit(1);
+    2a42:	4505                	li	a0,1
+    2a44:	240020ef          	jal	4c84 <exit>
+    printf("%s: unlink ../iputdir failed\n", s);
+    2a48:	85a6                	mv	a1,s1
+    2a4a:	00004517          	auipc	a0,0x4
+    2a4e:	9de50513          	addi	a0,a0,-1570 # 6428 <malloc+0x12c0>
+    2a52:	662020ef          	jal	50b4 <printf>
+    exit(1);
+    2a56:	4505                	li	a0,1
+    2a58:	22c020ef          	jal	4c84 <exit>
+    printf("%s: chdir / failed\n", s);
+    2a5c:	85a6                	mv	a1,s1
+    2a5e:	00004517          	auipc	a0,0x4
+    2a62:	9f250513          	addi	a0,a0,-1550 # 6450 <malloc+0x12e8>
+    2a66:	64e020ef          	jal	50b4 <printf>
+    exit(1);
+    2a6a:	4505                	li	a0,1
+    2a6c:	218020ef          	jal	4c84 <exit>
+
+0000000000002a70 <exitiputtest>:
+{
+    2a70:	7179                	addi	sp,sp,-48
+    2a72:	f406                	sd	ra,40(sp)
+    2a74:	f022                	sd	s0,32(sp)
+    2a76:	ec26                	sd	s1,24(sp)
+    2a78:	1800                	addi	s0,sp,48
+    2a7a:	84aa                	mv	s1,a0
+  pid = fork();
+    2a7c:	200020ef          	jal	4c7c <fork>
+  if(pid < 0){
+    2a80:	02054e63          	bltz	a0,2abc <exitiputtest+0x4c>
+  if(pid == 0){
+    2a84:	e541                	bnez	a0,2b0c <exitiputtest+0x9c>
+    if(mkdir("iputdir") < 0){
+    2a86:	00004517          	auipc	a0,0x4
+    2a8a:	95250513          	addi	a0,a0,-1710 # 63d8 <malloc+0x1270>
+    2a8e:	25e020ef          	jal	4cec <mkdir>
+    2a92:	02054f63          	bltz	a0,2ad0 <exitiputtest+0x60>
+    if(chdir("iputdir") < 0){
+    2a96:	00004517          	auipc	a0,0x4
+    2a9a:	94250513          	addi	a0,a0,-1726 # 63d8 <malloc+0x1270>
+    2a9e:	256020ef          	jal	4cf4 <chdir>
+    2aa2:	04054163          	bltz	a0,2ae4 <exitiputtest+0x74>
+    if(unlink("../iputdir") < 0){
+    2aa6:	00004517          	auipc	a0,0x4
+    2aaa:	97250513          	addi	a0,a0,-1678 # 6418 <malloc+0x12b0>
+    2aae:	226020ef          	jal	4cd4 <unlink>
+    2ab2:	04054363          	bltz	a0,2af8 <exitiputtest+0x88>
+    exit(0);
+    2ab6:	4501                	li	a0,0
+    2ab8:	1cc020ef          	jal	4c84 <exit>
+    printf("%s: fork failed\n", s);
+    2abc:	85a6                	mv	a1,s1
+    2abe:	00003517          	auipc	a0,0x3
+    2ac2:	06a50513          	addi	a0,a0,106 # 5b28 <malloc+0x9c0>
+    2ac6:	5ee020ef          	jal	50b4 <printf>
+    exit(1);
+    2aca:	4505                	li	a0,1
+    2acc:	1b8020ef          	jal	4c84 <exit>
+      printf("%s: mkdir failed\n", s);
+    2ad0:	85a6                	mv	a1,s1
+    2ad2:	00004517          	auipc	a0,0x4
+    2ad6:	90e50513          	addi	a0,a0,-1778 # 63e0 <malloc+0x1278>
+    2ada:	5da020ef          	jal	50b4 <printf>
+      exit(1);
+    2ade:	4505                	li	a0,1
+    2ae0:	1a4020ef          	jal	4c84 <exit>
+      printf("%s: child chdir failed\n", s);
+    2ae4:	85a6                	mv	a1,s1
+    2ae6:	00004517          	auipc	a0,0x4
+    2aea:	98250513          	addi	a0,a0,-1662 # 6468 <malloc+0x1300>
+    2aee:	5c6020ef          	jal	50b4 <printf>
+      exit(1);
+    2af2:	4505                	li	a0,1
+    2af4:	190020ef          	jal	4c84 <exit>
+      printf("%s: unlink ../iputdir failed\n", s);
+    2af8:	85a6                	mv	a1,s1
+    2afa:	00004517          	auipc	a0,0x4
+    2afe:	92e50513          	addi	a0,a0,-1746 # 6428 <malloc+0x12c0>
+    2b02:	5b2020ef          	jal	50b4 <printf>
+      exit(1);
+    2b06:	4505                	li	a0,1
+    2b08:	17c020ef          	jal	4c84 <exit>
+  wait(&xstatus);
+    2b0c:	fdc40513          	addi	a0,s0,-36
+    2b10:	17c020ef          	jal	4c8c <wait>
+  exit(xstatus);
+    2b14:	fdc42503          	lw	a0,-36(s0)
+    2b18:	16c020ef          	jal	4c84 <exit>
+
+0000000000002b1c <dirtest>:
+{
+    2b1c:	1101                	addi	sp,sp,-32
+    2b1e:	ec06                	sd	ra,24(sp)
+    2b20:	e822                	sd	s0,16(sp)
+    2b22:	e426                	sd	s1,8(sp)
+    2b24:	1000                	addi	s0,sp,32
+    2b26:	84aa                	mv	s1,a0
+  if(mkdir("dir0") < 0){
+    2b28:	00004517          	auipc	a0,0x4
+    2b2c:	95850513          	addi	a0,a0,-1704 # 6480 <malloc+0x1318>
+    2b30:	1bc020ef          	jal	4cec <mkdir>
+    2b34:	02054f63          	bltz	a0,2b72 <dirtest+0x56>
+  if(chdir("dir0") < 0){
+    2b38:	00004517          	auipc	a0,0x4
+    2b3c:	94850513          	addi	a0,a0,-1720 # 6480 <malloc+0x1318>
+    2b40:	1b4020ef          	jal	4cf4 <chdir>
+    2b44:	04054163          	bltz	a0,2b86 <dirtest+0x6a>
+  if(chdir("..") < 0){
+    2b48:	00004517          	auipc	a0,0x4
+    2b4c:	95850513          	addi	a0,a0,-1704 # 64a0 <malloc+0x1338>
+    2b50:	1a4020ef          	jal	4cf4 <chdir>
+    2b54:	04054363          	bltz	a0,2b9a <dirtest+0x7e>
+  if(unlink("dir0") < 0){
+    2b58:	00004517          	auipc	a0,0x4
+    2b5c:	92850513          	addi	a0,a0,-1752 # 6480 <malloc+0x1318>
+    2b60:	174020ef          	jal	4cd4 <unlink>
+    2b64:	04054563          	bltz	a0,2bae <dirtest+0x92>
+}
+    2b68:	60e2                	ld	ra,24(sp)
+    2b6a:	6442                	ld	s0,16(sp)
+    2b6c:	64a2                	ld	s1,8(sp)
+    2b6e:	6105                	addi	sp,sp,32
+    2b70:	8082                	ret
+    printf("%s: mkdir failed\n", s);
+    2b72:	85a6                	mv	a1,s1
+    2b74:	00004517          	auipc	a0,0x4
+    2b78:	86c50513          	addi	a0,a0,-1940 # 63e0 <malloc+0x1278>
+    2b7c:	538020ef          	jal	50b4 <printf>
+    exit(1);
+    2b80:	4505                	li	a0,1
+    2b82:	102020ef          	jal	4c84 <exit>
+    printf("%s: chdir dir0 failed\n", s);
+    2b86:	85a6                	mv	a1,s1
+    2b88:	00004517          	auipc	a0,0x4
+    2b8c:	90050513          	addi	a0,a0,-1792 # 6488 <malloc+0x1320>
+    2b90:	524020ef          	jal	50b4 <printf>
+    exit(1);
+    2b94:	4505                	li	a0,1
+    2b96:	0ee020ef          	jal	4c84 <exit>
+    printf("%s: chdir .. failed\n", s);
+    2b9a:	85a6                	mv	a1,s1
+    2b9c:	00004517          	auipc	a0,0x4
+    2ba0:	90c50513          	addi	a0,a0,-1780 # 64a8 <malloc+0x1340>
+    2ba4:	510020ef          	jal	50b4 <printf>
+    exit(1);
+    2ba8:	4505                	li	a0,1
+    2baa:	0da020ef          	jal	4c84 <exit>
+    printf("%s: unlink dir0 failed\n", s);
+    2bae:	85a6                	mv	a1,s1
+    2bb0:	00004517          	auipc	a0,0x4
+    2bb4:	91050513          	addi	a0,a0,-1776 # 64c0 <malloc+0x1358>
+    2bb8:	4fc020ef          	jal	50b4 <printf>
+    exit(1);
+    2bbc:	4505                	li	a0,1
+    2bbe:	0c6020ef          	jal	4c84 <exit>
+
+0000000000002bc2 <subdir>:
+{
+    2bc2:	1101                	addi	sp,sp,-32
+    2bc4:	ec06                	sd	ra,24(sp)
+    2bc6:	e822                	sd	s0,16(sp)
+    2bc8:	e426                	sd	s1,8(sp)
+    2bca:	e04a                	sd	s2,0(sp)
+    2bcc:	1000                	addi	s0,sp,32
+    2bce:	892a                	mv	s2,a0
+  unlink("ff");
+    2bd0:	00004517          	auipc	a0,0x4
+    2bd4:	a3850513          	addi	a0,a0,-1480 # 6608 <malloc+0x14a0>
+    2bd8:	0fc020ef          	jal	4cd4 <unlink>
+  if(mkdir("dd") != 0){
+    2bdc:	00004517          	auipc	a0,0x4
+    2be0:	8fc50513          	addi	a0,a0,-1796 # 64d8 <malloc+0x1370>
+    2be4:	108020ef          	jal	4cec <mkdir>
+    2be8:	2e051263          	bnez	a0,2ecc <subdir+0x30a>
+  fd = open("dd/ff", O_CREATE | O_RDWR);
+    2bec:	20200593          	li	a1,514
+    2bf0:	00004517          	auipc	a0,0x4
+    2bf4:	90850513          	addi	a0,a0,-1784 # 64f8 <malloc+0x1390>
+    2bf8:	0cc020ef          	jal	4cc4 <open>
+    2bfc:	84aa                	mv	s1,a0
+  if(fd < 0){
+    2bfe:	2e054163          	bltz	a0,2ee0 <subdir+0x31e>
+  write(fd, "ff", 2);
+    2c02:	4609                	li	a2,2
+    2c04:	00004597          	auipc	a1,0x4
+    2c08:	a0458593          	addi	a1,a1,-1532 # 6608 <malloc+0x14a0>
+    2c0c:	098020ef          	jal	4ca4 <write>
+  close(fd);
+    2c10:	8526                	mv	a0,s1
+    2c12:	09a020ef          	jal	4cac <close>
+  if(unlink("dd") >= 0){
+    2c16:	00004517          	auipc	a0,0x4
+    2c1a:	8c250513          	addi	a0,a0,-1854 # 64d8 <malloc+0x1370>
+    2c1e:	0b6020ef          	jal	4cd4 <unlink>
+    2c22:	2c055963          	bgez	a0,2ef4 <subdir+0x332>
+  if(mkdir("/dd/dd") != 0){
+    2c26:	00004517          	auipc	a0,0x4
+    2c2a:	92a50513          	addi	a0,a0,-1750 # 6550 <malloc+0x13e8>
+    2c2e:	0be020ef          	jal	4cec <mkdir>
+    2c32:	2c051b63          	bnez	a0,2f08 <subdir+0x346>
+  fd = open("dd/dd/ff", O_CREATE | O_RDWR);
+    2c36:	20200593          	li	a1,514
+    2c3a:	00004517          	auipc	a0,0x4
+    2c3e:	93e50513          	addi	a0,a0,-1730 # 6578 <malloc+0x1410>
+    2c42:	082020ef          	jal	4cc4 <open>
+    2c46:	84aa                	mv	s1,a0
+  if(fd < 0){
+    2c48:	2c054a63          	bltz	a0,2f1c <subdir+0x35a>
+  write(fd, "FF", 2);
+    2c4c:	4609                	li	a2,2
+    2c4e:	00004597          	auipc	a1,0x4
+    2c52:	95a58593          	addi	a1,a1,-1702 # 65a8 <malloc+0x1440>
+    2c56:	04e020ef          	jal	4ca4 <write>
+  close(fd);
+    2c5a:	8526                	mv	a0,s1
+    2c5c:	050020ef          	jal	4cac <close>
+  fd = open("dd/dd/../ff", 0);
+    2c60:	4581                	li	a1,0
+    2c62:	00004517          	auipc	a0,0x4
+    2c66:	94e50513          	addi	a0,a0,-1714 # 65b0 <malloc+0x1448>
+    2c6a:	05a020ef          	jal	4cc4 <open>
+    2c6e:	84aa                	mv	s1,a0
+  if(fd < 0){
+    2c70:	2c054063          	bltz	a0,2f30 <subdir+0x36e>
+  cc = read(fd, buf, sizeof(buf));
+    2c74:	660d                	lui	a2,0x3
+    2c76:	0000a597          	auipc	a1,0xa
+    2c7a:	03258593          	addi	a1,a1,50 # cca8 <buf>
+    2c7e:	01e020ef          	jal	4c9c <read>
+  if(cc != 2 || buf[0] != 'f'){
+    2c82:	4789                	li	a5,2
+    2c84:	2cf51063          	bne	a0,a5,2f44 <subdir+0x382>
+    2c88:	0000a717          	auipc	a4,0xa
+    2c8c:	02074703          	lbu	a4,32(a4) # cca8 <buf>
+    2c90:	06600793          	li	a5,102
+    2c94:	2af71863          	bne	a4,a5,2f44 <subdir+0x382>
+  close(fd);
+    2c98:	8526                	mv	a0,s1
+    2c9a:	012020ef          	jal	4cac <close>
+  if(link("dd/dd/ff", "dd/dd/ffff") != 0){
+    2c9e:	00004597          	auipc	a1,0x4
+    2ca2:	96258593          	addi	a1,a1,-1694 # 6600 <malloc+0x1498>
+    2ca6:	00004517          	auipc	a0,0x4
+    2caa:	8d250513          	addi	a0,a0,-1838 # 6578 <malloc+0x1410>
+    2cae:	036020ef          	jal	4ce4 <link>
+    2cb2:	2a051363          	bnez	a0,2f58 <subdir+0x396>
+  if(unlink("dd/dd/ff") != 0){
+    2cb6:	00004517          	auipc	a0,0x4
+    2cba:	8c250513          	addi	a0,a0,-1854 # 6578 <malloc+0x1410>
+    2cbe:	016020ef          	jal	4cd4 <unlink>
+    2cc2:	2a051563          	bnez	a0,2f6c <subdir+0x3aa>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    2cc6:	4581                	li	a1,0
+    2cc8:	00004517          	auipc	a0,0x4
+    2ccc:	8b050513          	addi	a0,a0,-1872 # 6578 <malloc+0x1410>
+    2cd0:	7f5010ef          	jal	4cc4 <open>
+    2cd4:	2a055663          	bgez	a0,2f80 <subdir+0x3be>
+  if(chdir("dd") != 0){
+    2cd8:	00004517          	auipc	a0,0x4
+    2cdc:	80050513          	addi	a0,a0,-2048 # 64d8 <malloc+0x1370>
+    2ce0:	014020ef          	jal	4cf4 <chdir>
+    2ce4:	2a051863          	bnez	a0,2f94 <subdir+0x3d2>
+  if(chdir("dd/../../dd") != 0){
+    2ce8:	00004517          	auipc	a0,0x4
+    2cec:	9b050513          	addi	a0,a0,-1616 # 6698 <malloc+0x1530>
+    2cf0:	004020ef          	jal	4cf4 <chdir>
+    2cf4:	2a051a63          	bnez	a0,2fa8 <subdir+0x3e6>
+  if(chdir("dd/../../../dd") != 0){
+    2cf8:	00004517          	auipc	a0,0x4
+    2cfc:	9d050513          	addi	a0,a0,-1584 # 66c8 <malloc+0x1560>
+    2d00:	7f5010ef          	jal	4cf4 <chdir>
+    2d04:	2a051c63          	bnez	a0,2fbc <subdir+0x3fa>
+  if(chdir("./..") != 0){
+    2d08:	00004517          	auipc	a0,0x4
+    2d0c:	9f850513          	addi	a0,a0,-1544 # 6700 <malloc+0x1598>
+    2d10:	7e5010ef          	jal	4cf4 <chdir>
+    2d14:	2a051e63          	bnez	a0,2fd0 <subdir+0x40e>
+  fd = open("dd/dd/ffff", 0);
+    2d18:	4581                	li	a1,0
+    2d1a:	00004517          	auipc	a0,0x4
+    2d1e:	8e650513          	addi	a0,a0,-1818 # 6600 <malloc+0x1498>
+    2d22:	7a3010ef          	jal	4cc4 <open>
+    2d26:	84aa                	mv	s1,a0
+  if(fd < 0){
+    2d28:	2a054e63          	bltz	a0,2fe4 <subdir+0x422>
+  if(read(fd, buf, sizeof(buf)) != 2){
+    2d2c:	660d                	lui	a2,0x3
+    2d2e:	0000a597          	auipc	a1,0xa
+    2d32:	f7a58593          	addi	a1,a1,-134 # cca8 <buf>
+    2d36:	767010ef          	jal	4c9c <read>
+    2d3a:	4789                	li	a5,2
+    2d3c:	2af51e63          	bne	a0,a5,2ff8 <subdir+0x436>
+  close(fd);
+    2d40:	8526                	mv	a0,s1
+    2d42:	76b010ef          	jal	4cac <close>
+  if(open("dd/dd/ff", O_RDONLY) >= 0){
+    2d46:	4581                	li	a1,0
+    2d48:	00004517          	auipc	a0,0x4
+    2d4c:	83050513          	addi	a0,a0,-2000 # 6578 <malloc+0x1410>
+    2d50:	775010ef          	jal	4cc4 <open>
+    2d54:	2a055c63          	bgez	a0,300c <subdir+0x44a>
+  if(open("dd/ff/ff", O_CREATE|O_RDWR) >= 0){
+    2d58:	20200593          	li	a1,514
+    2d5c:	00004517          	auipc	a0,0x4
+    2d60:	a3450513          	addi	a0,a0,-1484 # 6790 <malloc+0x1628>
+    2d64:	761010ef          	jal	4cc4 <open>
+    2d68:	2a055c63          	bgez	a0,3020 <subdir+0x45e>
+  if(open("dd/xx/ff", O_CREATE|O_RDWR) >= 0){
+    2d6c:	20200593          	li	a1,514
+    2d70:	00004517          	auipc	a0,0x4
+    2d74:	a5050513          	addi	a0,a0,-1456 # 67c0 <malloc+0x1658>
+    2d78:	74d010ef          	jal	4cc4 <open>
+    2d7c:	2a055c63          	bgez	a0,3034 <subdir+0x472>
+  if(open("dd", O_CREATE) >= 0){
+    2d80:	20000593          	li	a1,512
+    2d84:	00003517          	auipc	a0,0x3
+    2d88:	75450513          	addi	a0,a0,1876 # 64d8 <malloc+0x1370>
+    2d8c:	739010ef          	jal	4cc4 <open>
+    2d90:	2a055c63          	bgez	a0,3048 <subdir+0x486>
+  if(open("dd", O_RDWR) >= 0){
+    2d94:	4589                	li	a1,2
+    2d96:	00003517          	auipc	a0,0x3
+    2d9a:	74250513          	addi	a0,a0,1858 # 64d8 <malloc+0x1370>
+    2d9e:	727010ef          	jal	4cc4 <open>
+    2da2:	2a055d63          	bgez	a0,305c <subdir+0x49a>
+  if(open("dd", O_WRONLY) >= 0){
+    2da6:	4585                	li	a1,1
+    2da8:	00003517          	auipc	a0,0x3
+    2dac:	73050513          	addi	a0,a0,1840 # 64d8 <malloc+0x1370>
+    2db0:	715010ef          	jal	4cc4 <open>
+    2db4:	2a055e63          	bgez	a0,3070 <subdir+0x4ae>
+  if(link("dd/ff/ff", "dd/dd/xx") == 0){
+    2db8:	00004597          	auipc	a1,0x4
+    2dbc:	a9858593          	addi	a1,a1,-1384 # 6850 <malloc+0x16e8>
+    2dc0:	00004517          	auipc	a0,0x4
+    2dc4:	9d050513          	addi	a0,a0,-1584 # 6790 <malloc+0x1628>
+    2dc8:	71d010ef          	jal	4ce4 <link>
+    2dcc:	2a050c63          	beqz	a0,3084 <subdir+0x4c2>
+  if(link("dd/xx/ff", "dd/dd/xx") == 0){
+    2dd0:	00004597          	auipc	a1,0x4
+    2dd4:	a8058593          	addi	a1,a1,-1408 # 6850 <malloc+0x16e8>
+    2dd8:	00004517          	auipc	a0,0x4
+    2ddc:	9e850513          	addi	a0,a0,-1560 # 67c0 <malloc+0x1658>
+    2de0:	705010ef          	jal	4ce4 <link>
+    2de4:	2a050a63          	beqz	a0,3098 <subdir+0x4d6>
+  if(link("dd/ff", "dd/dd/ffff") == 0){
+    2de8:	00004597          	auipc	a1,0x4
+    2dec:	81858593          	addi	a1,a1,-2024 # 6600 <malloc+0x1498>
+    2df0:	00003517          	auipc	a0,0x3
+    2df4:	70850513          	addi	a0,a0,1800 # 64f8 <malloc+0x1390>
+    2df8:	6ed010ef          	jal	4ce4 <link>
+    2dfc:	2a050863          	beqz	a0,30ac <subdir+0x4ea>
+  if(mkdir("dd/ff/ff") == 0){
+    2e00:	00004517          	auipc	a0,0x4
+    2e04:	99050513          	addi	a0,a0,-1648 # 6790 <malloc+0x1628>
+    2e08:	6e5010ef          	jal	4cec <mkdir>
+    2e0c:	2a050a63          	beqz	a0,30c0 <subdir+0x4fe>
+  if(mkdir("dd/xx/ff") == 0){
+    2e10:	00004517          	auipc	a0,0x4
+    2e14:	9b050513          	addi	a0,a0,-1616 # 67c0 <malloc+0x1658>
+    2e18:	6d5010ef          	jal	4cec <mkdir>
+    2e1c:	2a050c63          	beqz	a0,30d4 <subdir+0x512>
+  if(mkdir("dd/dd/ffff") == 0){
+    2e20:	00003517          	auipc	a0,0x3
+    2e24:	7e050513          	addi	a0,a0,2016 # 6600 <malloc+0x1498>
+    2e28:	6c5010ef          	jal	4cec <mkdir>
+    2e2c:	2a050e63          	beqz	a0,30e8 <subdir+0x526>
+  if(unlink("dd/xx/ff") == 0){
+    2e30:	00004517          	auipc	a0,0x4
+    2e34:	99050513          	addi	a0,a0,-1648 # 67c0 <malloc+0x1658>
+    2e38:	69d010ef          	jal	4cd4 <unlink>
+    2e3c:	2c050063          	beqz	a0,30fc <subdir+0x53a>
+  if(unlink("dd/ff/ff") == 0){
+    2e40:	00004517          	auipc	a0,0x4
+    2e44:	95050513          	addi	a0,a0,-1712 # 6790 <malloc+0x1628>
+    2e48:	68d010ef          	jal	4cd4 <unlink>
+    2e4c:	2c050263          	beqz	a0,3110 <subdir+0x54e>
+  if(chdir("dd/ff") == 0){
+    2e50:	00003517          	auipc	a0,0x3
+    2e54:	6a850513          	addi	a0,a0,1704 # 64f8 <malloc+0x1390>
+    2e58:	69d010ef          	jal	4cf4 <chdir>
+    2e5c:	2c050463          	beqz	a0,3124 <subdir+0x562>
+  if(chdir("dd/xx") == 0){
+    2e60:	00004517          	auipc	a0,0x4
+    2e64:	b4050513          	addi	a0,a0,-1216 # 69a0 <malloc+0x1838>
+    2e68:	68d010ef          	jal	4cf4 <chdir>
+    2e6c:	2c050663          	beqz	a0,3138 <subdir+0x576>
+  if(unlink("dd/dd/ffff") != 0){
+    2e70:	00003517          	auipc	a0,0x3
+    2e74:	79050513          	addi	a0,a0,1936 # 6600 <malloc+0x1498>
+    2e78:	65d010ef          	jal	4cd4 <unlink>
+    2e7c:	2c051863          	bnez	a0,314c <subdir+0x58a>
+  if(unlink("dd/ff") != 0){
+    2e80:	00003517          	auipc	a0,0x3
+    2e84:	67850513          	addi	a0,a0,1656 # 64f8 <malloc+0x1390>
+    2e88:	64d010ef          	jal	4cd4 <unlink>
+    2e8c:	2c051a63          	bnez	a0,3160 <subdir+0x59e>
+  if(unlink("dd") == 0){
+    2e90:	00003517          	auipc	a0,0x3
+    2e94:	64850513          	addi	a0,a0,1608 # 64d8 <malloc+0x1370>
+    2e98:	63d010ef          	jal	4cd4 <unlink>
+    2e9c:	2c050c63          	beqz	a0,3174 <subdir+0x5b2>
+  if(unlink("dd/dd") < 0){
+    2ea0:	00004517          	auipc	a0,0x4
+    2ea4:	b7050513          	addi	a0,a0,-1168 # 6a10 <malloc+0x18a8>
+    2ea8:	62d010ef          	jal	4cd4 <unlink>
+    2eac:	2c054e63          	bltz	a0,3188 <subdir+0x5c6>
+  if(unlink("dd") < 0){
+    2eb0:	00003517          	auipc	a0,0x3
+    2eb4:	62850513          	addi	a0,a0,1576 # 64d8 <malloc+0x1370>
+    2eb8:	61d010ef          	jal	4cd4 <unlink>
+    2ebc:	2e054063          	bltz	a0,319c <subdir+0x5da>
+}
+    2ec0:	60e2                	ld	ra,24(sp)
+    2ec2:	6442                	ld	s0,16(sp)
+    2ec4:	64a2                	ld	s1,8(sp)
+    2ec6:	6902                	ld	s2,0(sp)
+    2ec8:	6105                	addi	sp,sp,32
+    2eca:	8082                	ret
+    printf("%s: mkdir dd failed\n", s);
+    2ecc:	85ca                	mv	a1,s2
+    2ece:	00003517          	auipc	a0,0x3
+    2ed2:	61250513          	addi	a0,a0,1554 # 64e0 <malloc+0x1378>
+    2ed6:	1de020ef          	jal	50b4 <printf>
+    exit(1);
+    2eda:	4505                	li	a0,1
+    2edc:	5a9010ef          	jal	4c84 <exit>
+    printf("%s: create dd/ff failed\n", s);
+    2ee0:	85ca                	mv	a1,s2
+    2ee2:	00003517          	auipc	a0,0x3
+    2ee6:	61e50513          	addi	a0,a0,1566 # 6500 <malloc+0x1398>
+    2eea:	1ca020ef          	jal	50b4 <printf>
+    exit(1);
+    2eee:	4505                	li	a0,1
+    2ef0:	595010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd (non-empty dir) succeeded!\n", s);
+    2ef4:	85ca                	mv	a1,s2
+    2ef6:	00003517          	auipc	a0,0x3
+    2efa:	62a50513          	addi	a0,a0,1578 # 6520 <malloc+0x13b8>
+    2efe:	1b6020ef          	jal	50b4 <printf>
+    exit(1);
+    2f02:	4505                	li	a0,1
+    2f04:	581010ef          	jal	4c84 <exit>
+    printf("%s: subdir mkdir dd/dd failed\n", s);
+    2f08:	85ca                	mv	a1,s2
+    2f0a:	00003517          	auipc	a0,0x3
+    2f0e:	64e50513          	addi	a0,a0,1614 # 6558 <malloc+0x13f0>
+    2f12:	1a2020ef          	jal	50b4 <printf>
+    exit(1);
+    2f16:	4505                	li	a0,1
+    2f18:	56d010ef          	jal	4c84 <exit>
+    printf("%s: create dd/dd/ff failed\n", s);
+    2f1c:	85ca                	mv	a1,s2
+    2f1e:	00003517          	auipc	a0,0x3
+    2f22:	66a50513          	addi	a0,a0,1642 # 6588 <malloc+0x1420>
+    2f26:	18e020ef          	jal	50b4 <printf>
+    exit(1);
+    2f2a:	4505                	li	a0,1
+    2f2c:	559010ef          	jal	4c84 <exit>
+    printf("%s: open dd/dd/../ff failed\n", s);
+    2f30:	85ca                	mv	a1,s2
+    2f32:	00003517          	auipc	a0,0x3
+    2f36:	68e50513          	addi	a0,a0,1678 # 65c0 <malloc+0x1458>
+    2f3a:	17a020ef          	jal	50b4 <printf>
+    exit(1);
+    2f3e:	4505                	li	a0,1
+    2f40:	545010ef          	jal	4c84 <exit>
+    printf("%s: dd/dd/../ff wrong content\n", s);
+    2f44:	85ca                	mv	a1,s2
+    2f46:	00003517          	auipc	a0,0x3
+    2f4a:	69a50513          	addi	a0,a0,1690 # 65e0 <malloc+0x1478>
+    2f4e:	166020ef          	jal	50b4 <printf>
+    exit(1);
+    2f52:	4505                	li	a0,1
+    2f54:	531010ef          	jal	4c84 <exit>
+    printf("%s: link dd/dd/ff dd/dd/ffff failed\n", s);
+    2f58:	85ca                	mv	a1,s2
+    2f5a:	00003517          	auipc	a0,0x3
+    2f5e:	6b650513          	addi	a0,a0,1718 # 6610 <malloc+0x14a8>
+    2f62:	152020ef          	jal	50b4 <printf>
+    exit(1);
+    2f66:	4505                	li	a0,1
+    2f68:	51d010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/dd/ff failed\n", s);
+    2f6c:	85ca                	mv	a1,s2
+    2f6e:	00003517          	auipc	a0,0x3
+    2f72:	6ca50513          	addi	a0,a0,1738 # 6638 <malloc+0x14d0>
+    2f76:	13e020ef          	jal	50b4 <printf>
+    exit(1);
+    2f7a:	4505                	li	a0,1
+    2f7c:	509010ef          	jal	4c84 <exit>
+    printf("%s: open (unlinked) dd/dd/ff succeeded\n", s);
+    2f80:	85ca                	mv	a1,s2
+    2f82:	00003517          	auipc	a0,0x3
+    2f86:	6d650513          	addi	a0,a0,1750 # 6658 <malloc+0x14f0>
+    2f8a:	12a020ef          	jal	50b4 <printf>
+    exit(1);
+    2f8e:	4505                	li	a0,1
+    2f90:	4f5010ef          	jal	4c84 <exit>
+    printf("%s: chdir dd failed\n", s);
+    2f94:	85ca                	mv	a1,s2
+    2f96:	00003517          	auipc	a0,0x3
+    2f9a:	6ea50513          	addi	a0,a0,1770 # 6680 <malloc+0x1518>
+    2f9e:	116020ef          	jal	50b4 <printf>
+    exit(1);
+    2fa2:	4505                	li	a0,1
+    2fa4:	4e1010ef          	jal	4c84 <exit>
+    printf("%s: chdir dd/../../dd failed\n", s);
+    2fa8:	85ca                	mv	a1,s2
+    2faa:	00003517          	auipc	a0,0x3
+    2fae:	6fe50513          	addi	a0,a0,1790 # 66a8 <malloc+0x1540>
+    2fb2:	102020ef          	jal	50b4 <printf>
+    exit(1);
+    2fb6:	4505                	li	a0,1
+    2fb8:	4cd010ef          	jal	4c84 <exit>
+    printf("%s: chdir dd/../../../dd failed\n", s);
+    2fbc:	85ca                	mv	a1,s2
+    2fbe:	00003517          	auipc	a0,0x3
+    2fc2:	71a50513          	addi	a0,a0,1818 # 66d8 <malloc+0x1570>
+    2fc6:	0ee020ef          	jal	50b4 <printf>
+    exit(1);
+    2fca:	4505                	li	a0,1
+    2fcc:	4b9010ef          	jal	4c84 <exit>
+    printf("%s: chdir ./.. failed\n", s);
+    2fd0:	85ca                	mv	a1,s2
+    2fd2:	00003517          	auipc	a0,0x3
+    2fd6:	73650513          	addi	a0,a0,1846 # 6708 <malloc+0x15a0>
+    2fda:	0da020ef          	jal	50b4 <printf>
+    exit(1);
+    2fde:	4505                	li	a0,1
+    2fe0:	4a5010ef          	jal	4c84 <exit>
+    printf("%s: open dd/dd/ffff failed\n", s);
+    2fe4:	85ca                	mv	a1,s2
+    2fe6:	00003517          	auipc	a0,0x3
+    2fea:	73a50513          	addi	a0,a0,1850 # 6720 <malloc+0x15b8>
+    2fee:	0c6020ef          	jal	50b4 <printf>
+    exit(1);
+    2ff2:	4505                	li	a0,1
+    2ff4:	491010ef          	jal	4c84 <exit>
+    printf("%s: read dd/dd/ffff wrong len\n", s);
+    2ff8:	85ca                	mv	a1,s2
+    2ffa:	00003517          	auipc	a0,0x3
+    2ffe:	74650513          	addi	a0,a0,1862 # 6740 <malloc+0x15d8>
+    3002:	0b2020ef          	jal	50b4 <printf>
+    exit(1);
+    3006:	4505                	li	a0,1
+    3008:	47d010ef          	jal	4c84 <exit>
+    printf("%s: open (unlinked) dd/dd/ff succeeded!\n", s);
+    300c:	85ca                	mv	a1,s2
+    300e:	00003517          	auipc	a0,0x3
+    3012:	75250513          	addi	a0,a0,1874 # 6760 <malloc+0x15f8>
+    3016:	09e020ef          	jal	50b4 <printf>
+    exit(1);
+    301a:	4505                	li	a0,1
+    301c:	469010ef          	jal	4c84 <exit>
+    printf("%s: create dd/ff/ff succeeded!\n", s);
+    3020:	85ca                	mv	a1,s2
+    3022:	00003517          	auipc	a0,0x3
+    3026:	77e50513          	addi	a0,a0,1918 # 67a0 <malloc+0x1638>
+    302a:	08a020ef          	jal	50b4 <printf>
+    exit(1);
+    302e:	4505                	li	a0,1
+    3030:	455010ef          	jal	4c84 <exit>
+    printf("%s: create dd/xx/ff succeeded!\n", s);
+    3034:	85ca                	mv	a1,s2
+    3036:	00003517          	auipc	a0,0x3
+    303a:	79a50513          	addi	a0,a0,1946 # 67d0 <malloc+0x1668>
+    303e:	076020ef          	jal	50b4 <printf>
+    exit(1);
+    3042:	4505                	li	a0,1
+    3044:	441010ef          	jal	4c84 <exit>
+    printf("%s: create dd succeeded!\n", s);
+    3048:	85ca                	mv	a1,s2
+    304a:	00003517          	auipc	a0,0x3
+    304e:	7a650513          	addi	a0,a0,1958 # 67f0 <malloc+0x1688>
+    3052:	062020ef          	jal	50b4 <printf>
+    exit(1);
+    3056:	4505                	li	a0,1
+    3058:	42d010ef          	jal	4c84 <exit>
+    printf("%s: open dd rdwr succeeded!\n", s);
+    305c:	85ca                	mv	a1,s2
+    305e:	00003517          	auipc	a0,0x3
+    3062:	7b250513          	addi	a0,a0,1970 # 6810 <malloc+0x16a8>
+    3066:	04e020ef          	jal	50b4 <printf>
+    exit(1);
+    306a:	4505                	li	a0,1
+    306c:	419010ef          	jal	4c84 <exit>
+    printf("%s: open dd wronly succeeded!\n", s);
+    3070:	85ca                	mv	a1,s2
+    3072:	00003517          	auipc	a0,0x3
+    3076:	7be50513          	addi	a0,a0,1982 # 6830 <malloc+0x16c8>
+    307a:	03a020ef          	jal	50b4 <printf>
+    exit(1);
+    307e:	4505                	li	a0,1
+    3080:	405010ef          	jal	4c84 <exit>
+    printf("%s: link dd/ff/ff dd/dd/xx succeeded!\n", s);
+    3084:	85ca                	mv	a1,s2
+    3086:	00003517          	auipc	a0,0x3
+    308a:	7da50513          	addi	a0,a0,2010 # 6860 <malloc+0x16f8>
+    308e:	026020ef          	jal	50b4 <printf>
+    exit(1);
+    3092:	4505                	li	a0,1
+    3094:	3f1010ef          	jal	4c84 <exit>
+    printf("%s: link dd/xx/ff dd/dd/xx succeeded!\n", s);
+    3098:	85ca                	mv	a1,s2
+    309a:	00003517          	auipc	a0,0x3
+    309e:	7ee50513          	addi	a0,a0,2030 # 6888 <malloc+0x1720>
+    30a2:	012020ef          	jal	50b4 <printf>
+    exit(1);
+    30a6:	4505                	li	a0,1
+    30a8:	3dd010ef          	jal	4c84 <exit>
+    printf("%s: link dd/ff dd/dd/ffff succeeded!\n", s);
+    30ac:	85ca                	mv	a1,s2
+    30ae:	00004517          	auipc	a0,0x4
+    30b2:	80250513          	addi	a0,a0,-2046 # 68b0 <malloc+0x1748>
+    30b6:	7ff010ef          	jal	50b4 <printf>
+    exit(1);
+    30ba:	4505                	li	a0,1
+    30bc:	3c9010ef          	jal	4c84 <exit>
+    printf("%s: mkdir dd/ff/ff succeeded!\n", s);
+    30c0:	85ca                	mv	a1,s2
+    30c2:	00004517          	auipc	a0,0x4
+    30c6:	81650513          	addi	a0,a0,-2026 # 68d8 <malloc+0x1770>
+    30ca:	7eb010ef          	jal	50b4 <printf>
+    exit(1);
+    30ce:	4505                	li	a0,1
+    30d0:	3b5010ef          	jal	4c84 <exit>
+    printf("%s: mkdir dd/xx/ff succeeded!\n", s);
+    30d4:	85ca                	mv	a1,s2
+    30d6:	00004517          	auipc	a0,0x4
+    30da:	82250513          	addi	a0,a0,-2014 # 68f8 <malloc+0x1790>
+    30de:	7d7010ef          	jal	50b4 <printf>
+    exit(1);
+    30e2:	4505                	li	a0,1
+    30e4:	3a1010ef          	jal	4c84 <exit>
+    printf("%s: mkdir dd/dd/ffff succeeded!\n", s);
+    30e8:	85ca                	mv	a1,s2
+    30ea:	00004517          	auipc	a0,0x4
+    30ee:	82e50513          	addi	a0,a0,-2002 # 6918 <malloc+0x17b0>
+    30f2:	7c3010ef          	jal	50b4 <printf>
+    exit(1);
+    30f6:	4505                	li	a0,1
+    30f8:	38d010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/xx/ff succeeded!\n", s);
+    30fc:	85ca                	mv	a1,s2
+    30fe:	00004517          	auipc	a0,0x4
+    3102:	84250513          	addi	a0,a0,-1982 # 6940 <malloc+0x17d8>
+    3106:	7af010ef          	jal	50b4 <printf>
+    exit(1);
+    310a:	4505                	li	a0,1
+    310c:	379010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/ff/ff succeeded!\n", s);
+    3110:	85ca                	mv	a1,s2
+    3112:	00004517          	auipc	a0,0x4
+    3116:	84e50513          	addi	a0,a0,-1970 # 6960 <malloc+0x17f8>
+    311a:	79b010ef          	jal	50b4 <printf>
+    exit(1);
+    311e:	4505                	li	a0,1
+    3120:	365010ef          	jal	4c84 <exit>
+    printf("%s: chdir dd/ff succeeded!\n", s);
+    3124:	85ca                	mv	a1,s2
+    3126:	00004517          	auipc	a0,0x4
+    312a:	85a50513          	addi	a0,a0,-1958 # 6980 <malloc+0x1818>
+    312e:	787010ef          	jal	50b4 <printf>
+    exit(1);
+    3132:	4505                	li	a0,1
+    3134:	351010ef          	jal	4c84 <exit>
+    printf("%s: chdir dd/xx succeeded!\n", s);
+    3138:	85ca                	mv	a1,s2
+    313a:	00004517          	auipc	a0,0x4
+    313e:	86e50513          	addi	a0,a0,-1938 # 69a8 <malloc+0x1840>
+    3142:	773010ef          	jal	50b4 <printf>
+    exit(1);
+    3146:	4505                	li	a0,1
+    3148:	33d010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/dd/ff failed\n", s);
+    314c:	85ca                	mv	a1,s2
+    314e:	00003517          	auipc	a0,0x3
+    3152:	4ea50513          	addi	a0,a0,1258 # 6638 <malloc+0x14d0>
+    3156:	75f010ef          	jal	50b4 <printf>
+    exit(1);
+    315a:	4505                	li	a0,1
+    315c:	329010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/ff failed\n", s);
+    3160:	85ca                	mv	a1,s2
+    3162:	00004517          	auipc	a0,0x4
+    3166:	86650513          	addi	a0,a0,-1946 # 69c8 <malloc+0x1860>
+    316a:	74b010ef          	jal	50b4 <printf>
+    exit(1);
+    316e:	4505                	li	a0,1
+    3170:	315010ef          	jal	4c84 <exit>
+    printf("%s: unlink non-empty dd succeeded!\n", s);
+    3174:	85ca                	mv	a1,s2
+    3176:	00004517          	auipc	a0,0x4
+    317a:	87250513          	addi	a0,a0,-1934 # 69e8 <malloc+0x1880>
+    317e:	737010ef          	jal	50b4 <printf>
+    exit(1);
+    3182:	4505                	li	a0,1
+    3184:	301010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd/dd failed\n", s);
+    3188:	85ca                	mv	a1,s2
+    318a:	00004517          	auipc	a0,0x4
+    318e:	88e50513          	addi	a0,a0,-1906 # 6a18 <malloc+0x18b0>
+    3192:	723010ef          	jal	50b4 <printf>
+    exit(1);
+    3196:	4505                	li	a0,1
+    3198:	2ed010ef          	jal	4c84 <exit>
+    printf("%s: unlink dd failed\n", s);
+    319c:	85ca                	mv	a1,s2
+    319e:	00004517          	auipc	a0,0x4
+    31a2:	89a50513          	addi	a0,a0,-1894 # 6a38 <malloc+0x18d0>
+    31a6:	70f010ef          	jal	50b4 <printf>
+    exit(1);
+    31aa:	4505                	li	a0,1
+    31ac:	2d9010ef          	jal	4c84 <exit>
+
+00000000000031b0 <rmdot>:
+{
+    31b0:	1101                	addi	sp,sp,-32
+    31b2:	ec06                	sd	ra,24(sp)
+    31b4:	e822                	sd	s0,16(sp)
+    31b6:	e426                	sd	s1,8(sp)
+    31b8:	1000                	addi	s0,sp,32
+    31ba:	84aa                	mv	s1,a0
+  if(mkdir("dots") != 0){
+    31bc:	00004517          	auipc	a0,0x4
+    31c0:	89450513          	addi	a0,a0,-1900 # 6a50 <malloc+0x18e8>
+    31c4:	329010ef          	jal	4cec <mkdir>
+    31c8:	e53d                	bnez	a0,3236 <rmdot+0x86>
+  if(chdir("dots") != 0){
+    31ca:	00004517          	auipc	a0,0x4
+    31ce:	88650513          	addi	a0,a0,-1914 # 6a50 <malloc+0x18e8>
+    31d2:	323010ef          	jal	4cf4 <chdir>
+    31d6:	e935                	bnez	a0,324a <rmdot+0x9a>
+  if(unlink(".") == 0){
+    31d8:	00002517          	auipc	a0,0x2
+    31dc:	7a850513          	addi	a0,a0,1960 # 5980 <malloc+0x818>
+    31e0:	2f5010ef          	jal	4cd4 <unlink>
+    31e4:	cd2d                	beqz	a0,325e <rmdot+0xae>
+  if(unlink("..") == 0){
+    31e6:	00003517          	auipc	a0,0x3
+    31ea:	2ba50513          	addi	a0,a0,698 # 64a0 <malloc+0x1338>
+    31ee:	2e7010ef          	jal	4cd4 <unlink>
+    31f2:	c141                	beqz	a0,3272 <rmdot+0xc2>
+  if(chdir("/") != 0){
+    31f4:	00003517          	auipc	a0,0x3
+    31f8:	25450513          	addi	a0,a0,596 # 6448 <malloc+0x12e0>
+    31fc:	2f9010ef          	jal	4cf4 <chdir>
+    3200:	e159                	bnez	a0,3286 <rmdot+0xd6>
+  if(unlink("dots/.") == 0){
+    3202:	00004517          	auipc	a0,0x4
+    3206:	8b650513          	addi	a0,a0,-1866 # 6ab8 <malloc+0x1950>
+    320a:	2cb010ef          	jal	4cd4 <unlink>
+    320e:	c551                	beqz	a0,329a <rmdot+0xea>
+  if(unlink("dots/..") == 0){
+    3210:	00004517          	auipc	a0,0x4
+    3214:	8d050513          	addi	a0,a0,-1840 # 6ae0 <malloc+0x1978>
+    3218:	2bd010ef          	jal	4cd4 <unlink>
+    321c:	c949                	beqz	a0,32ae <rmdot+0xfe>
+  if(unlink("dots") != 0){
+    321e:	00004517          	auipc	a0,0x4
+    3222:	83250513          	addi	a0,a0,-1998 # 6a50 <malloc+0x18e8>
+    3226:	2af010ef          	jal	4cd4 <unlink>
+    322a:	ed41                	bnez	a0,32c2 <rmdot+0x112>
+}
+    322c:	60e2                	ld	ra,24(sp)
+    322e:	6442                	ld	s0,16(sp)
+    3230:	64a2                	ld	s1,8(sp)
+    3232:	6105                	addi	sp,sp,32
+    3234:	8082                	ret
+    printf("%s: mkdir dots failed\n", s);
+    3236:	85a6                	mv	a1,s1
+    3238:	00004517          	auipc	a0,0x4
+    323c:	82050513          	addi	a0,a0,-2016 # 6a58 <malloc+0x18f0>
+    3240:	675010ef          	jal	50b4 <printf>
+    exit(1);
+    3244:	4505                	li	a0,1
+    3246:	23f010ef          	jal	4c84 <exit>
+    printf("%s: chdir dots failed\n", s);
+    324a:	85a6                	mv	a1,s1
+    324c:	00004517          	auipc	a0,0x4
+    3250:	82450513          	addi	a0,a0,-2012 # 6a70 <malloc+0x1908>
+    3254:	661010ef          	jal	50b4 <printf>
+    exit(1);
+    3258:	4505                	li	a0,1
+    325a:	22b010ef          	jal	4c84 <exit>
+    printf("%s: rm . worked!\n", s);
+    325e:	85a6                	mv	a1,s1
+    3260:	00004517          	auipc	a0,0x4
+    3264:	82850513          	addi	a0,a0,-2008 # 6a88 <malloc+0x1920>
+    3268:	64d010ef          	jal	50b4 <printf>
+    exit(1);
+    326c:	4505                	li	a0,1
+    326e:	217010ef          	jal	4c84 <exit>
+    printf("%s: rm .. worked!\n", s);
+    3272:	85a6                	mv	a1,s1
+    3274:	00004517          	auipc	a0,0x4
+    3278:	82c50513          	addi	a0,a0,-2004 # 6aa0 <malloc+0x1938>
+    327c:	639010ef          	jal	50b4 <printf>
+    exit(1);
+    3280:	4505                	li	a0,1
+    3282:	203010ef          	jal	4c84 <exit>
+    printf("%s: chdir / failed\n", s);
+    3286:	85a6                	mv	a1,s1
+    3288:	00003517          	auipc	a0,0x3
+    328c:	1c850513          	addi	a0,a0,456 # 6450 <malloc+0x12e8>
+    3290:	625010ef          	jal	50b4 <printf>
+    exit(1);
+    3294:	4505                	li	a0,1
+    3296:	1ef010ef          	jal	4c84 <exit>
+    printf("%s: unlink dots/. worked!\n", s);
+    329a:	85a6                	mv	a1,s1
+    329c:	00004517          	auipc	a0,0x4
+    32a0:	82450513          	addi	a0,a0,-2012 # 6ac0 <malloc+0x1958>
+    32a4:	611010ef          	jal	50b4 <printf>
+    exit(1);
+    32a8:	4505                	li	a0,1
+    32aa:	1db010ef          	jal	4c84 <exit>
+    printf("%s: unlink dots/.. worked!\n", s);
+    32ae:	85a6                	mv	a1,s1
+    32b0:	00004517          	auipc	a0,0x4
+    32b4:	83850513          	addi	a0,a0,-1992 # 6ae8 <malloc+0x1980>
+    32b8:	5fd010ef          	jal	50b4 <printf>
+    exit(1);
+    32bc:	4505                	li	a0,1
+    32be:	1c7010ef          	jal	4c84 <exit>
+    printf("%s: unlink dots failed!\n", s);
+    32c2:	85a6                	mv	a1,s1
+    32c4:	00004517          	auipc	a0,0x4
+    32c8:	84450513          	addi	a0,a0,-1980 # 6b08 <malloc+0x19a0>
+    32cc:	5e9010ef          	jal	50b4 <printf>
+    exit(1);
+    32d0:	4505                	li	a0,1
+    32d2:	1b3010ef          	jal	4c84 <exit>
+
+00000000000032d6 <dirfile>:
+{
+    32d6:	1101                	addi	sp,sp,-32
+    32d8:	ec06                	sd	ra,24(sp)
+    32da:	e822                	sd	s0,16(sp)
+    32dc:	e426                	sd	s1,8(sp)
+    32de:	e04a                	sd	s2,0(sp)
+    32e0:	1000                	addi	s0,sp,32
+    32e2:	892a                	mv	s2,a0
+  fd = open("dirfile", O_CREATE);
+    32e4:	20000593          	li	a1,512
+    32e8:	00004517          	auipc	a0,0x4
+    32ec:	84050513          	addi	a0,a0,-1984 # 6b28 <malloc+0x19c0>
+    32f0:	1d5010ef          	jal	4cc4 <open>
+  if(fd < 0){
+    32f4:	0c054563          	bltz	a0,33be <dirfile+0xe8>
+  close(fd);
+    32f8:	1b5010ef          	jal	4cac <close>
+  if(chdir("dirfile") == 0){
+    32fc:	00004517          	auipc	a0,0x4
+    3300:	82c50513          	addi	a0,a0,-2004 # 6b28 <malloc+0x19c0>
+    3304:	1f1010ef          	jal	4cf4 <chdir>
+    3308:	c569                	beqz	a0,33d2 <dirfile+0xfc>
+  fd = open("dirfile/xx", 0);
+    330a:	4581                	li	a1,0
+    330c:	00004517          	auipc	a0,0x4
+    3310:	86450513          	addi	a0,a0,-1948 # 6b70 <malloc+0x1a08>
+    3314:	1b1010ef          	jal	4cc4 <open>
+  if(fd >= 0){
+    3318:	0c055763          	bgez	a0,33e6 <dirfile+0x110>
+  fd = open("dirfile/xx", O_CREATE);
+    331c:	20000593          	li	a1,512
+    3320:	00004517          	auipc	a0,0x4
+    3324:	85050513          	addi	a0,a0,-1968 # 6b70 <malloc+0x1a08>
+    3328:	19d010ef          	jal	4cc4 <open>
+  if(fd >= 0){
+    332c:	0c055763          	bgez	a0,33fa <dirfile+0x124>
+  if(mkdir("dirfile/xx") == 0){
+    3330:	00004517          	auipc	a0,0x4
+    3334:	84050513          	addi	a0,a0,-1984 # 6b70 <malloc+0x1a08>
+    3338:	1b5010ef          	jal	4cec <mkdir>
+    333c:	0c050963          	beqz	a0,340e <dirfile+0x138>
+  if(unlink("dirfile/xx") == 0){
+    3340:	00004517          	auipc	a0,0x4
+    3344:	83050513          	addi	a0,a0,-2000 # 6b70 <malloc+0x1a08>
+    3348:	18d010ef          	jal	4cd4 <unlink>
+    334c:	0c050b63          	beqz	a0,3422 <dirfile+0x14c>
+  if(link("README", "dirfile/xx") == 0){
+    3350:	00004597          	auipc	a1,0x4
+    3354:	82058593          	addi	a1,a1,-2016 # 6b70 <malloc+0x1a08>
+    3358:	00002517          	auipc	a0,0x2
+    335c:	11850513          	addi	a0,a0,280 # 5470 <malloc+0x308>
+    3360:	185010ef          	jal	4ce4 <link>
+    3364:	0c050963          	beqz	a0,3436 <dirfile+0x160>
+  if(unlink("dirfile") != 0){
+    3368:	00003517          	auipc	a0,0x3
+    336c:	7c050513          	addi	a0,a0,1984 # 6b28 <malloc+0x19c0>
+    3370:	165010ef          	jal	4cd4 <unlink>
+    3374:	0c051b63          	bnez	a0,344a <dirfile+0x174>
+  fd = open(".", O_RDWR);
+    3378:	4589                	li	a1,2
+    337a:	00002517          	auipc	a0,0x2
+    337e:	60650513          	addi	a0,a0,1542 # 5980 <malloc+0x818>
+    3382:	143010ef          	jal	4cc4 <open>
+  if(fd >= 0){
+    3386:	0c055c63          	bgez	a0,345e <dirfile+0x188>
+  fd = open(".", 0);
+    338a:	4581                	li	a1,0
+    338c:	00002517          	auipc	a0,0x2
+    3390:	5f450513          	addi	a0,a0,1524 # 5980 <malloc+0x818>
+    3394:	131010ef          	jal	4cc4 <open>
+    3398:	84aa                	mv	s1,a0
+  if(write(fd, "x", 1) > 0){
+    339a:	4605                	li	a2,1
+    339c:	00002597          	auipc	a1,0x2
+    33a0:	f6c58593          	addi	a1,a1,-148 # 5308 <malloc+0x1a0>
+    33a4:	101010ef          	jal	4ca4 <write>
+    33a8:	0ca04563          	bgtz	a0,3472 <dirfile+0x19c>
+  close(fd);
+    33ac:	8526                	mv	a0,s1
+    33ae:	0ff010ef          	jal	4cac <close>
+}
+    33b2:	60e2                	ld	ra,24(sp)
+    33b4:	6442                	ld	s0,16(sp)
+    33b6:	64a2                	ld	s1,8(sp)
+    33b8:	6902                	ld	s2,0(sp)
+    33ba:	6105                	addi	sp,sp,32
+    33bc:	8082                	ret
+    printf("%s: create dirfile failed\n", s);
+    33be:	85ca                	mv	a1,s2
+    33c0:	00003517          	auipc	a0,0x3
+    33c4:	77050513          	addi	a0,a0,1904 # 6b30 <malloc+0x19c8>
+    33c8:	4ed010ef          	jal	50b4 <printf>
+    exit(1);
+    33cc:	4505                	li	a0,1
+    33ce:	0b7010ef          	jal	4c84 <exit>
+    printf("%s: chdir dirfile succeeded!\n", s);
+    33d2:	85ca                	mv	a1,s2
+    33d4:	00003517          	auipc	a0,0x3
+    33d8:	77c50513          	addi	a0,a0,1916 # 6b50 <malloc+0x19e8>
+    33dc:	4d9010ef          	jal	50b4 <printf>
+    exit(1);
+    33e0:	4505                	li	a0,1
+    33e2:	0a3010ef          	jal	4c84 <exit>
+    printf("%s: create dirfile/xx succeeded!\n", s);
+    33e6:	85ca                	mv	a1,s2
+    33e8:	00003517          	auipc	a0,0x3
+    33ec:	79850513          	addi	a0,a0,1944 # 6b80 <malloc+0x1a18>
+    33f0:	4c5010ef          	jal	50b4 <printf>
+    exit(1);
+    33f4:	4505                	li	a0,1
+    33f6:	08f010ef          	jal	4c84 <exit>
+    printf("%s: create dirfile/xx succeeded!\n", s);
+    33fa:	85ca                	mv	a1,s2
+    33fc:	00003517          	auipc	a0,0x3
+    3400:	78450513          	addi	a0,a0,1924 # 6b80 <malloc+0x1a18>
+    3404:	4b1010ef          	jal	50b4 <printf>
+    exit(1);
+    3408:	4505                	li	a0,1
+    340a:	07b010ef          	jal	4c84 <exit>
+    printf("%s: mkdir dirfile/xx succeeded!\n", s);
+    340e:	85ca                	mv	a1,s2
+    3410:	00003517          	auipc	a0,0x3
+    3414:	79850513          	addi	a0,a0,1944 # 6ba8 <malloc+0x1a40>
+    3418:	49d010ef          	jal	50b4 <printf>
+    exit(1);
+    341c:	4505                	li	a0,1
+    341e:	067010ef          	jal	4c84 <exit>
+    printf("%s: unlink dirfile/xx succeeded!\n", s);
+    3422:	85ca                	mv	a1,s2
+    3424:	00003517          	auipc	a0,0x3
+    3428:	7ac50513          	addi	a0,a0,1964 # 6bd0 <malloc+0x1a68>
+    342c:	489010ef          	jal	50b4 <printf>
+    exit(1);
+    3430:	4505                	li	a0,1
+    3432:	053010ef          	jal	4c84 <exit>
+    printf("%s: link to dirfile/xx succeeded!\n", s);
+    3436:	85ca                	mv	a1,s2
+    3438:	00003517          	auipc	a0,0x3
+    343c:	7c050513          	addi	a0,a0,1984 # 6bf8 <malloc+0x1a90>
+    3440:	475010ef          	jal	50b4 <printf>
+    exit(1);
+    3444:	4505                	li	a0,1
+    3446:	03f010ef          	jal	4c84 <exit>
+    printf("%s: unlink dirfile failed!\n", s);
+    344a:	85ca                	mv	a1,s2
+    344c:	00003517          	auipc	a0,0x3
+    3450:	7d450513          	addi	a0,a0,2004 # 6c20 <malloc+0x1ab8>
+    3454:	461010ef          	jal	50b4 <printf>
+    exit(1);
+    3458:	4505                	li	a0,1
+    345a:	02b010ef          	jal	4c84 <exit>
+    printf("%s: open . for writing succeeded!\n", s);
+    345e:	85ca                	mv	a1,s2
+    3460:	00003517          	auipc	a0,0x3
+    3464:	7e050513          	addi	a0,a0,2016 # 6c40 <malloc+0x1ad8>
+    3468:	44d010ef          	jal	50b4 <printf>
+    exit(1);
+    346c:	4505                	li	a0,1
+    346e:	017010ef          	jal	4c84 <exit>
+    printf("%s: write . succeeded!\n", s);
+    3472:	85ca                	mv	a1,s2
+    3474:	00003517          	auipc	a0,0x3
+    3478:	7f450513          	addi	a0,a0,2036 # 6c68 <malloc+0x1b00>
+    347c:	439010ef          	jal	50b4 <printf>
+    exit(1);
+    3480:	4505                	li	a0,1
+    3482:	003010ef          	jal	4c84 <exit>
+
+0000000000003486 <iref>:
+{
+    3486:	7139                	addi	sp,sp,-64
+    3488:	fc06                	sd	ra,56(sp)
+    348a:	f822                	sd	s0,48(sp)
+    348c:	f426                	sd	s1,40(sp)
+    348e:	f04a                	sd	s2,32(sp)
+    3490:	ec4e                	sd	s3,24(sp)
+    3492:	e852                	sd	s4,16(sp)
+    3494:	e456                	sd	s5,8(sp)
+    3496:	e05a                	sd	s6,0(sp)
+    3498:	0080                	addi	s0,sp,64
+    349a:	8b2a                	mv	s6,a0
+    349c:	03300913          	li	s2,51
+    if(mkdir("irefd") != 0){
+    34a0:	00003a17          	auipc	s4,0x3
+    34a4:	7e0a0a13          	addi	s4,s4,2016 # 6c80 <malloc+0x1b18>
+    mkdir("");
+    34a8:	00003497          	auipc	s1,0x3
+    34ac:	2e048493          	addi	s1,s1,736 # 6788 <malloc+0x1620>
+    link("README", "");
+    34b0:	00002a97          	auipc	s5,0x2
+    34b4:	fc0a8a93          	addi	s5,s5,-64 # 5470 <malloc+0x308>
+    fd = open("xx", O_CREATE);
+    34b8:	00003997          	auipc	s3,0x3
+    34bc:	6c098993          	addi	s3,s3,1728 # 6b78 <malloc+0x1a10>
+    34c0:	a835                	j	34fc <iref+0x76>
+      printf("%s: mkdir irefd failed\n", s);
+    34c2:	85da                	mv	a1,s6
+    34c4:	00003517          	auipc	a0,0x3
+    34c8:	7c450513          	addi	a0,a0,1988 # 6c88 <malloc+0x1b20>
+    34cc:	3e9010ef          	jal	50b4 <printf>
+      exit(1);
+    34d0:	4505                	li	a0,1
+    34d2:	7b2010ef          	jal	4c84 <exit>
+      printf("%s: chdir irefd failed\n", s);
+    34d6:	85da                	mv	a1,s6
+    34d8:	00003517          	auipc	a0,0x3
+    34dc:	7c850513          	addi	a0,a0,1992 # 6ca0 <malloc+0x1b38>
+    34e0:	3d5010ef          	jal	50b4 <printf>
+      exit(1);
+    34e4:	4505                	li	a0,1
+    34e6:	79e010ef          	jal	4c84 <exit>
+      close(fd);
+    34ea:	7c2010ef          	jal	4cac <close>
+    34ee:	a82d                	j	3528 <iref+0xa2>
+    unlink("xx");
+    34f0:	854e                	mv	a0,s3
+    34f2:	7e2010ef          	jal	4cd4 <unlink>
+  for(i = 0; i < NINODE + 1; i++){
+    34f6:	397d                	addiw	s2,s2,-1
+    34f8:	04090263          	beqz	s2,353c <iref+0xb6>
+    if(mkdir("irefd") != 0){
+    34fc:	8552                	mv	a0,s4
+    34fe:	7ee010ef          	jal	4cec <mkdir>
+    3502:	f161                	bnez	a0,34c2 <iref+0x3c>
+    if(chdir("irefd") != 0){
+    3504:	8552                	mv	a0,s4
+    3506:	7ee010ef          	jal	4cf4 <chdir>
+    350a:	f571                	bnez	a0,34d6 <iref+0x50>
+    mkdir("");
+    350c:	8526                	mv	a0,s1
+    350e:	7de010ef          	jal	4cec <mkdir>
+    link("README", "");
+    3512:	85a6                	mv	a1,s1
+    3514:	8556                	mv	a0,s5
+    3516:	7ce010ef          	jal	4ce4 <link>
+    fd = open("", O_CREATE);
+    351a:	20000593          	li	a1,512
+    351e:	8526                	mv	a0,s1
+    3520:	7a4010ef          	jal	4cc4 <open>
+    if(fd >= 0)
+    3524:	fc0553e3          	bgez	a0,34ea <iref+0x64>
+    fd = open("xx", O_CREATE);
+    3528:	20000593          	li	a1,512
+    352c:	854e                	mv	a0,s3
+    352e:	796010ef          	jal	4cc4 <open>
+    if(fd >= 0)
+    3532:	fa054fe3          	bltz	a0,34f0 <iref+0x6a>
+      close(fd);
+    3536:	776010ef          	jal	4cac <close>
+    353a:	bf5d                	j	34f0 <iref+0x6a>
+    353c:	03300493          	li	s1,51
+    chdir("..");
+    3540:	00003997          	auipc	s3,0x3
+    3544:	f6098993          	addi	s3,s3,-160 # 64a0 <malloc+0x1338>
+    unlink("irefd");
+    3548:	00003917          	auipc	s2,0x3
+    354c:	73890913          	addi	s2,s2,1848 # 6c80 <malloc+0x1b18>
+    chdir("..");
+    3550:	854e                	mv	a0,s3
+    3552:	7a2010ef          	jal	4cf4 <chdir>
+    unlink("irefd");
+    3556:	854a                	mv	a0,s2
+    3558:	77c010ef          	jal	4cd4 <unlink>
+  for(i = 0; i < NINODE + 1; i++){
+    355c:	34fd                	addiw	s1,s1,-1
+    355e:	f8ed                	bnez	s1,3550 <iref+0xca>
+  chdir("/");
+    3560:	00003517          	auipc	a0,0x3
+    3564:	ee850513          	addi	a0,a0,-280 # 6448 <malloc+0x12e0>
+    3568:	78c010ef          	jal	4cf4 <chdir>
+}
+    356c:	70e2                	ld	ra,56(sp)
+    356e:	7442                	ld	s0,48(sp)
+    3570:	74a2                	ld	s1,40(sp)
+    3572:	7902                	ld	s2,32(sp)
+    3574:	69e2                	ld	s3,24(sp)
+    3576:	6a42                	ld	s4,16(sp)
+    3578:	6aa2                	ld	s5,8(sp)
+    357a:	6b02                	ld	s6,0(sp)
+    357c:	6121                	addi	sp,sp,64
+    357e:	8082                	ret
+
+0000000000003580 <openiputtest>:
+{
+    3580:	7179                	addi	sp,sp,-48
+    3582:	f406                	sd	ra,40(sp)
+    3584:	f022                	sd	s0,32(sp)
+    3586:	ec26                	sd	s1,24(sp)
+    3588:	1800                	addi	s0,sp,48
+    358a:	84aa                	mv	s1,a0
+  if(mkdir("oidir") < 0){
+    358c:	00003517          	auipc	a0,0x3
+    3590:	72c50513          	addi	a0,a0,1836 # 6cb8 <malloc+0x1b50>
+    3594:	758010ef          	jal	4cec <mkdir>
+    3598:	02054a63          	bltz	a0,35cc <openiputtest+0x4c>
+  pid = fork();
+    359c:	6e0010ef          	jal	4c7c <fork>
+  if(pid < 0){
+    35a0:	04054063          	bltz	a0,35e0 <openiputtest+0x60>
+  if(pid == 0){
+    35a4:	e939                	bnez	a0,35fa <openiputtest+0x7a>
+    int fd = open("oidir", O_RDWR);
+    35a6:	4589                	li	a1,2
+    35a8:	00003517          	auipc	a0,0x3
+    35ac:	71050513          	addi	a0,a0,1808 # 6cb8 <malloc+0x1b50>
+    35b0:	714010ef          	jal	4cc4 <open>
+    if(fd >= 0){
+    35b4:	04054063          	bltz	a0,35f4 <openiputtest+0x74>
+      printf("%s: open directory for write succeeded\n", s);
+    35b8:	85a6                	mv	a1,s1
+    35ba:	00003517          	auipc	a0,0x3
+    35be:	71e50513          	addi	a0,a0,1822 # 6cd8 <malloc+0x1b70>
+    35c2:	2f3010ef          	jal	50b4 <printf>
+      exit(1);
+    35c6:	4505                	li	a0,1
+    35c8:	6bc010ef          	jal	4c84 <exit>
+    printf("%s: mkdir oidir failed\n", s);
+    35cc:	85a6                	mv	a1,s1
+    35ce:	00003517          	auipc	a0,0x3
+    35d2:	6f250513          	addi	a0,a0,1778 # 6cc0 <malloc+0x1b58>
+    35d6:	2df010ef          	jal	50b4 <printf>
+    exit(1);
+    35da:	4505                	li	a0,1
+    35dc:	6a8010ef          	jal	4c84 <exit>
+    printf("%s: fork failed\n", s);
+    35e0:	85a6                	mv	a1,s1
+    35e2:	00002517          	auipc	a0,0x2
+    35e6:	54650513          	addi	a0,a0,1350 # 5b28 <malloc+0x9c0>
+    35ea:	2cb010ef          	jal	50b4 <printf>
+    exit(1);
+    35ee:	4505                	li	a0,1
+    35f0:	694010ef          	jal	4c84 <exit>
+    exit(0);
+    35f4:	4501                	li	a0,0
+    35f6:	68e010ef          	jal	4c84 <exit>
+  pause(1);
+    35fa:	4505                	li	a0,1
+    35fc:	718010ef          	jal	4d14 <pause>
+  if(unlink("oidir") != 0){
+    3600:	00003517          	auipc	a0,0x3
+    3604:	6b850513          	addi	a0,a0,1720 # 6cb8 <malloc+0x1b50>
+    3608:	6cc010ef          	jal	4cd4 <unlink>
+    360c:	c919                	beqz	a0,3622 <openiputtest+0xa2>
+    printf("%s: unlink failed\n", s);
+    360e:	85a6                	mv	a1,s1
+    3610:	00002517          	auipc	a0,0x2
+    3614:	70850513          	addi	a0,a0,1800 # 5d18 <malloc+0xbb0>
+    3618:	29d010ef          	jal	50b4 <printf>
+    exit(1);
+    361c:	4505                	li	a0,1
+    361e:	666010ef          	jal	4c84 <exit>
+  wait(&xstatus);
+    3622:	fdc40513          	addi	a0,s0,-36
+    3626:	666010ef          	jal	4c8c <wait>
+  exit(xstatus);
+    362a:	fdc42503          	lw	a0,-36(s0)
+    362e:	656010ef          	jal	4c84 <exit>
+
+0000000000003632 <forkforkfork>:
+{
+    3632:	1101                	addi	sp,sp,-32
+    3634:	ec06                	sd	ra,24(sp)
+    3636:	e822                	sd	s0,16(sp)
+    3638:	e426                	sd	s1,8(sp)
+    363a:	1000                	addi	s0,sp,32
+    363c:	84aa                	mv	s1,a0
+  unlink("stopforking");
+    363e:	00003517          	auipc	a0,0x3
+    3642:	6c250513          	addi	a0,a0,1730 # 6d00 <malloc+0x1b98>
+    3646:	68e010ef          	jal	4cd4 <unlink>
+  int pid = fork();
+    364a:	632010ef          	jal	4c7c <fork>
+  if(pid < 0){
+    364e:	02054b63          	bltz	a0,3684 <forkforkfork+0x52>
+  if(pid == 0){
+    3652:	c139                	beqz	a0,3698 <forkforkfork+0x66>
+  pause(20); // two seconds
+    3654:	4551                	li	a0,20
+    3656:	6be010ef          	jal	4d14 <pause>
+  close(open("stopforking", O_CREATE|O_RDWR));
+    365a:	20200593          	li	a1,514
+    365e:	00003517          	auipc	a0,0x3
+    3662:	6a250513          	addi	a0,a0,1698 # 6d00 <malloc+0x1b98>
+    3666:	65e010ef          	jal	4cc4 <open>
+    366a:	642010ef          	jal	4cac <close>
+  wait(0);
+    366e:	4501                	li	a0,0
+    3670:	61c010ef          	jal	4c8c <wait>
+  pause(10); // one second
+    3674:	4529                	li	a0,10
+    3676:	69e010ef          	jal	4d14 <pause>
+}
+    367a:	60e2                	ld	ra,24(sp)
+    367c:	6442                	ld	s0,16(sp)
+    367e:	64a2                	ld	s1,8(sp)
+    3680:	6105                	addi	sp,sp,32
+    3682:	8082                	ret
+    printf("%s: fork failed", s);
+    3684:	85a6                	mv	a1,s1
+    3686:	00002517          	auipc	a0,0x2
+    368a:	66250513          	addi	a0,a0,1634 # 5ce8 <malloc+0xb80>
+    368e:	227010ef          	jal	50b4 <printf>
+    exit(1);
+    3692:	4505                	li	a0,1
+    3694:	5f0010ef          	jal	4c84 <exit>
+      int fd = open("stopforking", 0);
+    3698:	00003497          	auipc	s1,0x3
+    369c:	66848493          	addi	s1,s1,1640 # 6d00 <malloc+0x1b98>
+    36a0:	4581                	li	a1,0
+    36a2:	8526                	mv	a0,s1
+    36a4:	620010ef          	jal	4cc4 <open>
+      if(fd >= 0){
+    36a8:	02055163          	bgez	a0,36ca <forkforkfork+0x98>
+      if(fork() < 0){
+    36ac:	5d0010ef          	jal	4c7c <fork>
+    36b0:	fe0558e3          	bgez	a0,36a0 <forkforkfork+0x6e>
+        close(open("stopforking", O_CREATE|O_RDWR));
+    36b4:	20200593          	li	a1,514
+    36b8:	00003517          	auipc	a0,0x3
+    36bc:	64850513          	addi	a0,a0,1608 # 6d00 <malloc+0x1b98>
+    36c0:	604010ef          	jal	4cc4 <open>
+    36c4:	5e8010ef          	jal	4cac <close>
+    36c8:	bfe1                	j	36a0 <forkforkfork+0x6e>
+        exit(0);
+    36ca:	4501                	li	a0,0
+    36cc:	5b8010ef          	jal	4c84 <exit>
+
+00000000000036d0 <killstatus>:
+{
+    36d0:	7139                	addi	sp,sp,-64
+    36d2:	fc06                	sd	ra,56(sp)
+    36d4:	f822                	sd	s0,48(sp)
+    36d6:	f426                	sd	s1,40(sp)
+    36d8:	f04a                	sd	s2,32(sp)
+    36da:	ec4e                	sd	s3,24(sp)
+    36dc:	e852                	sd	s4,16(sp)
+    36de:	0080                	addi	s0,sp,64
+    36e0:	8a2a                	mv	s4,a0
+    36e2:	06400913          	li	s2,100
+    if(xst != -1) {
+    36e6:	59fd                	li	s3,-1
+    int pid1 = fork();
+    36e8:	594010ef          	jal	4c7c <fork>
+    36ec:	84aa                	mv	s1,a0
+    if(pid1 < 0){
+    36ee:	02054763          	bltz	a0,371c <killstatus+0x4c>
+    if(pid1 == 0){
+    36f2:	cd1d                	beqz	a0,3730 <killstatus+0x60>
+    pause(1);
+    36f4:	4505                	li	a0,1
+    36f6:	61e010ef          	jal	4d14 <pause>
+    kill(pid1);
+    36fa:	8526                	mv	a0,s1
+    36fc:	5b8010ef          	jal	4cb4 <kill>
+    wait(&xst);
+    3700:	fcc40513          	addi	a0,s0,-52
+    3704:	588010ef          	jal	4c8c <wait>
+    if(xst != -1) {
+    3708:	fcc42783          	lw	a5,-52(s0)
+    370c:	03379563          	bne	a5,s3,3736 <killstatus+0x66>
+  for(int i = 0; i < 100; i++){
+    3710:	397d                	addiw	s2,s2,-1
+    3712:	fc091be3          	bnez	s2,36e8 <killstatus+0x18>
+  exit(0);
+    3716:	4501                	li	a0,0
+    3718:	56c010ef          	jal	4c84 <exit>
+      printf("%s: fork failed\n", s);
+    371c:	85d2                	mv	a1,s4
+    371e:	00002517          	auipc	a0,0x2
+    3722:	40a50513          	addi	a0,a0,1034 # 5b28 <malloc+0x9c0>
+    3726:	18f010ef          	jal	50b4 <printf>
+      exit(1);
+    372a:	4505                	li	a0,1
+    372c:	558010ef          	jal	4c84 <exit>
+        getpid();
+    3730:	5d4010ef          	jal	4d04 <getpid>
+      while(1) {
+    3734:	bff5                	j	3730 <killstatus+0x60>
+       printf("%s: status should be -1\n", s);
+    3736:	85d2                	mv	a1,s4
+    3738:	00003517          	auipc	a0,0x3
+    373c:	5d850513          	addi	a0,a0,1496 # 6d10 <malloc+0x1ba8>
+    3740:	175010ef          	jal	50b4 <printf>
+       exit(1);
+    3744:	4505                	li	a0,1
+    3746:	53e010ef          	jal	4c84 <exit>
+
+000000000000374a <preempt>:
+{
+    374a:	7139                	addi	sp,sp,-64
+    374c:	fc06                	sd	ra,56(sp)
+    374e:	f822                	sd	s0,48(sp)
+    3750:	f426                	sd	s1,40(sp)
+    3752:	f04a                	sd	s2,32(sp)
+    3754:	ec4e                	sd	s3,24(sp)
+    3756:	e852                	sd	s4,16(sp)
+    3758:	0080                	addi	s0,sp,64
+    375a:	892a                	mv	s2,a0
+  pid1 = fork();
+    375c:	520010ef          	jal	4c7c <fork>
+  if(pid1 < 0) {
+    3760:	00054563          	bltz	a0,376a <preempt+0x20>
+    3764:	84aa                	mv	s1,a0
+  if(pid1 == 0)
+    3766:	ed01                	bnez	a0,377e <preempt+0x34>
+    for(;;)
+    3768:	a001                	j	3768 <preempt+0x1e>
+    printf("%s: fork failed", s);
+    376a:	85ca                	mv	a1,s2
+    376c:	00002517          	auipc	a0,0x2
+    3770:	57c50513          	addi	a0,a0,1404 # 5ce8 <malloc+0xb80>
+    3774:	141010ef          	jal	50b4 <printf>
+    exit(1);
+    3778:	4505                	li	a0,1
+    377a:	50a010ef          	jal	4c84 <exit>
+  pid2 = fork();
+    377e:	4fe010ef          	jal	4c7c <fork>
+    3782:	89aa                	mv	s3,a0
+  if(pid2 < 0) {
+    3784:	00054463          	bltz	a0,378c <preempt+0x42>
+  if(pid2 == 0)
+    3788:	ed01                	bnez	a0,37a0 <preempt+0x56>
+    for(;;)
+    378a:	a001                	j	378a <preempt+0x40>
+    printf("%s: fork failed\n", s);
+    378c:	85ca                	mv	a1,s2
+    378e:	00002517          	auipc	a0,0x2
+    3792:	39a50513          	addi	a0,a0,922 # 5b28 <malloc+0x9c0>
+    3796:	11f010ef          	jal	50b4 <printf>
+    exit(1);
+    379a:	4505                	li	a0,1
+    379c:	4e8010ef          	jal	4c84 <exit>
+  pipe(pfds);
+    37a0:	fc840513          	addi	a0,s0,-56
+    37a4:	4f0010ef          	jal	4c94 <pipe>
+  pid3 = fork();
+    37a8:	4d4010ef          	jal	4c7c <fork>
+    37ac:	8a2a                	mv	s4,a0
+  if(pid3 < 0) {
+    37ae:	02054863          	bltz	a0,37de <preempt+0x94>
+  if(pid3 == 0){
+    37b2:	e921                	bnez	a0,3802 <preempt+0xb8>
+    close(pfds[0]);
+    37b4:	fc842503          	lw	a0,-56(s0)
+    37b8:	4f4010ef          	jal	4cac <close>
+    if(write(pfds[1], "x", 1) != 1)
+    37bc:	4605                	li	a2,1
+    37be:	00002597          	auipc	a1,0x2
+    37c2:	b4a58593          	addi	a1,a1,-1206 # 5308 <malloc+0x1a0>
+    37c6:	fcc42503          	lw	a0,-52(s0)
+    37ca:	4da010ef          	jal	4ca4 <write>
+    37ce:	4785                	li	a5,1
+    37d0:	02f51163          	bne	a0,a5,37f2 <preempt+0xa8>
+    close(pfds[1]);
+    37d4:	fcc42503          	lw	a0,-52(s0)
+    37d8:	4d4010ef          	jal	4cac <close>
+    for(;;)
+    37dc:	a001                	j	37dc <preempt+0x92>
+     printf("%s: fork failed\n", s);
+    37de:	85ca                	mv	a1,s2
+    37e0:	00002517          	auipc	a0,0x2
+    37e4:	34850513          	addi	a0,a0,840 # 5b28 <malloc+0x9c0>
+    37e8:	0cd010ef          	jal	50b4 <printf>
+     exit(1);
+    37ec:	4505                	li	a0,1
+    37ee:	496010ef          	jal	4c84 <exit>
+      printf("%s: preempt write error", s);
+    37f2:	85ca                	mv	a1,s2
+    37f4:	00003517          	auipc	a0,0x3
+    37f8:	53c50513          	addi	a0,a0,1340 # 6d30 <malloc+0x1bc8>
+    37fc:	0b9010ef          	jal	50b4 <printf>
+    3800:	bfd1                	j	37d4 <preempt+0x8a>
+  close(pfds[1]);
+    3802:	fcc42503          	lw	a0,-52(s0)
+    3806:	4a6010ef          	jal	4cac <close>
+  if(read(pfds[0], buf, sizeof(buf)) != 1){
+    380a:	660d                	lui	a2,0x3
+    380c:	00009597          	auipc	a1,0x9
+    3810:	49c58593          	addi	a1,a1,1180 # cca8 <buf>
+    3814:	fc842503          	lw	a0,-56(s0)
+    3818:	484010ef          	jal	4c9c <read>
+    381c:	4785                	li	a5,1
+    381e:	02f50163          	beq	a0,a5,3840 <preempt+0xf6>
+    printf("%s: preempt read error", s);
+    3822:	85ca                	mv	a1,s2
+    3824:	00003517          	auipc	a0,0x3
+    3828:	52450513          	addi	a0,a0,1316 # 6d48 <malloc+0x1be0>
+    382c:	089010ef          	jal	50b4 <printf>
+}
+    3830:	70e2                	ld	ra,56(sp)
+    3832:	7442                	ld	s0,48(sp)
+    3834:	74a2                	ld	s1,40(sp)
+    3836:	7902                	ld	s2,32(sp)
+    3838:	69e2                	ld	s3,24(sp)
+    383a:	6a42                	ld	s4,16(sp)
+    383c:	6121                	addi	sp,sp,64
+    383e:	8082                	ret
+  close(pfds[0]);
+    3840:	fc842503          	lw	a0,-56(s0)
+    3844:	468010ef          	jal	4cac <close>
+  printf("kill... ");
+    3848:	00003517          	auipc	a0,0x3
+    384c:	51850513          	addi	a0,a0,1304 # 6d60 <malloc+0x1bf8>
+    3850:	065010ef          	jal	50b4 <printf>
+  kill(pid1);
+    3854:	8526                	mv	a0,s1
+    3856:	45e010ef          	jal	4cb4 <kill>
+  kill(pid2);
+    385a:	854e                	mv	a0,s3
+    385c:	458010ef          	jal	4cb4 <kill>
+  kill(pid3);
+    3860:	8552                	mv	a0,s4
+    3862:	452010ef          	jal	4cb4 <kill>
+  printf("wait... ");
+    3866:	00003517          	auipc	a0,0x3
+    386a:	50a50513          	addi	a0,a0,1290 # 6d70 <malloc+0x1c08>
+    386e:	047010ef          	jal	50b4 <printf>
+  wait(0);
+    3872:	4501                	li	a0,0
+    3874:	418010ef          	jal	4c8c <wait>
+  wait(0);
+    3878:	4501                	li	a0,0
+    387a:	412010ef          	jal	4c8c <wait>
+  wait(0);
+    387e:	4501                	li	a0,0
+    3880:	40c010ef          	jal	4c8c <wait>
+    3884:	b775                	j	3830 <preempt+0xe6>
+
+0000000000003886 <reparent>:
+{
+    3886:	7179                	addi	sp,sp,-48
+    3888:	f406                	sd	ra,40(sp)
+    388a:	f022                	sd	s0,32(sp)
+    388c:	ec26                	sd	s1,24(sp)
+    388e:	e84a                	sd	s2,16(sp)
+    3890:	e44e                	sd	s3,8(sp)
+    3892:	e052                	sd	s4,0(sp)
+    3894:	1800                	addi	s0,sp,48
+    3896:	89aa                	mv	s3,a0
+  int master_pid = getpid();
+    3898:	46c010ef          	jal	4d04 <getpid>
+    389c:	8a2a                	mv	s4,a0
+    389e:	0c800913          	li	s2,200
+    int pid = fork();
+    38a2:	3da010ef          	jal	4c7c <fork>
+    38a6:	84aa                	mv	s1,a0
+    if(pid < 0){
+    38a8:	00054e63          	bltz	a0,38c4 <reparent+0x3e>
+    if(pid){
+    38ac:	c121                	beqz	a0,38ec <reparent+0x66>
+      if(wait(0) != pid){
+    38ae:	4501                	li	a0,0
+    38b0:	3dc010ef          	jal	4c8c <wait>
+    38b4:	02951263          	bne	a0,s1,38d8 <reparent+0x52>
+  for(int i = 0; i < 200; i++){
+    38b8:	397d                	addiw	s2,s2,-1
+    38ba:	fe0914e3          	bnez	s2,38a2 <reparent+0x1c>
+  exit(0);
+    38be:	4501                	li	a0,0
+    38c0:	3c4010ef          	jal	4c84 <exit>
+      printf("%s: fork failed\n", s);
+    38c4:	85ce                	mv	a1,s3
+    38c6:	00002517          	auipc	a0,0x2
+    38ca:	26250513          	addi	a0,a0,610 # 5b28 <malloc+0x9c0>
+    38ce:	7e6010ef          	jal	50b4 <printf>
+      exit(1);
+    38d2:	4505                	li	a0,1
+    38d4:	3b0010ef          	jal	4c84 <exit>
+        printf("%s: wait wrong pid\n", s);
+    38d8:	85ce                	mv	a1,s3
+    38da:	00002517          	auipc	a0,0x2
+    38de:	3d650513          	addi	a0,a0,982 # 5cb0 <malloc+0xb48>
+    38e2:	7d2010ef          	jal	50b4 <printf>
+        exit(1);
+    38e6:	4505                	li	a0,1
+    38e8:	39c010ef          	jal	4c84 <exit>
+      int pid2 = fork();
+    38ec:	390010ef          	jal	4c7c <fork>
+      if(pid2 < 0){
+    38f0:	00054563          	bltz	a0,38fa <reparent+0x74>
+      exit(0);
+    38f4:	4501                	li	a0,0
+    38f6:	38e010ef          	jal	4c84 <exit>
+        kill(master_pid);
+    38fa:	8552                	mv	a0,s4
+    38fc:	3b8010ef          	jal	4cb4 <kill>
+        exit(1);
+    3900:	4505                	li	a0,1
+    3902:	382010ef          	jal	4c84 <exit>
+
+0000000000003906 <sbrkfail>:
+{
+    3906:	7175                	addi	sp,sp,-144
+    3908:	e506                	sd	ra,136(sp)
+    390a:	e122                	sd	s0,128(sp)
+    390c:	fca6                	sd	s1,120(sp)
+    390e:	f8ca                	sd	s2,112(sp)
+    3910:	f4ce                	sd	s3,104(sp)
+    3912:	f0d2                	sd	s4,96(sp)
+    3914:	ecd6                	sd	s5,88(sp)
+    3916:	e8da                	sd	s6,80(sp)
+    3918:	e4de                	sd	s7,72(sp)
+    391a:	0900                	addi	s0,sp,144
+    391c:	8b2a                	mv	s6,a0
+  if(pipe(fds) != 0){
+    391e:	fa040513          	addi	a0,s0,-96
+    3922:	372010ef          	jal	4c94 <pipe>
+    3926:	e919                	bnez	a0,393c <sbrkfail+0x36>
+    3928:	8aaa                	mv	s5,a0
+    392a:	f7040493          	addi	s1,s0,-144
+    392e:	f9840993          	addi	s3,s0,-104
+    3932:	8926                	mv	s2,s1
+    if(pids[i] != -1) {
+    3934:	5a7d                	li	s4,-1
+      if(scratch == '0')
+    3936:	03000b93          	li	s7,48
+    393a:	a08d                	j	399c <sbrkfail+0x96>
+    printf("%s: pipe() failed\n", s);
+    393c:	85da                	mv	a1,s6
+    393e:	00002517          	auipc	a0,0x2
+    3942:	2f250513          	addi	a0,a0,754 # 5c30 <malloc+0xac8>
+    3946:	76e010ef          	jal	50b4 <printf>
+    exit(1);
+    394a:	4505                	li	a0,1
+    394c:	338010ef          	jal	4c84 <exit>
+      if (sbrk(BIG - (uint64)sbrk(0)) ==  (char*)SBRK_ERROR)
+    3950:	300010ef          	jal	4c50 <sbrk>
+    3954:	064007b7          	lui	a5,0x6400
+    3958:	40a7853b          	subw	a0,a5,a0
+    395c:	2f4010ef          	jal	4c50 <sbrk>
+    3960:	57fd                	li	a5,-1
+    3962:	02f50063          	beq	a0,a5,3982 <sbrkfail+0x7c>
+        write(fds[1], "1", 1);
+    3966:	4605                	li	a2,1
+    3968:	00004597          	auipc	a1,0x4
+    396c:	aa858593          	addi	a1,a1,-1368 # 7410 <malloc+0x22a8>
+    3970:	fa442503          	lw	a0,-92(s0)
+    3974:	330010ef          	jal	4ca4 <write>
+      for(;;) pause(1000);
+    3978:	3e800513          	li	a0,1000
+    397c:	398010ef          	jal	4d14 <pause>
+    3980:	bfe5                	j	3978 <sbrkfail+0x72>
+        write(fds[1], "0", 1);
+    3982:	4605                	li	a2,1
+    3984:	00003597          	auipc	a1,0x3
+    3988:	3fc58593          	addi	a1,a1,1020 # 6d80 <malloc+0x1c18>
+    398c:	fa442503          	lw	a0,-92(s0)
+    3990:	314010ef          	jal	4ca4 <write>
+    3994:	b7d5                	j	3978 <sbrkfail+0x72>
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    3996:	0911                	addi	s2,s2,4
+    3998:	03390663          	beq	s2,s3,39c4 <sbrkfail+0xbe>
+    if((pids[i] = fork()) == 0){
+    399c:	2e0010ef          	jal	4c7c <fork>
+    39a0:	00a92023          	sw	a0,0(s2)
+    39a4:	d555                	beqz	a0,3950 <sbrkfail+0x4a>
+    if(pids[i] != -1) {
+    39a6:	ff4508e3          	beq	a0,s4,3996 <sbrkfail+0x90>
+      read(fds[0], &scratch, 1);
+    39aa:	4605                	li	a2,1
+    39ac:	f9f40593          	addi	a1,s0,-97
+    39b0:	fa042503          	lw	a0,-96(s0)
+    39b4:	2e8010ef          	jal	4c9c <read>
+      if(scratch == '0')
+    39b8:	f9f44783          	lbu	a5,-97(s0)
+    39bc:	fd779de3          	bne	a5,s7,3996 <sbrkfail+0x90>
+        failed = 1;
+    39c0:	4a85                	li	s5,1
+    39c2:	bfd1                	j	3996 <sbrkfail+0x90>
+  if(!failed) {
+    39c4:	000a8863          	beqz	s5,39d4 <sbrkfail+0xce>
+  c = sbrk(PGSIZE);
+    39c8:	6505                	lui	a0,0x1
+    39ca:	286010ef          	jal	4c50 <sbrk>
+    39ce:	8a2a                	mv	s4,a0
+    if(pids[i] == -1)
+    39d0:	597d                	li	s2,-1
+    39d2:	a821                	j	39ea <sbrkfail+0xe4>
+    printf("%s: no allocation failed; allocate more?\n", s);
+    39d4:	85da                	mv	a1,s6
+    39d6:	00003517          	auipc	a0,0x3
+    39da:	3b250513          	addi	a0,a0,946 # 6d88 <malloc+0x1c20>
+    39de:	6d6010ef          	jal	50b4 <printf>
+    39e2:	b7dd                	j	39c8 <sbrkfail+0xc2>
+  for(i = 0; i < sizeof(pids)/sizeof(pids[0]); i++){
+    39e4:	0491                	addi	s1,s1,4
+    39e6:	01348b63          	beq	s1,s3,39fc <sbrkfail+0xf6>
+    if(pids[i] == -1)
+    39ea:	4088                	lw	a0,0(s1)
+    39ec:	ff250ce3          	beq	a0,s2,39e4 <sbrkfail+0xde>
+    kill(pids[i]);
+    39f0:	2c4010ef          	jal	4cb4 <kill>
+    wait(0);
+    39f4:	4501                	li	a0,0
+    39f6:	296010ef          	jal	4c8c <wait>
+    39fa:	b7ed                	j	39e4 <sbrkfail+0xde>
+  if(c == (char*)SBRK_ERROR){
+    39fc:	57fd                	li	a5,-1
+    39fe:	02fa0a63          	beq	s4,a5,3a32 <sbrkfail+0x12c>
+  pid = fork();
+    3a02:	27a010ef          	jal	4c7c <fork>
+  if(pid < 0){
+    3a06:	04054063          	bltz	a0,3a46 <sbrkfail+0x140>
+  if(pid == 0){
+    3a0a:	e939                	bnez	a0,3a60 <sbrkfail+0x15a>
+    a = sbrk(10*BIG);
+    3a0c:	3e800537          	lui	a0,0x3e800
+    3a10:	240010ef          	jal	4c50 <sbrk>
+    if(a == (char*)SBRK_ERROR){
+    3a14:	57fd                	li	a5,-1
+    3a16:	04f50263          	beq	a0,a5,3a5a <sbrkfail+0x154>
+    printf("%s: allocate a lot of memory succeeded %d\n", s, 10*BIG);
+    3a1a:	3e800637          	lui	a2,0x3e800
+    3a1e:	85da                	mv	a1,s6
+    3a20:	00003517          	auipc	a0,0x3
+    3a24:	3b850513          	addi	a0,a0,952 # 6dd8 <malloc+0x1c70>
+    3a28:	68c010ef          	jal	50b4 <printf>
+    exit(1);
+    3a2c:	4505                	li	a0,1
+    3a2e:	256010ef          	jal	4c84 <exit>
+    printf("%s: failed sbrk leaked memory\n", s);
+    3a32:	85da                	mv	a1,s6
+    3a34:	00003517          	auipc	a0,0x3
+    3a38:	38450513          	addi	a0,a0,900 # 6db8 <malloc+0x1c50>
+    3a3c:	678010ef          	jal	50b4 <printf>
+    exit(1);
+    3a40:	4505                	li	a0,1
+    3a42:	242010ef          	jal	4c84 <exit>
+    printf("%s: fork failed\n", s);
+    3a46:	85da                	mv	a1,s6
+    3a48:	00002517          	auipc	a0,0x2
+    3a4c:	0e050513          	addi	a0,a0,224 # 5b28 <malloc+0x9c0>
+    3a50:	664010ef          	jal	50b4 <printf>
+    exit(1);
+    3a54:	4505                	li	a0,1
+    3a56:	22e010ef          	jal	4c84 <exit>
+      exit(0);
+    3a5a:	4501                	li	a0,0
+    3a5c:	228010ef          	jal	4c84 <exit>
+  wait(&xstatus);
+    3a60:	fac40513          	addi	a0,s0,-84
+    3a64:	228010ef          	jal	4c8c <wait>
+  if(xstatus != 0)
+    3a68:	fac42783          	lw	a5,-84(s0)
+    3a6c:	ef81                	bnez	a5,3a84 <sbrkfail+0x17e>
+}
+    3a6e:	60aa                	ld	ra,136(sp)
+    3a70:	640a                	ld	s0,128(sp)
+    3a72:	74e6                	ld	s1,120(sp)
+    3a74:	7946                	ld	s2,112(sp)
+    3a76:	79a6                	ld	s3,104(sp)
+    3a78:	7a06                	ld	s4,96(sp)
+    3a7a:	6ae6                	ld	s5,88(sp)
+    3a7c:	6b46                	ld	s6,80(sp)
+    3a7e:	6ba6                	ld	s7,72(sp)
+    3a80:	6149                	addi	sp,sp,144
+    3a82:	8082                	ret
+    exit(1);
+    3a84:	4505                	li	a0,1
+    3a86:	1fe010ef          	jal	4c84 <exit>
+
+0000000000003a8a <mem>:
+{
+    3a8a:	7139                	addi	sp,sp,-64
+    3a8c:	fc06                	sd	ra,56(sp)
+    3a8e:	f822                	sd	s0,48(sp)
+    3a90:	f426                	sd	s1,40(sp)
+    3a92:	f04a                	sd	s2,32(sp)
+    3a94:	ec4e                	sd	s3,24(sp)
+    3a96:	0080                	addi	s0,sp,64
+    3a98:	89aa                	mv	s3,a0
+  if((pid = fork()) == 0){
+    3a9a:	1e2010ef          	jal	4c7c <fork>
+    m1 = 0;
+    3a9e:	4481                	li	s1,0
+    while((m2 = malloc(10001)) != 0){
+    3aa0:	6909                	lui	s2,0x2
+    3aa2:	71190913          	addi	s2,s2,1809 # 2711 <fourteen+0x97>
+  if((pid = fork()) == 0){
+    3aa6:	cd11                	beqz	a0,3ac2 <mem+0x38>
+    wait(&xstatus);
+    3aa8:	fcc40513          	addi	a0,s0,-52
+    3aac:	1e0010ef          	jal	4c8c <wait>
+    if(xstatus == -1){
+    3ab0:	fcc42503          	lw	a0,-52(s0)
+    3ab4:	57fd                	li	a5,-1
+    3ab6:	04f50363          	beq	a0,a5,3afc <mem+0x72>
+    exit(xstatus);
+    3aba:	1ca010ef          	jal	4c84 <exit>
+      *(char**)m2 = m1;
+    3abe:	e104                	sd	s1,0(a0)
+      m1 = m2;
+    3ac0:	84aa                	mv	s1,a0
+    while((m2 = malloc(10001)) != 0){
+    3ac2:	854a                	mv	a0,s2
+    3ac4:	6a4010ef          	jal	5168 <malloc>
+    3ac8:	f97d                	bnez	a0,3abe <mem+0x34>
+    while(m1){
+    3aca:	c491                	beqz	s1,3ad6 <mem+0x4c>
+      m2 = *(char**)m1;
+    3acc:	8526                	mv	a0,s1
+    3ace:	6084                	ld	s1,0(s1)
+      free(m1);
+    3ad0:	616010ef          	jal	50e6 <free>
+    while(m1){
+    3ad4:	fce5                	bnez	s1,3acc <mem+0x42>
+    m1 = malloc(1024*20);
+    3ad6:	6515                	lui	a0,0x5
+    3ad8:	690010ef          	jal	5168 <malloc>
+    if(m1 == 0){
+    3adc:	c511                	beqz	a0,3ae8 <mem+0x5e>
+    free(m1);
+    3ade:	608010ef          	jal	50e6 <free>
+    exit(0);
+    3ae2:	4501                	li	a0,0
+    3ae4:	1a0010ef          	jal	4c84 <exit>
+      printf("%s: couldn't allocate mem?!!\n", s);
+    3ae8:	85ce                	mv	a1,s3
+    3aea:	00003517          	auipc	a0,0x3
+    3aee:	31e50513          	addi	a0,a0,798 # 6e08 <malloc+0x1ca0>
+    3af2:	5c2010ef          	jal	50b4 <printf>
+      exit(1);
+    3af6:	4505                	li	a0,1
+    3af8:	18c010ef          	jal	4c84 <exit>
+      exit(0);
+    3afc:	4501                	li	a0,0
+    3afe:	186010ef          	jal	4c84 <exit>
+
+0000000000003b02 <sharedfd>:
+{
+    3b02:	7159                	addi	sp,sp,-112
+    3b04:	f486                	sd	ra,104(sp)
+    3b06:	f0a2                	sd	s0,96(sp)
+    3b08:	e0d2                	sd	s4,64(sp)
+    3b0a:	1880                	addi	s0,sp,112
+    3b0c:	8a2a                	mv	s4,a0
+  unlink("sharedfd");
+    3b0e:	00003517          	auipc	a0,0x3
+    3b12:	31a50513          	addi	a0,a0,794 # 6e28 <malloc+0x1cc0>
+    3b16:	1be010ef          	jal	4cd4 <unlink>
+  fd = open("sharedfd", O_CREATE|O_RDWR);
+    3b1a:	20200593          	li	a1,514
+    3b1e:	00003517          	auipc	a0,0x3
+    3b22:	30a50513          	addi	a0,a0,778 # 6e28 <malloc+0x1cc0>
+    3b26:	19e010ef          	jal	4cc4 <open>
+  if(fd < 0){
+    3b2a:	04054863          	bltz	a0,3b7a <sharedfd+0x78>
+    3b2e:	eca6                	sd	s1,88(sp)
+    3b30:	e8ca                	sd	s2,80(sp)
+    3b32:	e4ce                	sd	s3,72(sp)
+    3b34:	fc56                	sd	s5,56(sp)
+    3b36:	f85a                	sd	s6,48(sp)
+    3b38:	f45e                	sd	s7,40(sp)
+    3b3a:	892a                	mv	s2,a0
+  pid = fork();
+    3b3c:	140010ef          	jal	4c7c <fork>
+    3b40:	89aa                	mv	s3,a0
+  memset(buf, pid==0?'c':'p', sizeof(buf));
+    3b42:	07000593          	li	a1,112
+    3b46:	e119                	bnez	a0,3b4c <sharedfd+0x4a>
+    3b48:	06300593          	li	a1,99
+    3b4c:	4629                	li	a2,10
+    3b4e:	fa040513          	addi	a0,s0,-96
+    3b52:	721000ef          	jal	4a72 <memset>
+    3b56:	3e800493          	li	s1,1000
+    if(write(fd, buf, sizeof(buf)) != sizeof(buf)){
+    3b5a:	4629                	li	a2,10
+    3b5c:	fa040593          	addi	a1,s0,-96
+    3b60:	854a                	mv	a0,s2
+    3b62:	142010ef          	jal	4ca4 <write>
+    3b66:	47a9                	li	a5,10
+    3b68:	02f51963          	bne	a0,a5,3b9a <sharedfd+0x98>
+  for(i = 0; i < N; i++){
+    3b6c:	34fd                	addiw	s1,s1,-1
+    3b6e:	f4f5                	bnez	s1,3b5a <sharedfd+0x58>
+  if(pid == 0) {
+    3b70:	02099f63          	bnez	s3,3bae <sharedfd+0xac>
+    exit(0);
+    3b74:	4501                	li	a0,0
+    3b76:	10e010ef          	jal	4c84 <exit>
+    3b7a:	eca6                	sd	s1,88(sp)
+    3b7c:	e8ca                	sd	s2,80(sp)
+    3b7e:	e4ce                	sd	s3,72(sp)
+    3b80:	fc56                	sd	s5,56(sp)
+    3b82:	f85a                	sd	s6,48(sp)
+    3b84:	f45e                	sd	s7,40(sp)
+    printf("%s: cannot open sharedfd for writing", s);
+    3b86:	85d2                	mv	a1,s4
+    3b88:	00003517          	auipc	a0,0x3
+    3b8c:	2b050513          	addi	a0,a0,688 # 6e38 <malloc+0x1cd0>
+    3b90:	524010ef          	jal	50b4 <printf>
+    exit(1);
+    3b94:	4505                	li	a0,1
+    3b96:	0ee010ef          	jal	4c84 <exit>
+      printf("%s: write sharedfd failed\n", s);
+    3b9a:	85d2                	mv	a1,s4
+    3b9c:	00003517          	auipc	a0,0x3
+    3ba0:	2c450513          	addi	a0,a0,708 # 6e60 <malloc+0x1cf8>
+    3ba4:	510010ef          	jal	50b4 <printf>
+      exit(1);
+    3ba8:	4505                	li	a0,1
+    3baa:	0da010ef          	jal	4c84 <exit>
+    wait(&xstatus);
+    3bae:	f9c40513          	addi	a0,s0,-100
+    3bb2:	0da010ef          	jal	4c8c <wait>
+    if(xstatus != 0)
+    3bb6:	f9c42983          	lw	s3,-100(s0)
+    3bba:	00098563          	beqz	s3,3bc4 <sharedfd+0xc2>
+      exit(xstatus);
+    3bbe:	854e                	mv	a0,s3
+    3bc0:	0c4010ef          	jal	4c84 <exit>
+  close(fd);
+    3bc4:	854a                	mv	a0,s2
+    3bc6:	0e6010ef          	jal	4cac <close>
+  fd = open("sharedfd", 0);
+    3bca:	4581                	li	a1,0
+    3bcc:	00003517          	auipc	a0,0x3
+    3bd0:	25c50513          	addi	a0,a0,604 # 6e28 <malloc+0x1cc0>
+    3bd4:	0f0010ef          	jal	4cc4 <open>
+    3bd8:	8baa                	mv	s7,a0
+  nc = np = 0;
+    3bda:	8ace                	mv	s5,s3
+  if(fd < 0){
+    3bdc:	02054363          	bltz	a0,3c02 <sharedfd+0x100>
+    3be0:	faa40913          	addi	s2,s0,-86
+      if(buf[i] == 'c')
+    3be4:	06300493          	li	s1,99
+      if(buf[i] == 'p')
+    3be8:	07000b13          	li	s6,112
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+    3bec:	4629                	li	a2,10
+    3bee:	fa040593          	addi	a1,s0,-96
+    3bf2:	855e                	mv	a0,s7
+    3bf4:	0a8010ef          	jal	4c9c <read>
+    3bf8:	02a05b63          	blez	a0,3c2e <sharedfd+0x12c>
+    3bfc:	fa040793          	addi	a5,s0,-96
+    3c00:	a839                	j	3c1e <sharedfd+0x11c>
+    printf("%s: cannot open sharedfd for reading\n", s);
+    3c02:	85d2                	mv	a1,s4
+    3c04:	00003517          	auipc	a0,0x3
+    3c08:	27c50513          	addi	a0,a0,636 # 6e80 <malloc+0x1d18>
+    3c0c:	4a8010ef          	jal	50b4 <printf>
+    exit(1);
+    3c10:	4505                	li	a0,1
+    3c12:	072010ef          	jal	4c84 <exit>
+        nc++;
+    3c16:	2985                	addiw	s3,s3,1
+    for(i = 0; i < sizeof(buf); i++){
+    3c18:	0785                	addi	a5,a5,1 # 6400001 <base+0x63f0359>
+    3c1a:	fd2789e3          	beq	a5,s2,3bec <sharedfd+0xea>
+      if(buf[i] == 'c')
+    3c1e:	0007c703          	lbu	a4,0(a5)
+    3c22:	fe970ae3          	beq	a4,s1,3c16 <sharedfd+0x114>
+      if(buf[i] == 'p')
+    3c26:	ff6719e3          	bne	a4,s6,3c18 <sharedfd+0x116>
+        np++;
+    3c2a:	2a85                	addiw	s5,s5,1
+    3c2c:	b7f5                	j	3c18 <sharedfd+0x116>
+  close(fd);
+    3c2e:	855e                	mv	a0,s7
+    3c30:	07c010ef          	jal	4cac <close>
+  unlink("sharedfd");
+    3c34:	00003517          	auipc	a0,0x3
+    3c38:	1f450513          	addi	a0,a0,500 # 6e28 <malloc+0x1cc0>
+    3c3c:	098010ef          	jal	4cd4 <unlink>
+  if(nc == N*SZ && np == N*SZ){
+    3c40:	6789                	lui	a5,0x2
+    3c42:	71078793          	addi	a5,a5,1808 # 2710 <fourteen+0x96>
+    3c46:	00f99763          	bne	s3,a5,3c54 <sharedfd+0x152>
+    3c4a:	6789                	lui	a5,0x2
+    3c4c:	71078793          	addi	a5,a5,1808 # 2710 <fourteen+0x96>
+    3c50:	00fa8c63          	beq	s5,a5,3c68 <sharedfd+0x166>
+    printf("%s: nc/np test fails\n", s);
+    3c54:	85d2                	mv	a1,s4
+    3c56:	00003517          	auipc	a0,0x3
+    3c5a:	25250513          	addi	a0,a0,594 # 6ea8 <malloc+0x1d40>
+    3c5e:	456010ef          	jal	50b4 <printf>
+    exit(1);
+    3c62:	4505                	li	a0,1
+    3c64:	020010ef          	jal	4c84 <exit>
+    exit(0);
+    3c68:	4501                	li	a0,0
+    3c6a:	01a010ef          	jal	4c84 <exit>
+
+0000000000003c6e <fourfiles>:
+{
+    3c6e:	7135                	addi	sp,sp,-160
+    3c70:	ed06                	sd	ra,152(sp)
+    3c72:	e922                	sd	s0,144(sp)
+    3c74:	e526                	sd	s1,136(sp)
+    3c76:	e14a                	sd	s2,128(sp)
+    3c78:	fcce                	sd	s3,120(sp)
+    3c7a:	f8d2                	sd	s4,112(sp)
+    3c7c:	f4d6                	sd	s5,104(sp)
+    3c7e:	f0da                	sd	s6,96(sp)
+    3c80:	ecde                	sd	s7,88(sp)
+    3c82:	e8e2                	sd	s8,80(sp)
+    3c84:	e4e6                	sd	s9,72(sp)
+    3c86:	e0ea                	sd	s10,64(sp)
+    3c88:	fc6e                	sd	s11,56(sp)
+    3c8a:	1100                	addi	s0,sp,160
+    3c8c:	8caa                	mv	s9,a0
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    3c8e:	00003797          	auipc	a5,0x3
+    3c92:	23278793          	addi	a5,a5,562 # 6ec0 <malloc+0x1d58>
+    3c96:	f6f43823          	sd	a5,-144(s0)
+    3c9a:	00003797          	auipc	a5,0x3
+    3c9e:	22e78793          	addi	a5,a5,558 # 6ec8 <malloc+0x1d60>
+    3ca2:	f6f43c23          	sd	a5,-136(s0)
+    3ca6:	00003797          	auipc	a5,0x3
+    3caa:	22a78793          	addi	a5,a5,554 # 6ed0 <malloc+0x1d68>
+    3cae:	f8f43023          	sd	a5,-128(s0)
+    3cb2:	00003797          	auipc	a5,0x3
+    3cb6:	22678793          	addi	a5,a5,550 # 6ed8 <malloc+0x1d70>
+    3cba:	f8f43423          	sd	a5,-120(s0)
+  for(pi = 0; pi < NCHILD; pi++){
+    3cbe:	f7040b93          	addi	s7,s0,-144
+  char *names[] = { "f0", "f1", "f2", "f3" };
+    3cc2:	895e                	mv	s2,s7
+  for(pi = 0; pi < NCHILD; pi++){
+    3cc4:	4481                	li	s1,0
+    3cc6:	4a11                	li	s4,4
+    fname = names[pi];
+    3cc8:	00093983          	ld	s3,0(s2)
+    unlink(fname);
+    3ccc:	854e                	mv	a0,s3
+    3cce:	006010ef          	jal	4cd4 <unlink>
+    pid = fork();
+    3cd2:	7ab000ef          	jal	4c7c <fork>
+    if(pid < 0){
+    3cd6:	02054e63          	bltz	a0,3d12 <fourfiles+0xa4>
+    if(pid == 0){
+    3cda:	c531                	beqz	a0,3d26 <fourfiles+0xb8>
+  for(pi = 0; pi < NCHILD; pi++){
+    3cdc:	2485                	addiw	s1,s1,1
+    3cde:	0921                	addi	s2,s2,8
+    3ce0:	ff4494e3          	bne	s1,s4,3cc8 <fourfiles+0x5a>
+    3ce4:	4491                	li	s1,4
+    wait(&xstatus);
+    3ce6:	f6c40513          	addi	a0,s0,-148
+    3cea:	7a3000ef          	jal	4c8c <wait>
+    if(xstatus != 0)
+    3cee:	f6c42a83          	lw	s5,-148(s0)
+    3cf2:	0a0a9463          	bnez	s5,3d9a <fourfiles+0x12c>
+  for(pi = 0; pi < NCHILD; pi++){
+    3cf6:	34fd                	addiw	s1,s1,-1
+    3cf8:	f4fd                	bnez	s1,3ce6 <fourfiles+0x78>
+    3cfa:	03000b13          	li	s6,48
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    3cfe:	00009a17          	auipc	s4,0x9
+    3d02:	faaa0a13          	addi	s4,s4,-86 # cca8 <buf>
+    if(total != N*SZ){
+    3d06:	6d05                	lui	s10,0x1
+    3d08:	770d0d13          	addi	s10,s10,1904 # 1770 <forkfork+0x1e>
+  for(i = 0; i < NCHILD; i++){
+    3d0c:	03400d93          	li	s11,52
+    3d10:	a0ed                	j	3dfa <fourfiles+0x18c>
+      printf("%s: fork failed\n", s);
+    3d12:	85e6                	mv	a1,s9
+    3d14:	00002517          	auipc	a0,0x2
+    3d18:	e1450513          	addi	a0,a0,-492 # 5b28 <malloc+0x9c0>
+    3d1c:	398010ef          	jal	50b4 <printf>
+      exit(1);
+    3d20:	4505                	li	a0,1
+    3d22:	763000ef          	jal	4c84 <exit>
+      fd = open(fname, O_CREATE | O_RDWR);
+    3d26:	20200593          	li	a1,514
+    3d2a:	854e                	mv	a0,s3
+    3d2c:	799000ef          	jal	4cc4 <open>
+    3d30:	892a                	mv	s2,a0
+      if(fd < 0){
+    3d32:	04054163          	bltz	a0,3d74 <fourfiles+0x106>
+      memset(buf, '0'+pi, SZ);
+    3d36:	1f400613          	li	a2,500
+    3d3a:	0304859b          	addiw	a1,s1,48
+    3d3e:	00009517          	auipc	a0,0x9
+    3d42:	f6a50513          	addi	a0,a0,-150 # cca8 <buf>
+    3d46:	52d000ef          	jal	4a72 <memset>
+    3d4a:	44b1                	li	s1,12
+        if((n = write(fd, buf, SZ)) != SZ){
+    3d4c:	00009997          	auipc	s3,0x9
+    3d50:	f5c98993          	addi	s3,s3,-164 # cca8 <buf>
+    3d54:	1f400613          	li	a2,500
+    3d58:	85ce                	mv	a1,s3
+    3d5a:	854a                	mv	a0,s2
+    3d5c:	749000ef          	jal	4ca4 <write>
+    3d60:	85aa                	mv	a1,a0
+    3d62:	1f400793          	li	a5,500
+    3d66:	02f51163          	bne	a0,a5,3d88 <fourfiles+0x11a>
+      for(i = 0; i < N; i++){
+    3d6a:	34fd                	addiw	s1,s1,-1
+    3d6c:	f4e5                	bnez	s1,3d54 <fourfiles+0xe6>
+      exit(0);
+    3d6e:	4501                	li	a0,0
+    3d70:	715000ef          	jal	4c84 <exit>
+        printf("%s: create failed\n", s);
+    3d74:	85e6                	mv	a1,s9
+    3d76:	00002517          	auipc	a0,0x2
+    3d7a:	e4a50513          	addi	a0,a0,-438 # 5bc0 <malloc+0xa58>
+    3d7e:	336010ef          	jal	50b4 <printf>
+        exit(1);
+    3d82:	4505                	li	a0,1
+    3d84:	701000ef          	jal	4c84 <exit>
+          printf("write failed %d\n", n);
+    3d88:	00003517          	auipc	a0,0x3
+    3d8c:	15850513          	addi	a0,a0,344 # 6ee0 <malloc+0x1d78>
+    3d90:	324010ef          	jal	50b4 <printf>
+          exit(1);
+    3d94:	4505                	li	a0,1
+    3d96:	6ef000ef          	jal	4c84 <exit>
+      exit(xstatus);
+    3d9a:	8556                	mv	a0,s5
+    3d9c:	6e9000ef          	jal	4c84 <exit>
+          printf("%s: wrong char\n", s);
+    3da0:	85e6                	mv	a1,s9
+    3da2:	00003517          	auipc	a0,0x3
+    3da6:	15650513          	addi	a0,a0,342 # 6ef8 <malloc+0x1d90>
+    3daa:	30a010ef          	jal	50b4 <printf>
+          exit(1);
+    3dae:	4505                	li	a0,1
+    3db0:	6d5000ef          	jal	4c84 <exit>
+      total += n;
+    3db4:	00a9093b          	addw	s2,s2,a0
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    3db8:	660d                	lui	a2,0x3
+    3dba:	85d2                	mv	a1,s4
+    3dbc:	854e                	mv	a0,s3
+    3dbe:	6df000ef          	jal	4c9c <read>
+    3dc2:	02a05063          	blez	a0,3de2 <fourfiles+0x174>
+    3dc6:	00009797          	auipc	a5,0x9
+    3dca:	ee278793          	addi	a5,a5,-286 # cca8 <buf>
+    3dce:	00f506b3          	add	a3,a0,a5
+        if(buf[j] != '0'+i){
+    3dd2:	0007c703          	lbu	a4,0(a5)
+    3dd6:	fc9715e3          	bne	a4,s1,3da0 <fourfiles+0x132>
+      for(j = 0; j < n; j++){
+    3dda:	0785                	addi	a5,a5,1
+    3ddc:	fed79be3          	bne	a5,a3,3dd2 <fourfiles+0x164>
+    3de0:	bfd1                	j	3db4 <fourfiles+0x146>
+    close(fd);
+    3de2:	854e                	mv	a0,s3
+    3de4:	6c9000ef          	jal	4cac <close>
+    if(total != N*SZ){
+    3de8:	03a91463          	bne	s2,s10,3e10 <fourfiles+0x1a2>
+    unlink(fname);
+    3dec:	8562                	mv	a0,s8
+    3dee:	6e7000ef          	jal	4cd4 <unlink>
+  for(i = 0; i < NCHILD; i++){
+    3df2:	0ba1                	addi	s7,s7,8
+    3df4:	2b05                	addiw	s6,s6,1
+    3df6:	03bb0763          	beq	s6,s11,3e24 <fourfiles+0x1b6>
+    fname = names[i];
+    3dfa:	000bbc03          	ld	s8,0(s7)
+    fd = open(fname, 0);
+    3dfe:	4581                	li	a1,0
+    3e00:	8562                	mv	a0,s8
+    3e02:	6c3000ef          	jal	4cc4 <open>
+    3e06:	89aa                	mv	s3,a0
+    total = 0;
+    3e08:	8956                	mv	s2,s5
+        if(buf[j] != '0'+i){
+    3e0a:	000b049b          	sext.w	s1,s6
+    while((n = read(fd, buf, sizeof(buf))) > 0){
+    3e0e:	b76d                	j	3db8 <fourfiles+0x14a>
+      printf("wrong length %d\n", total);
+    3e10:	85ca                	mv	a1,s2
+    3e12:	00003517          	auipc	a0,0x3
+    3e16:	0f650513          	addi	a0,a0,246 # 6f08 <malloc+0x1da0>
+    3e1a:	29a010ef          	jal	50b4 <printf>
+      exit(1);
+    3e1e:	4505                	li	a0,1
+    3e20:	665000ef          	jal	4c84 <exit>
+}
+    3e24:	60ea                	ld	ra,152(sp)
+    3e26:	644a                	ld	s0,144(sp)
+    3e28:	64aa                	ld	s1,136(sp)
+    3e2a:	690a                	ld	s2,128(sp)
+    3e2c:	79e6                	ld	s3,120(sp)
+    3e2e:	7a46                	ld	s4,112(sp)
+    3e30:	7aa6                	ld	s5,104(sp)
+    3e32:	7b06                	ld	s6,96(sp)
+    3e34:	6be6                	ld	s7,88(sp)
+    3e36:	6c46                	ld	s8,80(sp)
+    3e38:	6ca6                	ld	s9,72(sp)
+    3e3a:	6d06                	ld	s10,64(sp)
+    3e3c:	7de2                	ld	s11,56(sp)
+    3e3e:	610d                	addi	sp,sp,160
+    3e40:	8082                	ret
+
+0000000000003e42 <concreate>:
+{
+    3e42:	7135                	addi	sp,sp,-160
+    3e44:	ed06                	sd	ra,152(sp)
+    3e46:	e922                	sd	s0,144(sp)
+    3e48:	e526                	sd	s1,136(sp)
+    3e4a:	e14a                	sd	s2,128(sp)
+    3e4c:	fcce                	sd	s3,120(sp)
+    3e4e:	f8d2                	sd	s4,112(sp)
+    3e50:	f4d6                	sd	s5,104(sp)
+    3e52:	f0da                	sd	s6,96(sp)
+    3e54:	ecde                	sd	s7,88(sp)
+    3e56:	1100                	addi	s0,sp,160
+    3e58:	89aa                	mv	s3,a0
+  file[0] = 'C';
+    3e5a:	04300793          	li	a5,67
+    3e5e:	faf40423          	sb	a5,-88(s0)
+  file[2] = '\0';
+    3e62:	fa040523          	sb	zero,-86(s0)
+  for(i = 0; i < N; i++){
+    3e66:	4901                	li	s2,0
+    if(pid && (i % 3) == 1){
+    3e68:	4b0d                	li	s6,3
+    3e6a:	4a85                	li	s5,1
+      link("C0", file);
+    3e6c:	00003b97          	auipc	s7,0x3
+    3e70:	0b4b8b93          	addi	s7,s7,180 # 6f20 <malloc+0x1db8>
+  for(i = 0; i < N; i++){
+    3e74:	02800a13          	li	s4,40
+    3e78:	a41d                	j	409e <concreate+0x25c>
+      link("C0", file);
+    3e7a:	fa840593          	addi	a1,s0,-88
+    3e7e:	855e                	mv	a0,s7
+    3e80:	665000ef          	jal	4ce4 <link>
+    if(pid == 0) {
+    3e84:	a411                	j	4088 <concreate+0x246>
+    } else if(pid == 0 && (i % 5) == 1){
+    3e86:	4795                	li	a5,5
+    3e88:	02f9693b          	remw	s2,s2,a5
+    3e8c:	4785                	li	a5,1
+    3e8e:	02f90563          	beq	s2,a5,3eb8 <concreate+0x76>
+      fd = open(file, O_CREATE | O_RDWR);
+    3e92:	20200593          	li	a1,514
+    3e96:	fa840513          	addi	a0,s0,-88
+    3e9a:	62b000ef          	jal	4cc4 <open>
+      if(fd < 0){
+    3e9e:	1e055063          	bgez	a0,407e <concreate+0x23c>
+        printf("concreate create %s failed\n", file);
+    3ea2:	fa840593          	addi	a1,s0,-88
+    3ea6:	00003517          	auipc	a0,0x3
+    3eaa:	08250513          	addi	a0,a0,130 # 6f28 <malloc+0x1dc0>
+    3eae:	206010ef          	jal	50b4 <printf>
+        exit(1);
+    3eb2:	4505                	li	a0,1
+    3eb4:	5d1000ef          	jal	4c84 <exit>
+      link("C0", file);
+    3eb8:	fa840593          	addi	a1,s0,-88
+    3ebc:	00003517          	auipc	a0,0x3
+    3ec0:	06450513          	addi	a0,a0,100 # 6f20 <malloc+0x1db8>
+    3ec4:	621000ef          	jal	4ce4 <link>
+      exit(0);
+    3ec8:	4501                	li	a0,0
+    3eca:	5bb000ef          	jal	4c84 <exit>
+        exit(1);
+    3ece:	4505                	li	a0,1
+    3ed0:	5b5000ef          	jal	4c84 <exit>
+  memset(fa, 0, sizeof(fa));
+    3ed4:	02800613          	li	a2,40
+    3ed8:	4581                	li	a1,0
+    3eda:	f8040513          	addi	a0,s0,-128
+    3ede:	395000ef          	jal	4a72 <memset>
+  fd = open(".", 0);
+    3ee2:	4581                	li	a1,0
+    3ee4:	00002517          	auipc	a0,0x2
+    3ee8:	a9c50513          	addi	a0,a0,-1380 # 5980 <malloc+0x818>
+    3eec:	5d9000ef          	jal	4cc4 <open>
+    3ef0:	892a                	mv	s2,a0
+  n = 0;
+    3ef2:	8aa6                	mv	s5,s1
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    3ef4:	04300a13          	li	s4,67
+      if(i < 0 || i >= sizeof(fa)){
+    3ef8:	02700b13          	li	s6,39
+      fa[i] = 1;
+    3efc:	4b85                	li	s7,1
+  while(read(fd, &de, sizeof(de)) > 0){
+    3efe:	4641                	li	a2,16
+    3f00:	f7040593          	addi	a1,s0,-144
+    3f04:	854a                	mv	a0,s2
+    3f06:	597000ef          	jal	4c9c <read>
+    3f0a:	06a05a63          	blez	a0,3f7e <concreate+0x13c>
+    if(de.inum == 0)
+    3f0e:	f7045783          	lhu	a5,-144(s0)
+    3f12:	d7f5                	beqz	a5,3efe <concreate+0xbc>
+    if(de.name[0] == 'C' && de.name[2] == '\0'){
+    3f14:	f7244783          	lbu	a5,-142(s0)
+    3f18:	ff4793e3          	bne	a5,s4,3efe <concreate+0xbc>
+    3f1c:	f7444783          	lbu	a5,-140(s0)
+    3f20:	fff9                	bnez	a5,3efe <concreate+0xbc>
+      i = de.name[1] - '0';
+    3f22:	f7344783          	lbu	a5,-141(s0)
+    3f26:	fd07879b          	addiw	a5,a5,-48
+    3f2a:	0007871b          	sext.w	a4,a5
+      if(i < 0 || i >= sizeof(fa)){
+    3f2e:	02eb6063          	bltu	s6,a4,3f4e <concreate+0x10c>
+      if(fa[i]){
+    3f32:	fb070793          	addi	a5,a4,-80
+    3f36:	97a2                	add	a5,a5,s0
+    3f38:	fd07c783          	lbu	a5,-48(a5)
+    3f3c:	e78d                	bnez	a5,3f66 <concreate+0x124>
+      fa[i] = 1;
+    3f3e:	fb070793          	addi	a5,a4,-80
+    3f42:	00878733          	add	a4,a5,s0
+    3f46:	fd770823          	sb	s7,-48(a4)
+      n++;
+    3f4a:	2a85                	addiw	s5,s5,1
+    3f4c:	bf4d                	j	3efe <concreate+0xbc>
+        printf("%s: concreate weird file %s\n", s, de.name);
+    3f4e:	f7240613          	addi	a2,s0,-142
+    3f52:	85ce                	mv	a1,s3
+    3f54:	00003517          	auipc	a0,0x3
+    3f58:	ff450513          	addi	a0,a0,-12 # 6f48 <malloc+0x1de0>
+    3f5c:	158010ef          	jal	50b4 <printf>
+        exit(1);
+    3f60:	4505                	li	a0,1
+    3f62:	523000ef          	jal	4c84 <exit>
+        printf("%s: concreate duplicate file %s\n", s, de.name);
+    3f66:	f7240613          	addi	a2,s0,-142
+    3f6a:	85ce                	mv	a1,s3
+    3f6c:	00003517          	auipc	a0,0x3
+    3f70:	ffc50513          	addi	a0,a0,-4 # 6f68 <malloc+0x1e00>
+    3f74:	140010ef          	jal	50b4 <printf>
+        exit(1);
+    3f78:	4505                	li	a0,1
+    3f7a:	50b000ef          	jal	4c84 <exit>
+  close(fd);
+    3f7e:	854a                	mv	a0,s2
+    3f80:	52d000ef          	jal	4cac <close>
+  if(n != N){
+    3f84:	02800793          	li	a5,40
+    3f88:	00fa9763          	bne	s5,a5,3f96 <concreate+0x154>
+    if(((i % 3) == 0 && pid == 0) ||
+    3f8c:	4a8d                	li	s5,3
+    3f8e:	4b05                	li	s6,1
+  for(i = 0; i < N; i++){
+    3f90:	02800a13          	li	s4,40
+    3f94:	a079                	j	4022 <concreate+0x1e0>
+    printf("%s: concreate not enough files in directory listing\n", s);
+    3f96:	85ce                	mv	a1,s3
+    3f98:	00003517          	auipc	a0,0x3
+    3f9c:	ff850513          	addi	a0,a0,-8 # 6f90 <malloc+0x1e28>
+    3fa0:	114010ef          	jal	50b4 <printf>
+    exit(1);
+    3fa4:	4505                	li	a0,1
+    3fa6:	4df000ef          	jal	4c84 <exit>
+      printf("%s: fork failed\n", s);
+    3faa:	85ce                	mv	a1,s3
+    3fac:	00002517          	auipc	a0,0x2
+    3fb0:	b7c50513          	addi	a0,a0,-1156 # 5b28 <malloc+0x9c0>
+    3fb4:	100010ef          	jal	50b4 <printf>
+      exit(1);
+    3fb8:	4505                	li	a0,1
+    3fba:	4cb000ef          	jal	4c84 <exit>
+      close(open(file, 0));
+    3fbe:	4581                	li	a1,0
+    3fc0:	fa840513          	addi	a0,s0,-88
+    3fc4:	501000ef          	jal	4cc4 <open>
+    3fc8:	4e5000ef          	jal	4cac <close>
+      close(open(file, 0));
+    3fcc:	4581                	li	a1,0
+    3fce:	fa840513          	addi	a0,s0,-88
+    3fd2:	4f3000ef          	jal	4cc4 <open>
+    3fd6:	4d7000ef          	jal	4cac <close>
+      close(open(file, 0));
+    3fda:	4581                	li	a1,0
+    3fdc:	fa840513          	addi	a0,s0,-88
+    3fe0:	4e5000ef          	jal	4cc4 <open>
+    3fe4:	4c9000ef          	jal	4cac <close>
+      close(open(file, 0));
+    3fe8:	4581                	li	a1,0
+    3fea:	fa840513          	addi	a0,s0,-88
+    3fee:	4d7000ef          	jal	4cc4 <open>
+    3ff2:	4bb000ef          	jal	4cac <close>
+      close(open(file, 0));
+    3ff6:	4581                	li	a1,0
+    3ff8:	fa840513          	addi	a0,s0,-88
+    3ffc:	4c9000ef          	jal	4cc4 <open>
+    4000:	4ad000ef          	jal	4cac <close>
+      close(open(file, 0));
+    4004:	4581                	li	a1,0
+    4006:	fa840513          	addi	a0,s0,-88
+    400a:	4bb000ef          	jal	4cc4 <open>
+    400e:	49f000ef          	jal	4cac <close>
+    if(pid == 0)
+    4012:	06090363          	beqz	s2,4078 <concreate+0x236>
+      wait(0);
+    4016:	4501                	li	a0,0
+    4018:	475000ef          	jal	4c8c <wait>
+  for(i = 0; i < N; i++){
+    401c:	2485                	addiw	s1,s1,1
+    401e:	0b448963          	beq	s1,s4,40d0 <concreate+0x28e>
+    file[1] = '0' + i;
+    4022:	0304879b          	addiw	a5,s1,48
+    4026:	faf404a3          	sb	a5,-87(s0)
+    pid = fork();
+    402a:	453000ef          	jal	4c7c <fork>
+    402e:	892a                	mv	s2,a0
+    if(pid < 0){
+    4030:	f6054de3          	bltz	a0,3faa <concreate+0x168>
+    if(((i % 3) == 0 && pid == 0) ||
+    4034:	0354e73b          	remw	a4,s1,s5
+    4038:	00a767b3          	or	a5,a4,a0
+    403c:	2781                	sext.w	a5,a5
+    403e:	d3c1                	beqz	a5,3fbe <concreate+0x17c>
+    4040:	01671363          	bne	a4,s6,4046 <concreate+0x204>
+       ((i % 3) == 1 && pid != 0)){
+    4044:	fd2d                	bnez	a0,3fbe <concreate+0x17c>
+      unlink(file);
+    4046:	fa840513          	addi	a0,s0,-88
+    404a:	48b000ef          	jal	4cd4 <unlink>
+      unlink(file);
+    404e:	fa840513          	addi	a0,s0,-88
+    4052:	483000ef          	jal	4cd4 <unlink>
+      unlink(file);
+    4056:	fa840513          	addi	a0,s0,-88
+    405a:	47b000ef          	jal	4cd4 <unlink>
+      unlink(file);
+    405e:	fa840513          	addi	a0,s0,-88
+    4062:	473000ef          	jal	4cd4 <unlink>
+      unlink(file);
+    4066:	fa840513          	addi	a0,s0,-88
+    406a:	46b000ef          	jal	4cd4 <unlink>
+      unlink(file);
+    406e:	fa840513          	addi	a0,s0,-88
+    4072:	463000ef          	jal	4cd4 <unlink>
+    4076:	bf71                	j	4012 <concreate+0x1d0>
+      exit(0);
+    4078:	4501                	li	a0,0
+    407a:	40b000ef          	jal	4c84 <exit>
+      close(fd);
+    407e:	42f000ef          	jal	4cac <close>
+    if(pid == 0) {
+    4082:	b599                	j	3ec8 <concreate+0x86>
+      close(fd);
+    4084:	429000ef          	jal	4cac <close>
+      wait(&xstatus);
+    4088:	f6c40513          	addi	a0,s0,-148
+    408c:	401000ef          	jal	4c8c <wait>
+      if(xstatus != 0)
+    4090:	f6c42483          	lw	s1,-148(s0)
+    4094:	e2049de3          	bnez	s1,3ece <concreate+0x8c>
+  for(i = 0; i < N; i++){
+    4098:	2905                	addiw	s2,s2,1
+    409a:	e3490de3          	beq	s2,s4,3ed4 <concreate+0x92>
+    file[1] = '0' + i;
+    409e:	0309079b          	addiw	a5,s2,48
+    40a2:	faf404a3          	sb	a5,-87(s0)
+    unlink(file);
+    40a6:	fa840513          	addi	a0,s0,-88
+    40aa:	42b000ef          	jal	4cd4 <unlink>
+    pid = fork();
+    40ae:	3cf000ef          	jal	4c7c <fork>
+    if(pid && (i % 3) == 1){
+    40b2:	dc050ae3          	beqz	a0,3e86 <concreate+0x44>
+    40b6:	036967bb          	remw	a5,s2,s6
+    40ba:	dd5780e3          	beq	a5,s5,3e7a <concreate+0x38>
+      fd = open(file, O_CREATE | O_RDWR);
+    40be:	20200593          	li	a1,514
+    40c2:	fa840513          	addi	a0,s0,-88
+    40c6:	3ff000ef          	jal	4cc4 <open>
+      if(fd < 0){
+    40ca:	fa055de3          	bgez	a0,4084 <concreate+0x242>
+    40ce:	bbd1                	j	3ea2 <concreate+0x60>
+}
+    40d0:	60ea                	ld	ra,152(sp)
+    40d2:	644a                	ld	s0,144(sp)
+    40d4:	64aa                	ld	s1,136(sp)
+    40d6:	690a                	ld	s2,128(sp)
+    40d8:	79e6                	ld	s3,120(sp)
+    40da:	7a46                	ld	s4,112(sp)
+    40dc:	7aa6                	ld	s5,104(sp)
+    40de:	7b06                	ld	s6,96(sp)
+    40e0:	6be6                	ld	s7,88(sp)
+    40e2:	610d                	addi	sp,sp,160
+    40e4:	8082                	ret
+
+00000000000040e6 <bigfile>:
+{
+    40e6:	7139                	addi	sp,sp,-64
+    40e8:	fc06                	sd	ra,56(sp)
+    40ea:	f822                	sd	s0,48(sp)
+    40ec:	f426                	sd	s1,40(sp)
+    40ee:	f04a                	sd	s2,32(sp)
+    40f0:	ec4e                	sd	s3,24(sp)
+    40f2:	e852                	sd	s4,16(sp)
+    40f4:	e456                	sd	s5,8(sp)
+    40f6:	0080                	addi	s0,sp,64
+    40f8:	8aaa                	mv	s5,a0
+  unlink("bigfile.dat");
+    40fa:	00003517          	auipc	a0,0x3
+    40fe:	ece50513          	addi	a0,a0,-306 # 6fc8 <malloc+0x1e60>
+    4102:	3d3000ef          	jal	4cd4 <unlink>
+  fd = open("bigfile.dat", O_CREATE | O_RDWR);
+    4106:	20200593          	li	a1,514
+    410a:	00003517          	auipc	a0,0x3
+    410e:	ebe50513          	addi	a0,a0,-322 # 6fc8 <malloc+0x1e60>
+    4112:	3b3000ef          	jal	4cc4 <open>
+    4116:	89aa                	mv	s3,a0
+  for(i = 0; i < N; i++){
+    4118:	4481                	li	s1,0
+    memset(buf, i, SZ);
+    411a:	00009917          	auipc	s2,0x9
+    411e:	b8e90913          	addi	s2,s2,-1138 # cca8 <buf>
+  for(i = 0; i < N; i++){
+    4122:	4a51                	li	s4,20
+  if(fd < 0){
+    4124:	08054663          	bltz	a0,41b0 <bigfile+0xca>
+    memset(buf, i, SZ);
+    4128:	25800613          	li	a2,600
+    412c:	85a6                	mv	a1,s1
+    412e:	854a                	mv	a0,s2
+    4130:	143000ef          	jal	4a72 <memset>
+    if(write(fd, buf, SZ) != SZ){
+    4134:	25800613          	li	a2,600
+    4138:	85ca                	mv	a1,s2
+    413a:	854e                	mv	a0,s3
+    413c:	369000ef          	jal	4ca4 <write>
+    4140:	25800793          	li	a5,600
+    4144:	08f51063          	bne	a0,a5,41c4 <bigfile+0xde>
+  for(i = 0; i < N; i++){
+    4148:	2485                	addiw	s1,s1,1
+    414a:	fd449fe3          	bne	s1,s4,4128 <bigfile+0x42>
+  close(fd);
+    414e:	854e                	mv	a0,s3
+    4150:	35d000ef          	jal	4cac <close>
+  fd = open("bigfile.dat", 0);
+    4154:	4581                	li	a1,0
+    4156:	00003517          	auipc	a0,0x3
+    415a:	e7250513          	addi	a0,a0,-398 # 6fc8 <malloc+0x1e60>
+    415e:	367000ef          	jal	4cc4 <open>
+    4162:	8a2a                	mv	s4,a0
+  total = 0;
+    4164:	4981                	li	s3,0
+  for(i = 0; ; i++){
+    4166:	4481                	li	s1,0
+    cc = read(fd, buf, SZ/2);
+    4168:	00009917          	auipc	s2,0x9
+    416c:	b4090913          	addi	s2,s2,-1216 # cca8 <buf>
+  if(fd < 0){
+    4170:	06054463          	bltz	a0,41d8 <bigfile+0xf2>
+    cc = read(fd, buf, SZ/2);
+    4174:	12c00613          	li	a2,300
+    4178:	85ca                	mv	a1,s2
+    417a:	8552                	mv	a0,s4
+    417c:	321000ef          	jal	4c9c <read>
+    if(cc < 0){
+    4180:	06054663          	bltz	a0,41ec <bigfile+0x106>
+    if(cc == 0)
+    4184:	c155                	beqz	a0,4228 <bigfile+0x142>
+    if(cc != SZ/2){
+    4186:	12c00793          	li	a5,300
+    418a:	06f51b63          	bne	a0,a5,4200 <bigfile+0x11a>
+    if(buf[0] != i/2 || buf[SZ/2-1] != i/2){
+    418e:	01f4d79b          	srliw	a5,s1,0x1f
+    4192:	9fa5                	addw	a5,a5,s1
+    4194:	4017d79b          	sraiw	a5,a5,0x1
+    4198:	00094703          	lbu	a4,0(s2)
+    419c:	06f71c63          	bne	a4,a5,4214 <bigfile+0x12e>
+    41a0:	12b94703          	lbu	a4,299(s2)
+    41a4:	06f71863          	bne	a4,a5,4214 <bigfile+0x12e>
+    total += cc;
+    41a8:	12c9899b          	addiw	s3,s3,300
+  for(i = 0; ; i++){
+    41ac:	2485                	addiw	s1,s1,1
+    cc = read(fd, buf, SZ/2);
+    41ae:	b7d9                	j	4174 <bigfile+0x8e>
+    printf("%s: cannot create bigfile", s);
+    41b0:	85d6                	mv	a1,s5
+    41b2:	00003517          	auipc	a0,0x3
+    41b6:	e2650513          	addi	a0,a0,-474 # 6fd8 <malloc+0x1e70>
+    41ba:	6fb000ef          	jal	50b4 <printf>
+    exit(1);
+    41be:	4505                	li	a0,1
+    41c0:	2c5000ef          	jal	4c84 <exit>
+      printf("%s: write bigfile failed\n", s);
+    41c4:	85d6                	mv	a1,s5
+    41c6:	00003517          	auipc	a0,0x3
+    41ca:	e3250513          	addi	a0,a0,-462 # 6ff8 <malloc+0x1e90>
+    41ce:	6e7000ef          	jal	50b4 <printf>
+      exit(1);
+    41d2:	4505                	li	a0,1
+    41d4:	2b1000ef          	jal	4c84 <exit>
+    printf("%s: cannot open bigfile\n", s);
+    41d8:	85d6                	mv	a1,s5
+    41da:	00003517          	auipc	a0,0x3
+    41de:	e3e50513          	addi	a0,a0,-450 # 7018 <malloc+0x1eb0>
+    41e2:	6d3000ef          	jal	50b4 <printf>
+    exit(1);
+    41e6:	4505                	li	a0,1
+    41e8:	29d000ef          	jal	4c84 <exit>
+      printf("%s: read bigfile failed\n", s);
+    41ec:	85d6                	mv	a1,s5
+    41ee:	00003517          	auipc	a0,0x3
+    41f2:	e4a50513          	addi	a0,a0,-438 # 7038 <malloc+0x1ed0>
+    41f6:	6bf000ef          	jal	50b4 <printf>
+      exit(1);
+    41fa:	4505                	li	a0,1
+    41fc:	289000ef          	jal	4c84 <exit>
+      printf("%s: short read bigfile\n", s);
+    4200:	85d6                	mv	a1,s5
+    4202:	00003517          	auipc	a0,0x3
+    4206:	e5650513          	addi	a0,a0,-426 # 7058 <malloc+0x1ef0>
+    420a:	6ab000ef          	jal	50b4 <printf>
+      exit(1);
+    420e:	4505                	li	a0,1
+    4210:	275000ef          	jal	4c84 <exit>
+      printf("%s: read bigfile wrong data\n", s);
+    4214:	85d6                	mv	a1,s5
+    4216:	00003517          	auipc	a0,0x3
+    421a:	e5a50513          	addi	a0,a0,-422 # 7070 <malloc+0x1f08>
+    421e:	697000ef          	jal	50b4 <printf>
+      exit(1);
+    4222:	4505                	li	a0,1
+    4224:	261000ef          	jal	4c84 <exit>
+  close(fd);
+    4228:	8552                	mv	a0,s4
+    422a:	283000ef          	jal	4cac <close>
+  if(total != N*SZ){
+    422e:	678d                	lui	a5,0x3
+    4230:	ee078793          	addi	a5,a5,-288 # 2ee0 <subdir+0x31e>
+    4234:	02f99163          	bne	s3,a5,4256 <bigfile+0x170>
+  unlink("bigfile.dat");
+    4238:	00003517          	auipc	a0,0x3
+    423c:	d9050513          	addi	a0,a0,-624 # 6fc8 <malloc+0x1e60>
+    4240:	295000ef          	jal	4cd4 <unlink>
+}
+    4244:	70e2                	ld	ra,56(sp)
+    4246:	7442                	ld	s0,48(sp)
+    4248:	74a2                	ld	s1,40(sp)
+    424a:	7902                	ld	s2,32(sp)
+    424c:	69e2                	ld	s3,24(sp)
+    424e:	6a42                	ld	s4,16(sp)
+    4250:	6aa2                	ld	s5,8(sp)
+    4252:	6121                	addi	sp,sp,64
+    4254:	8082                	ret
+    printf("%s: read bigfile wrong total\n", s);
+    4256:	85d6                	mv	a1,s5
+    4258:	00003517          	auipc	a0,0x3
+    425c:	e3850513          	addi	a0,a0,-456 # 7090 <malloc+0x1f28>
+    4260:	655000ef          	jal	50b4 <printf>
+    exit(1);
+    4264:	4505                	li	a0,1
+    4266:	21f000ef          	jal	4c84 <exit>
+
+000000000000426a <bigargtest>:
+{
+    426a:	7121                	addi	sp,sp,-448
+    426c:	ff06                	sd	ra,440(sp)
+    426e:	fb22                	sd	s0,432(sp)
+    4270:	f726                	sd	s1,424(sp)
+    4272:	0380                	addi	s0,sp,448
+    4274:	84aa                	mv	s1,a0
+  unlink("bigarg-ok");
+    4276:	00003517          	auipc	a0,0x3
+    427a:	e3a50513          	addi	a0,a0,-454 # 70b0 <malloc+0x1f48>
+    427e:	257000ef          	jal	4cd4 <unlink>
+  pid = fork();
+    4282:	1fb000ef          	jal	4c7c <fork>
+  if(pid == 0){
+    4286:	c915                	beqz	a0,42ba <bigargtest+0x50>
+  } else if(pid < 0){
+    4288:	08054a63          	bltz	a0,431c <bigargtest+0xb2>
+  wait(&xstatus);
+    428c:	fdc40513          	addi	a0,s0,-36
+    4290:	1fd000ef          	jal	4c8c <wait>
+  if(xstatus != 0)
+    4294:	fdc42503          	lw	a0,-36(s0)
+    4298:	ed41                	bnez	a0,4330 <bigargtest+0xc6>
+  fd = open("bigarg-ok", 0);
+    429a:	4581                	li	a1,0
+    429c:	00003517          	auipc	a0,0x3
+    42a0:	e1450513          	addi	a0,a0,-492 # 70b0 <malloc+0x1f48>
+    42a4:	221000ef          	jal	4cc4 <open>
+  if(fd < 0){
+    42a8:	08054663          	bltz	a0,4334 <bigargtest+0xca>
+  close(fd);
+    42ac:	201000ef          	jal	4cac <close>
+}
+    42b0:	70fa                	ld	ra,440(sp)
+    42b2:	745a                	ld	s0,432(sp)
+    42b4:	74ba                	ld	s1,424(sp)
+    42b6:	6139                	addi	sp,sp,448
+    42b8:	8082                	ret
+    memset(big, ' ', sizeof(big));
+    42ba:	19000613          	li	a2,400
+    42be:	02000593          	li	a1,32
+    42c2:	e4840513          	addi	a0,s0,-440
+    42c6:	7ac000ef          	jal	4a72 <memset>
+    big[sizeof(big)-1] = '\0';
+    42ca:	fc040ba3          	sb	zero,-41(s0)
+    for(i = 0; i < MAXARG-1; i++)
+    42ce:	00005797          	auipc	a5,0x5
+    42d2:	1c278793          	addi	a5,a5,450 # 9490 <args.1>
+    42d6:	00005697          	auipc	a3,0x5
+    42da:	2b268693          	addi	a3,a3,690 # 9588 <args.1+0xf8>
+      args[i] = big;
+    42de:	e4840713          	addi	a4,s0,-440
+    42e2:	e398                	sd	a4,0(a5)
+    for(i = 0; i < MAXARG-1; i++)
+    42e4:	07a1                	addi	a5,a5,8
+    42e6:	fed79ee3          	bne	a5,a3,42e2 <bigargtest+0x78>
+    args[MAXARG-1] = 0;
+    42ea:	00005597          	auipc	a1,0x5
+    42ee:	1a658593          	addi	a1,a1,422 # 9490 <args.1>
+    42f2:	0e05bc23          	sd	zero,248(a1)
+    exec("echo", args);
+    42f6:	00001517          	auipc	a0,0x1
+    42fa:	fa250513          	addi	a0,a0,-94 # 5298 <malloc+0x130>
+    42fe:	1bf000ef          	jal	4cbc <exec>
+    fd = open("bigarg-ok", O_CREATE);
+    4302:	20000593          	li	a1,512
+    4306:	00003517          	auipc	a0,0x3
+    430a:	daa50513          	addi	a0,a0,-598 # 70b0 <malloc+0x1f48>
+    430e:	1b7000ef          	jal	4cc4 <open>
+    close(fd);
+    4312:	19b000ef          	jal	4cac <close>
+    exit(0);
+    4316:	4501                	li	a0,0
+    4318:	16d000ef          	jal	4c84 <exit>
+    printf("%s: bigargtest: fork failed\n", s);
+    431c:	85a6                	mv	a1,s1
+    431e:	00003517          	auipc	a0,0x3
+    4322:	da250513          	addi	a0,a0,-606 # 70c0 <malloc+0x1f58>
+    4326:	58f000ef          	jal	50b4 <printf>
+    exit(1);
+    432a:	4505                	li	a0,1
+    432c:	159000ef          	jal	4c84 <exit>
+    exit(xstatus);
+    4330:	155000ef          	jal	4c84 <exit>
+    printf("%s: bigarg test failed!\n", s);
+    4334:	85a6                	mv	a1,s1
+    4336:	00003517          	auipc	a0,0x3
+    433a:	daa50513          	addi	a0,a0,-598 # 70e0 <malloc+0x1f78>
+    433e:	577000ef          	jal	50b4 <printf>
+    exit(1);
+    4342:	4505                	li	a0,1
+    4344:	141000ef          	jal	4c84 <exit>
+
+0000000000004348 <lazy_alloc>:
+{
+    4348:	1141                	addi	sp,sp,-16
+    434a:	e406                	sd	ra,8(sp)
+    434c:	e022                	sd	s0,0(sp)
+    434e:	0800                	addi	s0,sp,16
+  prev_end = sbrklazy(REGION_SZ);
+    4350:	40000537          	lui	a0,0x40000
+    4354:	113000ef          	jal	4c66 <sbrklazy>
+  if (prev_end == (char *) SBRK_ERROR) {
+    4358:	57fd                	li	a5,-1
+    435a:	02f50a63          	beq	a0,a5,438e <lazy_alloc+0x46>
+  for (i = prev_end + PGSIZE; i < new_end; i += 64 * PGSIZE)
+    435e:	6605                	lui	a2,0x1
+    4360:	962a                	add	a2,a2,a0
+    4362:	400017b7          	lui	a5,0x40001
+    4366:	00f50733          	add	a4,a0,a5
+    436a:	87b2                	mv	a5,a2
+    436c:	000406b7          	lui	a3,0x40
+    *(char **)i = i;
+    4370:	e39c                	sd	a5,0(a5)
+  for (i = prev_end + PGSIZE; i < new_end; i += 64 * PGSIZE)
+    4372:	97b6                	add	a5,a5,a3
+    4374:	fee79ee3          	bne	a5,a4,4370 <lazy_alloc+0x28>
+  for (i = prev_end + PGSIZE; i < new_end; i += 64 * PGSIZE) {
+    4378:	000406b7          	lui	a3,0x40
+    if (*(char **)i != i) {
+    437c:	621c                	ld	a5,0(a2)
+    437e:	02c79163          	bne	a5,a2,43a0 <lazy_alloc+0x58>
+  for (i = prev_end + PGSIZE; i < new_end; i += 64 * PGSIZE) {
+    4382:	9636                	add	a2,a2,a3
+    4384:	fee61ce3          	bne	a2,a4,437c <lazy_alloc+0x34>
+  exit(0);
+    4388:	4501                	li	a0,0
+    438a:	0fb000ef          	jal	4c84 <exit>
+    printf("sbrklazy() failed\n");
+    438e:	00003517          	auipc	a0,0x3
+    4392:	d7250513          	addi	a0,a0,-654 # 7100 <malloc+0x1f98>
+    4396:	51f000ef          	jal	50b4 <printf>
+    exit(1);
+    439a:	4505                	li	a0,1
+    439c:	0e9000ef          	jal	4c84 <exit>
+      printf("failed to read value from memory\n");
+    43a0:	00003517          	auipc	a0,0x3
+    43a4:	d7850513          	addi	a0,a0,-648 # 7118 <malloc+0x1fb0>
+    43a8:	50d000ef          	jal	50b4 <printf>
+      exit(1);
+    43ac:	4505                	li	a0,1
+    43ae:	0d7000ef          	jal	4c84 <exit>
+
+00000000000043b2 <lazy_unmap>:
+{
+    43b2:	7139                	addi	sp,sp,-64
+    43b4:	fc06                	sd	ra,56(sp)
+    43b6:	f822                	sd	s0,48(sp)
+    43b8:	0080                	addi	s0,sp,64
+  prev_end = sbrklazy(REGION_SZ);
+    43ba:	40000537          	lui	a0,0x40000
+    43be:	0a9000ef          	jal	4c66 <sbrklazy>
+  if (prev_end == (char*)SBRK_ERROR) {
+    43c2:	57fd                	li	a5,-1
+    43c4:	04f50663          	beq	a0,a5,4410 <lazy_unmap+0x5e>
+    43c8:	f426                	sd	s1,40(sp)
+    43ca:	f04a                	sd	s2,32(sp)
+    43cc:	ec4e                	sd	s3,24(sp)
+  for (i = prev_end + PGSIZE; i < new_end; i += PGSIZE * PGSIZE)
+    43ce:	6905                	lui	s2,0x1
+    43d0:	992a                	add	s2,s2,a0
+    43d2:	400017b7          	lui	a5,0x40001
+    43d6:	00f504b3          	add	s1,a0,a5
+    43da:	87ca                	mv	a5,s2
+    43dc:	01000737          	lui	a4,0x1000
+    *(char **)i = i;
+    43e0:	e39c                	sd	a5,0(a5)
+  for (i = prev_end + PGSIZE; i < new_end; i += PGSIZE * PGSIZE)
+    43e2:	97ba                	add	a5,a5,a4
+    43e4:	fe979ee3          	bne	a5,s1,43e0 <lazy_unmap+0x2e>
+  for (i = prev_end + PGSIZE; i < new_end; i += PGSIZE * PGSIZE) {
+    43e8:	010009b7          	lui	s3,0x1000
+    pid = fork();
+    43ec:	091000ef          	jal	4c7c <fork>
+    if (pid < 0) {
+    43f0:	02054c63          	bltz	a0,4428 <lazy_unmap+0x76>
+    } else if (pid == 0) {
+    43f4:	c139                	beqz	a0,443a <lazy_unmap+0x88>
+      wait(&status);
+    43f6:	fcc40513          	addi	a0,s0,-52
+    43fa:	093000ef          	jal	4c8c <wait>
+      if (status == 0) {
+    43fe:	fcc42783          	lw	a5,-52(s0)
+    4402:	c7a9                	beqz	a5,444c <lazy_unmap+0x9a>
+  for (i = prev_end + PGSIZE; i < new_end; i += PGSIZE * PGSIZE) {
+    4404:	994e                	add	s2,s2,s3
+    4406:	fe9913e3          	bne	s2,s1,43ec <lazy_unmap+0x3a>
+  exit(0);
+    440a:	4501                	li	a0,0
+    440c:	079000ef          	jal	4c84 <exit>
+    4410:	f426                	sd	s1,40(sp)
+    4412:	f04a                	sd	s2,32(sp)
+    4414:	ec4e                	sd	s3,24(sp)
+    printf("sbrklazy() failed\n");
+    4416:	00003517          	auipc	a0,0x3
+    441a:	cea50513          	addi	a0,a0,-790 # 7100 <malloc+0x1f98>
+    441e:	497000ef          	jal	50b4 <printf>
+    exit(1);
+    4422:	4505                	li	a0,1
+    4424:	061000ef          	jal	4c84 <exit>
+      printf("error forking\n");
+    4428:	00003517          	auipc	a0,0x3
+    442c:	d1850513          	addi	a0,a0,-744 # 7140 <malloc+0x1fd8>
+    4430:	485000ef          	jal	50b4 <printf>
+      exit(1);
+    4434:	4505                	li	a0,1
+    4436:	04f000ef          	jal	4c84 <exit>
+      sbrklazy(-1L * REGION_SZ);
+    443a:	c0000537          	lui	a0,0xc0000
+    443e:	029000ef          	jal	4c66 <sbrklazy>
+      *(char **)i = i;
+    4442:	01293023          	sd	s2,0(s2) # 1000 <badarg>
+      exit(0);
+    4446:	4501                	li	a0,0
+    4448:	03d000ef          	jal	4c84 <exit>
+        printf("memory not unmapped\n");
+    444c:	00003517          	auipc	a0,0x3
+    4450:	d0450513          	addi	a0,a0,-764 # 7150 <malloc+0x1fe8>
+    4454:	461000ef          	jal	50b4 <printf>
+        exit(1);
+    4458:	4505                	li	a0,1
+    445a:	02b000ef          	jal	4c84 <exit>
+
+000000000000445e <lazy_copy>:
+{
+    445e:	7159                	addi	sp,sp,-112
+    4460:	f486                	sd	ra,104(sp)
+    4462:	f0a2                	sd	s0,96(sp)
+    4464:	eca6                	sd	s1,88(sp)
+    4466:	e8ca                	sd	s2,80(sp)
+    4468:	e4ce                	sd	s3,72(sp)
+    446a:	e0d2                	sd	s4,64(sp)
+    446c:	fc56                	sd	s5,56(sp)
+    446e:	f85a                	sd	s6,48(sp)
+    4470:	1880                	addi	s0,sp,112
+    char *p = sbrk(0);
+    4472:	4501                	li	a0,0
+    4474:	7dc000ef          	jal	4c50 <sbrk>
+    4478:	84aa                	mv	s1,a0
+    sbrklazy(4*PGSIZE);
+    447a:	6511                	lui	a0,0x4
+    447c:	7ea000ef          	jal	4c66 <sbrklazy>
+    open(p + 8192, 0);
+    4480:	4581                	li	a1,0
+    4482:	6509                	lui	a0,0x2
+    4484:	9526                	add	a0,a0,s1
+    4486:	03f000ef          	jal	4cc4 <open>
+    void *xx = sbrk(0);
+    448a:	4501                	li	a0,0
+    448c:	7c4000ef          	jal	4c50 <sbrk>
+    4490:	84aa                	mv	s1,a0
+    void *ret = sbrk(-(((uint64) xx)+1));
+    4492:	fff54513          	not	a0,a0
+    4496:	2501                	sext.w	a0,a0
+    4498:	7b8000ef          	jal	4c50 <sbrk>
+    if(ret != xx){
+    449c:	00a48c63          	beq	s1,a0,44b4 <lazy_copy+0x56>
+    44a0:	85aa                	mv	a1,a0
+      printf("sbrk(sbrk(0)+1) returned %p, not old sz\n", ret);
+    44a2:	00003517          	auipc	a0,0x3
+    44a6:	cc650513          	addi	a0,a0,-826 # 7168 <malloc+0x2000>
+    44aa:	40b000ef          	jal	50b4 <printf>
+      exit(1);
+    44ae:	4505                	li	a0,1
+    44b0:	7d4000ef          	jal	4c84 <exit>
+  unsigned long bad[] = {
+    44b4:	00003797          	auipc	a5,0x3
+    44b8:	23478793          	addi	a5,a5,564 # 76e8 <malloc+0x2580>
+    44bc:	7fa8                	ld	a0,120(a5)
+    44be:	63cc                	ld	a1,128(a5)
+    44c0:	67d0                	ld	a2,136(a5)
+    44c2:	6bd4                	ld	a3,144(a5)
+    44c4:	6fd8                	ld	a4,152(a5)
+    44c6:	73dc                	ld	a5,160(a5)
+    44c8:	f8a43823          	sd	a0,-112(s0)
+    44cc:	f8b43c23          	sd	a1,-104(s0)
+    44d0:	fac43023          	sd	a2,-96(s0)
+    44d4:	fad43423          	sd	a3,-88(s0)
+    44d8:	fae43823          	sd	a4,-80(s0)
+    44dc:	faf43c23          	sd	a5,-72(s0)
+  for(int i = 0; i < sizeof(bad)/sizeof(bad[0]); i++){
+    44e0:	f9040913          	addi	s2,s0,-112
+    44e4:	fc040b13          	addi	s6,s0,-64
+    int fd = open("README", 0);
+    44e8:	00001a17          	auipc	s4,0x1
+    44ec:	f88a0a13          	addi	s4,s4,-120 # 5470 <malloc+0x308>
+    fd = open("junk", O_CREATE|O_RDWR|O_TRUNC);
+    44f0:	00001a97          	auipc	s5,0x1
+    44f4:	e90a8a93          	addi	s5,s5,-368 # 5380 <malloc+0x218>
+    int fd = open("README", 0);
+    44f8:	4581                	li	a1,0
+    44fa:	8552                	mv	a0,s4
+    44fc:	7c8000ef          	jal	4cc4 <open>
+    4500:	84aa                	mv	s1,a0
+    if(fd < 0) { printf("cannot open README\n"); exit(1); }
+    4502:	04054663          	bltz	a0,454e <lazy_copy+0xf0>
+    if(read(fd, (char*)bad[i], 512) >= 0) { printf("read succeeded\n");  exit(1); }
+    4506:	00093983          	ld	s3,0(s2)
+    450a:	20000613          	li	a2,512
+    450e:	85ce                	mv	a1,s3
+    4510:	78c000ef          	jal	4c9c <read>
+    4514:	04055663          	bgez	a0,4560 <lazy_copy+0x102>
+    close(fd);
+    4518:	8526                	mv	a0,s1
+    451a:	792000ef          	jal	4cac <close>
+    fd = open("junk", O_CREATE|O_RDWR|O_TRUNC);
+    451e:	60200593          	li	a1,1538
+    4522:	8556                	mv	a0,s5
+    4524:	7a0000ef          	jal	4cc4 <open>
+    4528:	84aa                	mv	s1,a0
+    if(fd < 0) { printf("cannot open junk\n"); exit(1); }
+    452a:	04054463          	bltz	a0,4572 <lazy_copy+0x114>
+    if(write(fd, (char*)bad[i], 512) >= 0) { printf("write succeeded\n"); exit(1); }
+    452e:	20000613          	li	a2,512
+    4532:	85ce                	mv	a1,s3
+    4534:	770000ef          	jal	4ca4 <write>
+    4538:	04055663          	bgez	a0,4584 <lazy_copy+0x126>
+    close(fd);
+    453c:	8526                	mv	a0,s1
+    453e:	76e000ef          	jal	4cac <close>
+  for(int i = 0; i < sizeof(bad)/sizeof(bad[0]); i++){
+    4542:	0921                	addi	s2,s2,8
+    4544:	fb691ae3          	bne	s2,s6,44f8 <lazy_copy+0x9a>
+  exit(0);
+    4548:	4501                	li	a0,0
+    454a:	73a000ef          	jal	4c84 <exit>
+    if(fd < 0) { printf("cannot open README\n"); exit(1); }
+    454e:	00003517          	auipc	a0,0x3
+    4552:	c4a50513          	addi	a0,a0,-950 # 7198 <malloc+0x2030>
+    4556:	35f000ef          	jal	50b4 <printf>
+    455a:	4505                	li	a0,1
+    455c:	728000ef          	jal	4c84 <exit>
+    if(read(fd, (char*)bad[i], 512) >= 0) { printf("read succeeded\n");  exit(1); }
+    4560:	00003517          	auipc	a0,0x3
+    4564:	c5050513          	addi	a0,a0,-944 # 71b0 <malloc+0x2048>
+    4568:	34d000ef          	jal	50b4 <printf>
+    456c:	4505                	li	a0,1
+    456e:	716000ef          	jal	4c84 <exit>
+    if(fd < 0) { printf("cannot open junk\n"); exit(1); }
+    4572:	00003517          	auipc	a0,0x3
+    4576:	c4e50513          	addi	a0,a0,-946 # 71c0 <malloc+0x2058>
+    457a:	33b000ef          	jal	50b4 <printf>
+    457e:	4505                	li	a0,1
+    4580:	704000ef          	jal	4c84 <exit>
+    if(write(fd, (char*)bad[i], 512) >= 0) { printf("write succeeded\n"); exit(1); }
+    4584:	00003517          	auipc	a0,0x3
+    4588:	c5450513          	addi	a0,a0,-940 # 71d8 <malloc+0x2070>
+    458c:	329000ef          	jal	50b4 <printf>
+    4590:	4505                	li	a0,1
+    4592:	6f2000ef          	jal	4c84 <exit>
+
+0000000000004596 <fsfull>:
+{
+    4596:	7135                	addi	sp,sp,-160
+    4598:	ed06                	sd	ra,152(sp)
+    459a:	e922                	sd	s0,144(sp)
+    459c:	e526                	sd	s1,136(sp)
+    459e:	e14a                	sd	s2,128(sp)
+    45a0:	fcce                	sd	s3,120(sp)
+    45a2:	f8d2                	sd	s4,112(sp)
+    45a4:	f4d6                	sd	s5,104(sp)
+    45a6:	f0da                	sd	s6,96(sp)
+    45a8:	ecde                	sd	s7,88(sp)
+    45aa:	e8e2                	sd	s8,80(sp)
+    45ac:	e4e6                	sd	s9,72(sp)
+    45ae:	e0ea                	sd	s10,64(sp)
+    45b0:	1100                	addi	s0,sp,160
+  printf("fsfull test\n");
+    45b2:	00003517          	auipc	a0,0x3
+    45b6:	c3e50513          	addi	a0,a0,-962 # 71f0 <malloc+0x2088>
+    45ba:	2fb000ef          	jal	50b4 <printf>
+  for(nfiles = 0; ; nfiles++){
+    45be:	4481                	li	s1,0
+    name[0] = 'f';
+    45c0:	06600d13          	li	s10,102
+    name[1] = '0' + nfiles / 1000;
+    45c4:	3e800c13          	li	s8,1000
+    name[2] = '0' + (nfiles % 1000) / 100;
+    45c8:	06400b93          	li	s7,100
+    name[3] = '0' + (nfiles % 100) / 10;
+    45cc:	4b29                	li	s6,10
+    printf("writing %s\n", name);
+    45ce:	00003c97          	auipc	s9,0x3
+    45d2:	c32c8c93          	addi	s9,s9,-974 # 7200 <malloc+0x2098>
+    name[0] = 'f';
+    45d6:	f7a40023          	sb	s10,-160(s0)
+    name[1] = '0' + nfiles / 1000;
+    45da:	0384c7bb          	divw	a5,s1,s8
+    45de:	0307879b          	addiw	a5,a5,48
+    45e2:	f6f400a3          	sb	a5,-159(s0)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    45e6:	0384e7bb          	remw	a5,s1,s8
+    45ea:	0377c7bb          	divw	a5,a5,s7
+    45ee:	0307879b          	addiw	a5,a5,48
+    45f2:	f6f40123          	sb	a5,-158(s0)
+    name[3] = '0' + (nfiles % 100) / 10;
+    45f6:	0374e7bb          	remw	a5,s1,s7
+    45fa:	0367c7bb          	divw	a5,a5,s6
+    45fe:	0307879b          	addiw	a5,a5,48
+    4602:	f6f401a3          	sb	a5,-157(s0)
+    name[4] = '0' + (nfiles % 10);
+    4606:	0364e7bb          	remw	a5,s1,s6
+    460a:	0307879b          	addiw	a5,a5,48
+    460e:	f6f40223          	sb	a5,-156(s0)
+    name[5] = '\0';
+    4612:	f60402a3          	sb	zero,-155(s0)
+    printf("writing %s\n", name);
+    4616:	f6040593          	addi	a1,s0,-160
+    461a:	8566                	mv	a0,s9
+    461c:	299000ef          	jal	50b4 <printf>
+    int fd = open(name, O_CREATE|O_RDWR);
+    4620:	20200593          	li	a1,514
+    4624:	f6040513          	addi	a0,s0,-160
+    4628:	69c000ef          	jal	4cc4 <open>
+    462c:	892a                	mv	s2,a0
+    if(fd < 0){
+    462e:	08055f63          	bgez	a0,46cc <fsfull+0x136>
+      printf("open %s failed\n", name);
+    4632:	f6040593          	addi	a1,s0,-160
+    4636:	00003517          	auipc	a0,0x3
+    463a:	bda50513          	addi	a0,a0,-1062 # 7210 <malloc+0x20a8>
+    463e:	277000ef          	jal	50b4 <printf>
+  while(nfiles >= 0){
+    4642:	0604c163          	bltz	s1,46a4 <fsfull+0x10e>
+    name[0] = 'f';
+    4646:	06600b13          	li	s6,102
+    name[1] = '0' + nfiles / 1000;
+    464a:	3e800a13          	li	s4,1000
+    name[2] = '0' + (nfiles % 1000) / 100;
+    464e:	06400993          	li	s3,100
+    name[3] = '0' + (nfiles % 100) / 10;
+    4652:	4929                	li	s2,10
+  while(nfiles >= 0){
+    4654:	5afd                	li	s5,-1
+    name[0] = 'f';
+    4656:	f7640023          	sb	s6,-160(s0)
+    name[1] = '0' + nfiles / 1000;
+    465a:	0344c7bb          	divw	a5,s1,s4
+    465e:	0307879b          	addiw	a5,a5,48
+    4662:	f6f400a3          	sb	a5,-159(s0)
+    name[2] = '0' + (nfiles % 1000) / 100;
+    4666:	0344e7bb          	remw	a5,s1,s4
+    466a:	0337c7bb          	divw	a5,a5,s3
+    466e:	0307879b          	addiw	a5,a5,48
+    4672:	f6f40123          	sb	a5,-158(s0)
+    name[3] = '0' + (nfiles % 100) / 10;
+    4676:	0334e7bb          	remw	a5,s1,s3
+    467a:	0327c7bb          	divw	a5,a5,s2
+    467e:	0307879b          	addiw	a5,a5,48
+    4682:	f6f401a3          	sb	a5,-157(s0)
+    name[4] = '0' + (nfiles % 10);
+    4686:	0324e7bb          	remw	a5,s1,s2
+    468a:	0307879b          	addiw	a5,a5,48
+    468e:	f6f40223          	sb	a5,-156(s0)
+    name[5] = '\0';
+    4692:	f60402a3          	sb	zero,-155(s0)
+    unlink(name);
+    4696:	f6040513          	addi	a0,s0,-160
+    469a:	63a000ef          	jal	4cd4 <unlink>
+    nfiles--;
+    469e:	34fd                	addiw	s1,s1,-1
+  while(nfiles >= 0){
+    46a0:	fb549be3          	bne	s1,s5,4656 <fsfull+0xc0>
+  printf("fsfull test finished\n");
+    46a4:	00003517          	auipc	a0,0x3
+    46a8:	b8c50513          	addi	a0,a0,-1140 # 7230 <malloc+0x20c8>
+    46ac:	209000ef          	jal	50b4 <printf>
+}
+    46b0:	60ea                	ld	ra,152(sp)
+    46b2:	644a                	ld	s0,144(sp)
+    46b4:	64aa                	ld	s1,136(sp)
+    46b6:	690a                	ld	s2,128(sp)
+    46b8:	79e6                	ld	s3,120(sp)
+    46ba:	7a46                	ld	s4,112(sp)
+    46bc:	7aa6                	ld	s5,104(sp)
+    46be:	7b06                	ld	s6,96(sp)
+    46c0:	6be6                	ld	s7,88(sp)
+    46c2:	6c46                	ld	s8,80(sp)
+    46c4:	6ca6                	ld	s9,72(sp)
+    46c6:	6d06                	ld	s10,64(sp)
+    46c8:	610d                	addi	sp,sp,160
+    46ca:	8082                	ret
+    int total = 0;
+    46cc:	4981                	li	s3,0
+      int cc = write(fd, buf, BSIZE);
+    46ce:	00008a97          	auipc	s5,0x8
+    46d2:	5daa8a93          	addi	s5,s5,1498 # cca8 <buf>
+      if(cc < BSIZE)
+    46d6:	3ff00a13          	li	s4,1023
+      int cc = write(fd, buf, BSIZE);
+    46da:	40000613          	li	a2,1024
+    46de:	85d6                	mv	a1,s5
+    46e0:	854a                	mv	a0,s2
+    46e2:	5c2000ef          	jal	4ca4 <write>
+      if(cc < BSIZE)
+    46e6:	00aa5563          	bge	s4,a0,46f0 <fsfull+0x15a>
+      total += cc;
+    46ea:	00a989bb          	addw	s3,s3,a0
+    while(1){
+    46ee:	b7f5                	j	46da <fsfull+0x144>
+    printf("wrote %d bytes\n", total);
+    46f0:	85ce                	mv	a1,s3
+    46f2:	00003517          	auipc	a0,0x3
+    46f6:	b2e50513          	addi	a0,a0,-1234 # 7220 <malloc+0x20b8>
+    46fa:	1bb000ef          	jal	50b4 <printf>
+    close(fd);
+    46fe:	854a                	mv	a0,s2
+    4700:	5ac000ef          	jal	4cac <close>
+    if(total == 0)
+    4704:	f2098fe3          	beqz	s3,4642 <fsfull+0xac>
+  for(nfiles = 0; ; nfiles++){
+    4708:	2485                	addiw	s1,s1,1
+    470a:	b5f1                	j	45d6 <fsfull+0x40>
+
+000000000000470c <run>:
+//
+
+// run each test in its own process. run returns 1 if child's exit()
+// indicates success.
+int
+run(void f(char *), char *s) {
+    470c:	7179                	addi	sp,sp,-48
+    470e:	f406                	sd	ra,40(sp)
+    4710:	f022                	sd	s0,32(sp)
+    4712:	ec26                	sd	s1,24(sp)
+    4714:	e84a                	sd	s2,16(sp)
+    4716:	1800                	addi	s0,sp,48
+    4718:	84aa                	mv	s1,a0
+    471a:	892e                	mv	s2,a1
+  int pid;
+  int xstatus;
+
+  printf("test %s: ", s);
+    471c:	00003517          	auipc	a0,0x3
+    4720:	b2c50513          	addi	a0,a0,-1236 # 7248 <malloc+0x20e0>
+    4724:	191000ef          	jal	50b4 <printf>
+  if((pid = fork()) < 0) {
+    4728:	554000ef          	jal	4c7c <fork>
+    472c:	02054a63          	bltz	a0,4760 <run+0x54>
+    printf("runtest: fork error\n");
+    exit(1);
+  }
+  if(pid == 0) {
+    4730:	c129                	beqz	a0,4772 <run+0x66>
+    f(s);
+    exit(0);
+  } else {
+    wait(&xstatus);
+    4732:	fdc40513          	addi	a0,s0,-36
+    4736:	556000ef          	jal	4c8c <wait>
+    if(xstatus != 0) 
+    473a:	fdc42783          	lw	a5,-36(s0)
+    473e:	cf9d                	beqz	a5,477c <run+0x70>
+      printf("FAILED\n");
+    4740:	00003517          	auipc	a0,0x3
+    4744:	b3050513          	addi	a0,a0,-1232 # 7270 <malloc+0x2108>
+    4748:	16d000ef          	jal	50b4 <printf>
+    else
+      printf("OK\n");
+    return xstatus == 0;
+    474c:	fdc42503          	lw	a0,-36(s0)
+  }
+}
+    4750:	00153513          	seqz	a0,a0
+    4754:	70a2                	ld	ra,40(sp)
+    4756:	7402                	ld	s0,32(sp)
+    4758:	64e2                	ld	s1,24(sp)
+    475a:	6942                	ld	s2,16(sp)
+    475c:	6145                	addi	sp,sp,48
+    475e:	8082                	ret
+    printf("runtest: fork error\n");
+    4760:	00003517          	auipc	a0,0x3
+    4764:	af850513          	addi	a0,a0,-1288 # 7258 <malloc+0x20f0>
+    4768:	14d000ef          	jal	50b4 <printf>
+    exit(1);
+    476c:	4505                	li	a0,1
+    476e:	516000ef          	jal	4c84 <exit>
+    f(s);
+    4772:	854a                	mv	a0,s2
+    4774:	9482                	jalr	s1
+    exit(0);
+    4776:	4501                	li	a0,0
+    4778:	50c000ef          	jal	4c84 <exit>
+      printf("OK\n");
+    477c:	00003517          	auipc	a0,0x3
+    4780:	afc50513          	addi	a0,a0,-1284 # 7278 <malloc+0x2110>
+    4784:	131000ef          	jal	50b4 <printf>
+    4788:	b7d1                	j	474c <run+0x40>
+
+000000000000478a <runtests>:
+
+int
+runtests(struct test *tests, char *justone, int continuous) {
+    478a:	7139                	addi	sp,sp,-64
+    478c:	fc06                	sd	ra,56(sp)
+    478e:	f822                	sd	s0,48(sp)
+    4790:	f426                	sd	s1,40(sp)
+    4792:	ec4e                	sd	s3,24(sp)
+    4794:	0080                	addi	s0,sp,64
+    4796:	84aa                	mv	s1,a0
+  int ntests = 0;
+  for (struct test *t = tests; t->s != 0; t++) {
+    4798:	6508                	ld	a0,8(a0)
+    479a:	cd39                	beqz	a0,47f8 <runtests+0x6e>
+    479c:	f04a                	sd	s2,32(sp)
+    479e:	e852                	sd	s4,16(sp)
+    47a0:	e456                	sd	s5,8(sp)
+    47a2:	892e                	mv	s2,a1
+    47a4:	8a32                	mv	s4,a2
+  int ntests = 0;
+    47a6:	4981                	li	s3,0
+    if((justone == 0) || strcmp(t->s, justone) == 0) {
+      ntests++;
+      if(!run(t->f, t->s)){
+        if(continuous != 2){
+    47a8:	4a89                	li	s5,2
+    47aa:	a021                	j	47b2 <runtests+0x28>
+  for (struct test *t = tests; t->s != 0; t++) {
+    47ac:	04c1                	addi	s1,s1,16
+    47ae:	6488                	ld	a0,8(s1)
+    47b0:	c915                	beqz	a0,47e4 <runtests+0x5a>
+    if((justone == 0) || strcmp(t->s, justone) == 0) {
+    47b2:	00090663          	beqz	s2,47be <runtests+0x34>
+    47b6:	85ca                	mv	a1,s2
+    47b8:	264000ef          	jal	4a1c <strcmp>
+    47bc:	f965                	bnez	a0,47ac <runtests+0x22>
+      ntests++;
+    47be:	2985                	addiw	s3,s3,1 # 1000001 <base+0xff0359>
+      if(!run(t->f, t->s)){
+    47c0:	648c                	ld	a1,8(s1)
+    47c2:	6088                	ld	a0,0(s1)
+    47c4:	f49ff0ef          	jal	470c <run>
+    47c8:	f175                	bnez	a0,47ac <runtests+0x22>
+        if(continuous != 2){
+    47ca:	ff5a01e3          	beq	s4,s5,47ac <runtests+0x22>
+          printf("SOME TESTS FAILED\n");
+    47ce:	00003517          	auipc	a0,0x3
+    47d2:	ab250513          	addi	a0,a0,-1358 # 7280 <malloc+0x2118>
+    47d6:	0df000ef          	jal	50b4 <printf>
+          return -1;
+    47da:	59fd                	li	s3,-1
+    47dc:	7902                	ld	s2,32(sp)
+    47de:	6a42                	ld	s4,16(sp)
+    47e0:	6aa2                	ld	s5,8(sp)
+    47e2:	a021                	j	47ea <runtests+0x60>
+    47e4:	7902                	ld	s2,32(sp)
+    47e6:	6a42                	ld	s4,16(sp)
+    47e8:	6aa2                	ld	s5,8(sp)
+        }
+      }
+    }
+  }
+  return ntests;
+}
+    47ea:	854e                	mv	a0,s3
+    47ec:	70e2                	ld	ra,56(sp)
+    47ee:	7442                	ld	s0,48(sp)
+    47f0:	74a2                	ld	s1,40(sp)
+    47f2:	69e2                	ld	s3,24(sp)
+    47f4:	6121                	addi	sp,sp,64
+    47f6:	8082                	ret
+  return ntests;
+    47f8:	4981                	li	s3,0
+    47fa:	bfc5                	j	47ea <runtests+0x60>
+
+00000000000047fc <countfree>:
+
+
+// use sbrk() to count how many free physical memory pages there are.
+int
+countfree()
+{
+    47fc:	7179                	addi	sp,sp,-48
+    47fe:	f406                	sd	ra,40(sp)
+    4800:	f022                	sd	s0,32(sp)
+    4802:	ec26                	sd	s1,24(sp)
+    4804:	e84a                	sd	s2,16(sp)
+    4806:	e44e                	sd	s3,8(sp)
+    4808:	1800                	addi	s0,sp,48
+  int n = 0;
+  uint64 sz0 = (uint64)sbrk(0);
+    480a:	4501                	li	a0,0
+    480c:	444000ef          	jal	4c50 <sbrk>
+    4810:	89aa                	mv	s3,a0
+  int n = 0;
+    4812:	4481                	li	s1,0
+  while(1){
+    char *a = sbrk(PGSIZE);
+    if(a == SBRK_ERROR){
+    4814:	597d                	li	s2,-1
+    4816:	a011                	j	481a <countfree+0x1e>
+      break;
+    }
+    n += 1;
+    4818:	2485                	addiw	s1,s1,1
+    char *a = sbrk(PGSIZE);
+    481a:	6505                	lui	a0,0x1
+    481c:	434000ef          	jal	4c50 <sbrk>
+    if(a == SBRK_ERROR){
+    4820:	ff251ce3          	bne	a0,s2,4818 <countfree+0x1c>
+  }
+  sbrk(-((uint64)sbrk(0) - sz0));  
+    4824:	4501                	li	a0,0
+    4826:	42a000ef          	jal	4c50 <sbrk>
+    482a:	40a9853b          	subw	a0,s3,a0
+    482e:	422000ef          	jal	4c50 <sbrk>
+  return n;
+}
+    4832:	8526                	mv	a0,s1
+    4834:	70a2                	ld	ra,40(sp)
+    4836:	7402                	ld	s0,32(sp)
+    4838:	64e2                	ld	s1,24(sp)
+    483a:	6942                	ld	s2,16(sp)
+    483c:	69a2                	ld	s3,8(sp)
+    483e:	6145                	addi	sp,sp,48
+    4840:	8082                	ret
+
+0000000000004842 <drivetests>:
+
+int
+drivetests(int quick, int continuous, char *justone) {
+    4842:	7159                	addi	sp,sp,-112
+    4844:	f486                	sd	ra,104(sp)
+    4846:	f0a2                	sd	s0,96(sp)
+    4848:	eca6                	sd	s1,88(sp)
+    484a:	e8ca                	sd	s2,80(sp)
+    484c:	e4ce                	sd	s3,72(sp)
+    484e:	e0d2                	sd	s4,64(sp)
+    4850:	fc56                	sd	s5,56(sp)
+    4852:	f85a                	sd	s6,48(sp)
+    4854:	f45e                	sd	s7,40(sp)
+    4856:	f062                	sd	s8,32(sp)
+    4858:	ec66                	sd	s9,24(sp)
+    485a:	e86a                	sd	s10,16(sp)
+    485c:	e46e                	sd	s11,8(sp)
+    485e:	1880                	addi	s0,sp,112
+    4860:	8aaa                	mv	s5,a0
+    4862:	89ae                	mv	s3,a1
+    4864:	8a32                	mv	s4,a2
+  do {
+    printf("usertests starting\n");
+    4866:	00003c17          	auipc	s8,0x3
+    486a:	a32c0c13          	addi	s8,s8,-1486 # 7298 <malloc+0x2130>
+    int free0 = countfree();
+    int free1 = 0;
+    int ntests = 0;
+    int n;
+    n = runtests(quicktests, justone, continuous);
+    486e:	00004b97          	auipc	s7,0x4
+    4872:	7a2b8b93          	addi	s7,s7,1954 # 9010 <quicktests>
+    if (n < 0) {
+      if(continuous != 2) {
+    4876:	4b09                	li	s6,2
+      ntests += n;
+    }
+    if(!quick) {
+      if (justone == 0)
+        printf("usertests slow tests starting\n");
+      n = runtests(slowtests, justone, continuous);
+    4878:	00005c97          	auipc	s9,0x5
+    487c:	b98c8c93          	addi	s9,s9,-1128 # 9410 <slowtests>
+        printf("usertests slow tests starting\n");
+    4880:	00003d97          	auipc	s11,0x3
+    4884:	a30d8d93          	addi	s11,s11,-1488 # 72b0 <malloc+0x2148>
+      } else {
+        ntests += n;
+      }
+    }
+    if((free1 = countfree()) < free0) {
+      printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
+    4888:	00003d17          	auipc	s10,0x3
+    488c:	a48d0d13          	addi	s10,s10,-1464 # 72d0 <malloc+0x2168>
+    4890:	a025                	j	48b8 <drivetests+0x76>
+      if(continuous != 2) {
+    4892:	09699063          	bne	s3,s6,4912 <drivetests+0xd0>
+    int ntests = 0;
+    4896:	4481                	li	s1,0
+    4898:	a835                	j	48d4 <drivetests+0x92>
+        printf("usertests slow tests starting\n");
+    489a:	856e                	mv	a0,s11
+    489c:	019000ef          	jal	50b4 <printf>
+    48a0:	a835                	j	48dc <drivetests+0x9a>
+        if(continuous != 2) {
+    48a2:	07699a63          	bne	s3,s6,4916 <drivetests+0xd4>
+    if((free1 = countfree()) < free0) {
+    48a6:	f57ff0ef          	jal	47fc <countfree>
+    48aa:	05254263          	blt	a0,s2,48ee <drivetests+0xac>
+      if(continuous != 2) {
+        return 1;
+      }
+    }
+    if (justone != 0 && ntests == 0) {
+    48ae:	000a0363          	beqz	s4,48b4 <drivetests+0x72>
+    48b2:	c8a1                	beqz	s1,4902 <drivetests+0xc0>
+      printf("NO TESTS EXECUTED\n");
+      return 1;
+    }
+  } while(continuous);
+    48b4:	06098563          	beqz	s3,491e <drivetests+0xdc>
+    printf("usertests starting\n");
+    48b8:	8562                	mv	a0,s8
+    48ba:	7fa000ef          	jal	50b4 <printf>
+    int free0 = countfree();
+    48be:	f3fff0ef          	jal	47fc <countfree>
+    48c2:	892a                	mv	s2,a0
+    n = runtests(quicktests, justone, continuous);
+    48c4:	864e                	mv	a2,s3
+    48c6:	85d2                	mv	a1,s4
+    48c8:	855e                	mv	a0,s7
+    48ca:	ec1ff0ef          	jal	478a <runtests>
+    48ce:	84aa                	mv	s1,a0
+    if (n < 0) {
+    48d0:	fc0541e3          	bltz	a0,4892 <drivetests+0x50>
+    if(!quick) {
+    48d4:	fc0a99e3          	bnez	s5,48a6 <drivetests+0x64>
+      if (justone == 0)
+    48d8:	fc0a01e3          	beqz	s4,489a <drivetests+0x58>
+      n = runtests(slowtests, justone, continuous);
+    48dc:	864e                	mv	a2,s3
+    48de:	85d2                	mv	a1,s4
+    48e0:	8566                	mv	a0,s9
+    48e2:	ea9ff0ef          	jal	478a <runtests>
+      if (n < 0) {
+    48e6:	fa054ee3          	bltz	a0,48a2 <drivetests+0x60>
+        ntests += n;
+    48ea:	9ca9                	addw	s1,s1,a0
+    48ec:	bf6d                	j	48a6 <drivetests+0x64>
+      printf("FAILED -- lost some free pages %d (out of %d)\n", free1, free0);
+    48ee:	864a                	mv	a2,s2
+    48f0:	85aa                	mv	a1,a0
+    48f2:	856a                	mv	a0,s10
+    48f4:	7c0000ef          	jal	50b4 <printf>
+      if(continuous != 2) {
+    48f8:	03699163          	bne	s3,s6,491a <drivetests+0xd8>
+    if (justone != 0 && ntests == 0) {
+    48fc:	fa0a1be3          	bnez	s4,48b2 <drivetests+0x70>
+    4900:	bf65                	j	48b8 <drivetests+0x76>
+      printf("NO TESTS EXECUTED\n");
+    4902:	00003517          	auipc	a0,0x3
+    4906:	9fe50513          	addi	a0,a0,-1538 # 7300 <malloc+0x2198>
+    490a:	7aa000ef          	jal	50b4 <printf>
+      return 1;
+    490e:	4505                	li	a0,1
+    4910:	a801                	j	4920 <drivetests+0xde>
+        return 1;
+    4912:	4505                	li	a0,1
+    4914:	a031                	j	4920 <drivetests+0xde>
+          return 1;
+    4916:	4505                	li	a0,1
+    4918:	a021                	j	4920 <drivetests+0xde>
+        return 1;
+    491a:	4505                	li	a0,1
+    491c:	a011                	j	4920 <drivetests+0xde>
+  return 0;
+    491e:	854e                	mv	a0,s3
+}
+    4920:	70a6                	ld	ra,104(sp)
+    4922:	7406                	ld	s0,96(sp)
+    4924:	64e6                	ld	s1,88(sp)
+    4926:	6946                	ld	s2,80(sp)
+    4928:	69a6                	ld	s3,72(sp)
+    492a:	6a06                	ld	s4,64(sp)
+    492c:	7ae2                	ld	s5,56(sp)
+    492e:	7b42                	ld	s6,48(sp)
+    4930:	7ba2                	ld	s7,40(sp)
+    4932:	7c02                	ld	s8,32(sp)
+    4934:	6ce2                	ld	s9,24(sp)
+    4936:	6d42                	ld	s10,16(sp)
+    4938:	6da2                	ld	s11,8(sp)
+    493a:	6165                	addi	sp,sp,112
+    493c:	8082                	ret
+
+000000000000493e <main>:
+
+int
+main(int argc, char *argv[])
+{
+    493e:	1101                	addi	sp,sp,-32
+    4940:	ec06                	sd	ra,24(sp)
+    4942:	e822                	sd	s0,16(sp)
+    4944:	e426                	sd	s1,8(sp)
+    4946:	e04a                	sd	s2,0(sp)
+    4948:	1000                	addi	s0,sp,32
+    494a:	84aa                	mv	s1,a0
+  int continuous = 0;
+  int quick = 0;
+  char *justone = 0;
+
+  if(argc == 2 && strcmp(argv[1], "-q") == 0){
+    494c:	4789                	li	a5,2
+    494e:	00f50e63          	beq	a0,a5,496a <main+0x2c>
+    continuous = 1;
+  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
+    continuous = 2;
+  } else if(argc == 2 && argv[1][0] != '-'){
+    justone = argv[1];
+  } else if(argc > 1){
+    4952:	4785                	li	a5,1
+    4954:	06a7c663          	blt	a5,a0,49c0 <main+0x82>
+  char *justone = 0;
+    4958:	4601                	li	a2,0
+  int quick = 0;
+    495a:	4501                	li	a0,0
+  int continuous = 0;
+    495c:	4581                	li	a1,0
+    printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
+    exit(1);
+  }
+  if (drivetests(quick, continuous, justone)) {
+    495e:	ee5ff0ef          	jal	4842 <drivetests>
+    4962:	cd35                	beqz	a0,49de <main+0xa0>
+    exit(1);
+    4964:	4505                	li	a0,1
+    4966:	31e000ef          	jal	4c84 <exit>
+    496a:	892e                	mv	s2,a1
+  if(argc == 2 && strcmp(argv[1], "-q") == 0){
+    496c:	00003597          	auipc	a1,0x3
+    4970:	9ac58593          	addi	a1,a1,-1620 # 7318 <malloc+0x21b0>
+    4974:	00893503          	ld	a0,8(s2)
+    4978:	0a4000ef          	jal	4a1c <strcmp>
+    497c:	85aa                	mv	a1,a0
+    497e:	e501                	bnez	a0,4986 <main+0x48>
+  char *justone = 0;
+    4980:	4601                	li	a2,0
+    quick = 1;
+    4982:	4505                	li	a0,1
+    4984:	bfe9                	j	495e <main+0x20>
+  } else if(argc == 2 && strcmp(argv[1], "-c") == 0){
+    4986:	00003597          	auipc	a1,0x3
+    498a:	99a58593          	addi	a1,a1,-1638 # 7320 <malloc+0x21b8>
+    498e:	00893503          	ld	a0,8(s2)
+    4992:	08a000ef          	jal	4a1c <strcmp>
+    4996:	cd15                	beqz	a0,49d2 <main+0x94>
+  } else if(argc == 2 && strcmp(argv[1], "-C") == 0){
+    4998:	00003597          	auipc	a1,0x3
+    499c:	9d858593          	addi	a1,a1,-1576 # 7370 <malloc+0x2208>
+    49a0:	00893503          	ld	a0,8(s2)
+    49a4:	078000ef          	jal	4a1c <strcmp>
+    49a8:	c905                	beqz	a0,49d8 <main+0x9a>
+  } else if(argc == 2 && argv[1][0] != '-'){
+    49aa:	00893603          	ld	a2,8(s2)
+    49ae:	00064703          	lbu	a4,0(a2) # 1000 <badarg>
+    49b2:	02d00793          	li	a5,45
+    49b6:	00f70563          	beq	a4,a5,49c0 <main+0x82>
+  int quick = 0;
+    49ba:	4501                	li	a0,0
+  int continuous = 0;
+    49bc:	4581                	li	a1,0
+    49be:	b745                	j	495e <main+0x20>
+    printf("Usage: usertests [-c] [-C] [-q] [testname]\n");
+    49c0:	00003517          	auipc	a0,0x3
+    49c4:	96850513          	addi	a0,a0,-1688 # 7328 <malloc+0x21c0>
+    49c8:	6ec000ef          	jal	50b4 <printf>
+    exit(1);
+    49cc:	4505                	li	a0,1
+    49ce:	2b6000ef          	jal	4c84 <exit>
+  char *justone = 0;
+    49d2:	4601                	li	a2,0
+    continuous = 1;
+    49d4:	4585                	li	a1,1
+    49d6:	b761                	j	495e <main+0x20>
+    continuous = 2;
+    49d8:	85a6                	mv	a1,s1
+  char *justone = 0;
+    49da:	4601                	li	a2,0
+    49dc:	b749                	j	495e <main+0x20>
+  }
+  printf("ALL TESTS PASSED\n");
+    49de:	00003517          	auipc	a0,0x3
+    49e2:	97a50513          	addi	a0,a0,-1670 # 7358 <malloc+0x21f0>
+    49e6:	6ce000ef          	jal	50b4 <printf>
+  exit(0);
+    49ea:	4501                	li	a0,0
+    49ec:	298000ef          	jal	4c84 <exit>
+
+00000000000049f0 <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+    49f0:	1141                	addi	sp,sp,-16
+    49f2:	e406                	sd	ra,8(sp)
+    49f4:	e022                	sd	s0,0(sp)
+    49f6:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+    49f8:	f47ff0ef          	jal	493e <main>
+  exit(r);
+    49fc:	288000ef          	jal	4c84 <exit>
+
+0000000000004a00 <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+    4a00:	1141                	addi	sp,sp,-16
+    4a02:	e422                	sd	s0,8(sp)
+    4a04:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+    4a06:	87aa                	mv	a5,a0
+    4a08:	0585                	addi	a1,a1,1
+    4a0a:	0785                	addi	a5,a5,1
+    4a0c:	fff5c703          	lbu	a4,-1(a1)
+    4a10:	fee78fa3          	sb	a4,-1(a5)
+    4a14:	fb75                	bnez	a4,4a08 <strcpy+0x8>
+    ;
+  return os;
+}
+    4a16:	6422                	ld	s0,8(sp)
+    4a18:	0141                	addi	sp,sp,16
+    4a1a:	8082                	ret
+
+0000000000004a1c <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+    4a1c:	1141                	addi	sp,sp,-16
+    4a1e:	e422                	sd	s0,8(sp)
+    4a20:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+    4a22:	00054783          	lbu	a5,0(a0)
+    4a26:	cb91                	beqz	a5,4a3a <strcmp+0x1e>
+    4a28:	0005c703          	lbu	a4,0(a1)
+    4a2c:	00f71763          	bne	a4,a5,4a3a <strcmp+0x1e>
+    p++, q++;
+    4a30:	0505                	addi	a0,a0,1
+    4a32:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+    4a34:	00054783          	lbu	a5,0(a0)
+    4a38:	fbe5                	bnez	a5,4a28 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+    4a3a:	0005c503          	lbu	a0,0(a1)
+}
+    4a3e:	40a7853b          	subw	a0,a5,a0
+    4a42:	6422                	ld	s0,8(sp)
+    4a44:	0141                	addi	sp,sp,16
+    4a46:	8082                	ret
+
+0000000000004a48 <strlen>:
+
+uint
+strlen(const char *s)
+{
+    4a48:	1141                	addi	sp,sp,-16
+    4a4a:	e422                	sd	s0,8(sp)
+    4a4c:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+    4a4e:	00054783          	lbu	a5,0(a0)
+    4a52:	cf91                	beqz	a5,4a6e <strlen+0x26>
+    4a54:	0505                	addi	a0,a0,1
+    4a56:	87aa                	mv	a5,a0
+    4a58:	86be                	mv	a3,a5
+    4a5a:	0785                	addi	a5,a5,1
+    4a5c:	fff7c703          	lbu	a4,-1(a5)
+    4a60:	ff65                	bnez	a4,4a58 <strlen+0x10>
+    4a62:	40a6853b          	subw	a0,a3,a0
+    4a66:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+    4a68:	6422                	ld	s0,8(sp)
+    4a6a:	0141                	addi	sp,sp,16
+    4a6c:	8082                	ret
+  for(n = 0; s[n]; n++)
+    4a6e:	4501                	li	a0,0
+    4a70:	bfe5                	j	4a68 <strlen+0x20>
+
+0000000000004a72 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+    4a72:	1141                	addi	sp,sp,-16
+    4a74:	e422                	sd	s0,8(sp)
+    4a76:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+    4a78:	ca19                	beqz	a2,4a8e <memset+0x1c>
+    4a7a:	87aa                	mv	a5,a0
+    4a7c:	1602                	slli	a2,a2,0x20
+    4a7e:	9201                	srli	a2,a2,0x20
+    4a80:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+    4a84:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+    4a88:	0785                	addi	a5,a5,1
+    4a8a:	fee79de3          	bne	a5,a4,4a84 <memset+0x12>
+  }
+  return dst;
+}
+    4a8e:	6422                	ld	s0,8(sp)
+    4a90:	0141                	addi	sp,sp,16
+    4a92:	8082                	ret
+
+0000000000004a94 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+    4a94:	1141                	addi	sp,sp,-16
+    4a96:	e422                	sd	s0,8(sp)
+    4a98:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+    4a9a:	00054783          	lbu	a5,0(a0)
+    4a9e:	cb99                	beqz	a5,4ab4 <strchr+0x20>
+    if(*s == c)
+    4aa0:	00f58763          	beq	a1,a5,4aae <strchr+0x1a>
+  for(; *s; s++)
+    4aa4:	0505                	addi	a0,a0,1
+    4aa6:	00054783          	lbu	a5,0(a0)
+    4aaa:	fbfd                	bnez	a5,4aa0 <strchr+0xc>
+      return (char*)s;
+  return 0;
+    4aac:	4501                	li	a0,0
+}
+    4aae:	6422                	ld	s0,8(sp)
+    4ab0:	0141                	addi	sp,sp,16
+    4ab2:	8082                	ret
+  return 0;
+    4ab4:	4501                	li	a0,0
+    4ab6:	bfe5                	j	4aae <strchr+0x1a>
+
+0000000000004ab8 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+    4ab8:	711d                	addi	sp,sp,-96
+    4aba:	ec86                	sd	ra,88(sp)
+    4abc:	e8a2                	sd	s0,80(sp)
+    4abe:	e4a6                	sd	s1,72(sp)
+    4ac0:	e0ca                	sd	s2,64(sp)
+    4ac2:	fc4e                	sd	s3,56(sp)
+    4ac4:	f852                	sd	s4,48(sp)
+    4ac6:	f456                	sd	s5,40(sp)
+    4ac8:	f05a                	sd	s6,32(sp)
+    4aca:	ec5e                	sd	s7,24(sp)
+    4acc:	1080                	addi	s0,sp,96
+    4ace:	8baa                	mv	s7,a0
+    4ad0:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+    4ad2:	892a                	mv	s2,a0
+    4ad4:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+    4ad6:	4aa9                	li	s5,10
+    4ad8:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+    4ada:	89a6                	mv	s3,s1
+    4adc:	2485                	addiw	s1,s1,1
+    4ade:	0344d663          	bge	s1,s4,4b0a <gets+0x52>
+    cc = read(0, &c, 1);
+    4ae2:	4605                	li	a2,1
+    4ae4:	faf40593          	addi	a1,s0,-81
+    4ae8:	4501                	li	a0,0
+    4aea:	1b2000ef          	jal	4c9c <read>
+    if(cc < 1)
+    4aee:	00a05e63          	blez	a0,4b0a <gets+0x52>
+    buf[i++] = c;
+    4af2:	faf44783          	lbu	a5,-81(s0)
+    4af6:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+    4afa:	01578763          	beq	a5,s5,4b08 <gets+0x50>
+    4afe:	0905                	addi	s2,s2,1
+    4b00:	fd679de3          	bne	a5,s6,4ada <gets+0x22>
+    buf[i++] = c;
+    4b04:	89a6                	mv	s3,s1
+    4b06:	a011                	j	4b0a <gets+0x52>
+    4b08:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+    4b0a:	99de                	add	s3,s3,s7
+    4b0c:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+    4b10:	855e                	mv	a0,s7
+    4b12:	60e6                	ld	ra,88(sp)
+    4b14:	6446                	ld	s0,80(sp)
+    4b16:	64a6                	ld	s1,72(sp)
+    4b18:	6906                	ld	s2,64(sp)
+    4b1a:	79e2                	ld	s3,56(sp)
+    4b1c:	7a42                	ld	s4,48(sp)
+    4b1e:	7aa2                	ld	s5,40(sp)
+    4b20:	7b02                	ld	s6,32(sp)
+    4b22:	6be2                	ld	s7,24(sp)
+    4b24:	6125                	addi	sp,sp,96
+    4b26:	8082                	ret
+
+0000000000004b28 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+    4b28:	1101                	addi	sp,sp,-32
+    4b2a:	ec06                	sd	ra,24(sp)
+    4b2c:	e822                	sd	s0,16(sp)
+    4b2e:	e04a                	sd	s2,0(sp)
+    4b30:	1000                	addi	s0,sp,32
+    4b32:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+    4b34:	4581                	li	a1,0
+    4b36:	18e000ef          	jal	4cc4 <open>
+  if(fd < 0)
+    4b3a:	02054263          	bltz	a0,4b5e <stat+0x36>
+    4b3e:	e426                	sd	s1,8(sp)
+    4b40:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+    4b42:	85ca                	mv	a1,s2
+    4b44:	198000ef          	jal	4cdc <fstat>
+    4b48:	892a                	mv	s2,a0
+  close(fd);
+    4b4a:	8526                	mv	a0,s1
+    4b4c:	160000ef          	jal	4cac <close>
+  return r;
+    4b50:	64a2                	ld	s1,8(sp)
+}
+    4b52:	854a                	mv	a0,s2
+    4b54:	60e2                	ld	ra,24(sp)
+    4b56:	6442                	ld	s0,16(sp)
+    4b58:	6902                	ld	s2,0(sp)
+    4b5a:	6105                	addi	sp,sp,32
+    4b5c:	8082                	ret
+    return -1;
+    4b5e:	597d                	li	s2,-1
+    4b60:	bfcd                	j	4b52 <stat+0x2a>
+
+0000000000004b62 <atoi>:
+
+int
+atoi(const char *s)
+{
+    4b62:	1141                	addi	sp,sp,-16
+    4b64:	e422                	sd	s0,8(sp)
+    4b66:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+    4b68:	00054683          	lbu	a3,0(a0)
+    4b6c:	fd06879b          	addiw	a5,a3,-48 # 3ffd0 <base+0x30328>
+    4b70:	0ff7f793          	zext.b	a5,a5
+    4b74:	4625                	li	a2,9
+    4b76:	02f66863          	bltu	a2,a5,4ba6 <atoi+0x44>
+    4b7a:	872a                	mv	a4,a0
+  n = 0;
+    4b7c:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+    4b7e:	0705                	addi	a4,a4,1 # 1000001 <base+0xff0359>
+    4b80:	0025179b          	slliw	a5,a0,0x2
+    4b84:	9fa9                	addw	a5,a5,a0
+    4b86:	0017979b          	slliw	a5,a5,0x1
+    4b8a:	9fb5                	addw	a5,a5,a3
+    4b8c:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+    4b90:	00074683          	lbu	a3,0(a4)
+    4b94:	fd06879b          	addiw	a5,a3,-48
+    4b98:	0ff7f793          	zext.b	a5,a5
+    4b9c:	fef671e3          	bgeu	a2,a5,4b7e <atoi+0x1c>
+  return n;
+}
+    4ba0:	6422                	ld	s0,8(sp)
+    4ba2:	0141                	addi	sp,sp,16
+    4ba4:	8082                	ret
+  n = 0;
+    4ba6:	4501                	li	a0,0
+    4ba8:	bfe5                	j	4ba0 <atoi+0x3e>
+
+0000000000004baa <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+    4baa:	1141                	addi	sp,sp,-16
+    4bac:	e422                	sd	s0,8(sp)
+    4bae:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+    4bb0:	02b57463          	bgeu	a0,a1,4bd8 <memmove+0x2e>
+    while(n-- > 0)
+    4bb4:	00c05f63          	blez	a2,4bd2 <memmove+0x28>
+    4bb8:	1602                	slli	a2,a2,0x20
+    4bba:	9201                	srli	a2,a2,0x20
+    4bbc:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+    4bc0:	872a                	mv	a4,a0
+      *dst++ = *src++;
+    4bc2:	0585                	addi	a1,a1,1
+    4bc4:	0705                	addi	a4,a4,1
+    4bc6:	fff5c683          	lbu	a3,-1(a1)
+    4bca:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+    4bce:	fef71ae3          	bne	a4,a5,4bc2 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+    4bd2:	6422                	ld	s0,8(sp)
+    4bd4:	0141                	addi	sp,sp,16
+    4bd6:	8082                	ret
+    dst += n;
+    4bd8:	00c50733          	add	a4,a0,a2
+    src += n;
+    4bdc:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+    4bde:	fec05ae3          	blez	a2,4bd2 <memmove+0x28>
+    4be2:	fff6079b          	addiw	a5,a2,-1
+    4be6:	1782                	slli	a5,a5,0x20
+    4be8:	9381                	srli	a5,a5,0x20
+    4bea:	fff7c793          	not	a5,a5
+    4bee:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+    4bf0:	15fd                	addi	a1,a1,-1
+    4bf2:	177d                	addi	a4,a4,-1
+    4bf4:	0005c683          	lbu	a3,0(a1)
+    4bf8:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+    4bfc:	fee79ae3          	bne	a5,a4,4bf0 <memmove+0x46>
+    4c00:	bfc9                	j	4bd2 <memmove+0x28>
+
+0000000000004c02 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+    4c02:	1141                	addi	sp,sp,-16
+    4c04:	e422                	sd	s0,8(sp)
+    4c06:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+    4c08:	ca05                	beqz	a2,4c38 <memcmp+0x36>
+    4c0a:	fff6069b          	addiw	a3,a2,-1
+    4c0e:	1682                	slli	a3,a3,0x20
+    4c10:	9281                	srli	a3,a3,0x20
+    4c12:	0685                	addi	a3,a3,1
+    4c14:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+    4c16:	00054783          	lbu	a5,0(a0)
+    4c1a:	0005c703          	lbu	a4,0(a1)
+    4c1e:	00e79863          	bne	a5,a4,4c2e <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+    4c22:	0505                	addi	a0,a0,1
+    p2++;
+    4c24:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+    4c26:	fed518e3          	bne	a0,a3,4c16 <memcmp+0x14>
+  }
+  return 0;
+    4c2a:	4501                	li	a0,0
+    4c2c:	a019                	j	4c32 <memcmp+0x30>
+      return *p1 - *p2;
+    4c2e:	40e7853b          	subw	a0,a5,a4
+}
+    4c32:	6422                	ld	s0,8(sp)
+    4c34:	0141                	addi	sp,sp,16
+    4c36:	8082                	ret
+  return 0;
+    4c38:	4501                	li	a0,0
+    4c3a:	bfe5                	j	4c32 <memcmp+0x30>
+
+0000000000004c3c <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+    4c3c:	1141                	addi	sp,sp,-16
+    4c3e:	e406                	sd	ra,8(sp)
+    4c40:	e022                	sd	s0,0(sp)
+    4c42:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+    4c44:	f67ff0ef          	jal	4baa <memmove>
+}
+    4c48:	60a2                	ld	ra,8(sp)
+    4c4a:	6402                	ld	s0,0(sp)
+    4c4c:	0141                	addi	sp,sp,16
+    4c4e:	8082                	ret
+
+0000000000004c50 <sbrk>:
+
+char *
+sbrk(int n) {
+    4c50:	1141                	addi	sp,sp,-16
+    4c52:	e406                	sd	ra,8(sp)
+    4c54:	e022                	sd	s0,0(sp)
+    4c56:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+    4c58:	4585                	li	a1,1
+    4c5a:	0b2000ef          	jal	4d0c <sys_sbrk>
+}
+    4c5e:	60a2                	ld	ra,8(sp)
+    4c60:	6402                	ld	s0,0(sp)
+    4c62:	0141                	addi	sp,sp,16
+    4c64:	8082                	ret
+
+0000000000004c66 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+    4c66:	1141                	addi	sp,sp,-16
+    4c68:	e406                	sd	ra,8(sp)
+    4c6a:	e022                	sd	s0,0(sp)
+    4c6c:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+    4c6e:	4589                	li	a1,2
+    4c70:	09c000ef          	jal	4d0c <sys_sbrk>
+}
+    4c74:	60a2                	ld	ra,8(sp)
+    4c76:	6402                	ld	s0,0(sp)
+    4c78:	0141                	addi	sp,sp,16
+    4c7a:	8082                	ret
+
+0000000000004c7c <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+    4c7c:	4885                	li	a7,1
+ ecall
+    4c7e:	00000073          	ecall
+ ret
+    4c82:	8082                	ret
+
+0000000000004c84 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+    4c84:	4889                	li	a7,2
+ ecall
+    4c86:	00000073          	ecall
+ ret
+    4c8a:	8082                	ret
+
+0000000000004c8c <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+    4c8c:	488d                	li	a7,3
+ ecall
+    4c8e:	00000073          	ecall
+ ret
+    4c92:	8082                	ret
+
+0000000000004c94 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+    4c94:	4891                	li	a7,4
+ ecall
+    4c96:	00000073          	ecall
+ ret
+    4c9a:	8082                	ret
+
+0000000000004c9c <read>:
+.global read
+read:
+ li a7, SYS_read
+    4c9c:	4895                	li	a7,5
+ ecall
+    4c9e:	00000073          	ecall
+ ret
+    4ca2:	8082                	ret
+
+0000000000004ca4 <write>:
+.global write
+write:
+ li a7, SYS_write
+    4ca4:	48c1                	li	a7,16
+ ecall
+    4ca6:	00000073          	ecall
+ ret
+    4caa:	8082                	ret
+
+0000000000004cac <close>:
+.global close
+close:
+ li a7, SYS_close
+    4cac:	48d5                	li	a7,21
+ ecall
+    4cae:	00000073          	ecall
+ ret
+    4cb2:	8082                	ret
+
+0000000000004cb4 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+    4cb4:	4899                	li	a7,6
+ ecall
+    4cb6:	00000073          	ecall
+ ret
+    4cba:	8082                	ret
+
+0000000000004cbc <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+    4cbc:	489d                	li	a7,7
+ ecall
+    4cbe:	00000073          	ecall
+ ret
+    4cc2:	8082                	ret
+
+0000000000004cc4 <open>:
+.global open
+open:
+ li a7, SYS_open
+    4cc4:	48bd                	li	a7,15
+ ecall
+    4cc6:	00000073          	ecall
+ ret
+    4cca:	8082                	ret
+
+0000000000004ccc <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+    4ccc:	48c5                	li	a7,17
+ ecall
+    4cce:	00000073          	ecall
+ ret
+    4cd2:	8082                	ret
+
+0000000000004cd4 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+    4cd4:	48c9                	li	a7,18
+ ecall
+    4cd6:	00000073          	ecall
+ ret
+    4cda:	8082                	ret
+
+0000000000004cdc <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+    4cdc:	48a1                	li	a7,8
+ ecall
+    4cde:	00000073          	ecall
+ ret
+    4ce2:	8082                	ret
+
+0000000000004ce4 <link>:
+.global link
+link:
+ li a7, SYS_link
+    4ce4:	48cd                	li	a7,19
+ ecall
+    4ce6:	00000073          	ecall
+ ret
+    4cea:	8082                	ret
+
+0000000000004cec <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+    4cec:	48d1                	li	a7,20
+ ecall
+    4cee:	00000073          	ecall
+ ret
+    4cf2:	8082                	ret
+
+0000000000004cf4 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+    4cf4:	48a5                	li	a7,9
+ ecall
+    4cf6:	00000073          	ecall
+ ret
+    4cfa:	8082                	ret
+
+0000000000004cfc <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+    4cfc:	48a9                	li	a7,10
+ ecall
+    4cfe:	00000073          	ecall
+ ret
+    4d02:	8082                	ret
+
+0000000000004d04 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+    4d04:	48ad                	li	a7,11
+ ecall
+    4d06:	00000073          	ecall
+ ret
+    4d0a:	8082                	ret
+
+0000000000004d0c <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+    4d0c:	48b1                	li	a7,12
+ ecall
+    4d0e:	00000073          	ecall
+ ret
+    4d12:	8082                	ret
+
+0000000000004d14 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+    4d14:	48b5                	li	a7,13
+ ecall
+    4d16:	00000073          	ecall
+ ret
+    4d1a:	8082                	ret
+
+0000000000004d1c <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+    4d1c:	48b9                	li	a7,14
+ ecall
+    4d1e:	00000073          	ecall
+ ret
+    4d22:	8082                	ret
+
+0000000000004d24 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+    4d24:	48d9                	li	a7,22
+ ecall
+    4d26:	00000073          	ecall
+ ret
+    4d2a:	8082                	ret
+
+0000000000004d2c <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+    4d2c:	1101                	addi	sp,sp,-32
+    4d2e:	ec06                	sd	ra,24(sp)
+    4d30:	e822                	sd	s0,16(sp)
+    4d32:	1000                	addi	s0,sp,32
+    4d34:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+    4d38:	4605                	li	a2,1
+    4d3a:	fef40593          	addi	a1,s0,-17
+    4d3e:	f67ff0ef          	jal	4ca4 <write>
+}
+    4d42:	60e2                	ld	ra,24(sp)
+    4d44:	6442                	ld	s0,16(sp)
+    4d46:	6105                	addi	sp,sp,32
+    4d48:	8082                	ret
+
+0000000000004d4a <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+    4d4a:	715d                	addi	sp,sp,-80
+    4d4c:	e486                	sd	ra,72(sp)
+    4d4e:	e0a2                	sd	s0,64(sp)
+    4d50:	f84a                	sd	s2,48(sp)
+    4d52:	0880                	addi	s0,sp,80
+    4d54:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+    4d56:	c299                	beqz	a3,4d5c <printint+0x12>
+    4d58:	0805c363          	bltz	a1,4dde <printint+0x94>
+  neg = 0;
+    4d5c:	4881                	li	a7,0
+    4d5e:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+    4d62:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+    4d64:	00003517          	auipc	a0,0x3
+    4d68:	a2c50513          	addi	a0,a0,-1492 # 7790 <digits>
+    4d6c:	883e                	mv	a6,a5
+    4d6e:	2785                	addiw	a5,a5,1
+    4d70:	02c5f733          	remu	a4,a1,a2
+    4d74:	972a                	add	a4,a4,a0
+    4d76:	00074703          	lbu	a4,0(a4)
+    4d7a:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+    4d7e:	872e                	mv	a4,a1
+    4d80:	02c5d5b3          	divu	a1,a1,a2
+    4d84:	0685                	addi	a3,a3,1
+    4d86:	fec773e3          	bgeu	a4,a2,4d6c <printint+0x22>
+  if(neg)
+    4d8a:	00088b63          	beqz	a7,4da0 <printint+0x56>
+    buf[i++] = '-';
+    4d8e:	fd078793          	addi	a5,a5,-48
+    4d92:	97a2                	add	a5,a5,s0
+    4d94:	02d00713          	li	a4,45
+    4d98:	fee78423          	sb	a4,-24(a5)
+    4d9c:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+    4da0:	02f05a63          	blez	a5,4dd4 <printint+0x8a>
+    4da4:	fc26                	sd	s1,56(sp)
+    4da6:	f44e                	sd	s3,40(sp)
+    4da8:	fb840713          	addi	a4,s0,-72
+    4dac:	00f704b3          	add	s1,a4,a5
+    4db0:	fff70993          	addi	s3,a4,-1
+    4db4:	99be                	add	s3,s3,a5
+    4db6:	37fd                	addiw	a5,a5,-1
+    4db8:	1782                	slli	a5,a5,0x20
+    4dba:	9381                	srli	a5,a5,0x20
+    4dbc:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+    4dc0:	fff4c583          	lbu	a1,-1(s1)
+    4dc4:	854a                	mv	a0,s2
+    4dc6:	f67ff0ef          	jal	4d2c <putc>
+  while(--i >= 0)
+    4dca:	14fd                	addi	s1,s1,-1
+    4dcc:	ff349ae3          	bne	s1,s3,4dc0 <printint+0x76>
+    4dd0:	74e2                	ld	s1,56(sp)
+    4dd2:	79a2                	ld	s3,40(sp)
+}
+    4dd4:	60a6                	ld	ra,72(sp)
+    4dd6:	6406                	ld	s0,64(sp)
+    4dd8:	7942                	ld	s2,48(sp)
+    4dda:	6161                	addi	sp,sp,80
+    4ddc:	8082                	ret
+    x = -xx;
+    4dde:	40b005b3          	neg	a1,a1
+    neg = 1;
+    4de2:	4885                	li	a7,1
+    x = -xx;
+    4de4:	bfad                	j	4d5e <printint+0x14>
+
+0000000000004de6 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+    4de6:	711d                	addi	sp,sp,-96
+    4de8:	ec86                	sd	ra,88(sp)
+    4dea:	e8a2                	sd	s0,80(sp)
+    4dec:	e0ca                	sd	s2,64(sp)
+    4dee:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+    4df0:	0005c903          	lbu	s2,0(a1)
+    4df4:	28090663          	beqz	s2,5080 <vprintf+0x29a>
+    4df8:	e4a6                	sd	s1,72(sp)
+    4dfa:	fc4e                	sd	s3,56(sp)
+    4dfc:	f852                	sd	s4,48(sp)
+    4dfe:	f456                	sd	s5,40(sp)
+    4e00:	f05a                	sd	s6,32(sp)
+    4e02:	ec5e                	sd	s7,24(sp)
+    4e04:	e862                	sd	s8,16(sp)
+    4e06:	e466                	sd	s9,8(sp)
+    4e08:	8b2a                	mv	s6,a0
+    4e0a:	8a2e                	mv	s4,a1
+    4e0c:	8bb2                	mv	s7,a2
+  state = 0;
+    4e0e:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+    4e10:	4481                	li	s1,0
+    4e12:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+    4e14:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+    4e18:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+    4e1c:	06c00c93          	li	s9,108
+    4e20:	a005                	j	4e40 <vprintf+0x5a>
+        putc(fd, c0);
+    4e22:	85ca                	mv	a1,s2
+    4e24:	855a                	mv	a0,s6
+    4e26:	f07ff0ef          	jal	4d2c <putc>
+    4e2a:	a019                	j	4e30 <vprintf+0x4a>
+    } else if(state == '%'){
+    4e2c:	03598263          	beq	s3,s5,4e50 <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+    4e30:	2485                	addiw	s1,s1,1
+    4e32:	8726                	mv	a4,s1
+    4e34:	009a07b3          	add	a5,s4,s1
+    4e38:	0007c903          	lbu	s2,0(a5)
+    4e3c:	22090a63          	beqz	s2,5070 <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+    4e40:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+    4e44:	fe0994e3          	bnez	s3,4e2c <vprintf+0x46>
+      if(c0 == '%'){
+    4e48:	fd579de3          	bne	a5,s5,4e22 <vprintf+0x3c>
+        state = '%';
+    4e4c:	89be                	mv	s3,a5
+    4e4e:	b7cd                	j	4e30 <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+    4e50:	00ea06b3          	add	a3,s4,a4
+    4e54:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+    4e58:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+    4e5a:	c681                	beqz	a3,4e62 <vprintf+0x7c>
+    4e5c:	9752                	add	a4,a4,s4
+    4e5e:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+    4e62:	05878363          	beq	a5,s8,4ea8 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+    4e66:	05978d63          	beq	a5,s9,4ec0 <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+    4e6a:	07500713          	li	a4,117
+    4e6e:	0ee78763          	beq	a5,a4,4f5c <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+    4e72:	07800713          	li	a4,120
+    4e76:	12e78963          	beq	a5,a4,4fa8 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+    4e7a:	07000713          	li	a4,112
+    4e7e:	14e78e63          	beq	a5,a4,4fda <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+    4e82:	06300713          	li	a4,99
+    4e86:	18e78e63          	beq	a5,a4,5022 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+    4e8a:	07300713          	li	a4,115
+    4e8e:	1ae78463          	beq	a5,a4,5036 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+    4e92:	02500713          	li	a4,37
+    4e96:	04e79563          	bne	a5,a4,4ee0 <vprintf+0xfa>
+        putc(fd, '%');
+    4e9a:	02500593          	li	a1,37
+    4e9e:	855a                	mv	a0,s6
+    4ea0:	e8dff0ef          	jal	4d2c <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+    4ea4:	4981                	li	s3,0
+    4ea6:	b769                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+    4ea8:	008b8913          	addi	s2,s7,8
+    4eac:	4685                	li	a3,1
+    4eae:	4629                	li	a2,10
+    4eb0:	000ba583          	lw	a1,0(s7)
+    4eb4:	855a                	mv	a0,s6
+    4eb6:	e95ff0ef          	jal	4d4a <printint>
+    4eba:	8bca                	mv	s7,s2
+      state = 0;
+    4ebc:	4981                	li	s3,0
+    4ebe:	bf8d                	j	4e30 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+    4ec0:	06400793          	li	a5,100
+    4ec4:	02f68963          	beq	a3,a5,4ef6 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+    4ec8:	06c00793          	li	a5,108
+    4ecc:	04f68263          	beq	a3,a5,4f10 <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+    4ed0:	07500793          	li	a5,117
+    4ed4:	0af68063          	beq	a3,a5,4f74 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+    4ed8:	07800793          	li	a5,120
+    4edc:	0ef68263          	beq	a3,a5,4fc0 <vprintf+0x1da>
+        putc(fd, '%');
+    4ee0:	02500593          	li	a1,37
+    4ee4:	855a                	mv	a0,s6
+    4ee6:	e47ff0ef          	jal	4d2c <putc>
+        putc(fd, c0);
+    4eea:	85ca                	mv	a1,s2
+    4eec:	855a                	mv	a0,s6
+    4eee:	e3fff0ef          	jal	4d2c <putc>
+      state = 0;
+    4ef2:	4981                	li	s3,0
+    4ef4:	bf35                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+    4ef6:	008b8913          	addi	s2,s7,8
+    4efa:	4685                	li	a3,1
+    4efc:	4629                	li	a2,10
+    4efe:	000bb583          	ld	a1,0(s7)
+    4f02:	855a                	mv	a0,s6
+    4f04:	e47ff0ef          	jal	4d4a <printint>
+        i += 1;
+    4f08:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+    4f0a:	8bca                	mv	s7,s2
+      state = 0;
+    4f0c:	4981                	li	s3,0
+        i += 1;
+    4f0e:	b70d                	j	4e30 <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+    4f10:	06400793          	li	a5,100
+    4f14:	02f60763          	beq	a2,a5,4f42 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+    4f18:	07500793          	li	a5,117
+    4f1c:	06f60963          	beq	a2,a5,4f8e <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+    4f20:	07800793          	li	a5,120
+    4f24:	faf61ee3          	bne	a2,a5,4ee0 <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+    4f28:	008b8913          	addi	s2,s7,8
+    4f2c:	4681                	li	a3,0
+    4f2e:	4641                	li	a2,16
+    4f30:	000bb583          	ld	a1,0(s7)
+    4f34:	855a                	mv	a0,s6
+    4f36:	e15ff0ef          	jal	4d4a <printint>
+        i += 2;
+    4f3a:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+    4f3c:	8bca                	mv	s7,s2
+      state = 0;
+    4f3e:	4981                	li	s3,0
+        i += 2;
+    4f40:	bdc5                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+    4f42:	008b8913          	addi	s2,s7,8
+    4f46:	4685                	li	a3,1
+    4f48:	4629                	li	a2,10
+    4f4a:	000bb583          	ld	a1,0(s7)
+    4f4e:	855a                	mv	a0,s6
+    4f50:	dfbff0ef          	jal	4d4a <printint>
+        i += 2;
+    4f54:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+    4f56:	8bca                	mv	s7,s2
+      state = 0;
+    4f58:	4981                	li	s3,0
+        i += 2;
+    4f5a:	bdd9                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+    4f5c:	008b8913          	addi	s2,s7,8
+    4f60:	4681                	li	a3,0
+    4f62:	4629                	li	a2,10
+    4f64:	000be583          	lwu	a1,0(s7)
+    4f68:	855a                	mv	a0,s6
+    4f6a:	de1ff0ef          	jal	4d4a <printint>
+    4f6e:	8bca                	mv	s7,s2
+      state = 0;
+    4f70:	4981                	li	s3,0
+    4f72:	bd7d                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+    4f74:	008b8913          	addi	s2,s7,8
+    4f78:	4681                	li	a3,0
+    4f7a:	4629                	li	a2,10
+    4f7c:	000bb583          	ld	a1,0(s7)
+    4f80:	855a                	mv	a0,s6
+    4f82:	dc9ff0ef          	jal	4d4a <printint>
+        i += 1;
+    4f86:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+    4f88:	8bca                	mv	s7,s2
+      state = 0;
+    4f8a:	4981                	li	s3,0
+        i += 1;
+    4f8c:	b555                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+    4f8e:	008b8913          	addi	s2,s7,8
+    4f92:	4681                	li	a3,0
+    4f94:	4629                	li	a2,10
+    4f96:	000bb583          	ld	a1,0(s7)
+    4f9a:	855a                	mv	a0,s6
+    4f9c:	dafff0ef          	jal	4d4a <printint>
+        i += 2;
+    4fa0:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+    4fa2:	8bca                	mv	s7,s2
+      state = 0;
+    4fa4:	4981                	li	s3,0
+        i += 2;
+    4fa6:	b569                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+    4fa8:	008b8913          	addi	s2,s7,8
+    4fac:	4681                	li	a3,0
+    4fae:	4641                	li	a2,16
+    4fb0:	000be583          	lwu	a1,0(s7)
+    4fb4:	855a                	mv	a0,s6
+    4fb6:	d95ff0ef          	jal	4d4a <printint>
+    4fba:	8bca                	mv	s7,s2
+      state = 0;
+    4fbc:	4981                	li	s3,0
+    4fbe:	bd8d                	j	4e30 <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+    4fc0:	008b8913          	addi	s2,s7,8
+    4fc4:	4681                	li	a3,0
+    4fc6:	4641                	li	a2,16
+    4fc8:	000bb583          	ld	a1,0(s7)
+    4fcc:	855a                	mv	a0,s6
+    4fce:	d7dff0ef          	jal	4d4a <printint>
+        i += 1;
+    4fd2:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+    4fd4:	8bca                	mv	s7,s2
+      state = 0;
+    4fd6:	4981                	li	s3,0
+        i += 1;
+    4fd8:	bda1                	j	4e30 <vprintf+0x4a>
+    4fda:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+    4fdc:	008b8d13          	addi	s10,s7,8
+    4fe0:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+    4fe4:	03000593          	li	a1,48
+    4fe8:	855a                	mv	a0,s6
+    4fea:	d43ff0ef          	jal	4d2c <putc>
+  putc(fd, 'x');
+    4fee:	07800593          	li	a1,120
+    4ff2:	855a                	mv	a0,s6
+    4ff4:	d39ff0ef          	jal	4d2c <putc>
+    4ff8:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+    4ffa:	00002b97          	auipc	s7,0x2
+    4ffe:	796b8b93          	addi	s7,s7,1942 # 7790 <digits>
+    5002:	03c9d793          	srli	a5,s3,0x3c
+    5006:	97de                	add	a5,a5,s7
+    5008:	0007c583          	lbu	a1,0(a5)
+    500c:	855a                	mv	a0,s6
+    500e:	d1fff0ef          	jal	4d2c <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+    5012:	0992                	slli	s3,s3,0x4
+    5014:	397d                	addiw	s2,s2,-1
+    5016:	fe0916e3          	bnez	s2,5002 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+    501a:	8bea                	mv	s7,s10
+      state = 0;
+    501c:	4981                	li	s3,0
+    501e:	6d02                	ld	s10,0(sp)
+    5020:	bd01                	j	4e30 <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+    5022:	008b8913          	addi	s2,s7,8
+    5026:	000bc583          	lbu	a1,0(s7)
+    502a:	855a                	mv	a0,s6
+    502c:	d01ff0ef          	jal	4d2c <putc>
+    5030:	8bca                	mv	s7,s2
+      state = 0;
+    5032:	4981                	li	s3,0
+    5034:	bbf5                	j	4e30 <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+    5036:	008b8993          	addi	s3,s7,8
+    503a:	000bb903          	ld	s2,0(s7)
+    503e:	00090f63          	beqz	s2,505c <vprintf+0x276>
+        for(; *s; s++)
+    5042:	00094583          	lbu	a1,0(s2)
+    5046:	c195                	beqz	a1,506a <vprintf+0x284>
+          putc(fd, *s);
+    5048:	855a                	mv	a0,s6
+    504a:	ce3ff0ef          	jal	4d2c <putc>
+        for(; *s; s++)
+    504e:	0905                	addi	s2,s2,1
+    5050:	00094583          	lbu	a1,0(s2)
+    5054:	f9f5                	bnez	a1,5048 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+    5056:	8bce                	mv	s7,s3
+      state = 0;
+    5058:	4981                	li	s3,0
+    505a:	bbd9                	j	4e30 <vprintf+0x4a>
+          s = "(null)";
+    505c:	00002917          	auipc	s2,0x2
+    5060:	68490913          	addi	s2,s2,1668 # 76e0 <malloc+0x2578>
+        for(; *s; s++)
+    5064:	02800593          	li	a1,40
+    5068:	b7c5                	j	5048 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+    506a:	8bce                	mv	s7,s3
+      state = 0;
+    506c:	4981                	li	s3,0
+    506e:	b3c9                	j	4e30 <vprintf+0x4a>
+    5070:	64a6                	ld	s1,72(sp)
+    5072:	79e2                	ld	s3,56(sp)
+    5074:	7a42                	ld	s4,48(sp)
+    5076:	7aa2                	ld	s5,40(sp)
+    5078:	7b02                	ld	s6,32(sp)
+    507a:	6be2                	ld	s7,24(sp)
+    507c:	6c42                	ld	s8,16(sp)
+    507e:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+    5080:	60e6                	ld	ra,88(sp)
+    5082:	6446                	ld	s0,80(sp)
+    5084:	6906                	ld	s2,64(sp)
+    5086:	6125                	addi	sp,sp,96
+    5088:	8082                	ret
+
+000000000000508a <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+    508a:	715d                	addi	sp,sp,-80
+    508c:	ec06                	sd	ra,24(sp)
+    508e:	e822                	sd	s0,16(sp)
+    5090:	1000                	addi	s0,sp,32
+    5092:	e010                	sd	a2,0(s0)
+    5094:	e414                	sd	a3,8(s0)
+    5096:	e818                	sd	a4,16(s0)
+    5098:	ec1c                	sd	a5,24(s0)
+    509a:	03043023          	sd	a6,32(s0)
+    509e:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+    50a2:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+    50a6:	8622                	mv	a2,s0
+    50a8:	d3fff0ef          	jal	4de6 <vprintf>
+}
+    50ac:	60e2                	ld	ra,24(sp)
+    50ae:	6442                	ld	s0,16(sp)
+    50b0:	6161                	addi	sp,sp,80
+    50b2:	8082                	ret
+
+00000000000050b4 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+    50b4:	711d                	addi	sp,sp,-96
+    50b6:	ec06                	sd	ra,24(sp)
+    50b8:	e822                	sd	s0,16(sp)
+    50ba:	1000                	addi	s0,sp,32
+    50bc:	e40c                	sd	a1,8(s0)
+    50be:	e810                	sd	a2,16(s0)
+    50c0:	ec14                	sd	a3,24(s0)
+    50c2:	f018                	sd	a4,32(s0)
+    50c4:	f41c                	sd	a5,40(s0)
+    50c6:	03043823          	sd	a6,48(s0)
+    50ca:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+    50ce:	00840613          	addi	a2,s0,8
+    50d2:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+    50d6:	85aa                	mv	a1,a0
+    50d8:	4505                	li	a0,1
+    50da:	d0dff0ef          	jal	4de6 <vprintf>
+}
+    50de:	60e2                	ld	ra,24(sp)
+    50e0:	6442                	ld	s0,16(sp)
+    50e2:	6125                	addi	sp,sp,96
+    50e4:	8082                	ret
+
+00000000000050e6 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+    50e6:	1141                	addi	sp,sp,-16
+    50e8:	e422                	sd	s0,8(sp)
+    50ea:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+    50ec:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    50f0:	00004797          	auipc	a5,0x4
+    50f4:	3907b783          	ld	a5,912(a5) # 9480 <freep>
+    50f8:	a02d                	j	5122 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+    50fa:	4618                	lw	a4,8(a2)
+    50fc:	9f2d                	addw	a4,a4,a1
+    50fe:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+    5102:	6398                	ld	a4,0(a5)
+    5104:	6310                	ld	a2,0(a4)
+    5106:	a83d                	j	5144 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+    5108:	ff852703          	lw	a4,-8(a0)
+    510c:	9f31                	addw	a4,a4,a2
+    510e:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+    5110:	ff053683          	ld	a3,-16(a0)
+    5114:	a091                	j	5158 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    5116:	6398                	ld	a4,0(a5)
+    5118:	00e7e463          	bltu	a5,a4,5120 <free+0x3a>
+    511c:	00e6ea63          	bltu	a3,a4,5130 <free+0x4a>
+{
+    5120:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+    5122:	fed7fae3          	bgeu	a5,a3,5116 <free+0x30>
+    5126:	6398                	ld	a4,0(a5)
+    5128:	00e6e463          	bltu	a3,a4,5130 <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+    512c:	fee7eae3          	bltu	a5,a4,5120 <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+    5130:	ff852583          	lw	a1,-8(a0)
+    5134:	6390                	ld	a2,0(a5)
+    5136:	02059813          	slli	a6,a1,0x20
+    513a:	01c85713          	srli	a4,a6,0x1c
+    513e:	9736                	add	a4,a4,a3
+    5140:	fae60de3          	beq	a2,a4,50fa <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+    5144:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+    5148:	4790                	lw	a2,8(a5)
+    514a:	02061593          	slli	a1,a2,0x20
+    514e:	01c5d713          	srli	a4,a1,0x1c
+    5152:	973e                	add	a4,a4,a5
+    5154:	fae68ae3          	beq	a3,a4,5108 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+    5158:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+    515a:	00004717          	auipc	a4,0x4
+    515e:	32f73323          	sd	a5,806(a4) # 9480 <freep>
+}
+    5162:	6422                	ld	s0,8(sp)
+    5164:	0141                	addi	sp,sp,16
+    5166:	8082                	ret
+
+0000000000005168 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+    5168:	7139                	addi	sp,sp,-64
+    516a:	fc06                	sd	ra,56(sp)
+    516c:	f822                	sd	s0,48(sp)
+    516e:	f426                	sd	s1,40(sp)
+    5170:	ec4e                	sd	s3,24(sp)
+    5172:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+    5174:	02051493          	slli	s1,a0,0x20
+    5178:	9081                	srli	s1,s1,0x20
+    517a:	04bd                	addi	s1,s1,15
+    517c:	8091                	srli	s1,s1,0x4
+    517e:	0014899b          	addiw	s3,s1,1
+    5182:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+    5184:	00004517          	auipc	a0,0x4
+    5188:	2fc53503          	ld	a0,764(a0) # 9480 <freep>
+    518c:	c915                	beqz	a0,51c0 <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    518e:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    5190:	4798                	lw	a4,8(a5)
+    5192:	08977a63          	bgeu	a4,s1,5226 <malloc+0xbe>
+    5196:	f04a                	sd	s2,32(sp)
+    5198:	e852                	sd	s4,16(sp)
+    519a:	e456                	sd	s5,8(sp)
+    519c:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+    519e:	8a4e                	mv	s4,s3
+    51a0:	0009871b          	sext.w	a4,s3
+    51a4:	6685                	lui	a3,0x1
+    51a6:	00d77363          	bgeu	a4,a3,51ac <malloc+0x44>
+    51aa:	6a05                	lui	s4,0x1
+    51ac:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+    51b0:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+    51b4:	00004917          	auipc	s2,0x4
+    51b8:	2cc90913          	addi	s2,s2,716 # 9480 <freep>
+  if(p == SBRK_ERROR)
+    51bc:	5afd                	li	s5,-1
+    51be:	a081                	j	51fe <malloc+0x96>
+    51c0:	f04a                	sd	s2,32(sp)
+    51c2:	e852                	sd	s4,16(sp)
+    51c4:	e456                	sd	s5,8(sp)
+    51c6:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+    51c8:	0000b797          	auipc	a5,0xb
+    51cc:	ae078793          	addi	a5,a5,-1312 # fca8 <base>
+    51d0:	00004717          	auipc	a4,0x4
+    51d4:	2af73823          	sd	a5,688(a4) # 9480 <freep>
+    51d8:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+    51da:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+    51de:	b7c1                	j	519e <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+    51e0:	6398                	ld	a4,0(a5)
+    51e2:	e118                	sd	a4,0(a0)
+    51e4:	a8a9                	j	523e <malloc+0xd6>
+  hp->s.size = nu;
+    51e6:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+    51ea:	0541                	addi	a0,a0,16
+    51ec:	efbff0ef          	jal	50e6 <free>
+  return freep;
+    51f0:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+    51f4:	c12d                	beqz	a0,5256 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+    51f6:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+    51f8:	4798                	lw	a4,8(a5)
+    51fa:	02977263          	bgeu	a4,s1,521e <malloc+0xb6>
+    if(p == freep)
+    51fe:	00093703          	ld	a4,0(s2)
+    5202:	853e                	mv	a0,a5
+    5204:	fef719e3          	bne	a4,a5,51f6 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+    5208:	8552                	mv	a0,s4
+    520a:	a47ff0ef          	jal	4c50 <sbrk>
+  if(p == SBRK_ERROR)
+    520e:	fd551ce3          	bne	a0,s5,51e6 <malloc+0x7e>
+        return 0;
+    5212:	4501                	li	a0,0
+    5214:	7902                	ld	s2,32(sp)
+    5216:	6a42                	ld	s4,16(sp)
+    5218:	6aa2                	ld	s5,8(sp)
+    521a:	6b02                	ld	s6,0(sp)
+    521c:	a03d                	j	524a <malloc+0xe2>
+    521e:	7902                	ld	s2,32(sp)
+    5220:	6a42                	ld	s4,16(sp)
+    5222:	6aa2                	ld	s5,8(sp)
+    5224:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+    5226:	fae48de3          	beq	s1,a4,51e0 <malloc+0x78>
+        p->s.size -= nunits;
+    522a:	4137073b          	subw	a4,a4,s3
+    522e:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+    5230:	02071693          	slli	a3,a4,0x20
+    5234:	01c6d713          	srli	a4,a3,0x1c
+    5238:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+    523a:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+    523e:	00004717          	auipc	a4,0x4
+    5242:	24a73123          	sd	a0,578(a4) # 9480 <freep>
+      return (void*)(p + 1);
+    5246:	01078513          	addi	a0,a5,16
+  }
+}
+    524a:	70e2                	ld	ra,56(sp)
+    524c:	7442                	ld	s0,48(sp)
+    524e:	74a2                	ld	s1,40(sp)
+    5250:	69e2                	ld	s3,24(sp)
+    5252:	6121                	addi	sp,sp,64
+    5254:	8082                	ret
+    5256:	7902                	ld	s2,32(sp)
+    5258:	6a42                	ld	s4,16(sp)
+    525a:	6aa2                	ld	s5,8(sp)
+    525c:	6b02                	ld	s6,0(sp)
+    525e:	b7f5                	j	524a <malloc+0xe2>
diff -ruN xv6-riscv/user/usertests.d xv62/user/usertests.d
--- xv6-riscv/user/usertests.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/usertests.d	2025-09-14 12:32:51.844883116 +0000
@@ -0,0 +1,3 @@
+user/usertests.o: user/usertests.c kernel/param.h kernel/types.h \
+ kernel/stat.h user/user.h kernel/fs.h kernel/fcntl.h kernel/syscall.h \
+ kernel/memlayout.h kernel/riscv.h
Binary files xv6-riscv/user/usertests.o and xv62/user/usertests.o differ
diff -ruN xv6-riscv/user/usertests.sym xv62/user/usertests.sym
--- xv6-riscv/user/usertests.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/usertests.sym	2025-09-14 12:32:51.912883102 +0000
@@ -0,0 +1,147 @@
+0000000000000000 .text
+0000000000005260 .rodata
+00000000000077a8 .eh_frame
+0000000000009000 .data
+0000000000009480 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_ranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 usertests.c
+0000000000009590 big.0
+0000000000009490 args.1
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000004d2c putc
+0000000000004d4a printint
+0000000000007790 digits
+0000000000000000 umalloc.c
+0000000000009480 freep
+000000000000fca8 base
+00000000000009be writebig
+00000000000025b0 sbrk8000
+0000000000004a00 strcpy
+0000000000001650 exitwait
+0000000000001db6 manywrites
+0000000000004d14 pause
+00000000000050b4 printf
+0000000000004d0c sys_sbrk
+00000000000003be outofinodes
+000000000000426a bigargtest
+0000000000004baa memmove
+0000000000003580 openiputtest
+0000000000004ccc mknod
+0000000000003886 reparent
+0000000000004ab8 gets
+000000000000445e lazy_copy
+0000000000004d04 getpid
+00000000000014b4 pipe1
+0000000000004c3c memcpy
+0000000000003486 iref
+0000000000000fd4 pgbug
+0000000000001d12 nowrite
+0000000000005168 malloc
+00000000000005aa copyout
+0000000000001cae stacktest
+00000000000025de execout
+0000000000002452 sbrkbugs
+0000000000002a70 exitiputtest
+0000000000004596 fsfull
+0000000000000e9e bigdir
+0000000000001ae4 forktest
+0000000000004c66 sbrklazy
+0000000000001fce rwsbrk
+00000000000011dc truncate3
+000000000000022c bigwrite
+0000000000003b02 sharedfd
+0000000000004c94 pipe
+00000000000036d0 killstatus
+000000000000a598 uninit
+00000000000032d6 dirfile
+0000000000004ca4 write
+0000000000000078 bsstest
+0000000000004cdc fstat
+000000000000508a fprintf
+0000000000004cb4 kill
+00000000000027b6 diskfull
+0000000000000e3c validatetest
+0000000000009010 quicktests
+00000000000031b0 rmdot
+000000000000047e copyin
+0000000000004de6 vprintf
+0000000000000118 truncate2
+0000000000004cf4 chdir
+0000000000009000 big
+000000000000133e exectest
+0000000000004cbc exec
+00000000000002ee badwrite
+0000000000004c8c wait
+0000000000004c9c read
+00000000000043b2 lazy_unmap
+000000000000374a preempt
+0000000000004cd4 unlink
+0000000000001000 badarg
+00000000000023f8 argptest
+0000000000003a8a mem
+000000000000478a runtests
+0000000000004c02 memcmp
+0000000000004c7c fork
+000000000000250e sbrklast
+0000000000001eca copyinstr3
+0000000000001752 forkfork
+0000000000004c50 sbrk
+0000000000009410 slowtests
+0000000000004d1c uptime
+00000000000016e0 twochildren
+0000000000001c1c MAXVAplus
+0000000000004a72 memset
+0000000000001b8c kernmem
+00000000000001b8 createtest
+000000000000493e main
+0000000000001830 createdelete
+0000000000003632 forkforkfork
+0000000000003906 sbrkfail
+0000000000004a1c strcmp
+000000000000087e writetest
+0000000000004cfc dup
+00000000000006e0 truncate1
+00000000000000b2 opentest
+000000000000470c run
+0000000000004348 lazy_alloc
+0000000000002bc2 subdir
+000000000000103e copyinstr2
+0000000000000c74 linktest
+000000000000cca8 buf
+0000000000002b1c dirtest
+0000000000004842 drivetests
+0000000000002354 sbrkarg
+00000000000029ca iputtest
+0000000000004d24 getreadcount
+0000000000004b28 stat
+00000000000040e6 bigfile
+00000000000047fc countfree
+0000000000000b1e unlinkread
+0000000000004ce4 link
+0000000000004c84 exit
+00000000000049f0 start
+0000000000004b62 atoi
+0000000000000000 copyinstr1
+0000000000001a08 linkunlink
+00000000000020d4 sbrkbasic
+0000000000004a48 strlen
+0000000000004cc4 open
+0000000000004a94 strchr
+0000000000003e42 concreate
+000000000000267a fourteen
+0000000000003c6e fourfiles
+0000000000002216 sbrkmuch
+0000000000004cec mkdir
+0000000000004cac close
+00000000000017e8 reparent2
+00000000000050e6 free
diff -ruN xv6-riscv/user/usys.S xv62/user/usys.S
--- xv6-riscv/user/usys.S	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/usys.S	2025-09-14 12:32:50.448883403 +0000
@@ -0,0 +1,112 @@
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ ecall
+ ret
+.global exit
+exit:
+ li a7, SYS_exit
+ ecall
+ ret
+.global wait
+wait:
+ li a7, SYS_wait
+ ecall
+ ret
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ ecall
+ ret
+.global read
+read:
+ li a7, SYS_read
+ ecall
+ ret
+.global write
+write:
+ li a7, SYS_write
+ ecall
+ ret
+.global close
+close:
+ li a7, SYS_close
+ ecall
+ ret
+.global kill
+kill:
+ li a7, SYS_kill
+ ecall
+ ret
+.global exec
+exec:
+ li a7, SYS_exec
+ ecall
+ ret
+.global open
+open:
+ li a7, SYS_open
+ ecall
+ ret
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ ecall
+ ret
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ ecall
+ ret
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ ecall
+ ret
+.global link
+link:
+ li a7, SYS_link
+ ecall
+ ret
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ ecall
+ ret
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ ecall
+ ret
+.global dup
+dup:
+ li a7, SYS_dup
+ ecall
+ ret
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ ecall
+ ret
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ ecall
+ ret
+.global pause
+pause:
+ li a7, SYS_pause
+ ecall
+ ret
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ ecall
+ ret
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ ecall
+ ret
diff -ruN xv6-riscv/user/usys.d xv62/user/usys.d
--- xv6-riscv/user/usys.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/usys.d	2025-09-14 12:32:50.464883400 +0000
@@ -0,0 +1 @@
+user/usys.o: user/usys.S kernel/syscall.h
Binary files xv6-riscv/user/usys.o and xv62/user/usys.o differ
diff -ruN xv6-riscv/user/usys.pl xv62/user/usys.pl
--- xv6-riscv/user/usys.pl	2025-09-13 15:52:01.169875875 +0000
+++ xv62/user/usys.pl	2025-09-13 14:34:47.235630566 +0000
@@ -42,3 +42,4 @@
 entry("sbrk");
 entry("pause");
 entry("uptime");
+entry("getreadcount");
diff -ruN xv6-riscv/user/wc.asm xv62/user/wc.asm
--- xv6-riscv/user/wc.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/wc.asm	2025-09-14 12:32:52.076883069 +0000
@@ -0,0 +1,1652 @@
+
+user/_wc:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <wc>:
+
+char buf[512];
+
+void
+wc(int fd, char *name)
+{
+   0:	7119                	addi	sp,sp,-128
+   2:	fc86                	sd	ra,120(sp)
+   4:	f8a2                	sd	s0,112(sp)
+   6:	f4a6                	sd	s1,104(sp)
+   8:	f0ca                	sd	s2,96(sp)
+   a:	ecce                	sd	s3,88(sp)
+   c:	e8d2                	sd	s4,80(sp)
+   e:	e4d6                	sd	s5,72(sp)
+  10:	e0da                	sd	s6,64(sp)
+  12:	fc5e                	sd	s7,56(sp)
+  14:	f862                	sd	s8,48(sp)
+  16:	f466                	sd	s9,40(sp)
+  18:	f06a                	sd	s10,32(sp)
+  1a:	ec6e                	sd	s11,24(sp)
+  1c:	0100                	addi	s0,sp,128
+  1e:	f8a43423          	sd	a0,-120(s0)
+  22:	f8b43023          	sd	a1,-128(s0)
+  int i, n;
+  int l, w, c, inword;
+
+  l = w = c = 0;
+  inword = 0;
+  26:	4901                	li	s2,0
+  l = w = c = 0;
+  28:	4d01                	li	s10,0
+  2a:	4c81                	li	s9,0
+  2c:	4c01                	li	s8,0
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  2e:	00001d97          	auipc	s11,0x1
+  32:	fe2d8d93          	addi	s11,s11,-30 # 1010 <buf>
+    for(i=0; i<n; i++){
+      c++;
+      if(buf[i] == '\n')
+  36:	4aa9                	li	s5,10
+        l++;
+      if(strchr(" \r\t\n\v", buf[i]))
+  38:	00001a17          	auipc	s4,0x1
+  3c:	998a0a13          	addi	s4,s4,-1640 # 9d0 <malloc+0xfc>
+        inword = 0;
+  40:	4b81                	li	s7,0
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  42:	a035                	j	6e <wc+0x6e>
+      if(strchr(" \r\t\n\v", buf[i]))
+  44:	8552                	mv	a0,s4
+  46:	1ba000ef          	jal	200 <strchr>
+  4a:	c919                	beqz	a0,60 <wc+0x60>
+        inword = 0;
+  4c:	895e                	mv	s2,s7
+    for(i=0; i<n; i++){
+  4e:	0485                	addi	s1,s1,1
+  50:	01348d63          	beq	s1,s3,6a <wc+0x6a>
+      if(buf[i] == '\n')
+  54:	0004c583          	lbu	a1,0(s1)
+  58:	ff5596e3          	bne	a1,s5,44 <wc+0x44>
+        l++;
+  5c:	2c05                	addiw	s8,s8,1
+  5e:	b7dd                	j	44 <wc+0x44>
+      else if(!inword){
+  60:	fe0917e3          	bnez	s2,4e <wc+0x4e>
+        w++;
+  64:	2c85                	addiw	s9,s9,1
+        inword = 1;
+  66:	4905                	li	s2,1
+  68:	b7dd                	j	4e <wc+0x4e>
+  6a:	01ab0d3b          	addw	s10,s6,s10
+  while((n = read(fd, buf, sizeof(buf))) > 0){
+  6e:	20000613          	li	a2,512
+  72:	85ee                	mv	a1,s11
+  74:	f8843503          	ld	a0,-120(s0)
+  78:	390000ef          	jal	408 <read>
+  7c:	8b2a                	mv	s6,a0
+  7e:	00a05963          	blez	a0,90 <wc+0x90>
+    for(i=0; i<n; i++){
+  82:	00001497          	auipc	s1,0x1
+  86:	f8e48493          	addi	s1,s1,-114 # 1010 <buf>
+  8a:	009509b3          	add	s3,a0,s1
+  8e:	b7d9                	j	54 <wc+0x54>
+      }
+    }
+  }
+  if(n < 0){
+  90:	02054c63          	bltz	a0,c8 <wc+0xc8>
+    printf("wc: read error\n");
+    exit(1);
+  }
+  printf("%d %d %d %s\n", l, w, c, name);
+  94:	f8043703          	ld	a4,-128(s0)
+  98:	86ea                	mv	a3,s10
+  9a:	8666                	mv	a2,s9
+  9c:	85e2                	mv	a1,s8
+  9e:	00001517          	auipc	a0,0x1
+  a2:	95250513          	addi	a0,a0,-1710 # 9f0 <malloc+0x11c>
+  a6:	77a000ef          	jal	820 <printf>
+}
+  aa:	70e6                	ld	ra,120(sp)
+  ac:	7446                	ld	s0,112(sp)
+  ae:	74a6                	ld	s1,104(sp)
+  b0:	7906                	ld	s2,96(sp)
+  b2:	69e6                	ld	s3,88(sp)
+  b4:	6a46                	ld	s4,80(sp)
+  b6:	6aa6                	ld	s5,72(sp)
+  b8:	6b06                	ld	s6,64(sp)
+  ba:	7be2                	ld	s7,56(sp)
+  bc:	7c42                	ld	s8,48(sp)
+  be:	7ca2                	ld	s9,40(sp)
+  c0:	7d02                	ld	s10,32(sp)
+  c2:	6de2                	ld	s11,24(sp)
+  c4:	6109                	addi	sp,sp,128
+  c6:	8082                	ret
+    printf("wc: read error\n");
+  c8:	00001517          	auipc	a0,0x1
+  cc:	91850513          	addi	a0,a0,-1768 # 9e0 <malloc+0x10c>
+  d0:	750000ef          	jal	820 <printf>
+    exit(1);
+  d4:	4505                	li	a0,1
+  d6:	31a000ef          	jal	3f0 <exit>
+
+00000000000000da <main>:
+
+int
+main(int argc, char *argv[])
+{
+  da:	7179                	addi	sp,sp,-48
+  dc:	f406                	sd	ra,40(sp)
+  de:	f022                	sd	s0,32(sp)
+  e0:	1800                	addi	s0,sp,48
+  int fd, i;
+
+  if(argc <= 1){
+  e2:	4785                	li	a5,1
+  e4:	04a7d463          	bge	a5,a0,12c <main+0x52>
+  e8:	ec26                	sd	s1,24(sp)
+  ea:	e84a                	sd	s2,16(sp)
+  ec:	e44e                	sd	s3,8(sp)
+  ee:	00858913          	addi	s2,a1,8
+  f2:	ffe5099b          	addiw	s3,a0,-2
+  f6:	02099793          	slli	a5,s3,0x20
+  fa:	01d7d993          	srli	s3,a5,0x1d
+  fe:	05c1                	addi	a1,a1,16
+ 100:	99ae                	add	s3,s3,a1
+    wc(0, "");
+    exit(0);
+  }
+
+  for(i = 1; i < argc; i++){
+    if((fd = open(argv[i], O_RDONLY)) < 0){
+ 102:	4581                	li	a1,0
+ 104:	00093503          	ld	a0,0(s2)
+ 108:	328000ef          	jal	430 <open>
+ 10c:	84aa                	mv	s1,a0
+ 10e:	02054c63          	bltz	a0,146 <main+0x6c>
+      printf("wc: cannot open %s\n", argv[i]);
+      exit(1);
+    }
+    wc(fd, argv[i]);
+ 112:	00093583          	ld	a1,0(s2)
+ 116:	eebff0ef          	jal	0 <wc>
+    close(fd);
+ 11a:	8526                	mv	a0,s1
+ 11c:	2fc000ef          	jal	418 <close>
+  for(i = 1; i < argc; i++){
+ 120:	0921                	addi	s2,s2,8
+ 122:	ff3910e3          	bne	s2,s3,102 <main+0x28>
+  }
+  exit(0);
+ 126:	4501                	li	a0,0
+ 128:	2c8000ef          	jal	3f0 <exit>
+ 12c:	ec26                	sd	s1,24(sp)
+ 12e:	e84a                	sd	s2,16(sp)
+ 130:	e44e                	sd	s3,8(sp)
+    wc(0, "");
+ 132:	00001597          	auipc	a1,0x1
+ 136:	8a658593          	addi	a1,a1,-1882 # 9d8 <malloc+0x104>
+ 13a:	4501                	li	a0,0
+ 13c:	ec5ff0ef          	jal	0 <wc>
+    exit(0);
+ 140:	4501                	li	a0,0
+ 142:	2ae000ef          	jal	3f0 <exit>
+      printf("wc: cannot open %s\n", argv[i]);
+ 146:	00093583          	ld	a1,0(s2)
+ 14a:	00001517          	auipc	a0,0x1
+ 14e:	8b650513          	addi	a0,a0,-1866 # a00 <malloc+0x12c>
+ 152:	6ce000ef          	jal	820 <printf>
+      exit(1);
+ 156:	4505                	li	a0,1
+ 158:	298000ef          	jal	3f0 <exit>
+
+000000000000015c <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+ 15c:	1141                	addi	sp,sp,-16
+ 15e:	e406                	sd	ra,8(sp)
+ 160:	e022                	sd	s0,0(sp)
+ 162:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+ 164:	f77ff0ef          	jal	da <main>
+  exit(r);
+ 168:	288000ef          	jal	3f0 <exit>
+
+000000000000016c <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+ 16c:	1141                	addi	sp,sp,-16
+ 16e:	e422                	sd	s0,8(sp)
+ 170:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+ 172:	87aa                	mv	a5,a0
+ 174:	0585                	addi	a1,a1,1
+ 176:	0785                	addi	a5,a5,1
+ 178:	fff5c703          	lbu	a4,-1(a1)
+ 17c:	fee78fa3          	sb	a4,-1(a5)
+ 180:	fb75                	bnez	a4,174 <strcpy+0x8>
+    ;
+  return os;
+}
+ 182:	6422                	ld	s0,8(sp)
+ 184:	0141                	addi	sp,sp,16
+ 186:	8082                	ret
+
+0000000000000188 <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+ 188:	1141                	addi	sp,sp,-16
+ 18a:	e422                	sd	s0,8(sp)
+ 18c:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+ 18e:	00054783          	lbu	a5,0(a0)
+ 192:	cb91                	beqz	a5,1a6 <strcmp+0x1e>
+ 194:	0005c703          	lbu	a4,0(a1)
+ 198:	00f71763          	bne	a4,a5,1a6 <strcmp+0x1e>
+    p++, q++;
+ 19c:	0505                	addi	a0,a0,1
+ 19e:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+ 1a0:	00054783          	lbu	a5,0(a0)
+ 1a4:	fbe5                	bnez	a5,194 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+ 1a6:	0005c503          	lbu	a0,0(a1)
+}
+ 1aa:	40a7853b          	subw	a0,a5,a0
+ 1ae:	6422                	ld	s0,8(sp)
+ 1b0:	0141                	addi	sp,sp,16
+ 1b2:	8082                	ret
+
+00000000000001b4 <strlen>:
+
+uint
+strlen(const char *s)
+{
+ 1b4:	1141                	addi	sp,sp,-16
+ 1b6:	e422                	sd	s0,8(sp)
+ 1b8:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+ 1ba:	00054783          	lbu	a5,0(a0)
+ 1be:	cf91                	beqz	a5,1da <strlen+0x26>
+ 1c0:	0505                	addi	a0,a0,1
+ 1c2:	87aa                	mv	a5,a0
+ 1c4:	86be                	mv	a3,a5
+ 1c6:	0785                	addi	a5,a5,1
+ 1c8:	fff7c703          	lbu	a4,-1(a5)
+ 1cc:	ff65                	bnez	a4,1c4 <strlen+0x10>
+ 1ce:	40a6853b          	subw	a0,a3,a0
+ 1d2:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+ 1d4:	6422                	ld	s0,8(sp)
+ 1d6:	0141                	addi	sp,sp,16
+ 1d8:	8082                	ret
+  for(n = 0; s[n]; n++)
+ 1da:	4501                	li	a0,0
+ 1dc:	bfe5                	j	1d4 <strlen+0x20>
+
+00000000000001de <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+ 1de:	1141                	addi	sp,sp,-16
+ 1e0:	e422                	sd	s0,8(sp)
+ 1e2:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+ 1e4:	ca19                	beqz	a2,1fa <memset+0x1c>
+ 1e6:	87aa                	mv	a5,a0
+ 1e8:	1602                	slli	a2,a2,0x20
+ 1ea:	9201                	srli	a2,a2,0x20
+ 1ec:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+ 1f0:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+ 1f4:	0785                	addi	a5,a5,1
+ 1f6:	fee79de3          	bne	a5,a4,1f0 <memset+0x12>
+  }
+  return dst;
+}
+ 1fa:	6422                	ld	s0,8(sp)
+ 1fc:	0141                	addi	sp,sp,16
+ 1fe:	8082                	ret
+
+0000000000000200 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+ 200:	1141                	addi	sp,sp,-16
+ 202:	e422                	sd	s0,8(sp)
+ 204:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+ 206:	00054783          	lbu	a5,0(a0)
+ 20a:	cb99                	beqz	a5,220 <strchr+0x20>
+    if(*s == c)
+ 20c:	00f58763          	beq	a1,a5,21a <strchr+0x1a>
+  for(; *s; s++)
+ 210:	0505                	addi	a0,a0,1
+ 212:	00054783          	lbu	a5,0(a0)
+ 216:	fbfd                	bnez	a5,20c <strchr+0xc>
+      return (char*)s;
+  return 0;
+ 218:	4501                	li	a0,0
+}
+ 21a:	6422                	ld	s0,8(sp)
+ 21c:	0141                	addi	sp,sp,16
+ 21e:	8082                	ret
+  return 0;
+ 220:	4501                	li	a0,0
+ 222:	bfe5                	j	21a <strchr+0x1a>
+
+0000000000000224 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+ 224:	711d                	addi	sp,sp,-96
+ 226:	ec86                	sd	ra,88(sp)
+ 228:	e8a2                	sd	s0,80(sp)
+ 22a:	e4a6                	sd	s1,72(sp)
+ 22c:	e0ca                	sd	s2,64(sp)
+ 22e:	fc4e                	sd	s3,56(sp)
+ 230:	f852                	sd	s4,48(sp)
+ 232:	f456                	sd	s5,40(sp)
+ 234:	f05a                	sd	s6,32(sp)
+ 236:	ec5e                	sd	s7,24(sp)
+ 238:	1080                	addi	s0,sp,96
+ 23a:	8baa                	mv	s7,a0
+ 23c:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 23e:	892a                	mv	s2,a0
+ 240:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 242:	4aa9                	li	s5,10
+ 244:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 246:	89a6                	mv	s3,s1
+ 248:	2485                	addiw	s1,s1,1
+ 24a:	0344d663          	bge	s1,s4,276 <gets+0x52>
+    cc = read(0, &c, 1);
+ 24e:	4605                	li	a2,1
+ 250:	faf40593          	addi	a1,s0,-81
+ 254:	4501                	li	a0,0
+ 256:	1b2000ef          	jal	408 <read>
+    if(cc < 1)
+ 25a:	00a05e63          	blez	a0,276 <gets+0x52>
+    buf[i++] = c;
+ 25e:	faf44783          	lbu	a5,-81(s0)
+ 262:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 266:	01578763          	beq	a5,s5,274 <gets+0x50>
+ 26a:	0905                	addi	s2,s2,1
+ 26c:	fd679de3          	bne	a5,s6,246 <gets+0x22>
+    buf[i++] = c;
+ 270:	89a6                	mv	s3,s1
+ 272:	a011                	j	276 <gets+0x52>
+ 274:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 276:	99de                	add	s3,s3,s7
+ 278:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 27c:	855e                	mv	a0,s7
+ 27e:	60e6                	ld	ra,88(sp)
+ 280:	6446                	ld	s0,80(sp)
+ 282:	64a6                	ld	s1,72(sp)
+ 284:	6906                	ld	s2,64(sp)
+ 286:	79e2                	ld	s3,56(sp)
+ 288:	7a42                	ld	s4,48(sp)
+ 28a:	7aa2                	ld	s5,40(sp)
+ 28c:	7b02                	ld	s6,32(sp)
+ 28e:	6be2                	ld	s7,24(sp)
+ 290:	6125                	addi	sp,sp,96
+ 292:	8082                	ret
+
+0000000000000294 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 294:	1101                	addi	sp,sp,-32
+ 296:	ec06                	sd	ra,24(sp)
+ 298:	e822                	sd	s0,16(sp)
+ 29a:	e04a                	sd	s2,0(sp)
+ 29c:	1000                	addi	s0,sp,32
+ 29e:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 2a0:	4581                	li	a1,0
+ 2a2:	18e000ef          	jal	430 <open>
+  if(fd < 0)
+ 2a6:	02054263          	bltz	a0,2ca <stat+0x36>
+ 2aa:	e426                	sd	s1,8(sp)
+ 2ac:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 2ae:	85ca                	mv	a1,s2
+ 2b0:	198000ef          	jal	448 <fstat>
+ 2b4:	892a                	mv	s2,a0
+  close(fd);
+ 2b6:	8526                	mv	a0,s1
+ 2b8:	160000ef          	jal	418 <close>
+  return r;
+ 2bc:	64a2                	ld	s1,8(sp)
+}
+ 2be:	854a                	mv	a0,s2
+ 2c0:	60e2                	ld	ra,24(sp)
+ 2c2:	6442                	ld	s0,16(sp)
+ 2c4:	6902                	ld	s2,0(sp)
+ 2c6:	6105                	addi	sp,sp,32
+ 2c8:	8082                	ret
+    return -1;
+ 2ca:	597d                	li	s2,-1
+ 2cc:	bfcd                	j	2be <stat+0x2a>
+
+00000000000002ce <atoi>:
+
+int
+atoi(const char *s)
+{
+ 2ce:	1141                	addi	sp,sp,-16
+ 2d0:	e422                	sd	s0,8(sp)
+ 2d2:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 2d4:	00054683          	lbu	a3,0(a0)
+ 2d8:	fd06879b          	addiw	a5,a3,-48
+ 2dc:	0ff7f793          	zext.b	a5,a5
+ 2e0:	4625                	li	a2,9
+ 2e2:	02f66863          	bltu	a2,a5,312 <atoi+0x44>
+ 2e6:	872a                	mv	a4,a0
+  n = 0;
+ 2e8:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 2ea:	0705                	addi	a4,a4,1
+ 2ec:	0025179b          	slliw	a5,a0,0x2
+ 2f0:	9fa9                	addw	a5,a5,a0
+ 2f2:	0017979b          	slliw	a5,a5,0x1
+ 2f6:	9fb5                	addw	a5,a5,a3
+ 2f8:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 2fc:	00074683          	lbu	a3,0(a4)
+ 300:	fd06879b          	addiw	a5,a3,-48
+ 304:	0ff7f793          	zext.b	a5,a5
+ 308:	fef671e3          	bgeu	a2,a5,2ea <atoi+0x1c>
+  return n;
+}
+ 30c:	6422                	ld	s0,8(sp)
+ 30e:	0141                	addi	sp,sp,16
+ 310:	8082                	ret
+  n = 0;
+ 312:	4501                	li	a0,0
+ 314:	bfe5                	j	30c <atoi+0x3e>
+
+0000000000000316 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 316:	1141                	addi	sp,sp,-16
+ 318:	e422                	sd	s0,8(sp)
+ 31a:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 31c:	02b57463          	bgeu	a0,a1,344 <memmove+0x2e>
+    while(n-- > 0)
+ 320:	00c05f63          	blez	a2,33e <memmove+0x28>
+ 324:	1602                	slli	a2,a2,0x20
+ 326:	9201                	srli	a2,a2,0x20
+ 328:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 32c:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 32e:	0585                	addi	a1,a1,1
+ 330:	0705                	addi	a4,a4,1
+ 332:	fff5c683          	lbu	a3,-1(a1)
+ 336:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 33a:	fef71ae3          	bne	a4,a5,32e <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 33e:	6422                	ld	s0,8(sp)
+ 340:	0141                	addi	sp,sp,16
+ 342:	8082                	ret
+    dst += n;
+ 344:	00c50733          	add	a4,a0,a2
+    src += n;
+ 348:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 34a:	fec05ae3          	blez	a2,33e <memmove+0x28>
+ 34e:	fff6079b          	addiw	a5,a2,-1
+ 352:	1782                	slli	a5,a5,0x20
+ 354:	9381                	srli	a5,a5,0x20
+ 356:	fff7c793          	not	a5,a5
+ 35a:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 35c:	15fd                	addi	a1,a1,-1
+ 35e:	177d                	addi	a4,a4,-1
+ 360:	0005c683          	lbu	a3,0(a1)
+ 364:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 368:	fee79ae3          	bne	a5,a4,35c <memmove+0x46>
+ 36c:	bfc9                	j	33e <memmove+0x28>
+
+000000000000036e <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 36e:	1141                	addi	sp,sp,-16
+ 370:	e422                	sd	s0,8(sp)
+ 372:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 374:	ca05                	beqz	a2,3a4 <memcmp+0x36>
+ 376:	fff6069b          	addiw	a3,a2,-1
+ 37a:	1682                	slli	a3,a3,0x20
+ 37c:	9281                	srli	a3,a3,0x20
+ 37e:	0685                	addi	a3,a3,1
+ 380:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 382:	00054783          	lbu	a5,0(a0)
+ 386:	0005c703          	lbu	a4,0(a1)
+ 38a:	00e79863          	bne	a5,a4,39a <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 38e:	0505                	addi	a0,a0,1
+    p2++;
+ 390:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 392:	fed518e3          	bne	a0,a3,382 <memcmp+0x14>
+  }
+  return 0;
+ 396:	4501                	li	a0,0
+ 398:	a019                	j	39e <memcmp+0x30>
+      return *p1 - *p2;
+ 39a:	40e7853b          	subw	a0,a5,a4
+}
+ 39e:	6422                	ld	s0,8(sp)
+ 3a0:	0141                	addi	sp,sp,16
+ 3a2:	8082                	ret
+  return 0;
+ 3a4:	4501                	li	a0,0
+ 3a6:	bfe5                	j	39e <memcmp+0x30>
+
+00000000000003a8 <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 3a8:	1141                	addi	sp,sp,-16
+ 3aa:	e406                	sd	ra,8(sp)
+ 3ac:	e022                	sd	s0,0(sp)
+ 3ae:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 3b0:	f67ff0ef          	jal	316 <memmove>
+}
+ 3b4:	60a2                	ld	ra,8(sp)
+ 3b6:	6402                	ld	s0,0(sp)
+ 3b8:	0141                	addi	sp,sp,16
+ 3ba:	8082                	ret
+
+00000000000003bc <sbrk>:
+
+char *
+sbrk(int n) {
+ 3bc:	1141                	addi	sp,sp,-16
+ 3be:	e406                	sd	ra,8(sp)
+ 3c0:	e022                	sd	s0,0(sp)
+ 3c2:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 3c4:	4585                	li	a1,1
+ 3c6:	0b2000ef          	jal	478 <sys_sbrk>
+}
+ 3ca:	60a2                	ld	ra,8(sp)
+ 3cc:	6402                	ld	s0,0(sp)
+ 3ce:	0141                	addi	sp,sp,16
+ 3d0:	8082                	ret
+
+00000000000003d2 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 3d2:	1141                	addi	sp,sp,-16
+ 3d4:	e406                	sd	ra,8(sp)
+ 3d6:	e022                	sd	s0,0(sp)
+ 3d8:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 3da:	4589                	li	a1,2
+ 3dc:	09c000ef          	jal	478 <sys_sbrk>
+}
+ 3e0:	60a2                	ld	ra,8(sp)
+ 3e2:	6402                	ld	s0,0(sp)
+ 3e4:	0141                	addi	sp,sp,16
+ 3e6:	8082                	ret
+
+00000000000003e8 <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 3e8:	4885                	li	a7,1
+ ecall
+ 3ea:	00000073          	ecall
+ ret
+ 3ee:	8082                	ret
+
+00000000000003f0 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 3f0:	4889                	li	a7,2
+ ecall
+ 3f2:	00000073          	ecall
+ ret
+ 3f6:	8082                	ret
+
+00000000000003f8 <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 3f8:	488d                	li	a7,3
+ ecall
+ 3fa:	00000073          	ecall
+ ret
+ 3fe:	8082                	ret
+
+0000000000000400 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 400:	4891                	li	a7,4
+ ecall
+ 402:	00000073          	ecall
+ ret
+ 406:	8082                	ret
+
+0000000000000408 <read>:
+.global read
+read:
+ li a7, SYS_read
+ 408:	4895                	li	a7,5
+ ecall
+ 40a:	00000073          	ecall
+ ret
+ 40e:	8082                	ret
+
+0000000000000410 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 410:	48c1                	li	a7,16
+ ecall
+ 412:	00000073          	ecall
+ ret
+ 416:	8082                	ret
+
+0000000000000418 <close>:
+.global close
+close:
+ li a7, SYS_close
+ 418:	48d5                	li	a7,21
+ ecall
+ 41a:	00000073          	ecall
+ ret
+ 41e:	8082                	ret
+
+0000000000000420 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 420:	4899                	li	a7,6
+ ecall
+ 422:	00000073          	ecall
+ ret
+ 426:	8082                	ret
+
+0000000000000428 <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 428:	489d                	li	a7,7
+ ecall
+ 42a:	00000073          	ecall
+ ret
+ 42e:	8082                	ret
+
+0000000000000430 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 430:	48bd                	li	a7,15
+ ecall
+ 432:	00000073          	ecall
+ ret
+ 436:	8082                	ret
+
+0000000000000438 <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 438:	48c5                	li	a7,17
+ ecall
+ 43a:	00000073          	ecall
+ ret
+ 43e:	8082                	ret
+
+0000000000000440 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 440:	48c9                	li	a7,18
+ ecall
+ 442:	00000073          	ecall
+ ret
+ 446:	8082                	ret
+
+0000000000000448 <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 448:	48a1                	li	a7,8
+ ecall
+ 44a:	00000073          	ecall
+ ret
+ 44e:	8082                	ret
+
+0000000000000450 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 450:	48cd                	li	a7,19
+ ecall
+ 452:	00000073          	ecall
+ ret
+ 456:	8082                	ret
+
+0000000000000458 <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 458:	48d1                	li	a7,20
+ ecall
+ 45a:	00000073          	ecall
+ ret
+ 45e:	8082                	ret
+
+0000000000000460 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 460:	48a5                	li	a7,9
+ ecall
+ 462:	00000073          	ecall
+ ret
+ 466:	8082                	ret
+
+0000000000000468 <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 468:	48a9                	li	a7,10
+ ecall
+ 46a:	00000073          	ecall
+ ret
+ 46e:	8082                	ret
+
+0000000000000470 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 470:	48ad                	li	a7,11
+ ecall
+ 472:	00000073          	ecall
+ ret
+ 476:	8082                	ret
+
+0000000000000478 <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 478:	48b1                	li	a7,12
+ ecall
+ 47a:	00000073          	ecall
+ ret
+ 47e:	8082                	ret
+
+0000000000000480 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 480:	48b5                	li	a7,13
+ ecall
+ 482:	00000073          	ecall
+ ret
+ 486:	8082                	ret
+
+0000000000000488 <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 488:	48b9                	li	a7,14
+ ecall
+ 48a:	00000073          	ecall
+ ret
+ 48e:	8082                	ret
+
+0000000000000490 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 490:	48d9                	li	a7,22
+ ecall
+ 492:	00000073          	ecall
+ ret
+ 496:	8082                	ret
+
+0000000000000498 <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 498:	1101                	addi	sp,sp,-32
+ 49a:	ec06                	sd	ra,24(sp)
+ 49c:	e822                	sd	s0,16(sp)
+ 49e:	1000                	addi	s0,sp,32
+ 4a0:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 4a4:	4605                	li	a2,1
+ 4a6:	fef40593          	addi	a1,s0,-17
+ 4aa:	f67ff0ef          	jal	410 <write>
+}
+ 4ae:	60e2                	ld	ra,24(sp)
+ 4b0:	6442                	ld	s0,16(sp)
+ 4b2:	6105                	addi	sp,sp,32
+ 4b4:	8082                	ret
+
+00000000000004b6 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 4b6:	715d                	addi	sp,sp,-80
+ 4b8:	e486                	sd	ra,72(sp)
+ 4ba:	e0a2                	sd	s0,64(sp)
+ 4bc:	f84a                	sd	s2,48(sp)
+ 4be:	0880                	addi	s0,sp,80
+ 4c0:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 4c2:	c299                	beqz	a3,4c8 <printint+0x12>
+ 4c4:	0805c363          	bltz	a1,54a <printint+0x94>
+  neg = 0;
+ 4c8:	4881                	li	a7,0
+ 4ca:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 4ce:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 4d0:	00000517          	auipc	a0,0x0
+ 4d4:	55050513          	addi	a0,a0,1360 # a20 <digits>
+ 4d8:	883e                	mv	a6,a5
+ 4da:	2785                	addiw	a5,a5,1
+ 4dc:	02c5f733          	remu	a4,a1,a2
+ 4e0:	972a                	add	a4,a4,a0
+ 4e2:	00074703          	lbu	a4,0(a4)
+ 4e6:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 4ea:	872e                	mv	a4,a1
+ 4ec:	02c5d5b3          	divu	a1,a1,a2
+ 4f0:	0685                	addi	a3,a3,1
+ 4f2:	fec773e3          	bgeu	a4,a2,4d8 <printint+0x22>
+  if(neg)
+ 4f6:	00088b63          	beqz	a7,50c <printint+0x56>
+    buf[i++] = '-';
+ 4fa:	fd078793          	addi	a5,a5,-48
+ 4fe:	97a2                	add	a5,a5,s0
+ 500:	02d00713          	li	a4,45
+ 504:	fee78423          	sb	a4,-24(a5)
+ 508:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 50c:	02f05a63          	blez	a5,540 <printint+0x8a>
+ 510:	fc26                	sd	s1,56(sp)
+ 512:	f44e                	sd	s3,40(sp)
+ 514:	fb840713          	addi	a4,s0,-72
+ 518:	00f704b3          	add	s1,a4,a5
+ 51c:	fff70993          	addi	s3,a4,-1
+ 520:	99be                	add	s3,s3,a5
+ 522:	37fd                	addiw	a5,a5,-1
+ 524:	1782                	slli	a5,a5,0x20
+ 526:	9381                	srli	a5,a5,0x20
+ 528:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 52c:	fff4c583          	lbu	a1,-1(s1)
+ 530:	854a                	mv	a0,s2
+ 532:	f67ff0ef          	jal	498 <putc>
+  while(--i >= 0)
+ 536:	14fd                	addi	s1,s1,-1
+ 538:	ff349ae3          	bne	s1,s3,52c <printint+0x76>
+ 53c:	74e2                	ld	s1,56(sp)
+ 53e:	79a2                	ld	s3,40(sp)
+}
+ 540:	60a6                	ld	ra,72(sp)
+ 542:	6406                	ld	s0,64(sp)
+ 544:	7942                	ld	s2,48(sp)
+ 546:	6161                	addi	sp,sp,80
+ 548:	8082                	ret
+    x = -xx;
+ 54a:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 54e:	4885                	li	a7,1
+    x = -xx;
+ 550:	bfad                	j	4ca <printint+0x14>
+
+0000000000000552 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 552:	711d                	addi	sp,sp,-96
+ 554:	ec86                	sd	ra,88(sp)
+ 556:	e8a2                	sd	s0,80(sp)
+ 558:	e0ca                	sd	s2,64(sp)
+ 55a:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 55c:	0005c903          	lbu	s2,0(a1)
+ 560:	28090663          	beqz	s2,7ec <vprintf+0x29a>
+ 564:	e4a6                	sd	s1,72(sp)
+ 566:	fc4e                	sd	s3,56(sp)
+ 568:	f852                	sd	s4,48(sp)
+ 56a:	f456                	sd	s5,40(sp)
+ 56c:	f05a                	sd	s6,32(sp)
+ 56e:	ec5e                	sd	s7,24(sp)
+ 570:	e862                	sd	s8,16(sp)
+ 572:	e466                	sd	s9,8(sp)
+ 574:	8b2a                	mv	s6,a0
+ 576:	8a2e                	mv	s4,a1
+ 578:	8bb2                	mv	s7,a2
+  state = 0;
+ 57a:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 57c:	4481                	li	s1,0
+ 57e:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 580:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 584:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 588:	06c00c93          	li	s9,108
+ 58c:	a005                	j	5ac <vprintf+0x5a>
+        putc(fd, c0);
+ 58e:	85ca                	mv	a1,s2
+ 590:	855a                	mv	a0,s6
+ 592:	f07ff0ef          	jal	498 <putc>
+ 596:	a019                	j	59c <vprintf+0x4a>
+    } else if(state == '%'){
+ 598:	03598263          	beq	s3,s5,5bc <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 59c:	2485                	addiw	s1,s1,1
+ 59e:	8726                	mv	a4,s1
+ 5a0:	009a07b3          	add	a5,s4,s1
+ 5a4:	0007c903          	lbu	s2,0(a5)
+ 5a8:	22090a63          	beqz	s2,7dc <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 5ac:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 5b0:	fe0994e3          	bnez	s3,598 <vprintf+0x46>
+      if(c0 == '%'){
+ 5b4:	fd579de3          	bne	a5,s5,58e <vprintf+0x3c>
+        state = '%';
+ 5b8:	89be                	mv	s3,a5
+ 5ba:	b7cd                	j	59c <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 5bc:	00ea06b3          	add	a3,s4,a4
+ 5c0:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 5c4:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 5c6:	c681                	beqz	a3,5ce <vprintf+0x7c>
+ 5c8:	9752                	add	a4,a4,s4
+ 5ca:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 5ce:	05878363          	beq	a5,s8,614 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 5d2:	05978d63          	beq	a5,s9,62c <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 5d6:	07500713          	li	a4,117
+ 5da:	0ee78763          	beq	a5,a4,6c8 <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 5de:	07800713          	li	a4,120
+ 5e2:	12e78963          	beq	a5,a4,714 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 5e6:	07000713          	li	a4,112
+ 5ea:	14e78e63          	beq	a5,a4,746 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 5ee:	06300713          	li	a4,99
+ 5f2:	18e78e63          	beq	a5,a4,78e <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 5f6:	07300713          	li	a4,115
+ 5fa:	1ae78463          	beq	a5,a4,7a2 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 5fe:	02500713          	li	a4,37
+ 602:	04e79563          	bne	a5,a4,64c <vprintf+0xfa>
+        putc(fd, '%');
+ 606:	02500593          	li	a1,37
+ 60a:	855a                	mv	a0,s6
+ 60c:	e8dff0ef          	jal	498 <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 610:	4981                	li	s3,0
+ 612:	b769                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 614:	008b8913          	addi	s2,s7,8
+ 618:	4685                	li	a3,1
+ 61a:	4629                	li	a2,10
+ 61c:	000ba583          	lw	a1,0(s7)
+ 620:	855a                	mv	a0,s6
+ 622:	e95ff0ef          	jal	4b6 <printint>
+ 626:	8bca                	mv	s7,s2
+      state = 0;
+ 628:	4981                	li	s3,0
+ 62a:	bf8d                	j	59c <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 62c:	06400793          	li	a5,100
+ 630:	02f68963          	beq	a3,a5,662 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 634:	06c00793          	li	a5,108
+ 638:	04f68263          	beq	a3,a5,67c <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 63c:	07500793          	li	a5,117
+ 640:	0af68063          	beq	a3,a5,6e0 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 644:	07800793          	li	a5,120
+ 648:	0ef68263          	beq	a3,a5,72c <vprintf+0x1da>
+        putc(fd, '%');
+ 64c:	02500593          	li	a1,37
+ 650:	855a                	mv	a0,s6
+ 652:	e47ff0ef          	jal	498 <putc>
+        putc(fd, c0);
+ 656:	85ca                	mv	a1,s2
+ 658:	855a                	mv	a0,s6
+ 65a:	e3fff0ef          	jal	498 <putc>
+      state = 0;
+ 65e:	4981                	li	s3,0
+ 660:	bf35                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 662:	008b8913          	addi	s2,s7,8
+ 666:	4685                	li	a3,1
+ 668:	4629                	li	a2,10
+ 66a:	000bb583          	ld	a1,0(s7)
+ 66e:	855a                	mv	a0,s6
+ 670:	e47ff0ef          	jal	4b6 <printint>
+        i += 1;
+ 674:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 676:	8bca                	mv	s7,s2
+      state = 0;
+ 678:	4981                	li	s3,0
+        i += 1;
+ 67a:	b70d                	j	59c <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 67c:	06400793          	li	a5,100
+ 680:	02f60763          	beq	a2,a5,6ae <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 684:	07500793          	li	a5,117
+ 688:	06f60963          	beq	a2,a5,6fa <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 68c:	07800793          	li	a5,120
+ 690:	faf61ee3          	bne	a2,a5,64c <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 694:	008b8913          	addi	s2,s7,8
+ 698:	4681                	li	a3,0
+ 69a:	4641                	li	a2,16
+ 69c:	000bb583          	ld	a1,0(s7)
+ 6a0:	855a                	mv	a0,s6
+ 6a2:	e15ff0ef          	jal	4b6 <printint>
+        i += 2;
+ 6a6:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 6a8:	8bca                	mv	s7,s2
+      state = 0;
+ 6aa:	4981                	li	s3,0
+        i += 2;
+ 6ac:	bdc5                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 6ae:	008b8913          	addi	s2,s7,8
+ 6b2:	4685                	li	a3,1
+ 6b4:	4629                	li	a2,10
+ 6b6:	000bb583          	ld	a1,0(s7)
+ 6ba:	855a                	mv	a0,s6
+ 6bc:	dfbff0ef          	jal	4b6 <printint>
+        i += 2;
+ 6c0:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 6c2:	8bca                	mv	s7,s2
+      state = 0;
+ 6c4:	4981                	li	s3,0
+        i += 2;
+ 6c6:	bdd9                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 6c8:	008b8913          	addi	s2,s7,8
+ 6cc:	4681                	li	a3,0
+ 6ce:	4629                	li	a2,10
+ 6d0:	000be583          	lwu	a1,0(s7)
+ 6d4:	855a                	mv	a0,s6
+ 6d6:	de1ff0ef          	jal	4b6 <printint>
+ 6da:	8bca                	mv	s7,s2
+      state = 0;
+ 6dc:	4981                	li	s3,0
+ 6de:	bd7d                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 6e0:	008b8913          	addi	s2,s7,8
+ 6e4:	4681                	li	a3,0
+ 6e6:	4629                	li	a2,10
+ 6e8:	000bb583          	ld	a1,0(s7)
+ 6ec:	855a                	mv	a0,s6
+ 6ee:	dc9ff0ef          	jal	4b6 <printint>
+        i += 1;
+ 6f2:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 6f4:	8bca                	mv	s7,s2
+      state = 0;
+ 6f6:	4981                	li	s3,0
+        i += 1;
+ 6f8:	b555                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 6fa:	008b8913          	addi	s2,s7,8
+ 6fe:	4681                	li	a3,0
+ 700:	4629                	li	a2,10
+ 702:	000bb583          	ld	a1,0(s7)
+ 706:	855a                	mv	a0,s6
+ 708:	dafff0ef          	jal	4b6 <printint>
+        i += 2;
+ 70c:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 70e:	8bca                	mv	s7,s2
+      state = 0;
+ 710:	4981                	li	s3,0
+        i += 2;
+ 712:	b569                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 714:	008b8913          	addi	s2,s7,8
+ 718:	4681                	li	a3,0
+ 71a:	4641                	li	a2,16
+ 71c:	000be583          	lwu	a1,0(s7)
+ 720:	855a                	mv	a0,s6
+ 722:	d95ff0ef          	jal	4b6 <printint>
+ 726:	8bca                	mv	s7,s2
+      state = 0;
+ 728:	4981                	li	s3,0
+ 72a:	bd8d                	j	59c <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 72c:	008b8913          	addi	s2,s7,8
+ 730:	4681                	li	a3,0
+ 732:	4641                	li	a2,16
+ 734:	000bb583          	ld	a1,0(s7)
+ 738:	855a                	mv	a0,s6
+ 73a:	d7dff0ef          	jal	4b6 <printint>
+        i += 1;
+ 73e:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 740:	8bca                	mv	s7,s2
+      state = 0;
+ 742:	4981                	li	s3,0
+        i += 1;
+ 744:	bda1                	j	59c <vprintf+0x4a>
+ 746:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 748:	008b8d13          	addi	s10,s7,8
+ 74c:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 750:	03000593          	li	a1,48
+ 754:	855a                	mv	a0,s6
+ 756:	d43ff0ef          	jal	498 <putc>
+  putc(fd, 'x');
+ 75a:	07800593          	li	a1,120
+ 75e:	855a                	mv	a0,s6
+ 760:	d39ff0ef          	jal	498 <putc>
+ 764:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 766:	00000b97          	auipc	s7,0x0
+ 76a:	2bab8b93          	addi	s7,s7,698 # a20 <digits>
+ 76e:	03c9d793          	srli	a5,s3,0x3c
+ 772:	97de                	add	a5,a5,s7
+ 774:	0007c583          	lbu	a1,0(a5)
+ 778:	855a                	mv	a0,s6
+ 77a:	d1fff0ef          	jal	498 <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 77e:	0992                	slli	s3,s3,0x4
+ 780:	397d                	addiw	s2,s2,-1
+ 782:	fe0916e3          	bnez	s2,76e <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 786:	8bea                	mv	s7,s10
+      state = 0;
+ 788:	4981                	li	s3,0
+ 78a:	6d02                	ld	s10,0(sp)
+ 78c:	bd01                	j	59c <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 78e:	008b8913          	addi	s2,s7,8
+ 792:	000bc583          	lbu	a1,0(s7)
+ 796:	855a                	mv	a0,s6
+ 798:	d01ff0ef          	jal	498 <putc>
+ 79c:	8bca                	mv	s7,s2
+      state = 0;
+ 79e:	4981                	li	s3,0
+ 7a0:	bbf5                	j	59c <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 7a2:	008b8993          	addi	s3,s7,8
+ 7a6:	000bb903          	ld	s2,0(s7)
+ 7aa:	00090f63          	beqz	s2,7c8 <vprintf+0x276>
+        for(; *s; s++)
+ 7ae:	00094583          	lbu	a1,0(s2)
+ 7b2:	c195                	beqz	a1,7d6 <vprintf+0x284>
+          putc(fd, *s);
+ 7b4:	855a                	mv	a0,s6
+ 7b6:	ce3ff0ef          	jal	498 <putc>
+        for(; *s; s++)
+ 7ba:	0905                	addi	s2,s2,1
+ 7bc:	00094583          	lbu	a1,0(s2)
+ 7c0:	f9f5                	bnez	a1,7b4 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 7c2:	8bce                	mv	s7,s3
+      state = 0;
+ 7c4:	4981                	li	s3,0
+ 7c6:	bbd9                	j	59c <vprintf+0x4a>
+          s = "(null)";
+ 7c8:	00000917          	auipc	s2,0x0
+ 7cc:	25090913          	addi	s2,s2,592 # a18 <malloc+0x144>
+        for(; *s; s++)
+ 7d0:	02800593          	li	a1,40
+ 7d4:	b7c5                	j	7b4 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 7d6:	8bce                	mv	s7,s3
+      state = 0;
+ 7d8:	4981                	li	s3,0
+ 7da:	b3c9                	j	59c <vprintf+0x4a>
+ 7dc:	64a6                	ld	s1,72(sp)
+ 7de:	79e2                	ld	s3,56(sp)
+ 7e0:	7a42                	ld	s4,48(sp)
+ 7e2:	7aa2                	ld	s5,40(sp)
+ 7e4:	7b02                	ld	s6,32(sp)
+ 7e6:	6be2                	ld	s7,24(sp)
+ 7e8:	6c42                	ld	s8,16(sp)
+ 7ea:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 7ec:	60e6                	ld	ra,88(sp)
+ 7ee:	6446                	ld	s0,80(sp)
+ 7f0:	6906                	ld	s2,64(sp)
+ 7f2:	6125                	addi	sp,sp,96
+ 7f4:	8082                	ret
+
+00000000000007f6 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 7f6:	715d                	addi	sp,sp,-80
+ 7f8:	ec06                	sd	ra,24(sp)
+ 7fa:	e822                	sd	s0,16(sp)
+ 7fc:	1000                	addi	s0,sp,32
+ 7fe:	e010                	sd	a2,0(s0)
+ 800:	e414                	sd	a3,8(s0)
+ 802:	e818                	sd	a4,16(s0)
+ 804:	ec1c                	sd	a5,24(s0)
+ 806:	03043023          	sd	a6,32(s0)
+ 80a:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 80e:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 812:	8622                	mv	a2,s0
+ 814:	d3fff0ef          	jal	552 <vprintf>
+}
+ 818:	60e2                	ld	ra,24(sp)
+ 81a:	6442                	ld	s0,16(sp)
+ 81c:	6161                	addi	sp,sp,80
+ 81e:	8082                	ret
+
+0000000000000820 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 820:	711d                	addi	sp,sp,-96
+ 822:	ec06                	sd	ra,24(sp)
+ 824:	e822                	sd	s0,16(sp)
+ 826:	1000                	addi	s0,sp,32
+ 828:	e40c                	sd	a1,8(s0)
+ 82a:	e810                	sd	a2,16(s0)
+ 82c:	ec14                	sd	a3,24(s0)
+ 82e:	f018                	sd	a4,32(s0)
+ 830:	f41c                	sd	a5,40(s0)
+ 832:	03043823          	sd	a6,48(s0)
+ 836:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 83a:	00840613          	addi	a2,s0,8
+ 83e:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 842:	85aa                	mv	a1,a0
+ 844:	4505                	li	a0,1
+ 846:	d0dff0ef          	jal	552 <vprintf>
+}
+ 84a:	60e2                	ld	ra,24(sp)
+ 84c:	6442                	ld	s0,16(sp)
+ 84e:	6125                	addi	sp,sp,96
+ 850:	8082                	ret
+
+0000000000000852 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 852:	1141                	addi	sp,sp,-16
+ 854:	e422                	sd	s0,8(sp)
+ 856:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 858:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 85c:	00000797          	auipc	a5,0x0
+ 860:	7a47b783          	ld	a5,1956(a5) # 1000 <freep>
+ 864:	a02d                	j	88e <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 866:	4618                	lw	a4,8(a2)
+ 868:	9f2d                	addw	a4,a4,a1
+ 86a:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 86e:	6398                	ld	a4,0(a5)
+ 870:	6310                	ld	a2,0(a4)
+ 872:	a83d                	j	8b0 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 874:	ff852703          	lw	a4,-8(a0)
+ 878:	9f31                	addw	a4,a4,a2
+ 87a:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 87c:	ff053683          	ld	a3,-16(a0)
+ 880:	a091                	j	8c4 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 882:	6398                	ld	a4,0(a5)
+ 884:	00e7e463          	bltu	a5,a4,88c <free+0x3a>
+ 888:	00e6ea63          	bltu	a3,a4,89c <free+0x4a>
+{
+ 88c:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 88e:	fed7fae3          	bgeu	a5,a3,882 <free+0x30>
+ 892:	6398                	ld	a4,0(a5)
+ 894:	00e6e463          	bltu	a3,a4,89c <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 898:	fee7eae3          	bltu	a5,a4,88c <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 89c:	ff852583          	lw	a1,-8(a0)
+ 8a0:	6390                	ld	a2,0(a5)
+ 8a2:	02059813          	slli	a6,a1,0x20
+ 8a6:	01c85713          	srli	a4,a6,0x1c
+ 8aa:	9736                	add	a4,a4,a3
+ 8ac:	fae60de3          	beq	a2,a4,866 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 8b0:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 8b4:	4790                	lw	a2,8(a5)
+ 8b6:	02061593          	slli	a1,a2,0x20
+ 8ba:	01c5d713          	srli	a4,a1,0x1c
+ 8be:	973e                	add	a4,a4,a5
+ 8c0:	fae68ae3          	beq	a3,a4,874 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 8c4:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 8c6:	00000717          	auipc	a4,0x0
+ 8ca:	72f73d23          	sd	a5,1850(a4) # 1000 <freep>
+}
+ 8ce:	6422                	ld	s0,8(sp)
+ 8d0:	0141                	addi	sp,sp,16
+ 8d2:	8082                	ret
+
+00000000000008d4 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 8d4:	7139                	addi	sp,sp,-64
+ 8d6:	fc06                	sd	ra,56(sp)
+ 8d8:	f822                	sd	s0,48(sp)
+ 8da:	f426                	sd	s1,40(sp)
+ 8dc:	ec4e                	sd	s3,24(sp)
+ 8de:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 8e0:	02051493          	slli	s1,a0,0x20
+ 8e4:	9081                	srli	s1,s1,0x20
+ 8e6:	04bd                	addi	s1,s1,15
+ 8e8:	8091                	srli	s1,s1,0x4
+ 8ea:	0014899b          	addiw	s3,s1,1
+ 8ee:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 8f0:	00000517          	auipc	a0,0x0
+ 8f4:	71053503          	ld	a0,1808(a0) # 1000 <freep>
+ 8f8:	c915                	beqz	a0,92c <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 8fa:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 8fc:	4798                	lw	a4,8(a5)
+ 8fe:	08977a63          	bgeu	a4,s1,992 <malloc+0xbe>
+ 902:	f04a                	sd	s2,32(sp)
+ 904:	e852                	sd	s4,16(sp)
+ 906:	e456                	sd	s5,8(sp)
+ 908:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 90a:	8a4e                	mv	s4,s3
+ 90c:	0009871b          	sext.w	a4,s3
+ 910:	6685                	lui	a3,0x1
+ 912:	00d77363          	bgeu	a4,a3,918 <malloc+0x44>
+ 916:	6a05                	lui	s4,0x1
+ 918:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 91c:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 920:	00000917          	auipc	s2,0x0
+ 924:	6e090913          	addi	s2,s2,1760 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 928:	5afd                	li	s5,-1
+ 92a:	a081                	j	96a <malloc+0x96>
+ 92c:	f04a                	sd	s2,32(sp)
+ 92e:	e852                	sd	s4,16(sp)
+ 930:	e456                	sd	s5,8(sp)
+ 932:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 934:	00001797          	auipc	a5,0x1
+ 938:	8dc78793          	addi	a5,a5,-1828 # 1210 <base>
+ 93c:	00000717          	auipc	a4,0x0
+ 940:	6cf73223          	sd	a5,1732(a4) # 1000 <freep>
+ 944:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 946:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 94a:	b7c1                	j	90a <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 94c:	6398                	ld	a4,0(a5)
+ 94e:	e118                	sd	a4,0(a0)
+ 950:	a8a9                	j	9aa <malloc+0xd6>
+  hp->s.size = nu;
+ 952:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 956:	0541                	addi	a0,a0,16
+ 958:	efbff0ef          	jal	852 <free>
+  return freep;
+ 95c:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 960:	c12d                	beqz	a0,9c2 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 962:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 964:	4798                	lw	a4,8(a5)
+ 966:	02977263          	bgeu	a4,s1,98a <malloc+0xb6>
+    if(p == freep)
+ 96a:	00093703          	ld	a4,0(s2)
+ 96e:	853e                	mv	a0,a5
+ 970:	fef719e3          	bne	a4,a5,962 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 974:	8552                	mv	a0,s4
+ 976:	a47ff0ef          	jal	3bc <sbrk>
+  if(p == SBRK_ERROR)
+ 97a:	fd551ce3          	bne	a0,s5,952 <malloc+0x7e>
+        return 0;
+ 97e:	4501                	li	a0,0
+ 980:	7902                	ld	s2,32(sp)
+ 982:	6a42                	ld	s4,16(sp)
+ 984:	6aa2                	ld	s5,8(sp)
+ 986:	6b02                	ld	s6,0(sp)
+ 988:	a03d                	j	9b6 <malloc+0xe2>
+ 98a:	7902                	ld	s2,32(sp)
+ 98c:	6a42                	ld	s4,16(sp)
+ 98e:	6aa2                	ld	s5,8(sp)
+ 990:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 992:	fae48de3          	beq	s1,a4,94c <malloc+0x78>
+        p->s.size -= nunits;
+ 996:	4137073b          	subw	a4,a4,s3
+ 99a:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 99c:	02071693          	slli	a3,a4,0x20
+ 9a0:	01c6d713          	srli	a4,a3,0x1c
+ 9a4:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 9a6:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 9aa:	00000717          	auipc	a4,0x0
+ 9ae:	64a73b23          	sd	a0,1622(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 9b2:	01078513          	addi	a0,a5,16
+  }
+}
+ 9b6:	70e2                	ld	ra,56(sp)
+ 9b8:	7442                	ld	s0,48(sp)
+ 9ba:	74a2                	ld	s1,40(sp)
+ 9bc:	69e2                	ld	s3,24(sp)
+ 9be:	6121                	addi	sp,sp,64
+ 9c0:	8082                	ret
+ 9c2:	7902                	ld	s2,32(sp)
+ 9c4:	6a42                	ld	s4,16(sp)
+ 9c6:	6aa2                	ld	s5,8(sp)
+ 9c8:	6b02                	ld	s6,0(sp)
+ 9ca:	b7f5                	j	9b6 <malloc+0xe2>
diff -ruN xv6-riscv/user/wc.d xv62/user/wc.d
--- xv6-riscv/user/wc.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/wc.d	2025-09-14 12:32:52.060883072 +0000
@@ -0,0 +1,2 @@
+user/wc.o: user/wc.c kernel/types.h kernel/stat.h kernel/fcntl.h \
+ user/user.h
Binary files xv6-riscv/user/wc.o and xv62/user/wc.o differ
diff -ruN xv6-riscv/user/wc.sym xv62/user/wc.sym
--- xv6-riscv/user/wc.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/wc.sym	2025-09-14 12:32:52.080883068 +0000
@@ -0,0 +1,68 @@
+0000000000000000 .text
+00000000000009d0 .rodata
+0000000000000a38 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 wc.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+0000000000000498 putc
+00000000000004b6 printint
+0000000000000a20 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001210 base
+000000000000016c strcpy
+0000000000000480 pause
+0000000000000820 printf
+0000000000000478 sys_sbrk
+0000000000000316 memmove
+0000000000000438 mknod
+0000000000000224 gets
+0000000000000470 getpid
+00000000000003a8 memcpy
+00000000000008d4 malloc
+00000000000003d2 sbrklazy
+0000000000000400 pipe
+0000000000000410 write
+0000000000000448 fstat
+00000000000007f6 fprintf
+0000000000000420 kill
+0000000000000552 vprintf
+0000000000000460 chdir
+0000000000000428 exec
+00000000000003f8 wait
+0000000000000408 read
+0000000000000440 unlink
+0000000000000000 wc
+000000000000036e memcmp
+00000000000003e8 fork
+00000000000003bc sbrk
+0000000000000488 uptime
+00000000000001de memset
+00000000000000da main
+0000000000000188 strcmp
+0000000000000468 dup
+0000000000001010 buf
+0000000000000490 getreadcount
+0000000000000294 stat
+0000000000000450 link
+00000000000003f0 exit
+000000000000015c start
+00000000000002ce atoi
+00000000000001b4 strlen
+0000000000000430 open
+0000000000000200 strchr
+0000000000000458 mkdir
+0000000000000418 close
+0000000000000852 free
diff -ruN xv6-riscv/user/zombie.asm xv62/user/zombie.asm
--- xv6-riscv/user/zombie.asm	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/zombie.asm	2025-09-14 12:32:52.128883058 +0000
@@ -0,0 +1,1481 @@
+
+user/_zombie:     file format elf64-littleriscv
+
+
+Disassembly of section .text:
+
+0000000000000000 <main>:
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(void)
+{
+   0:	1141                	addi	sp,sp,-16
+   2:	e406                	sd	ra,8(sp)
+   4:	e022                	sd	s0,0(sp)
+   6:	0800                	addi	s0,sp,16
+  if(fork() > 0)
+   8:	2a2000ef          	jal	2aa <fork>
+   c:	00a04563          	bgtz	a0,16 <main+0x16>
+    pause(5);  // Let child exit before parent.
+  exit(0);
+  10:	4501                	li	a0,0
+  12:	2a0000ef          	jal	2b2 <exit>
+    pause(5);  // Let child exit before parent.
+  16:	4515                	li	a0,5
+  18:	32a000ef          	jal	342 <pause>
+  1c:	bfd5                	j	10 <main+0x10>
+
+000000000000001e <start>:
+//
+// wrapper so that it's OK if main() does not call exit().
+//
+void
+start(int argc, char **argv)
+{
+  1e:	1141                	addi	sp,sp,-16
+  20:	e406                	sd	ra,8(sp)
+  22:	e022                	sd	s0,0(sp)
+  24:	0800                	addi	s0,sp,16
+  int r;
+  extern int main(int argc, char **argv);
+  r = main(argc, argv);
+  26:	fdbff0ef          	jal	0 <main>
+  exit(r);
+  2a:	288000ef          	jal	2b2 <exit>
+
+000000000000002e <strcpy>:
+}
+
+char*
+strcpy(char *s, const char *t)
+{
+  2e:	1141                	addi	sp,sp,-16
+  30:	e422                	sd	s0,8(sp)
+  32:	0800                	addi	s0,sp,16
+  char *os;
+
+  os = s;
+  while((*s++ = *t++) != 0)
+  34:	87aa                	mv	a5,a0
+  36:	0585                	addi	a1,a1,1
+  38:	0785                	addi	a5,a5,1
+  3a:	fff5c703          	lbu	a4,-1(a1)
+  3e:	fee78fa3          	sb	a4,-1(a5)
+  42:	fb75                	bnez	a4,36 <strcpy+0x8>
+    ;
+  return os;
+}
+  44:	6422                	ld	s0,8(sp)
+  46:	0141                	addi	sp,sp,16
+  48:	8082                	ret
+
+000000000000004a <strcmp>:
+
+int
+strcmp(const char *p, const char *q)
+{
+  4a:	1141                	addi	sp,sp,-16
+  4c:	e422                	sd	s0,8(sp)
+  4e:	0800                	addi	s0,sp,16
+  while(*p && *p == *q)
+  50:	00054783          	lbu	a5,0(a0)
+  54:	cb91                	beqz	a5,68 <strcmp+0x1e>
+  56:	0005c703          	lbu	a4,0(a1)
+  5a:	00f71763          	bne	a4,a5,68 <strcmp+0x1e>
+    p++, q++;
+  5e:	0505                	addi	a0,a0,1
+  60:	0585                	addi	a1,a1,1
+  while(*p && *p == *q)
+  62:	00054783          	lbu	a5,0(a0)
+  66:	fbe5                	bnez	a5,56 <strcmp+0xc>
+  return (uchar)*p - (uchar)*q;
+  68:	0005c503          	lbu	a0,0(a1)
+}
+  6c:	40a7853b          	subw	a0,a5,a0
+  70:	6422                	ld	s0,8(sp)
+  72:	0141                	addi	sp,sp,16
+  74:	8082                	ret
+
+0000000000000076 <strlen>:
+
+uint
+strlen(const char *s)
+{
+  76:	1141                	addi	sp,sp,-16
+  78:	e422                	sd	s0,8(sp)
+  7a:	0800                	addi	s0,sp,16
+  int n;
+
+  for(n = 0; s[n]; n++)
+  7c:	00054783          	lbu	a5,0(a0)
+  80:	cf91                	beqz	a5,9c <strlen+0x26>
+  82:	0505                	addi	a0,a0,1
+  84:	87aa                	mv	a5,a0
+  86:	86be                	mv	a3,a5
+  88:	0785                	addi	a5,a5,1
+  8a:	fff7c703          	lbu	a4,-1(a5)
+  8e:	ff65                	bnez	a4,86 <strlen+0x10>
+  90:	40a6853b          	subw	a0,a3,a0
+  94:	2505                	addiw	a0,a0,1
+    ;
+  return n;
+}
+  96:	6422                	ld	s0,8(sp)
+  98:	0141                	addi	sp,sp,16
+  9a:	8082                	ret
+  for(n = 0; s[n]; n++)
+  9c:	4501                	li	a0,0
+  9e:	bfe5                	j	96 <strlen+0x20>
+
+00000000000000a0 <memset>:
+
+void*
+memset(void *dst, int c, uint n)
+{
+  a0:	1141                	addi	sp,sp,-16
+  a2:	e422                	sd	s0,8(sp)
+  a4:	0800                	addi	s0,sp,16
+  char *cdst = (char *) dst;
+  int i;
+  for(i = 0; i < n; i++){
+  a6:	ca19                	beqz	a2,bc <memset+0x1c>
+  a8:	87aa                	mv	a5,a0
+  aa:	1602                	slli	a2,a2,0x20
+  ac:	9201                	srli	a2,a2,0x20
+  ae:	00a60733          	add	a4,a2,a0
+    cdst[i] = c;
+  b2:	00b78023          	sb	a1,0(a5)
+  for(i = 0; i < n; i++){
+  b6:	0785                	addi	a5,a5,1
+  b8:	fee79de3          	bne	a5,a4,b2 <memset+0x12>
+  }
+  return dst;
+}
+  bc:	6422                	ld	s0,8(sp)
+  be:	0141                	addi	sp,sp,16
+  c0:	8082                	ret
+
+00000000000000c2 <strchr>:
+
+char*
+strchr(const char *s, char c)
+{
+  c2:	1141                	addi	sp,sp,-16
+  c4:	e422                	sd	s0,8(sp)
+  c6:	0800                	addi	s0,sp,16
+  for(; *s; s++)
+  c8:	00054783          	lbu	a5,0(a0)
+  cc:	cb99                	beqz	a5,e2 <strchr+0x20>
+    if(*s == c)
+  ce:	00f58763          	beq	a1,a5,dc <strchr+0x1a>
+  for(; *s; s++)
+  d2:	0505                	addi	a0,a0,1
+  d4:	00054783          	lbu	a5,0(a0)
+  d8:	fbfd                	bnez	a5,ce <strchr+0xc>
+      return (char*)s;
+  return 0;
+  da:	4501                	li	a0,0
+}
+  dc:	6422                	ld	s0,8(sp)
+  de:	0141                	addi	sp,sp,16
+  e0:	8082                	ret
+  return 0;
+  e2:	4501                	li	a0,0
+  e4:	bfe5                	j	dc <strchr+0x1a>
+
+00000000000000e6 <gets>:
+
+char*
+gets(char *buf, int max)
+{
+  e6:	711d                	addi	sp,sp,-96
+  e8:	ec86                	sd	ra,88(sp)
+  ea:	e8a2                	sd	s0,80(sp)
+  ec:	e4a6                	sd	s1,72(sp)
+  ee:	e0ca                	sd	s2,64(sp)
+  f0:	fc4e                	sd	s3,56(sp)
+  f2:	f852                	sd	s4,48(sp)
+  f4:	f456                	sd	s5,40(sp)
+  f6:	f05a                	sd	s6,32(sp)
+  f8:	ec5e                	sd	s7,24(sp)
+  fa:	1080                	addi	s0,sp,96
+  fc:	8baa                	mv	s7,a0
+  fe:	8a2e                	mv	s4,a1
+  int i, cc;
+  char c;
+
+  for(i=0; i+1 < max; ){
+ 100:	892a                	mv	s2,a0
+ 102:	4481                	li	s1,0
+    cc = read(0, &c, 1);
+    if(cc < 1)
+      break;
+    buf[i++] = c;
+    if(c == '\n' || c == '\r')
+ 104:	4aa9                	li	s5,10
+ 106:	4b35                	li	s6,13
+  for(i=0; i+1 < max; ){
+ 108:	89a6                	mv	s3,s1
+ 10a:	2485                	addiw	s1,s1,1
+ 10c:	0344d663          	bge	s1,s4,138 <gets+0x52>
+    cc = read(0, &c, 1);
+ 110:	4605                	li	a2,1
+ 112:	faf40593          	addi	a1,s0,-81
+ 116:	4501                	li	a0,0
+ 118:	1b2000ef          	jal	2ca <read>
+    if(cc < 1)
+ 11c:	00a05e63          	blez	a0,138 <gets+0x52>
+    buf[i++] = c;
+ 120:	faf44783          	lbu	a5,-81(s0)
+ 124:	00f90023          	sb	a5,0(s2)
+    if(c == '\n' || c == '\r')
+ 128:	01578763          	beq	a5,s5,136 <gets+0x50>
+ 12c:	0905                	addi	s2,s2,1
+ 12e:	fd679de3          	bne	a5,s6,108 <gets+0x22>
+    buf[i++] = c;
+ 132:	89a6                	mv	s3,s1
+ 134:	a011                	j	138 <gets+0x52>
+ 136:	89a6                	mv	s3,s1
+      break;
+  }
+  buf[i] = '\0';
+ 138:	99de                	add	s3,s3,s7
+ 13a:	00098023          	sb	zero,0(s3)
+  return buf;
+}
+ 13e:	855e                	mv	a0,s7
+ 140:	60e6                	ld	ra,88(sp)
+ 142:	6446                	ld	s0,80(sp)
+ 144:	64a6                	ld	s1,72(sp)
+ 146:	6906                	ld	s2,64(sp)
+ 148:	79e2                	ld	s3,56(sp)
+ 14a:	7a42                	ld	s4,48(sp)
+ 14c:	7aa2                	ld	s5,40(sp)
+ 14e:	7b02                	ld	s6,32(sp)
+ 150:	6be2                	ld	s7,24(sp)
+ 152:	6125                	addi	sp,sp,96
+ 154:	8082                	ret
+
+0000000000000156 <stat>:
+
+int
+stat(const char *n, struct stat *st)
+{
+ 156:	1101                	addi	sp,sp,-32
+ 158:	ec06                	sd	ra,24(sp)
+ 15a:	e822                	sd	s0,16(sp)
+ 15c:	e04a                	sd	s2,0(sp)
+ 15e:	1000                	addi	s0,sp,32
+ 160:	892e                	mv	s2,a1
+  int fd;
+  int r;
+
+  fd = open(n, O_RDONLY);
+ 162:	4581                	li	a1,0
+ 164:	18e000ef          	jal	2f2 <open>
+  if(fd < 0)
+ 168:	02054263          	bltz	a0,18c <stat+0x36>
+ 16c:	e426                	sd	s1,8(sp)
+ 16e:	84aa                	mv	s1,a0
+    return -1;
+  r = fstat(fd, st);
+ 170:	85ca                	mv	a1,s2
+ 172:	198000ef          	jal	30a <fstat>
+ 176:	892a                	mv	s2,a0
+  close(fd);
+ 178:	8526                	mv	a0,s1
+ 17a:	160000ef          	jal	2da <close>
+  return r;
+ 17e:	64a2                	ld	s1,8(sp)
+}
+ 180:	854a                	mv	a0,s2
+ 182:	60e2                	ld	ra,24(sp)
+ 184:	6442                	ld	s0,16(sp)
+ 186:	6902                	ld	s2,0(sp)
+ 188:	6105                	addi	sp,sp,32
+ 18a:	8082                	ret
+    return -1;
+ 18c:	597d                	li	s2,-1
+ 18e:	bfcd                	j	180 <stat+0x2a>
+
+0000000000000190 <atoi>:
+
+int
+atoi(const char *s)
+{
+ 190:	1141                	addi	sp,sp,-16
+ 192:	e422                	sd	s0,8(sp)
+ 194:	0800                	addi	s0,sp,16
+  int n;
+
+  n = 0;
+  while('0' <= *s && *s <= '9')
+ 196:	00054683          	lbu	a3,0(a0)
+ 19a:	fd06879b          	addiw	a5,a3,-48
+ 19e:	0ff7f793          	zext.b	a5,a5
+ 1a2:	4625                	li	a2,9
+ 1a4:	02f66863          	bltu	a2,a5,1d4 <atoi+0x44>
+ 1a8:	872a                	mv	a4,a0
+  n = 0;
+ 1aa:	4501                	li	a0,0
+    n = n*10 + *s++ - '0';
+ 1ac:	0705                	addi	a4,a4,1
+ 1ae:	0025179b          	slliw	a5,a0,0x2
+ 1b2:	9fa9                	addw	a5,a5,a0
+ 1b4:	0017979b          	slliw	a5,a5,0x1
+ 1b8:	9fb5                	addw	a5,a5,a3
+ 1ba:	fd07851b          	addiw	a0,a5,-48
+  while('0' <= *s && *s <= '9')
+ 1be:	00074683          	lbu	a3,0(a4)
+ 1c2:	fd06879b          	addiw	a5,a3,-48
+ 1c6:	0ff7f793          	zext.b	a5,a5
+ 1ca:	fef671e3          	bgeu	a2,a5,1ac <atoi+0x1c>
+  return n;
+}
+ 1ce:	6422                	ld	s0,8(sp)
+ 1d0:	0141                	addi	sp,sp,16
+ 1d2:	8082                	ret
+  n = 0;
+ 1d4:	4501                	li	a0,0
+ 1d6:	bfe5                	j	1ce <atoi+0x3e>
+
+00000000000001d8 <memmove>:
+
+void*
+memmove(void *vdst, const void *vsrc, int n)
+{
+ 1d8:	1141                	addi	sp,sp,-16
+ 1da:	e422                	sd	s0,8(sp)
+ 1dc:	0800                	addi	s0,sp,16
+  char *dst;
+  const char *src;
+
+  dst = vdst;
+  src = vsrc;
+  if (src > dst) {
+ 1de:	02b57463          	bgeu	a0,a1,206 <memmove+0x2e>
+    while(n-- > 0)
+ 1e2:	00c05f63          	blez	a2,200 <memmove+0x28>
+ 1e6:	1602                	slli	a2,a2,0x20
+ 1e8:	9201                	srli	a2,a2,0x20
+ 1ea:	00c507b3          	add	a5,a0,a2
+  dst = vdst;
+ 1ee:	872a                	mv	a4,a0
+      *dst++ = *src++;
+ 1f0:	0585                	addi	a1,a1,1
+ 1f2:	0705                	addi	a4,a4,1
+ 1f4:	fff5c683          	lbu	a3,-1(a1)
+ 1f8:	fed70fa3          	sb	a3,-1(a4)
+    while(n-- > 0)
+ 1fc:	fef71ae3          	bne	a4,a5,1f0 <memmove+0x18>
+    src += n;
+    while(n-- > 0)
+      *--dst = *--src;
+  }
+  return vdst;
+}
+ 200:	6422                	ld	s0,8(sp)
+ 202:	0141                	addi	sp,sp,16
+ 204:	8082                	ret
+    dst += n;
+ 206:	00c50733          	add	a4,a0,a2
+    src += n;
+ 20a:	95b2                	add	a1,a1,a2
+    while(n-- > 0)
+ 20c:	fec05ae3          	blez	a2,200 <memmove+0x28>
+ 210:	fff6079b          	addiw	a5,a2,-1
+ 214:	1782                	slli	a5,a5,0x20
+ 216:	9381                	srli	a5,a5,0x20
+ 218:	fff7c793          	not	a5,a5
+ 21c:	97ba                	add	a5,a5,a4
+      *--dst = *--src;
+ 21e:	15fd                	addi	a1,a1,-1
+ 220:	177d                	addi	a4,a4,-1
+ 222:	0005c683          	lbu	a3,0(a1)
+ 226:	00d70023          	sb	a3,0(a4)
+    while(n-- > 0)
+ 22a:	fee79ae3          	bne	a5,a4,21e <memmove+0x46>
+ 22e:	bfc9                	j	200 <memmove+0x28>
+
+0000000000000230 <memcmp>:
+
+int
+memcmp(const void *s1, const void *s2, uint n)
+{
+ 230:	1141                	addi	sp,sp,-16
+ 232:	e422                	sd	s0,8(sp)
+ 234:	0800                	addi	s0,sp,16
+  const char *p1 = s1, *p2 = s2;
+  while (n-- > 0) {
+ 236:	ca05                	beqz	a2,266 <memcmp+0x36>
+ 238:	fff6069b          	addiw	a3,a2,-1
+ 23c:	1682                	slli	a3,a3,0x20
+ 23e:	9281                	srli	a3,a3,0x20
+ 240:	0685                	addi	a3,a3,1
+ 242:	96aa                	add	a3,a3,a0
+    if (*p1 != *p2) {
+ 244:	00054783          	lbu	a5,0(a0)
+ 248:	0005c703          	lbu	a4,0(a1)
+ 24c:	00e79863          	bne	a5,a4,25c <memcmp+0x2c>
+      return *p1 - *p2;
+    }
+    p1++;
+ 250:	0505                	addi	a0,a0,1
+    p2++;
+ 252:	0585                	addi	a1,a1,1
+  while (n-- > 0) {
+ 254:	fed518e3          	bne	a0,a3,244 <memcmp+0x14>
+  }
+  return 0;
+ 258:	4501                	li	a0,0
+ 25a:	a019                	j	260 <memcmp+0x30>
+      return *p1 - *p2;
+ 25c:	40e7853b          	subw	a0,a5,a4
+}
+ 260:	6422                	ld	s0,8(sp)
+ 262:	0141                	addi	sp,sp,16
+ 264:	8082                	ret
+  return 0;
+ 266:	4501                	li	a0,0
+ 268:	bfe5                	j	260 <memcmp+0x30>
+
+000000000000026a <memcpy>:
+
+void *
+memcpy(void *dst, const void *src, uint n)
+{
+ 26a:	1141                	addi	sp,sp,-16
+ 26c:	e406                	sd	ra,8(sp)
+ 26e:	e022                	sd	s0,0(sp)
+ 270:	0800                	addi	s0,sp,16
+  return memmove(dst, src, n);
+ 272:	f67ff0ef          	jal	1d8 <memmove>
+}
+ 276:	60a2                	ld	ra,8(sp)
+ 278:	6402                	ld	s0,0(sp)
+ 27a:	0141                	addi	sp,sp,16
+ 27c:	8082                	ret
+
+000000000000027e <sbrk>:
+
+char *
+sbrk(int n) {
+ 27e:	1141                	addi	sp,sp,-16
+ 280:	e406                	sd	ra,8(sp)
+ 282:	e022                	sd	s0,0(sp)
+ 284:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_EAGER);
+ 286:	4585                	li	a1,1
+ 288:	0b2000ef          	jal	33a <sys_sbrk>
+}
+ 28c:	60a2                	ld	ra,8(sp)
+ 28e:	6402                	ld	s0,0(sp)
+ 290:	0141                	addi	sp,sp,16
+ 292:	8082                	ret
+
+0000000000000294 <sbrklazy>:
+
+char *
+sbrklazy(int n) {
+ 294:	1141                	addi	sp,sp,-16
+ 296:	e406                	sd	ra,8(sp)
+ 298:	e022                	sd	s0,0(sp)
+ 29a:	0800                	addi	s0,sp,16
+  return sys_sbrk(n, SBRK_LAZY);
+ 29c:	4589                	li	a1,2
+ 29e:	09c000ef          	jal	33a <sys_sbrk>
+}
+ 2a2:	60a2                	ld	ra,8(sp)
+ 2a4:	6402                	ld	s0,0(sp)
+ 2a6:	0141                	addi	sp,sp,16
+ 2a8:	8082                	ret
+
+00000000000002aa <fork>:
+# generated by usys.pl - do not edit
+#include "kernel/syscall.h"
+.global fork
+fork:
+ li a7, SYS_fork
+ 2aa:	4885                	li	a7,1
+ ecall
+ 2ac:	00000073          	ecall
+ ret
+ 2b0:	8082                	ret
+
+00000000000002b2 <exit>:
+.global exit
+exit:
+ li a7, SYS_exit
+ 2b2:	4889                	li	a7,2
+ ecall
+ 2b4:	00000073          	ecall
+ ret
+ 2b8:	8082                	ret
+
+00000000000002ba <wait>:
+.global wait
+wait:
+ li a7, SYS_wait
+ 2ba:	488d                	li	a7,3
+ ecall
+ 2bc:	00000073          	ecall
+ ret
+ 2c0:	8082                	ret
+
+00000000000002c2 <pipe>:
+.global pipe
+pipe:
+ li a7, SYS_pipe
+ 2c2:	4891                	li	a7,4
+ ecall
+ 2c4:	00000073          	ecall
+ ret
+ 2c8:	8082                	ret
+
+00000000000002ca <read>:
+.global read
+read:
+ li a7, SYS_read
+ 2ca:	4895                	li	a7,5
+ ecall
+ 2cc:	00000073          	ecall
+ ret
+ 2d0:	8082                	ret
+
+00000000000002d2 <write>:
+.global write
+write:
+ li a7, SYS_write
+ 2d2:	48c1                	li	a7,16
+ ecall
+ 2d4:	00000073          	ecall
+ ret
+ 2d8:	8082                	ret
+
+00000000000002da <close>:
+.global close
+close:
+ li a7, SYS_close
+ 2da:	48d5                	li	a7,21
+ ecall
+ 2dc:	00000073          	ecall
+ ret
+ 2e0:	8082                	ret
+
+00000000000002e2 <kill>:
+.global kill
+kill:
+ li a7, SYS_kill
+ 2e2:	4899                	li	a7,6
+ ecall
+ 2e4:	00000073          	ecall
+ ret
+ 2e8:	8082                	ret
+
+00000000000002ea <exec>:
+.global exec
+exec:
+ li a7, SYS_exec
+ 2ea:	489d                	li	a7,7
+ ecall
+ 2ec:	00000073          	ecall
+ ret
+ 2f0:	8082                	ret
+
+00000000000002f2 <open>:
+.global open
+open:
+ li a7, SYS_open
+ 2f2:	48bd                	li	a7,15
+ ecall
+ 2f4:	00000073          	ecall
+ ret
+ 2f8:	8082                	ret
+
+00000000000002fa <mknod>:
+.global mknod
+mknod:
+ li a7, SYS_mknod
+ 2fa:	48c5                	li	a7,17
+ ecall
+ 2fc:	00000073          	ecall
+ ret
+ 300:	8082                	ret
+
+0000000000000302 <unlink>:
+.global unlink
+unlink:
+ li a7, SYS_unlink
+ 302:	48c9                	li	a7,18
+ ecall
+ 304:	00000073          	ecall
+ ret
+ 308:	8082                	ret
+
+000000000000030a <fstat>:
+.global fstat
+fstat:
+ li a7, SYS_fstat
+ 30a:	48a1                	li	a7,8
+ ecall
+ 30c:	00000073          	ecall
+ ret
+ 310:	8082                	ret
+
+0000000000000312 <link>:
+.global link
+link:
+ li a7, SYS_link
+ 312:	48cd                	li	a7,19
+ ecall
+ 314:	00000073          	ecall
+ ret
+ 318:	8082                	ret
+
+000000000000031a <mkdir>:
+.global mkdir
+mkdir:
+ li a7, SYS_mkdir
+ 31a:	48d1                	li	a7,20
+ ecall
+ 31c:	00000073          	ecall
+ ret
+ 320:	8082                	ret
+
+0000000000000322 <chdir>:
+.global chdir
+chdir:
+ li a7, SYS_chdir
+ 322:	48a5                	li	a7,9
+ ecall
+ 324:	00000073          	ecall
+ ret
+ 328:	8082                	ret
+
+000000000000032a <dup>:
+.global dup
+dup:
+ li a7, SYS_dup
+ 32a:	48a9                	li	a7,10
+ ecall
+ 32c:	00000073          	ecall
+ ret
+ 330:	8082                	ret
+
+0000000000000332 <getpid>:
+.global getpid
+getpid:
+ li a7, SYS_getpid
+ 332:	48ad                	li	a7,11
+ ecall
+ 334:	00000073          	ecall
+ ret
+ 338:	8082                	ret
+
+000000000000033a <sys_sbrk>:
+.global sys_sbrk
+sys_sbrk:
+ li a7, SYS_sbrk
+ 33a:	48b1                	li	a7,12
+ ecall
+ 33c:	00000073          	ecall
+ ret
+ 340:	8082                	ret
+
+0000000000000342 <pause>:
+.global pause
+pause:
+ li a7, SYS_pause
+ 342:	48b5                	li	a7,13
+ ecall
+ 344:	00000073          	ecall
+ ret
+ 348:	8082                	ret
+
+000000000000034a <uptime>:
+.global uptime
+uptime:
+ li a7, SYS_uptime
+ 34a:	48b9                	li	a7,14
+ ecall
+ 34c:	00000073          	ecall
+ ret
+ 350:	8082                	ret
+
+0000000000000352 <getreadcount>:
+.global getreadcount
+getreadcount:
+ li a7, SYS_getreadcount
+ 352:	48d9                	li	a7,22
+ ecall
+ 354:	00000073          	ecall
+ ret
+ 358:	8082                	ret
+
+000000000000035a <putc>:
+
+static char digits[] = "0123456789ABCDEF";
+
+static void
+putc(int fd, char c)
+{
+ 35a:	1101                	addi	sp,sp,-32
+ 35c:	ec06                	sd	ra,24(sp)
+ 35e:	e822                	sd	s0,16(sp)
+ 360:	1000                	addi	s0,sp,32
+ 362:	feb407a3          	sb	a1,-17(s0)
+  write(fd, &c, 1);
+ 366:	4605                	li	a2,1
+ 368:	fef40593          	addi	a1,s0,-17
+ 36c:	f67ff0ef          	jal	2d2 <write>
+}
+ 370:	60e2                	ld	ra,24(sp)
+ 372:	6442                	ld	s0,16(sp)
+ 374:	6105                	addi	sp,sp,32
+ 376:	8082                	ret
+
+0000000000000378 <printint>:
+
+static void
+printint(int fd, long long xx, int base, int sgn)
+{
+ 378:	715d                	addi	sp,sp,-80
+ 37a:	e486                	sd	ra,72(sp)
+ 37c:	e0a2                	sd	s0,64(sp)
+ 37e:	f84a                	sd	s2,48(sp)
+ 380:	0880                	addi	s0,sp,80
+ 382:	892a                	mv	s2,a0
+  char buf[20];
+  int i, neg;
+  unsigned long long x;
+
+  neg = 0;
+  if(sgn && xx < 0){
+ 384:	c299                	beqz	a3,38a <printint+0x12>
+ 386:	0805c363          	bltz	a1,40c <printint+0x94>
+  neg = 0;
+ 38a:	4881                	li	a7,0
+ 38c:	fb840693          	addi	a3,s0,-72
+    x = -xx;
+  } else {
+    x = xx;
+  }
+
+  i = 0;
+ 390:	4781                	li	a5,0
+  do{
+    buf[i++] = digits[x % base];
+ 392:	00000517          	auipc	a0,0x0
+ 396:	50650513          	addi	a0,a0,1286 # 898 <digits>
+ 39a:	883e                	mv	a6,a5
+ 39c:	2785                	addiw	a5,a5,1
+ 39e:	02c5f733          	remu	a4,a1,a2
+ 3a2:	972a                	add	a4,a4,a0
+ 3a4:	00074703          	lbu	a4,0(a4)
+ 3a8:	00e68023          	sb	a4,0(a3)
+  }while((x /= base) != 0);
+ 3ac:	872e                	mv	a4,a1
+ 3ae:	02c5d5b3          	divu	a1,a1,a2
+ 3b2:	0685                	addi	a3,a3,1
+ 3b4:	fec773e3          	bgeu	a4,a2,39a <printint+0x22>
+  if(neg)
+ 3b8:	00088b63          	beqz	a7,3ce <printint+0x56>
+    buf[i++] = '-';
+ 3bc:	fd078793          	addi	a5,a5,-48
+ 3c0:	97a2                	add	a5,a5,s0
+ 3c2:	02d00713          	li	a4,45
+ 3c6:	fee78423          	sb	a4,-24(a5)
+ 3ca:	0028079b          	addiw	a5,a6,2
+
+  while(--i >= 0)
+ 3ce:	02f05a63          	blez	a5,402 <printint+0x8a>
+ 3d2:	fc26                	sd	s1,56(sp)
+ 3d4:	f44e                	sd	s3,40(sp)
+ 3d6:	fb840713          	addi	a4,s0,-72
+ 3da:	00f704b3          	add	s1,a4,a5
+ 3de:	fff70993          	addi	s3,a4,-1
+ 3e2:	99be                	add	s3,s3,a5
+ 3e4:	37fd                	addiw	a5,a5,-1
+ 3e6:	1782                	slli	a5,a5,0x20
+ 3e8:	9381                	srli	a5,a5,0x20
+ 3ea:	40f989b3          	sub	s3,s3,a5
+    putc(fd, buf[i]);
+ 3ee:	fff4c583          	lbu	a1,-1(s1)
+ 3f2:	854a                	mv	a0,s2
+ 3f4:	f67ff0ef          	jal	35a <putc>
+  while(--i >= 0)
+ 3f8:	14fd                	addi	s1,s1,-1
+ 3fa:	ff349ae3          	bne	s1,s3,3ee <printint+0x76>
+ 3fe:	74e2                	ld	s1,56(sp)
+ 400:	79a2                	ld	s3,40(sp)
+}
+ 402:	60a6                	ld	ra,72(sp)
+ 404:	6406                	ld	s0,64(sp)
+ 406:	7942                	ld	s2,48(sp)
+ 408:	6161                	addi	sp,sp,80
+ 40a:	8082                	ret
+    x = -xx;
+ 40c:	40b005b3          	neg	a1,a1
+    neg = 1;
+ 410:	4885                	li	a7,1
+    x = -xx;
+ 412:	bfad                	j	38c <printint+0x14>
+
+0000000000000414 <vprintf>:
+}
+
+// Print to the given fd. Only understands %d, %x, %p, %c, %s.
+void
+vprintf(int fd, const char *fmt, va_list ap)
+{
+ 414:	711d                	addi	sp,sp,-96
+ 416:	ec86                	sd	ra,88(sp)
+ 418:	e8a2                	sd	s0,80(sp)
+ 41a:	e0ca                	sd	s2,64(sp)
+ 41c:	1080                	addi	s0,sp,96
+  char *s;
+  int c0, c1, c2, i, state;
+
+  state = 0;
+  for(i = 0; fmt[i]; i++){
+ 41e:	0005c903          	lbu	s2,0(a1)
+ 422:	28090663          	beqz	s2,6ae <vprintf+0x29a>
+ 426:	e4a6                	sd	s1,72(sp)
+ 428:	fc4e                	sd	s3,56(sp)
+ 42a:	f852                	sd	s4,48(sp)
+ 42c:	f456                	sd	s5,40(sp)
+ 42e:	f05a                	sd	s6,32(sp)
+ 430:	ec5e                	sd	s7,24(sp)
+ 432:	e862                	sd	s8,16(sp)
+ 434:	e466                	sd	s9,8(sp)
+ 436:	8b2a                	mv	s6,a0
+ 438:	8a2e                	mv	s4,a1
+ 43a:	8bb2                	mv	s7,a2
+  state = 0;
+ 43c:	4981                	li	s3,0
+  for(i = 0; fmt[i]; i++){
+ 43e:	4481                	li	s1,0
+ 440:	4701                	li	a4,0
+      if(c0 == '%'){
+        state = '%';
+      } else {
+        putc(fd, c0);
+      }
+    } else if(state == '%'){
+ 442:	02500a93          	li	s5,37
+      c1 = c2 = 0;
+      if(c0) c1 = fmt[i+1] & 0xff;
+      if(c1) c2 = fmt[i+2] & 0xff;
+      if(c0 == 'd'){
+ 446:	06400c13          	li	s8,100
+        printint(fd, va_arg(ap, int), 10, 1);
+      } else if(c0 == 'l' && c1 == 'd'){
+ 44a:	06c00c93          	li	s9,108
+ 44e:	a005                	j	46e <vprintf+0x5a>
+        putc(fd, c0);
+ 450:	85ca                	mv	a1,s2
+ 452:	855a                	mv	a0,s6
+ 454:	f07ff0ef          	jal	35a <putc>
+ 458:	a019                	j	45e <vprintf+0x4a>
+    } else if(state == '%'){
+ 45a:	03598263          	beq	s3,s5,47e <vprintf+0x6a>
+  for(i = 0; fmt[i]; i++){
+ 45e:	2485                	addiw	s1,s1,1
+ 460:	8726                	mv	a4,s1
+ 462:	009a07b3          	add	a5,s4,s1
+ 466:	0007c903          	lbu	s2,0(a5)
+ 46a:	22090a63          	beqz	s2,69e <vprintf+0x28a>
+    c0 = fmt[i] & 0xff;
+ 46e:	0009079b          	sext.w	a5,s2
+    if(state == 0){
+ 472:	fe0994e3          	bnez	s3,45a <vprintf+0x46>
+      if(c0 == '%'){
+ 476:	fd579de3          	bne	a5,s5,450 <vprintf+0x3c>
+        state = '%';
+ 47a:	89be                	mv	s3,a5
+ 47c:	b7cd                	j	45e <vprintf+0x4a>
+      if(c0) c1 = fmt[i+1] & 0xff;
+ 47e:	00ea06b3          	add	a3,s4,a4
+ 482:	0016c683          	lbu	a3,1(a3)
+      c1 = c2 = 0;
+ 486:	8636                	mv	a2,a3
+      if(c1) c2 = fmt[i+2] & 0xff;
+ 488:	c681                	beqz	a3,490 <vprintf+0x7c>
+ 48a:	9752                	add	a4,a4,s4
+ 48c:	00274603          	lbu	a2,2(a4)
+      if(c0 == 'd'){
+ 490:	05878363          	beq	a5,s8,4d6 <vprintf+0xc2>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 494:	05978d63          	beq	a5,s9,4ee <vprintf+0xda>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+        printint(fd, va_arg(ap, uint64), 10, 1);
+        i += 2;
+      } else if(c0 == 'u'){
+ 498:	07500713          	li	a4,117
+ 49c:	0ee78763          	beq	a5,a4,58a <vprintf+0x176>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+        printint(fd, va_arg(ap, uint64), 10, 0);
+        i += 2;
+      } else if(c0 == 'x'){
+ 4a0:	07800713          	li	a4,120
+ 4a4:	12e78963          	beq	a5,a4,5d6 <vprintf+0x1c2>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 1;
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+        printint(fd, va_arg(ap, uint64), 16, 0);
+        i += 2;
+      } else if(c0 == 'p'){
+ 4a8:	07000713          	li	a4,112
+ 4ac:	14e78e63          	beq	a5,a4,608 <vprintf+0x1f4>
+        printptr(fd, va_arg(ap, uint64));
+      } else if(c0 == 'c'){
+ 4b0:	06300713          	li	a4,99
+ 4b4:	18e78e63          	beq	a5,a4,650 <vprintf+0x23c>
+        putc(fd, va_arg(ap, uint32));
+      } else if(c0 == 's'){
+ 4b8:	07300713          	li	a4,115
+ 4bc:	1ae78463          	beq	a5,a4,664 <vprintf+0x250>
+        if((s = va_arg(ap, char*)) == 0)
+          s = "(null)";
+        for(; *s; s++)
+          putc(fd, *s);
+      } else if(c0 == '%'){
+ 4c0:	02500713          	li	a4,37
+ 4c4:	04e79563          	bne	a5,a4,50e <vprintf+0xfa>
+        putc(fd, '%');
+ 4c8:	02500593          	li	a1,37
+ 4cc:	855a                	mv	a0,s6
+ 4ce:	e8dff0ef          	jal	35a <putc>
+        // Unknown % sequence.  Print it to draw attention.
+        putc(fd, '%');
+        putc(fd, c0);
+      }
+
+      state = 0;
+ 4d2:	4981                	li	s3,0
+ 4d4:	b769                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, int), 10, 1);
+ 4d6:	008b8913          	addi	s2,s7,8
+ 4da:	4685                	li	a3,1
+ 4dc:	4629                	li	a2,10
+ 4de:	000ba583          	lw	a1,0(s7)
+ 4e2:	855a                	mv	a0,s6
+ 4e4:	e95ff0ef          	jal	378 <printint>
+ 4e8:	8bca                	mv	s7,s2
+      state = 0;
+ 4ea:	4981                	li	s3,0
+ 4ec:	bf8d                	j	45e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'd'){
+ 4ee:	06400793          	li	a5,100
+ 4f2:	02f68963          	beq	a3,a5,524 <vprintf+0x110>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 4f6:	06c00793          	li	a5,108
+ 4fa:	04f68263          	beq	a3,a5,53e <vprintf+0x12a>
+      } else if(c0 == 'l' && c1 == 'u'){
+ 4fe:	07500793          	li	a5,117
+ 502:	0af68063          	beq	a3,a5,5a2 <vprintf+0x18e>
+      } else if(c0 == 'l' && c1 == 'x'){
+ 506:	07800793          	li	a5,120
+ 50a:	0ef68263          	beq	a3,a5,5ee <vprintf+0x1da>
+        putc(fd, '%');
+ 50e:	02500593          	li	a1,37
+ 512:	855a                	mv	a0,s6
+ 514:	e47ff0ef          	jal	35a <putc>
+        putc(fd, c0);
+ 518:	85ca                	mv	a1,s2
+ 51a:	855a                	mv	a0,s6
+ 51c:	e3fff0ef          	jal	35a <putc>
+      state = 0;
+ 520:	4981                	li	s3,0
+ 522:	bf35                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 524:	008b8913          	addi	s2,s7,8
+ 528:	4685                	li	a3,1
+ 52a:	4629                	li	a2,10
+ 52c:	000bb583          	ld	a1,0(s7)
+ 530:	855a                	mv	a0,s6
+ 532:	e47ff0ef          	jal	378 <printint>
+        i += 1;
+ 536:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 538:	8bca                	mv	s7,s2
+      state = 0;
+ 53a:	4981                	li	s3,0
+        i += 1;
+ 53c:	b70d                	j	45e <vprintf+0x4a>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'd'){
+ 53e:	06400793          	li	a5,100
+ 542:	02f60763          	beq	a2,a5,570 <vprintf+0x15c>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'u'){
+ 546:	07500793          	li	a5,117
+ 54a:	06f60963          	beq	a2,a5,5bc <vprintf+0x1a8>
+      } else if(c0 == 'l' && c1 == 'l' && c2 == 'x'){
+ 54e:	07800793          	li	a5,120
+ 552:	faf61ee3          	bne	a2,a5,50e <vprintf+0xfa>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 556:	008b8913          	addi	s2,s7,8
+ 55a:	4681                	li	a3,0
+ 55c:	4641                	li	a2,16
+ 55e:	000bb583          	ld	a1,0(s7)
+ 562:	855a                	mv	a0,s6
+ 564:	e15ff0ef          	jal	378 <printint>
+        i += 2;
+ 568:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 56a:	8bca                	mv	s7,s2
+      state = 0;
+ 56c:	4981                	li	s3,0
+        i += 2;
+ 56e:	bdc5                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 570:	008b8913          	addi	s2,s7,8
+ 574:	4685                	li	a3,1
+ 576:	4629                	li	a2,10
+ 578:	000bb583          	ld	a1,0(s7)
+ 57c:	855a                	mv	a0,s6
+ 57e:	dfbff0ef          	jal	378 <printint>
+        i += 2;
+ 582:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 1);
+ 584:	8bca                	mv	s7,s2
+      state = 0;
+ 586:	4981                	li	s3,0
+        i += 2;
+ 588:	bdd9                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 10, 0);
+ 58a:	008b8913          	addi	s2,s7,8
+ 58e:	4681                	li	a3,0
+ 590:	4629                	li	a2,10
+ 592:	000be583          	lwu	a1,0(s7)
+ 596:	855a                	mv	a0,s6
+ 598:	de1ff0ef          	jal	378 <printint>
+ 59c:	8bca                	mv	s7,s2
+      state = 0;
+ 59e:	4981                	li	s3,0
+ 5a0:	bd7d                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5a2:	008b8913          	addi	s2,s7,8
+ 5a6:	4681                	li	a3,0
+ 5a8:	4629                	li	a2,10
+ 5aa:	000bb583          	ld	a1,0(s7)
+ 5ae:	855a                	mv	a0,s6
+ 5b0:	dc9ff0ef          	jal	378 <printint>
+        i += 1;
+ 5b4:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5b6:	8bca                	mv	s7,s2
+      state = 0;
+ 5b8:	4981                	li	s3,0
+        i += 1;
+ 5ba:	b555                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5bc:	008b8913          	addi	s2,s7,8
+ 5c0:	4681                	li	a3,0
+ 5c2:	4629                	li	a2,10
+ 5c4:	000bb583          	ld	a1,0(s7)
+ 5c8:	855a                	mv	a0,s6
+ 5ca:	dafff0ef          	jal	378 <printint>
+        i += 2;
+ 5ce:	2489                	addiw	s1,s1,2
+        printint(fd, va_arg(ap, uint64), 10, 0);
+ 5d0:	8bca                	mv	s7,s2
+      state = 0;
+ 5d2:	4981                	li	s3,0
+        i += 2;
+ 5d4:	b569                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint32), 16, 0);
+ 5d6:	008b8913          	addi	s2,s7,8
+ 5da:	4681                	li	a3,0
+ 5dc:	4641                	li	a2,16
+ 5de:	000be583          	lwu	a1,0(s7)
+ 5e2:	855a                	mv	a0,s6
+ 5e4:	d95ff0ef          	jal	378 <printint>
+ 5e8:	8bca                	mv	s7,s2
+      state = 0;
+ 5ea:	4981                	li	s3,0
+ 5ec:	bd8d                	j	45e <vprintf+0x4a>
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 5ee:	008b8913          	addi	s2,s7,8
+ 5f2:	4681                	li	a3,0
+ 5f4:	4641                	li	a2,16
+ 5f6:	000bb583          	ld	a1,0(s7)
+ 5fa:	855a                	mv	a0,s6
+ 5fc:	d7dff0ef          	jal	378 <printint>
+        i += 1;
+ 600:	2485                	addiw	s1,s1,1
+        printint(fd, va_arg(ap, uint64), 16, 0);
+ 602:	8bca                	mv	s7,s2
+      state = 0;
+ 604:	4981                	li	s3,0
+        i += 1;
+ 606:	bda1                	j	45e <vprintf+0x4a>
+ 608:	e06a                	sd	s10,0(sp)
+        printptr(fd, va_arg(ap, uint64));
+ 60a:	008b8d13          	addi	s10,s7,8
+ 60e:	000bb983          	ld	s3,0(s7)
+  putc(fd, '0');
+ 612:	03000593          	li	a1,48
+ 616:	855a                	mv	a0,s6
+ 618:	d43ff0ef          	jal	35a <putc>
+  putc(fd, 'x');
+ 61c:	07800593          	li	a1,120
+ 620:	855a                	mv	a0,s6
+ 622:	d39ff0ef          	jal	35a <putc>
+ 626:	4941                	li	s2,16
+    putc(fd, digits[x >> (sizeof(uint64) * 8 - 4)]);
+ 628:	00000b97          	auipc	s7,0x0
+ 62c:	270b8b93          	addi	s7,s7,624 # 898 <digits>
+ 630:	03c9d793          	srli	a5,s3,0x3c
+ 634:	97de                	add	a5,a5,s7
+ 636:	0007c583          	lbu	a1,0(a5)
+ 63a:	855a                	mv	a0,s6
+ 63c:	d1fff0ef          	jal	35a <putc>
+  for (i = 0; i < (sizeof(uint64) * 2); i++, x <<= 4)
+ 640:	0992                	slli	s3,s3,0x4
+ 642:	397d                	addiw	s2,s2,-1
+ 644:	fe0916e3          	bnez	s2,630 <vprintf+0x21c>
+        printptr(fd, va_arg(ap, uint64));
+ 648:	8bea                	mv	s7,s10
+      state = 0;
+ 64a:	4981                	li	s3,0
+ 64c:	6d02                	ld	s10,0(sp)
+ 64e:	bd01                	j	45e <vprintf+0x4a>
+        putc(fd, va_arg(ap, uint32));
+ 650:	008b8913          	addi	s2,s7,8
+ 654:	000bc583          	lbu	a1,0(s7)
+ 658:	855a                	mv	a0,s6
+ 65a:	d01ff0ef          	jal	35a <putc>
+ 65e:	8bca                	mv	s7,s2
+      state = 0;
+ 660:	4981                	li	s3,0
+ 662:	bbf5                	j	45e <vprintf+0x4a>
+        if((s = va_arg(ap, char*)) == 0)
+ 664:	008b8993          	addi	s3,s7,8
+ 668:	000bb903          	ld	s2,0(s7)
+ 66c:	00090f63          	beqz	s2,68a <vprintf+0x276>
+        for(; *s; s++)
+ 670:	00094583          	lbu	a1,0(s2)
+ 674:	c195                	beqz	a1,698 <vprintf+0x284>
+          putc(fd, *s);
+ 676:	855a                	mv	a0,s6
+ 678:	ce3ff0ef          	jal	35a <putc>
+        for(; *s; s++)
+ 67c:	0905                	addi	s2,s2,1
+ 67e:	00094583          	lbu	a1,0(s2)
+ 682:	f9f5                	bnez	a1,676 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 684:	8bce                	mv	s7,s3
+      state = 0;
+ 686:	4981                	li	s3,0
+ 688:	bbd9                	j	45e <vprintf+0x4a>
+          s = "(null)";
+ 68a:	00000917          	auipc	s2,0x0
+ 68e:	20690913          	addi	s2,s2,518 # 890 <malloc+0xfa>
+        for(; *s; s++)
+ 692:	02800593          	li	a1,40
+ 696:	b7c5                	j	676 <vprintf+0x262>
+        if((s = va_arg(ap, char*)) == 0)
+ 698:	8bce                	mv	s7,s3
+      state = 0;
+ 69a:	4981                	li	s3,0
+ 69c:	b3c9                	j	45e <vprintf+0x4a>
+ 69e:	64a6                	ld	s1,72(sp)
+ 6a0:	79e2                	ld	s3,56(sp)
+ 6a2:	7a42                	ld	s4,48(sp)
+ 6a4:	7aa2                	ld	s5,40(sp)
+ 6a6:	7b02                	ld	s6,32(sp)
+ 6a8:	6be2                	ld	s7,24(sp)
+ 6aa:	6c42                	ld	s8,16(sp)
+ 6ac:	6ca2                	ld	s9,8(sp)
+    }
+  }
+}
+ 6ae:	60e6                	ld	ra,88(sp)
+ 6b0:	6446                	ld	s0,80(sp)
+ 6b2:	6906                	ld	s2,64(sp)
+ 6b4:	6125                	addi	sp,sp,96
+ 6b6:	8082                	ret
+
+00000000000006b8 <fprintf>:
+
+void
+fprintf(int fd, const char *fmt, ...)
+{
+ 6b8:	715d                	addi	sp,sp,-80
+ 6ba:	ec06                	sd	ra,24(sp)
+ 6bc:	e822                	sd	s0,16(sp)
+ 6be:	1000                	addi	s0,sp,32
+ 6c0:	e010                	sd	a2,0(s0)
+ 6c2:	e414                	sd	a3,8(s0)
+ 6c4:	e818                	sd	a4,16(s0)
+ 6c6:	ec1c                	sd	a5,24(s0)
+ 6c8:	03043023          	sd	a6,32(s0)
+ 6cc:	03143423          	sd	a7,40(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 6d0:	fe843423          	sd	s0,-24(s0)
+  vprintf(fd, fmt, ap);
+ 6d4:	8622                	mv	a2,s0
+ 6d6:	d3fff0ef          	jal	414 <vprintf>
+}
+ 6da:	60e2                	ld	ra,24(sp)
+ 6dc:	6442                	ld	s0,16(sp)
+ 6de:	6161                	addi	sp,sp,80
+ 6e0:	8082                	ret
+
+00000000000006e2 <printf>:
+
+void
+printf(const char *fmt, ...)
+{
+ 6e2:	711d                	addi	sp,sp,-96
+ 6e4:	ec06                	sd	ra,24(sp)
+ 6e6:	e822                	sd	s0,16(sp)
+ 6e8:	1000                	addi	s0,sp,32
+ 6ea:	e40c                	sd	a1,8(s0)
+ 6ec:	e810                	sd	a2,16(s0)
+ 6ee:	ec14                	sd	a3,24(s0)
+ 6f0:	f018                	sd	a4,32(s0)
+ 6f2:	f41c                	sd	a5,40(s0)
+ 6f4:	03043823          	sd	a6,48(s0)
+ 6f8:	03143c23          	sd	a7,56(s0)
+  va_list ap;
+
+  va_start(ap, fmt);
+ 6fc:	00840613          	addi	a2,s0,8
+ 700:	fec43423          	sd	a2,-24(s0)
+  vprintf(1, fmt, ap);
+ 704:	85aa                	mv	a1,a0
+ 706:	4505                	li	a0,1
+ 708:	d0dff0ef          	jal	414 <vprintf>
+}
+ 70c:	60e2                	ld	ra,24(sp)
+ 70e:	6442                	ld	s0,16(sp)
+ 710:	6125                	addi	sp,sp,96
+ 712:	8082                	ret
+
+0000000000000714 <free>:
+static Header base;
+static Header *freep;
+
+void
+free(void *ap)
+{
+ 714:	1141                	addi	sp,sp,-16
+ 716:	e422                	sd	s0,8(sp)
+ 718:	0800                	addi	s0,sp,16
+  Header *bp, *p;
+
+  bp = (Header*)ap - 1;
+ 71a:	ff050693          	addi	a3,a0,-16
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 71e:	00001797          	auipc	a5,0x1
+ 722:	8e27b783          	ld	a5,-1822(a5) # 1000 <freep>
+ 726:	a02d                	j	750 <free+0x3c>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+      break;
+  if(bp + bp->s.size == p->s.ptr){
+    bp->s.size += p->s.ptr->s.size;
+ 728:	4618                	lw	a4,8(a2)
+ 72a:	9f2d                	addw	a4,a4,a1
+ 72c:	fee52c23          	sw	a4,-8(a0)
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 730:	6398                	ld	a4,0(a5)
+ 732:	6310                	ld	a2,0(a4)
+ 734:	a83d                	j	772 <free+0x5e>
+  } else
+    bp->s.ptr = p->s.ptr;
+  if(p + p->s.size == bp){
+    p->s.size += bp->s.size;
+ 736:	ff852703          	lw	a4,-8(a0)
+ 73a:	9f31                	addw	a4,a4,a2
+ 73c:	c798                	sw	a4,8(a5)
+    p->s.ptr = bp->s.ptr;
+ 73e:	ff053683          	ld	a3,-16(a0)
+ 742:	a091                	j	786 <free+0x72>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 744:	6398                	ld	a4,0(a5)
+ 746:	00e7e463          	bltu	a5,a4,74e <free+0x3a>
+ 74a:	00e6ea63          	bltu	a3,a4,75e <free+0x4a>
+{
+ 74e:	87ba                	mv	a5,a4
+  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
+ 750:	fed7fae3          	bgeu	a5,a3,744 <free+0x30>
+ 754:	6398                	ld	a4,0(a5)
+ 756:	00e6e463          	bltu	a3,a4,75e <free+0x4a>
+    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
+ 75a:	fee7eae3          	bltu	a5,a4,74e <free+0x3a>
+  if(bp + bp->s.size == p->s.ptr){
+ 75e:	ff852583          	lw	a1,-8(a0)
+ 762:	6390                	ld	a2,0(a5)
+ 764:	02059813          	slli	a6,a1,0x20
+ 768:	01c85713          	srli	a4,a6,0x1c
+ 76c:	9736                	add	a4,a4,a3
+ 76e:	fae60de3          	beq	a2,a4,728 <free+0x14>
+    bp->s.ptr = p->s.ptr->s.ptr;
+ 772:	fec53823          	sd	a2,-16(a0)
+  if(p + p->s.size == bp){
+ 776:	4790                	lw	a2,8(a5)
+ 778:	02061593          	slli	a1,a2,0x20
+ 77c:	01c5d713          	srli	a4,a1,0x1c
+ 780:	973e                	add	a4,a4,a5
+ 782:	fae68ae3          	beq	a3,a4,736 <free+0x22>
+    p->s.ptr = bp->s.ptr;
+ 786:	e394                	sd	a3,0(a5)
+  } else
+    p->s.ptr = bp;
+  freep = p;
+ 788:	00001717          	auipc	a4,0x1
+ 78c:	86f73c23          	sd	a5,-1928(a4) # 1000 <freep>
+}
+ 790:	6422                	ld	s0,8(sp)
+ 792:	0141                	addi	sp,sp,16
+ 794:	8082                	ret
+
+0000000000000796 <malloc>:
+  return freep;
+}
+
+void*
+malloc(uint nbytes)
+{
+ 796:	7139                	addi	sp,sp,-64
+ 798:	fc06                	sd	ra,56(sp)
+ 79a:	f822                	sd	s0,48(sp)
+ 79c:	f426                	sd	s1,40(sp)
+ 79e:	ec4e                	sd	s3,24(sp)
+ 7a0:	0080                	addi	s0,sp,64
+  Header *p, *prevp;
+  uint nunits;
+
+  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
+ 7a2:	02051493          	slli	s1,a0,0x20
+ 7a6:	9081                	srli	s1,s1,0x20
+ 7a8:	04bd                	addi	s1,s1,15
+ 7aa:	8091                	srli	s1,s1,0x4
+ 7ac:	0014899b          	addiw	s3,s1,1
+ 7b0:	0485                	addi	s1,s1,1
+  if((prevp = freep) == 0){
+ 7b2:	00001517          	auipc	a0,0x1
+ 7b6:	84e53503          	ld	a0,-1970(a0) # 1000 <freep>
+ 7ba:	c915                	beqz	a0,7ee <malloc+0x58>
+    base.s.ptr = freep = prevp = &base;
+    base.s.size = 0;
+  }
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 7bc:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 7be:	4798                	lw	a4,8(a5)
+ 7c0:	08977a63          	bgeu	a4,s1,854 <malloc+0xbe>
+ 7c4:	f04a                	sd	s2,32(sp)
+ 7c6:	e852                	sd	s4,16(sp)
+ 7c8:	e456                	sd	s5,8(sp)
+ 7ca:	e05a                	sd	s6,0(sp)
+  if(nu < 4096)
+ 7cc:	8a4e                	mv	s4,s3
+ 7ce:	0009871b          	sext.w	a4,s3
+ 7d2:	6685                	lui	a3,0x1
+ 7d4:	00d77363          	bgeu	a4,a3,7da <malloc+0x44>
+ 7d8:	6a05                	lui	s4,0x1
+ 7da:	000a0b1b          	sext.w	s6,s4
+  p = sbrk(nu * sizeof(Header));
+ 7de:	004a1a1b          	slliw	s4,s4,0x4
+        p->s.size = nunits;
+      }
+      freep = prevp;
+      return (void*)(p + 1);
+    }
+    if(p == freep)
+ 7e2:	00001917          	auipc	s2,0x1
+ 7e6:	81e90913          	addi	s2,s2,-2018 # 1000 <freep>
+  if(p == SBRK_ERROR)
+ 7ea:	5afd                	li	s5,-1
+ 7ec:	a081                	j	82c <malloc+0x96>
+ 7ee:	f04a                	sd	s2,32(sp)
+ 7f0:	e852                	sd	s4,16(sp)
+ 7f2:	e456                	sd	s5,8(sp)
+ 7f4:	e05a                	sd	s6,0(sp)
+    base.s.ptr = freep = prevp = &base;
+ 7f6:	00001797          	auipc	a5,0x1
+ 7fa:	81a78793          	addi	a5,a5,-2022 # 1010 <base>
+ 7fe:	00001717          	auipc	a4,0x1
+ 802:	80f73123          	sd	a5,-2046(a4) # 1000 <freep>
+ 806:	e39c                	sd	a5,0(a5)
+    base.s.size = 0;
+ 808:	0007a423          	sw	zero,8(a5)
+    if(p->s.size >= nunits){
+ 80c:	b7c1                	j	7cc <malloc+0x36>
+        prevp->s.ptr = p->s.ptr;
+ 80e:	6398                	ld	a4,0(a5)
+ 810:	e118                	sd	a4,0(a0)
+ 812:	a8a9                	j	86c <malloc+0xd6>
+  hp->s.size = nu;
+ 814:	01652423          	sw	s6,8(a0)
+  free((void*)(hp + 1));
+ 818:	0541                	addi	a0,a0,16
+ 81a:	efbff0ef          	jal	714 <free>
+  return freep;
+ 81e:	00093503          	ld	a0,0(s2)
+      if((p = morecore(nunits)) == 0)
+ 822:	c12d                	beqz	a0,884 <malloc+0xee>
+  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
+ 824:	611c                	ld	a5,0(a0)
+    if(p->s.size >= nunits){
+ 826:	4798                	lw	a4,8(a5)
+ 828:	02977263          	bgeu	a4,s1,84c <malloc+0xb6>
+    if(p == freep)
+ 82c:	00093703          	ld	a4,0(s2)
+ 830:	853e                	mv	a0,a5
+ 832:	fef719e3          	bne	a4,a5,824 <malloc+0x8e>
+  p = sbrk(nu * sizeof(Header));
+ 836:	8552                	mv	a0,s4
+ 838:	a47ff0ef          	jal	27e <sbrk>
+  if(p == SBRK_ERROR)
+ 83c:	fd551ce3          	bne	a0,s5,814 <malloc+0x7e>
+        return 0;
+ 840:	4501                	li	a0,0
+ 842:	7902                	ld	s2,32(sp)
+ 844:	6a42                	ld	s4,16(sp)
+ 846:	6aa2                	ld	s5,8(sp)
+ 848:	6b02                	ld	s6,0(sp)
+ 84a:	a03d                	j	878 <malloc+0xe2>
+ 84c:	7902                	ld	s2,32(sp)
+ 84e:	6a42                	ld	s4,16(sp)
+ 850:	6aa2                	ld	s5,8(sp)
+ 852:	6b02                	ld	s6,0(sp)
+      if(p->s.size == nunits)
+ 854:	fae48de3          	beq	s1,a4,80e <malloc+0x78>
+        p->s.size -= nunits;
+ 858:	4137073b          	subw	a4,a4,s3
+ 85c:	c798                	sw	a4,8(a5)
+        p += p->s.size;
+ 85e:	02071693          	slli	a3,a4,0x20
+ 862:	01c6d713          	srli	a4,a3,0x1c
+ 866:	97ba                	add	a5,a5,a4
+        p->s.size = nunits;
+ 868:	0137a423          	sw	s3,8(a5)
+      freep = prevp;
+ 86c:	00000717          	auipc	a4,0x0
+ 870:	78a73a23          	sd	a0,1940(a4) # 1000 <freep>
+      return (void*)(p + 1);
+ 874:	01078513          	addi	a0,a5,16
+  }
+}
+ 878:	70e2                	ld	ra,56(sp)
+ 87a:	7442                	ld	s0,48(sp)
+ 87c:	74a2                	ld	s1,40(sp)
+ 87e:	69e2                	ld	s3,24(sp)
+ 880:	6121                	addi	sp,sp,64
+ 882:	8082                	ret
+ 884:	7902                	ld	s2,32(sp)
+ 886:	6a42                	ld	s4,16(sp)
+ 888:	6aa2                	ld	s5,8(sp)
+ 88a:	6b02                	ld	s6,0(sp)
+ 88c:	b7f5                	j	878 <malloc+0xe2>
diff -ruN xv6-riscv/user/zombie.d xv62/user/zombie.d
--- xv6-riscv/user/zombie.d	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/zombie.d	2025-09-14 12:32:52.112883061 +0000
@@ -0,0 +1 @@
+user/zombie.o: user/zombie.c kernel/types.h kernel/stat.h user/user.h
Binary files xv6-riscv/user/zombie.o and xv62/user/zombie.o differ
diff -ruN xv6-riscv/user/zombie.sym xv62/user/zombie.sym
--- xv6-riscv/user/zombie.sym	1970-01-01 00:00:00.000000000 +0000
+++ xv62/user/zombie.sym	2025-09-14 12:32:52.128883058 +0000
@@ -0,0 +1,66 @@
+0000000000000000 .text
+0000000000000890 .rodata
+00000000000008b0 .eh_frame
+0000000000001000 .data
+0000000000001000 .bss
+0000000000000000 .debug_info
+0000000000000000 .debug_abbrev
+0000000000000000 .debug_loc
+0000000000000000 .debug_aranges
+0000000000000000 .debug_line
+0000000000000000 .debug_str
+0000000000000000 .comment
+0000000000000000 .riscv.attributes
+0000000000000000 .debug_ranges
+0000000000000000 zombie.c
+0000000000000000 ulib.c
+0000000000000000 usys.o
+0000000000000000 printf.c
+000000000000035a putc
+0000000000000378 printint
+0000000000000898 digits
+0000000000000000 umalloc.c
+0000000000001000 freep
+0000000000001010 base
+000000000000002e strcpy
+0000000000000342 pause
+00000000000006e2 printf
+000000000000033a sys_sbrk
+00000000000001d8 memmove
+00000000000002fa mknod
+00000000000000e6 gets
+0000000000000332 getpid
+000000000000026a memcpy
+0000000000000796 malloc
+0000000000000294 sbrklazy
+00000000000002c2 pipe
+00000000000002d2 write
+000000000000030a fstat
+00000000000006b8 fprintf
+00000000000002e2 kill
+0000000000000414 vprintf
+0000000000000322 chdir
+00000000000002ea exec
+00000000000002ba wait
+00000000000002ca read
+0000000000000302 unlink
+0000000000000230 memcmp
+00000000000002aa fork
+000000000000027e sbrk
+000000000000034a uptime
+00000000000000a0 memset
+0000000000000000 main
+000000000000004a strcmp
+000000000000032a dup
+0000000000000352 getreadcount
+0000000000000156 stat
+0000000000000312 link
+00000000000002b2 exit
+000000000000001e start
+0000000000000190 atoi
+0000000000000076 strlen
+00000000000002f2 open
+00000000000000c2 strchr
+000000000000031a mkdir
+00000000000002da close
+0000000000000714 free
